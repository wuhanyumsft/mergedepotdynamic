{"content":"    \r\n    <h1 id=\"System_Reflection_AssemblyName\">\r\n      <span class=\"lang-csharp\">AssemblyName</span>\r\n        Class\r\n    </h1>\r\n    \r\n    \r\n    <nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n      <h3>In this Article</h3>\r\n    </nav><div class=\"summary\">\r\n    \t<p>Describes an assembly&#39;s unique identity in full.</p>\n\r\n    </div><h2>Syntax</h2>\r\n    \r\n    \t<h3>Declaration</h3>\r\n    \t<pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]\n[System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._AssemblyName))]\n[System.Runtime.InteropServices.ComVisible(true)]\npublic sealed class AssemblyName : ICloneable, System.Runtime.InteropServices._AssemblyName, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable</code></pre>\r\n    \r\n    \r\n    \r\n    <h3>Inheritance Hierarchy</h3>\r\n    <ul class=\"inheritance\">\r\n        <li class=\"l0\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a>\r\n          </div>\r\n        </li>\r\n      <li class=\"l1\">\r\n        <div class=\"xref\">\r\n          <div class=\"lang-csharp\">AssemblyName</div>\r\n        </div>\r\n      </li>\r\n    </ul>\r\n    \r\n      <div class=\"referencebox inheritedMembers\">\r\n        <h3>Inherited Members</h3>\r\n        <h4></h4>\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object,Object)</a>\r\n          </div>\r\n          \r\n      </div>\r\n    \r\n    \r\n      <h2>Remarks</h2>\r\n      <p>The AssemblyName object contains information about an assembly, which you can use to bind to that assembly. An assembly&#39;s identity consists of the following:  </p>\n<ul>\n<li><p>Simple name.  </p>\n</li>\n<li><p>Version number.  </p>\n</li>\n<li><p>Cryptographic key pair.  </p>\n</li>\n<li><p>Supported culture.  </p>\n<p>The simple name is typically the file name for the manifest file without its extension. The key pair includes a public and private key, used to create strong-name signatures for assemblies.  </p>\n<p>All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.  </p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Delimiter</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Backslash (\\)</td>\n<td>Escape character.</td>\n</tr>\n<tr>\n<td>Comma (,)</td>\n<td>Precedes the assembly name.</td>\n</tr>\n<tr>\n<td>Plus sign (+)</td>\n<td>Precedes a nested class.</td>\n</tr>\n</tbody>\n</table>\n<p> For example, the fully qualified name for a class might look like this:  </p>\n<p> ContainingClass+NestedClass,MyAssembly  </p>\n<p> A &quot;++&quot; becomes &quot;\\+\\+&quot;, and a &quot;\\&quot; becomes &quot;\\\\&quot;.  </p>\n<p> This qualified name can be persisted and later used to load the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>. To search for and load a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, use <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> either with the type name only or with the assembly qualified type name. <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> with the type name only will look for the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> in the caller&#39;s assembly and then in the System assembly. <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> with the assembly qualified type name will look for the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> in any assembly.  </p>\n<p> A fully specified AssemblyName must have the name, culture, public key or public key token, major version, minor version, build number, and revision number parameters. The last four are packaged in the <a class=\"xref\" href=\"system.version\" data-linktype=\"relative-path\">Version</a> type.  </p>\n<p> To create a simple name, create an AssemblyName object using the default constructor and set the <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_Name_\" data-linktype=\"relative-path\">Name</a>. The other properties are optional.  </p>\n<p> To create a full strong name, create an AssemblyName object using the default constructor and set the <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_Name_\" data-linktype=\"relative-path\">Name</a> and <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_KeyPair_\" data-linktype=\"relative-path\">KeyPair</a>. The other properties are optional. Use <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_SetPublicKey_\" data-linktype=\"relative-path\">SetPublicKey</a> and <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_SetPublicKeyToken_\" data-linktype=\"relative-path\">SetPublicKeyToken</a> to set the public key and the strong name. The strong name signing always uses the <a class=\"xref\" href=\"system.security.cryptography.sha1\" data-linktype=\"relative-path\">SHA1</a> hash algorithm.  </p>\n<p> To ensure that the names are constructed correctly, use the following properties:  </p>\n<ul>\n<li><a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_FullName_\" data-linktype=\"relative-path\">FullName</a>  \n</li>\n<li><a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_FullName_\" data-linktype=\"relative-path\">FullName</a>  \n</li>\n<li><a class=\"xref\" href=\"system.type#System_Type_AssemblyQualifiedName_\" data-linktype=\"relative-path\">AssemblyQualifiedName</a>  \n\n<p>You can also get the name by using the <code>/l</code> option with the <a href=\"../Topic/Gacutil.exe%20(Global%20Assembly%20Cache%20Tool).md\" data-linktype=\"relative-path\">Gacutil.exe (Global Assembly Cache Tool)</a>  </p>\n<p>For a partially specified strong name, create an AssemblyName object using the default constructor and set the name and public key. An assembly created using such an AssemblyName can be signed later using the Assembly Linker (Al.exe).  </p>\n<p>It is possible to specify a public key and a <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_KeyPair_\" data-linktype=\"relative-path\">KeyPair</a> with inconsistent values. This can be useful in developer scenarios. In this case, the public key retrieved with <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_GetPublicKey_\" data-linktype=\"relative-path\">GetPublicKey</a> specifies the correct public key, while the <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_KeyPair_\" data-linktype=\"relative-path\">KeyPair</a> specifies the public and private keys used during development. When the runtime detects a mismatch between the <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_KeyPair_\" data-linktype=\"relative-path\">KeyPair</a> and the public key, it looks up in the registry the correct key that matches the public key.  </p>\n<p>The format of the display name of an AssemblyName is a comma-delimited Unicode string that begins with the name, as follows:  </p>\n<p><code>Name &lt;,Culture = CultureInfo&gt; &lt;,Version = Major.Minor.Build.Revision&gt; &lt;, StrongName&gt; &lt;,PublicKeyToken&gt; &#39;\\0&#39;</code>  </p>\n<p><code>Name</code> is the textual name of the assembly. <code>CultureInfo</code> is the RFC1766-format-defined culture. <code>Major</code>, <code>Minor</code>, <code>Build</code>, and <code>Revision</code> are the major version, minor version, build number, and revision number of the assembly. <code>StrongName</code> is the hexadecimal-encoded low-order 64 bits of the hash value of the public key generated using the SHA-1 hashing algorithm and the public key specified by <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_SetPublicKey_\" data-linktype=\"relative-path\">SetPublicKey</a>. <code>PublicKeyToken</code> is the hexadecimal-encoded public key specified by <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_SetPublicKey_\" data-linktype=\"relative-path\">SetPublicKey</a>.  </p>\n<p>Hexadecimal encoding is defined as the conversion of each byte of a binary object to two hexadecimal characters, progressing from least to most significant byte. Additional display values will be added as deemed necessary.  </p>\n<p>If the full public key is known, then PublicKey may be substituted for StrongName.  </p>\n<p>Also note that except for <code>Name</code>, which must come first, the lexical order of parameters is unimportant. However, any parameter (<code>Version</code>, <code>Culture</code>, <code>StrongName</code> or <code>PublicKey</code>) not specifically set is considered to be omitted, and the AssemblyName is then considered partial. When specifying partial information, Name parameters must be specified in the order described above.  </p>\n<p>When supplying a display name, the convention <code>StrongName =null</code> or <code>PublicKey= null</code> indicates that binding and matching against a simply named assembly is required. Additionally, the convention <code>Culture= &quot;&quot;</code> (double quote representing an empty string) indicates matching against the default culture.  </p>\n<p>The following example shows an AssemblyName for a simply named assembly with default culture.  </p>\n</li>\n</ul>\n<pre><code>ExampleAssembly, Culture=&quot;&quot;  \n</code></pre><p> The following example shows a fully specified reference for a strongly named assembly with culture &quot;en&quot;.  </p>\n<pre><code>ExampleAssembly, Version=1.0.0.0, Culture=en, PublicKeyToken=a5d015c7d5a0b012  \n</code></pre>\r\n    \r\n    \r\n    <h2>Constructors\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName__ctor\" data-linktype=\"self-bookmark\">AssemblyName()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> class.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName__ctor_System_String_\" data-linktype=\"self-bookmark\">AssemblyName(String)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> class with the specified display name.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Properties\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_CodeBase\" data-linktype=\"self-bookmark\">CodeBase</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets or sets the location of the assembly as a URL.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_ContentType\" data-linktype=\"self-bookmark\">ContentType</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets or sets a value that indicates what type of content the assembly contains.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_CultureInfo\" data-linktype=\"self-bookmark\">CultureInfo</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets or sets the culture supported by the assembly.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_CultureName\" data-linktype=\"self-bookmark\">CultureName</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets or sets the name of the culture associated with the assembly.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_EscapedCodeBase\" data-linktype=\"self-bookmark\">EscapedCodeBase</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the URI, including escape characters, that represents the codebase.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_Flags\" data-linktype=\"self-bookmark\">Flags</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets or sets the attributes of the assembly.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_FullName\" data-linktype=\"self-bookmark\">FullName</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the full name of the assembly, also known as the display name.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_HashAlgorithm\" data-linktype=\"self-bookmark\">HashAlgorithm</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets or sets the hash algorithm used by the assembly manifest.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_KeyPair\" data-linktype=\"self-bookmark\">KeyPair</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets or sets the public and private cryptographic key pair that is used to create a strong name signature for the assembly.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_Name\" data-linktype=\"self-bookmark\">Name</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets or sets the simple name of the assembly. This is usually, but not necessarily, the file name of the manifest file of the assembly, minus its extension.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_ProcessorArchitecture\" data-linktype=\"self-bookmark\">ProcessorArchitecture</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets or sets a value that identifies the processor and bits-per-word of the platform targeted by an executable.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_Version\" data-linktype=\"self-bookmark\">Version</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets or sets the major, minor, build, and revision numbers of the assembly.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_VersionCompatibility\" data-linktype=\"self-bookmark\">VersionCompatibility</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets or sets the information related to the assembly&#39;s compatibility with other assemblies.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Methods\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_Clone\" data-linktype=\"self-bookmark\">Clone()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Makes a copy of this <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> object.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_GetAssemblyName_System_String_\" data-linktype=\"self-bookmark\">GetAssemblyName(String)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> for a given file.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_GetObjectData_System_Runtime_Serialization_SerializationInfo_System_Runtime_Serialization_StreamingContext_\" data-linktype=\"self-bookmark\">GetObjectData(SerializationInfo,StreamingContext)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets serialization information with all the data needed to recreate an instance of this <code>AssemblyName</code>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_GetPublicKey\" data-linktype=\"self-bookmark\">GetPublicKey()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the public key of the assembly.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_GetPublicKeyToken\" data-linktype=\"self-bookmark\">GetPublicKeyToken()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the public key token, which is the last 8 bytes of the SHA-1 hash of the public key under which the application or assembly is signed.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_OnDeserialization_System_Object_\" data-linktype=\"self-bookmark\">OnDeserialization(Object)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Implements the <a class=\"xref\" href=\"system.runtime.serialization.iserializable\" data-linktype=\"relative-path\">ISerializable</a> interface and is called back by the deserialization event when deserialization is complete.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_ReferenceMatchesDefinition_System_Reflection_AssemblyName_System_Reflection_AssemblyName_\" data-linktype=\"self-bookmark\">ReferenceMatchesDefinition(AssemblyName,AssemblyName)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns a value indicating whether two assembly names are the same. The comparison is based on the simple assembly names.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_SetPublicKey_System_Byte___\" data-linktype=\"self-bookmark\">SetPublicKey(Byte[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets the public key identifying the assembly.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_SetPublicKeyToken_System_Byte___\" data-linktype=\"self-bookmark\">SetPublicKeyToken(Byte[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets the public key token, which is the last 8 bytes of the SHA-1 hash of the public key under which the application or assembly is signed.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_ToString\" data-linktype=\"self-bookmark\">ToString()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns the full name of the assembly, also known as the display name.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Explicit Interface Implementations\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_System_Runtime_InteropServices__AssemblyName_GetIDsOfNames_System_Guid__System_IntPtr_System_UInt32_System_UInt32_System_IntPtr_\" data-linktype=\"self-bookmark\">_AssemblyName.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Maps a set of names to a corresponding set of dispatch identifiers.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_System_Runtime_InteropServices__AssemblyName_GetTypeInfo_System_UInt32_System_UInt32_System_IntPtr_\" data-linktype=\"self-bookmark\">_AssemblyName.GetTypeInfo(UInt32,UInt32,IntPtr)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Retrieves the type information for an object, which can then be used to get the type information for an interface.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_System_Runtime_InteropServices__AssemblyName_GetTypeInfoCount_System_UInt32__\" data-linktype=\"self-bookmark\">_AssemblyName.GetTypeInfoCount(UInt32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_AssemblyName_System_Runtime_InteropServices__AssemblyName_Invoke_System_UInt32_System_Guid__System_UInt32_System_Int16_System_IntPtr_System_IntPtr_System_IntPtr_System_IntPtr_\" data-linktype=\"self-bookmark\">_AssemblyName.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Provides access to properties and methods exposed by an object.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"constructors\">\r\n        <h2>Constructors\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName__ctor\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName__ctor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">AssemblyName()</div>        \r\n          </div>\r\n    \r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> class.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public AssemblyName ();</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates a dynamic assembly named <code>MyAssembly.exe</code> and saves it to your hard disk. After running the example, you can use the <a href=\"../Topic/Ildasm.exe%20(IL%20Disassembler).md\" data-linktype=\"relative-path\">Ildasm.exe (IL Disassembler)</a> to examine the assembly metadata.  </p>\n<pre><code class=\"lang-cpp\" name=\"AssemblyName_Constructor#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Threading;\nusing namespace System::Reflection::Emit;\nstatic void MakeAssembly( AssemblyName^ myAssemblyName, String^ fileName )\n{\n   // Get the assembly builder from the application domain associated with the current thread.\n   AssemblyBuilder^ myAssemblyBuilder = Thread::GetDomain()-&gt;DefineDynamicAssembly( myAssemblyName, AssemblyBuilderAccess::RunAndSave );\n\n   // Create a dynamic module in the assembly.\n   ModuleBuilder^ myModuleBuilder = myAssemblyBuilder-&gt;DefineDynamicModule( &quot;MyModule&quot;, fileName );\n\n   // Create a type in the module.\n   TypeBuilder^ myTypeBuilder = myModuleBuilder-&gt;DefineType( &quot;MyType&quot; );\n\n   // Create a method called &#39;Main&#39;.\n   MethodBuilder^ myMethodBuilder = myTypeBuilder-&gt;DefineMethod( &quot;Main&quot;, static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::HideBySig | MethodAttributes::Static), void::typeid, nullptr );\n\n   // Get the Intermediate Language generator for the method.\n   ILGenerator^ myILGenerator = myMethodBuilder-&gt;GetILGenerator();\n\n   // Use the utility method to generate the IL instructions that print a String* to the console.\n   myILGenerator-&gt;EmitWriteLine( &quot;Hello World!&quot; );\n\n   // Generate the &#39;ret&#39; IL instruction.\n   myILGenerator-&gt;Emit( OpCodes::Ret );\n\n   // End the creation of the type.\n   myTypeBuilder-&gt;CreateType();\n\n   // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n   myAssemblyBuilder-&gt;SetEntryPoint( myMethodBuilder );\n   myAssemblyBuilder-&gt;Save( fileName );\n}\n\nint main()\n{\n   // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n   AssemblyName^ myAssemblyName = gcnew AssemblyName;\n   myAssemblyName-&gt;Name = &quot;MyAssembly&quot;;\n   myAssemblyName-&gt;Version = gcnew Version( &quot;1.0.0.2001&quot; );\n   MakeAssembly( myAssemblyName, &quot;MyAssembly.exe&quot; );\n\n   // Get all the assemblies currently loaded in the application domain.\n   array&lt;Assembly^&gt;^myAssemblies = Thread::GetDomain()-&gt;GetAssemblies();\n\n   // Get the dynamic assembly named &#39;MyAssembly&#39;. \n   Assembly^ myAssembly = nullptr;\n   for ( int i = 0; i &lt; myAssemblies-&gt;Length; i++ )\n   {\n      if ( String::Compare( myAssemblies[ i ]-&gt;GetName()-&gt;Name, &quot;MyAssembly&quot; ) == 0 )\n            myAssembly = myAssemblies[ i ];\n   }\n   if ( myAssembly != nullptr )\n   {\n      Console::WriteLine(  &quot;<br>Displaying the assembly name<br>&quot; );\n      Console::WriteLine( myAssembly );\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"AssemblyName_Constructor#1\">Imports System\nImports System.Reflection\nImports System.Threading\nImports System.Reflection.Emit\nImports Microsoft.VisualBasic\n\nPublic Class AssemblyName_Constructor\n   \n   Public Shared Sub MakeAssembly(myAssemblyName As AssemblyName, fileName As String)\n      &#39; Get the assembly builder from the application domain associated with the current thread.\n      Dim myAssemblyBuilder As AssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave)\n      &#39; Create a dynamic module in the assembly.\n      Dim myModuleBuilder As ModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName)\n      &#39; Create a type in the module.\n      Dim myTypeBuilder As TypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;)\n      &#39; Create a method called &#39;Main&#39;.\n      Dim myMethodBuilder As MethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public Or MethodAttributes.HideBySig Or MethodAttributes.Static, GetType(object), Nothing)\n      Dim myILGenerator As ILGenerator = myMethodBuilder.GetILGenerator()\n      &#39; Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;)\n      &#39; Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret)\n      &#39; End the creation of the type.\n      myTypeBuilder.CreateType()\n      &#39; Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder)\n      myAssemblyBuilder.Save(fileName)\n   End Sub &#39;MakeAssembly\n   \n   \n   Public Shared Sub Main()\n      \n\n      &#39; Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      Dim myAssemblyName As New AssemblyName()\n      myAssemblyName.Name = &quot;MyAssembly&quot;\n      myAssemblyName.Version = New Version(&quot;1.0.0.2001&quot;)\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;)\n      \n      &#39; Get all the assemblies currently loaded in the application domain.\n      Dim myAssemblies As [Assembly]() = Thread.GetDomain().GetAssemblies()\n      \n      &#39; Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Dim myAssembly As [Assembly] = Nothing\n      Dim i As Integer\n      For i = 0 To myAssemblies.Length - 1\n         If [String].Compare(myAssemblies(i).GetName().Name, &quot;MyAssembly&quot;) = 0 Then\n            myAssembly = myAssemblies(i)\n         End If\n      Next i\n      If Not (myAssembly Is Nothing) Then\n         Console.WriteLine(ControlChars.Cr + &quot;Displaying the assembly name&quot; + ControlChars.Cr)\n         Console.WriteLine(myAssembly)\n      End If\n   End Sub &#39;Main \nEnd Class &#39;AssemblyName_Constructor \n</code></pre><pre><code class=\"lang-cs\" name=\"AssemblyName_Constructor#1\">\nusing System;\nusing System.Reflection;\nusing System.Threading;\nusing System.Reflection.Emit;\n\npublic class AssemblyName_Constructor\n{\n   public static void MakeAssembly(AssemblyName myAssemblyName, string fileName)\n   {\n      // Get the assembly builder from the application domain associated with the current thread.\n      AssemblyBuilder myAssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave);\n      // Create a dynamic module in the assembly.\n      ModuleBuilder myModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName);\n      // Create a type in the module.\n      TypeBuilder myTypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;);\n      // Create a method called &#39;Main&#39;.\n      MethodBuilder myMethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public | MethodAttributes.HideBySig |\n         MethodAttributes.Static, typeof(void), null);\n      // Get the Intermediate Language generator for the method.\n      ILGenerator myILGenerator = myMethodBuilder.GetILGenerator();\n      // Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;);\n      // Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret);\n      // End the creation of the type.\n      myTypeBuilder.CreateType();\n      // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder);\n      myAssemblyBuilder.Save(fileName);\n   }\n\n   public static void Main()\n   {\n\n\n      // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      AssemblyName myAssemblyName = new AssemblyName(); \n      myAssemblyName.Name = &quot;MyAssembly&quot;;\n      myAssemblyName.Version = new Version(&quot;1.0.0.2001&quot;);\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;);\n\n      // Get all the assemblies currently loaded in the application domain.\n      Assembly[] myAssemblies = Thread.GetDomain().GetAssemblies();\n\n      // Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Assembly myAssembly = null;\n      for(int i = 0; i &lt; myAssemblies.Length; i++)\n      {\n         if(String.Compare(myAssemblies[i].GetName().Name, &quot;MyAssembly&quot;) == 0)\n            myAssembly = myAssemblies[i];\n      }\n      if(myAssembly != null)\n      {\n         Console.WriteLine(&quot;<br>Displaying the assembly name<br>&quot;);\n         Console.WriteLine(myAssembly);\n      }\n   }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName__ctor_System_String_\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName__ctor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">AssemblyName(String)</div>        \r\n          </div>\r\n    \r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> class with the specified display name.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public AssemblyName (string assemblyName);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>assemblyName</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The display name of the assembly, as returned by the <span class=\"xref\">stem.Reflection.AssemblyName.FullName*</span> property.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>assemblyName</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>assemblyName</code> is a zero length string.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.fileloadexception\" data-linktype=\"relative-path\">FileLoadException</a></div>\r\n                  </div>\r\n                  <div class=\"alert NOTE\"><br> In the <a href=\"http://go.microsoft.com/fwlink/?LinkID=247912\" data-linktype=\"external\">.NET for Windows Store apps</a> or the <a href=\"../Topic/Cross-Platform%20Development%20with%20the%20Portable%20Class%20Library.md\" data-linktype=\"relative-path\">Portable Class Library</a>, catch the base class exception, <a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a>, instead.<br>\n</div>  \n\n<p> The referenced assembly could not be found, or could not be loaded.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The supplied <code>assemblyName</code> is parsed, and the appropriate fields of the new <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> are initialized with values from the display name. This is the recommended way of parsing display names. Writing your own code to parse display names is not recommended.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an instance of <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> from a display name. The individual elements of the display name are output to the console as properties of the <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a>object.  </p>\n<pre><code class=\"lang-cpp\" name=\"AssemblyName_Constructor_2#1\">using namespace System;\nusing namespace System::Reflection;\n\nint main()\n{\n   // Create an AssemblyName, specifying the display name, and then\n   // print the properties.\n   AssemblyName^ myAssemblyName = \n      gcnew AssemblyName(&quot;Example, Version=1.0.0.2001, Culture=en-US, PublicKeyToken=null&quot;);\n   Console::WriteLine(&quot;Name: {0}&quot;, myAssemblyName-&gt;Name);\n   Console::WriteLine(&quot;Version: {0}&quot;, myAssemblyName-&gt;Version);\n   Console::WriteLine(&quot;CultureInfo: {0}&quot;, myAssemblyName-&gt;CultureInfo);\n   Console::WriteLine(&quot;FullName: {0}&quot;, myAssemblyName-&gt;FullName);\n}\n/* This code example produces output similar to the following:\n\nName: Example\nVersion: 1.0.0.2001\nCultureInfo: en-US\nFullName: Example, Version=1.0.0.2001, Culture=en-US, PublicKeyToken=null\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"AssemblyName_Constructor_2#1\">Imports System\nImports System.Reflection\n\nPublic Class AssemblyNameDemo\n   \n   Public Shared Sub Main()\n \n      &#39; Create an AssemblyName, specifying the display name, and then\n      &#39; print the properties.\n      Dim myAssemblyName As New _\n         AssemblyName(&quot;Example, Version=1.0.0.2001, Culture=en-US, PublicKeyToken=null&quot;)\n      Console.WriteLine(&quot;Name: {0}&quot;, myAssemblyName.Name)\n      Console.WriteLine(&quot;Version: {0}&quot;, myAssemblyName.Version)\n      Console.WriteLine(&quot;CultureInfo: {0}&quot;, myAssemblyName.CultureInfo)\n      Console.WriteLine(&quot;FullName: {0}&quot;, myAssemblyName.FullName)\n\n   End Sub  \nEnd Class \n\n&#39; This code example produces output similar to the following:\n&#39;\n&#39;Name: Example\n&#39;Version: 1.0.0.2001\n&#39;CultureInfo: en-US\n&#39;FullName: Example, Version=1.0.0.2001, Culture=en-US, PublicKeyToken=null\n</code></pre><pre><code class=\"lang-cs\" name=\"AssemblyName_Constructor_2#1\">using System;\nusing System.Reflection;\n\npublic class AssemblyNameDemo\n{\n   public static void Main()\n   {\n      // Create an AssemblyName, specifying the display name, and then\n      // print the properties.\n      AssemblyName myAssemblyName = \n         new AssemblyName(&quot;Example, Version=1.0.0.2001, Culture=en-US, PublicKeyToken=null&quot;);\n      Console.WriteLine(&quot;Name: {0}&quot;, myAssemblyName.Name);\n      Console.WriteLine(&quot;Version: {0}&quot;, myAssemblyName.Version);\n      Console.WriteLine(&quot;CultureInfo: {0}&quot;, myAssemblyName.CultureInfo);\n      Console.WriteLine(&quot;FullName: {0}&quot;, myAssemblyName.FullName);\n   }\n}\n/* This code example produces output similar to the following:\n\nName: Example\nVersion: 1.0.0.2001\nCultureInfo: en-US\nFullName: Example, Version=1.0.0.2001, Culture=en-US, PublicKeyToken=null\n */\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"properties\">\r\n        <h2>Properties\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_CodeBase\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_CodeBase_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">CodeBase</div>        \r\n          </div>\r\n    \r\n            <p>Gets or sets the location of the assembly as a URL.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public string CodeBase { get; set; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </div>\r\n                  <p>A string that is the URL location of the assembly.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>When an assembly is loaded, this value can also be obtained using the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_CodeBase_\" data-linktype=\"relative-path\">CodeBase</a> property.  </p>\n<p> If the assembly was loaded as a byte array, this property returns the location of the caller of the [Load(Byte&lt;xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%29&gt; method overload, not the location of the loaded assembly.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Do not use an <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> with only the CodeBase property set. The CodeBase property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_Load_\" data-linktype=\"relative-path\">Load</a> method. Instead, the assembly is loaded using load-from rules. For information about the disadvantages of using the load-from context, see the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_LoadFrom_\" data-linktype=\"relative-path\">LoadFrom</a> method overload or <a href=\"../Topic/Best%20Practices%20for%20Assembly%20Loading.md\" data-linktype=\"relative-path\">Best Practices for Assembly Loading</a>.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example emits a dynamic assembly and saves it to the current directory. When the assembly is created, the CodeBase property is used to specify the directory where the assembly is saved.  </p>\n<pre><code class=\"lang-cs\" name=\"AssemblyName_CodeBase#1\">\nusing System;\nusing System.Reflection;\nusing System.Threading;\nusing System.IO;\nusing System.Globalization;\nusing System.Reflection.Emit;\nusing System.Configuration.Assemblies;\n\npublic class AssemblyName_CodeBase\n{\n   public static void MakeAssembly(AssemblyName myAssemblyName, string fileName)\n   {\n      // Get the assembly builder from the application domain associated with the current thread.\n      AssemblyBuilder myAssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave);\n      // Create a dynamic module in the assembly.\n      ModuleBuilder myModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName);\n      // Create a type in the module.\n      TypeBuilder myTypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;);\n      // Create a method called &#39;Main&#39;.\n      MethodBuilder myMethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public | MethodAttributes.HideBySig |\n         MethodAttributes.Static, typeof(void), null);\n      // Get the Intermediate Language generator for the method.\n      ILGenerator myILGenerator = myMethodBuilder.GetILGenerator();\n      // Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;);\n      // Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret);\n      // End the creation of the type.\n      myTypeBuilder.CreateType();\n      // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder);\n      myAssemblyBuilder.Save(fileName);\n   }\n\n   public static void Main()\n   {\n\n\n\n      // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      AssemblyName myAssemblyName = new AssemblyName();\n      // Set the codebase to the physical directory were the assembly resides.\n      myAssemblyName.CodeBase = Directory.GetCurrentDirectory();\n      // Set the culture information of the assembly to &#39;English-American&#39;.\n      myAssemblyName.CultureInfo = new CultureInfo(&quot;en-US&quot;);\n      // Set the hash algoritm to &#39;SHA1&#39;.\n      myAssemblyName.HashAlgorithm = AssemblyHashAlgorithm.SHA1;\n      myAssemblyName.Name = &quot;MyAssembly&quot;;\n      myAssemblyName.Version = new Version(&quot;1.0.0.2001&quot;);\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;);\n\n      // Get all the assemblies currently loaded in the application domain.\n      Assembly[] myAssemblies = Thread.GetDomain().GetAssemblies();\n\n      // Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Assembly myAssembly = null;\n      for(int i = 0; i &lt; myAssemblies.Length; i++)\n      {\n         if(String.Compare(myAssemblies[i].GetName().Name, &quot;MyAssembly&quot;) == 0)\n            myAssembly = myAssemblies[i];\n      }\n      // Display the full assembly information to the console.\n      if(myAssembly != null)\n      {\n         Console.WriteLine(&quot;<br>Displaying the full assembly name<br>&quot;);\n         Console.WriteLine(myAssembly.GetName().FullName);\n      }\n   }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"AssemblyName_CodeBase#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Threading;\nusing namespace System::IO;\nusing namespace System::Globalization;\nusing namespace System::Reflection::Emit;\nusing namespace System::Configuration::Assemblies;\nstatic void MakeAssembly( AssemblyName^ myAssemblyName, String^ fileName )\n{\n   // Get the assembly builder from the application domain associated with the current thread.\n   AssemblyBuilder^ myAssemblyBuilder = Thread::GetDomain()-&gt;DefineDynamicAssembly( myAssemblyName, AssemblyBuilderAccess::RunAndSave );\n\n   // Create a dynamic module in the assembly.\n   ModuleBuilder^ myModuleBuilder = myAssemblyBuilder-&gt;DefineDynamicModule( &quot;MyModule&quot;, fileName );\n\n   // Create a type in the module.\n   TypeBuilder^ myTypeBuilder = myModuleBuilder-&gt;DefineType( &quot;MyType&quot; );\n\n   // Create a method called &#39;Main&#39;.\n   MethodBuilder^ myMethodBuilder = myTypeBuilder-&gt;DefineMethod( &quot;Main&quot;, static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::HideBySig | MethodAttributes::Static), void::typeid, nullptr );\n\n   // Get the Intermediate Language generator for the method.\n   ILGenerator^ myILGenerator = myMethodBuilder-&gt;GetILGenerator();\n\n   // Use the utility method to generate the IL instructions that print a String* to the console.\n   myILGenerator-&gt;EmitWriteLine( &quot;Hello World!&quot; );\n\n   // Generate the &#39;ret&#39; IL instruction.\n   myILGenerator-&gt;Emit( OpCodes::Ret );\n\n   // End the creation of the type.\n   myTypeBuilder-&gt;CreateType();\n\n   // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n   myAssemblyBuilder-&gt;SetEntryPoint( myMethodBuilder );\n   myAssemblyBuilder-&gt;Save( fileName );\n}\n\nint main()\n{\n   // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n   AssemblyName^ myAssemblyName = gcnew AssemblyName;\n\n   // Set the codebase to the physical directory were the assembly resides.\n   myAssemblyName-&gt;CodeBase = Directory::GetCurrentDirectory();\n\n   // Set the culture information of the assembly to &#39;English-American&#39;.\n   myAssemblyName-&gt;CultureInfo = gcnew CultureInfo( &quot;en-US&quot; );\n\n   // Set the hash algoritm to &#39;SHA1&#39;.\n   myAssemblyName-&gt;HashAlgorithm = AssemblyHashAlgorithm::SHA1;\n   myAssemblyName-&gt;Name = &quot;MyAssembly&quot;;\n   myAssemblyName-&gt;Version = gcnew Version( &quot;1.0.0.2001&quot; );\n   MakeAssembly( myAssemblyName, &quot;MyAssembly.exe&quot; );\n\n   // Get all the assemblies currently loaded in the application domain.\n   array&lt;Assembly^&gt;^myAssemblies = Thread::GetDomain()-&gt;GetAssemblies();\n\n   // Get the dynamic assembly named &#39;MyAssembly&#39;. \n   Assembly^ myAssembly = nullptr;\n   for ( int i = 0; i &lt; myAssemblies-&gt;Length; i++ )\n   {\n      if ( String::Compare( myAssemblies[ i ]-&gt;GetName()-&gt;Name, &quot;MyAssembly&quot; ) == 0 )\n            myAssembly = myAssemblies[ i ];\n   }\n   if ( myAssembly != nullptr )\n   {\n      Console::WriteLine( &quot;<br>Displaying the full assembly name<br>&quot; );\n      Console::WriteLine( myAssembly-&gt;GetName()-&gt;FullName );\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"AssemblyName_CodeBase#1\">\nImports System\nImports Microsoft.VisualBasic\nImports System.Reflection\nImports System.Threading\nImports System.IO\nImports System.Globalization\nImports System.Reflection.Emit\nImports System.Configuration.Assemblies\n\nPublic Class AssemblyName_CodeBase\n   \n   Public Shared Sub MakeAssembly(myAssemblyName As AssemblyName, fileName As String)\n      &#39; Get the assembly builder from the application domain associated with the current thread.\n      Dim myAssemblyBuilder As AssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave)\n      &#39; Create a dynamic module in the assembly.\n      Dim myModuleBuilder As ModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName)\n      &#39; Create a type in the module.\n      Dim myTypeBuilder As TypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;)\n      &#39; Create a method called &#39;Main&#39;.\n      Dim myMethodBuilder As MethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public Or MethodAttributes.HideBySig Or MethodAttributes.Static, GetType(object), Nothing)\n      &#39; Get the Intermediate Language generator for the method.\n      Dim myILGenerator As ILGenerator = myMethodBuilder.GetILGenerator()\n      &#39; Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;)\n      &#39; Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret)\n      &#39; End the creation of the type.\n      myTypeBuilder.CreateType()\n      &#39; Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder)\n      myAssemblyBuilder.Save(fileName)\n   End Sub &#39;MakeAssembly\n   \n   \n   Public Shared Sub Main()\n      \n      &#39; Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      Dim myAssemblyName As New AssemblyName()\n      &#39; Set the codebase to the physical directory were the assembly resides.\n      myAssemblyName.CodeBase = Directory.GetCurrentDirectory()\n      &#39; Set the culture information of the assembly to &#39;English-American&#39;.\n      myAssemblyName.CultureInfo = New CultureInfo(&quot;en-US&quot;)\n      &#39; Set the hash algoritm to &#39;SHA1&#39;.\n      myAssemblyName.HashAlgorithm = AssemblyHashAlgorithm.SHA1\n      myAssemblyName.Name = &quot;MyAssembly&quot;\n      myAssemblyName.Version = New Version(&quot;1.0.0.2001&quot;)\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;)\n      \n      &#39; Get all the assemblies currently loaded in the application domain.\n      Dim myAssemblies As [Assembly]() = Thread.GetDomain().GetAssemblies()\n      \n      &#39; Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Dim myAssembly As [Assembly] = Nothing\n      Dim i As Integer\n      For i = 0 To myAssemblies.Length - 1\n         If [String].Compare(myAssemblies(i).GetName().Name, &quot;MyAssembly&quot;) = 0 Then\n            myAssembly = myAssemblies(i)\n         End If\n      Next i &#39; Display the full assembly information to the console.\n      If Not (myAssembly Is Nothing) Then\n         Console.WriteLine(vbCrLf &amp; &quot;Displaying the full assembly name&quot; &amp; vbCrLf)\n         Console.WriteLine(myAssembly.GetName().FullName)\n      End If\n   End Sub \nEnd Class \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_ContentType\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_ContentType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ContentType</div>        \r\n          </div>\r\n    \r\n            <p>Gets or sets a value that indicates what type of content the assembly contains.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.AssemblyContentType ContentType { get; set; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.assemblycontenttype\" data-linktype=\"relative-path\">AssemblyContentType</a></div>\r\n                  </div>\r\n                  <p>A value that indicates what type of content the assembly contains.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_CultureInfo\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_CultureInfo_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">CultureInfo</div>        \r\n          </div>\r\n    \r\n            <p>Gets or sets the culture supported by the assembly.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Globalization.CultureInfo CultureInfo { get; set; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.globalization.cultureinfo\" data-linktype=\"relative-path\">CultureInfo</a></div>\r\n                  </div>\r\n                  <p>An object that represents the culture supported by the assembly.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example emits a dynamic assembly and saves it to the current directory. When the assembly is created, the CultureInfo property is used to specify the culture, which is part of the assembly&#39;s display name.  </p>\n<pre><code class=\"lang-cs\" name=\"AssemblyName_CodeBase#2\">\nusing System;\nusing System.Reflection;\nusing System.Threading;\nusing System.IO;\nusing System.Globalization;\nusing System.Reflection.Emit;\nusing System.Configuration.Assemblies;\n\npublic class AssemblyName_CodeBase\n{\n   public static void MakeAssembly(AssemblyName myAssemblyName, string fileName)\n   {\n      // Get the assembly builder from the application domain associated with the current thread.\n      AssemblyBuilder myAssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave);\n      // Create a dynamic module in the assembly.\n      ModuleBuilder myModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName);\n      // Create a type in the module.\n      TypeBuilder myTypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;);\n      // Create a method called &#39;Main&#39;.\n      MethodBuilder myMethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public | MethodAttributes.HideBySig |\n         MethodAttributes.Static, typeof(void), null);\n      // Get the Intermediate Language generator for the method.\n      ILGenerator myILGenerator = myMethodBuilder.GetILGenerator();\n      // Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;);\n      // Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret);\n      // End the creation of the type.\n      myTypeBuilder.CreateType();\n      // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder);\n      myAssemblyBuilder.Save(fileName);\n   }\n\n   public static void Main()\n   {\n\n\n\n      // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      AssemblyName myAssemblyName = new AssemblyName();\n      // Set the codebase to the physical directory were the assembly resides.\n      myAssemblyName.CodeBase = Directory.GetCurrentDirectory();\n      // Set the culture information of the assembly to &#39;English-American&#39;.\n      myAssemblyName.CultureInfo = new CultureInfo(&quot;en-US&quot;);\n      // Set the hash algoritm to &#39;SHA1&#39;.\n      myAssemblyName.HashAlgorithm = AssemblyHashAlgorithm.SHA1;\n      myAssemblyName.Name = &quot;MyAssembly&quot;;\n      myAssemblyName.Version = new Version(&quot;1.0.0.2001&quot;);\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;);\n\n      // Get all the assemblies currently loaded in the application domain.\n      Assembly[] myAssemblies = Thread.GetDomain().GetAssemblies();\n\n      // Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Assembly myAssembly = null;\n      for(int i = 0; i &lt; myAssemblies.Length; i++)\n      {\n         if(String.Compare(myAssemblies[i].GetName().Name, &quot;MyAssembly&quot;) == 0)\n            myAssembly = myAssemblies[i];\n      }\n      // Display the full assembly information to the console.\n      if(myAssembly != null)\n      {\n         Console.WriteLine(&quot;<br>Displaying the full assembly name<br>&quot;);\n         Console.WriteLine(myAssembly.GetName().FullName);\n      }\n   }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"AssemblyName_CodeBase#2\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Threading;\nusing namespace System::IO;\nusing namespace System::Globalization;\nusing namespace System::Reflection::Emit;\nusing namespace System::Configuration::Assemblies;\nstatic void MakeAssembly( AssemblyName^ myAssemblyName, String^ fileName )\n{\n   // Get the assembly builder from the application domain associated with the current thread.\n   AssemblyBuilder^ myAssemblyBuilder = Thread::GetDomain()-&gt;DefineDynamicAssembly( myAssemblyName, AssemblyBuilderAccess::RunAndSave );\n\n   // Create a dynamic module in the assembly.\n   ModuleBuilder^ myModuleBuilder = myAssemblyBuilder-&gt;DefineDynamicModule( &quot;MyModule&quot;, fileName );\n\n   // Create a type in the module.\n   TypeBuilder^ myTypeBuilder = myModuleBuilder-&gt;DefineType( &quot;MyType&quot; );\n\n   // Create a method called &#39;Main&#39;.\n   MethodBuilder^ myMethodBuilder = myTypeBuilder-&gt;DefineMethod( &quot;Main&quot;, static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::HideBySig | MethodAttributes::Static), void::typeid, nullptr );\n\n   // Get the Intermediate Language generator for the method.\n   ILGenerator^ myILGenerator = myMethodBuilder-&gt;GetILGenerator();\n\n   // Use the utility method to generate the IL instructions that print a String* to the console.\n   myILGenerator-&gt;EmitWriteLine( &quot;Hello World!&quot; );\n\n   // Generate the &#39;ret&#39; IL instruction.\n   myILGenerator-&gt;Emit( OpCodes::Ret );\n\n   // End the creation of the type.\n   myTypeBuilder-&gt;CreateType();\n\n   // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n   myAssemblyBuilder-&gt;SetEntryPoint( myMethodBuilder );\n   myAssemblyBuilder-&gt;Save( fileName );\n}\n\nint main()\n{\n   // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n   AssemblyName^ myAssemblyName = gcnew AssemblyName;\n\n   // Set the codebase to the physical directory were the assembly resides.\n   myAssemblyName-&gt;CodeBase = Directory::GetCurrentDirectory();\n\n   // Set the culture information of the assembly to &#39;English-American&#39;.\n   myAssemblyName-&gt;CultureInfo = gcnew CultureInfo( &quot;en-US&quot; );\n\n   // Set the hash algoritm to &#39;SHA1&#39;.\n   myAssemblyName-&gt;HashAlgorithm = AssemblyHashAlgorithm::SHA1;\n   myAssemblyName-&gt;Name = &quot;MyAssembly&quot;;\n   myAssemblyName-&gt;Version = gcnew Version( &quot;1.0.0.2001&quot; );\n   MakeAssembly( myAssemblyName, &quot;MyAssembly.exe&quot; );\n\n   // Get all the assemblies currently loaded in the application domain.\n   array&lt;Assembly^&gt;^myAssemblies = Thread::GetDomain()-&gt;GetAssemblies();\n\n   // Get the dynamic assembly named &#39;MyAssembly&#39;. \n   Assembly^ myAssembly = nullptr;\n   for ( int i = 0; i &lt; myAssemblies-&gt;Length; i++ )\n   {\n      if ( String::Compare( myAssemblies[ i ]-&gt;GetName()-&gt;Name, &quot;MyAssembly&quot; ) == 0 )\n            myAssembly = myAssemblies[ i ];\n   }\n   if ( myAssembly != nullptr )\n   {\n      Console::WriteLine( &quot;<br>Displaying the full assembly name<br>&quot; );\n      Console::WriteLine( myAssembly-&gt;GetName()-&gt;FullName );\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"AssemblyName_CodeBase#2\">\nImports System\nImports Microsoft.VisualBasic\nImports System.Reflection\nImports System.Threading\nImports System.IO\nImports System.Globalization\nImports System.Reflection.Emit\nImports System.Configuration.Assemblies\n\nPublic Class AssemblyName_CodeBase\n   \n   Public Shared Sub MakeAssembly(myAssemblyName As AssemblyName, fileName As String)\n      &#39; Get the assembly builder from the application domain associated with the current thread.\n      Dim myAssemblyBuilder As AssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave)\n      &#39; Create a dynamic module in the assembly.\n      Dim myModuleBuilder As ModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName)\n      &#39; Create a type in the module.\n      Dim myTypeBuilder As TypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;)\n      &#39; Create a method called &#39;Main&#39;.\n      Dim myMethodBuilder As MethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public Or MethodAttributes.HideBySig Or MethodAttributes.Static, GetType(object), Nothing)\n      &#39; Get the Intermediate Language generator for the method.\n      Dim myILGenerator As ILGenerator = myMethodBuilder.GetILGenerator()\n      &#39; Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;)\n      &#39; Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret)\n      &#39; End the creation of the type.\n      myTypeBuilder.CreateType()\n      &#39; Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder)\n      myAssemblyBuilder.Save(fileName)\n   End Sub &#39;MakeAssembly\n   \n   \n   Public Shared Sub Main()\n      \n      &#39; Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      Dim myAssemblyName As New AssemblyName()\n      &#39; Set the codebase to the physical directory were the assembly resides.\n      myAssemblyName.CodeBase = Directory.GetCurrentDirectory()\n      &#39; Set the culture information of the assembly to &#39;English-American&#39;.\n      myAssemblyName.CultureInfo = New CultureInfo(&quot;en-US&quot;)\n      &#39; Set the hash algoritm to &#39;SHA1&#39;.\n      myAssemblyName.HashAlgorithm = AssemblyHashAlgorithm.SHA1\n      myAssemblyName.Name = &quot;MyAssembly&quot;\n      myAssemblyName.Version = New Version(&quot;1.0.0.2001&quot;)\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;)\n      \n      &#39; Get all the assemblies currently loaded in the application domain.\n      Dim myAssemblies As [Assembly]() = Thread.GetDomain().GetAssemblies()\n      \n      &#39; Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Dim myAssembly As [Assembly] = Nothing\n      Dim i As Integer\n      For i = 0 To myAssemblies.Length - 1\n         If [String].Compare(myAssemblies(i).GetName().Name, &quot;MyAssembly&quot;) = 0 Then\n            myAssembly = myAssemblies(i)\n         End If\n      Next i &#39; Display the full assembly information to the console.\n      If Not (myAssembly Is Nothing) Then\n         Console.WriteLine(vbCrLf &amp; &quot;Displaying the full assembly name&quot; &amp; vbCrLf)\n         Console.WriteLine(myAssembly.GetName().FullName)\n      End If\n   End Sub \nEnd Class \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_CultureName\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_CultureName_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">CultureName</div>        \r\n          </div>\r\n    \r\n            <p>Gets or sets the name of the culture associated with the assembly.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public string CultureName { get; set; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </div>\r\n                  <p>The culture name.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_EscapedCodeBase\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_EscapedCodeBase_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">EscapedCodeBase</div>        \r\n          </div>\r\n    \r\n            <p>Gets the URI, including escape characters, that represents the codebase.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public string EscapedCodeBase { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </div>\r\n                  <p>A URI with escape characters.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_Flags\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_Flags_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Flags</div>        \r\n          </div>\r\n    \r\n            <p>Gets or sets the attributes of the assembly.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.AssemblyNameFlags Flags { get; set; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.assemblynameflags\" data-linktype=\"relative-path\">AssemblyNameFlags</a></div>\r\n                  </div>\r\n                  <p>A value that represents the attributes of the assembly.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example emits a dynamic assembly and saves it to the current directory. When the assembly is created, the Flags property is used to specify that the assembly has a public key.  </p>\n<pre><code class=\"lang-vb\" name=\"AssemblyName_KeyPair#4\">Imports System\nImports System.Reflection\nImports System.Threading\nImports System.IO\nImports System.Globalization\nImports System.Reflection.Emit\nImports System.Configuration.Assemblies\nImports System.Text\nImports Microsoft.VisualBasic\n\n\nPublic Class AssemblyName_CodeBase\n   \n   Public Shared Sub MakeAssembly(myAssemblyName As AssemblyName, fileName As String)\n      &#39; Get the assembly builder from the application domain associated with the current thread.\n      Dim myAssemblyBuilder As AssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave)\n      &#39; Create a dynamic module in the assembly.\n      Dim myModuleBuilder As ModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName)\n      &#39; Create a type in the module.\n      Dim myTypeBuilder As TypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;)\n      &#39; Create a method called &#39;Main&#39;.\n      Dim myMethodBuilder As MethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public Or MethodAttributes.HideBySig Or MethodAttributes.Static, GetType(object), Nothing)\n      &#39; Get the Intermediate Language generator for the method.\n      Dim myILGenerator As ILGenerator = myMethodBuilder.GetILGenerator()\n      &#39; Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;)\n      &#39; Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret)\n      &#39; End the creation of the type.\n      myTypeBuilder.CreateType()\n      &#39; Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder)\n      myAssemblyBuilder.Save(fileName)\n   End Sub &#39;MakeAssembly\n   \n   \n   Public Shared Sub Main()\n      \n\n      &#39; Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      Dim myAssemblyName As New AssemblyName()\n      &#39; Set the codebase to the physical directory were the assembly resides.\n      myAssemblyName.CodeBase = Directory.GetCurrentDirectory()\n      &#39; Set the culture information of the assembly to &#39;English-American&#39;.\n      myAssemblyName.CultureInfo = New CultureInfo(&quot;en-US&quot;)\n      &#39; Set the hash algoritm to &#39;SHA1&#39;.\n      myAssemblyName.HashAlgorithm = AssemblyHashAlgorithm.SHA1\n      myAssemblyName.VersionCompatibility = AssemblyVersionCompatibility.SameProcess\n      myAssemblyName.Flags = AssemblyNameFlags.PublicKey\n      &#39; Provide this assembly with a strong name.\n      myAssemblyName.KeyPair = New StrongNameKeyPair(File.Open(&quot;KeyPair.snk&quot;, FileMode.Open, FileAccess.Read))\n      myAssemblyName.Name = &quot;MyAssembly&quot;\n      myAssemblyName.Version = New Version(&quot;1.0.0.2001&quot;)\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;)\n      \n      &#39; Get the assemblies loaded in the current application domain.\n      Dim myAssemblies As [Assembly]() = Thread.GetDomain().GetAssemblies()\n      \n      &#39; Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Dim myAssembly As [Assembly] = Nothing\n      Dim i As Integer\n      For i = 0 To myAssemblies.Length - 1\n         If [String].Compare(myAssemblies(i).GetName().Name, &quot;MyAssembly&quot;) = 0 Then\n            myAssembly = myAssemblies(i)\n         End If \n      Next i &#39; Display the full assembly information to the console.\n      If Not (myAssembly Is Nothing) Then\n      Console.WriteLine(ControlChars.CrLf +&quot;Displaying the full assembly name.&quot;+ ControlChars.CrLf)\n      Console.WriteLine(myAssembly.GetName().FullName)\n      Console.WriteLine(ControlChars.CrLf +&quot;Displaying the public key.&quot; + ControlChars.CrLf)\n      Dim pk() As Byte\n      pk = myAssembly.GetName().GetPublicKey()\n      For i = 0 To (pk.GetLength(0)) - 1\n         Console.Write(&quot;{0:x2}&quot;, pk(i))\n      Next i\n      Console.WriteLine()\n      Console.WriteLine(ControlChars.CrLf +&quot;Displaying the public key token.&quot;+ ControlChars.CrLf)\n      Dim pt() As Byte\n      pt = myAssembly.GetName().GetPublicKeyToken()\n      For i = 0 To (pt.GetLength(0)) - 1\n         Console.Write(&quot;{0:x2}&quot;, pt(i))\n      Next i\n      End If\n   End Sub &#39;Main \nEnd Class &#39;AssemblyName_CodeBase \n</code></pre><pre><code class=\"lang-cs\" name=\"AssemblyName_KeyPair#4\">\nusing System;\nusing System.Reflection;\nusing System.Threading;\nusing System.IO;\nusing System.Globalization;\nusing System.Reflection.Emit;\nusing System.Configuration.Assemblies;\nusing System.Text;\n\npublic class AssemblyName_CodeBase\n{\n   public static void MakeAssembly(AssemblyName myAssemblyName, string fileName)\n   {\n      // Get the assembly builder from the application domain associated with the current thread.\n      AssemblyBuilder myAssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave);\n      // Create a dynamic module in the assembly.\n      ModuleBuilder myModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName);\n      // Create a type in the module.\n      TypeBuilder myTypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;);\n      // Create a method called &#39;Main&#39;.\n      MethodBuilder myMethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public | MethodAttributes.HideBySig |\n         MethodAttributes.Static, typeof(void), null);\n      // Get the Intermediate Language generator for the method.\n      ILGenerator myILGenerator = myMethodBuilder.GetILGenerator();\n      // Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;);\n      // Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret);\n      // End the creation of the type.\n      myTypeBuilder.CreateType();\n      // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder);\n      myAssemblyBuilder.Save(fileName);\n   }\n\n   public static void Main()\n   {\n      // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      AssemblyName myAssemblyName = new AssemblyName();\n      // Set the codebase to the physical directory were the assembly resides.\n      myAssemblyName.CodeBase = Directory.GetCurrentDirectory();\n      // Set the culture information of the assembly to &#39;English-American&#39;.\n      myAssemblyName.CultureInfo = new CultureInfo(&quot;en-US&quot;);\n      // Set the hash algoritm to &#39;SHA1&#39;.\n      myAssemblyName.HashAlgorithm = AssemblyHashAlgorithm.SHA1;\n      myAssemblyName.VersionCompatibility = AssemblyVersionCompatibility.SameProcess;\n      myAssemblyName.Flags = AssemblyNameFlags.PublicKey;\n      // Provide this assembly with a strong name.\n      myAssemblyName.KeyPair = new StrongNameKeyPair(File.Open(&quot;KeyPair.snk&quot;, FileMode.Open, FileAccess.Read));\n      myAssemblyName.Name = &quot;MyAssembly&quot;;\n      myAssemblyName.Version = new Version(&quot;1.0.0.2001&quot;);\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;);\n      \n      // Get the assemblies loaded in the current application domain.\n      Assembly[] myAssemblies = Thread.GetDomain().GetAssemblies();\n\n      // Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Assembly myAssembly = null;\n      for(int i = 0; i &lt; myAssemblies.Length; i++)\n         if(String.Compare(myAssemblies[i].GetName().Name, &quot;MyAssembly&quot;) == 0)\n            myAssembly = myAssemblies[i];\n\n      // Display the full assembly information to the console.\n      if(myAssembly != null)\n      {\n         Console.WriteLine(&quot;<br>Displaying the full assembly name.<br>&quot;);\n         Console.WriteLine(myAssembly.GetName().FullName);\n         Console.WriteLine(&quot;<br>Displaying the public key.<br>&quot;);\n         byte []pk;\n         pk = myAssembly.GetName().GetPublicKey();\n \t     for (int i=0;i&lt;pk.GetLength(0);i++)\n \t\t    Console.Write (&quot;{0:x2}&quot;, pk[i]);\n         Console.WriteLine();\n         Console.WriteLine(&quot;<br>Displaying the public key token.<br>&quot;);\n         byte []pt;\n         pt = myAssembly.GetName().GetPublicKeyToken();\n         for (int i=0;i&lt;pt.GetLength(0);i++)\n \t\t    Console.Write (&quot;{0:x2}&quot;, pt[i]);\n      }\n   }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"AssemblyName_KeyPair#4\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Threading;\nusing namespace System::IO;\nusing namespace System::Globalization;\nusing namespace System::Reflection::Emit;\nusing namespace System::Configuration::Assemblies;\nusing namespace System::Text;\nstatic void MakeAssembly( AssemblyName^ myAssemblyName, String^ fileName )\n{\n   // Get the assembly builder from the application domain associated with the current thread.\n   AssemblyBuilder^ myAssemblyBuilder = Thread::GetDomain()-&gt;DefineDynamicAssembly( myAssemblyName, AssemblyBuilderAccess::RunAndSave );\n\n   // Create a dynamic module in the assembly.\n   ModuleBuilder^ myModuleBuilder = myAssemblyBuilder-&gt;DefineDynamicModule( &quot;MyModule&quot;, fileName );\n\n   // Create a type in the module.\n   TypeBuilder^ myTypeBuilder = myModuleBuilder-&gt;DefineType( &quot;MyType&quot; );\n\n   // Create a method called &#39;Main&#39;.\n   MethodBuilder^ myMethodBuilder = myTypeBuilder-&gt;DefineMethod( &quot;Main&quot;, static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::HideBySig | MethodAttributes::Static), void::typeid, nullptr );\n\n   // Get the Intermediate Language generator for the method.\n   ILGenerator^ myILGenerator = myMethodBuilder-&gt;GetILGenerator();\n\n   // Use the utility method to generate the IL instructions that print a String* to the console.\n   myILGenerator-&gt;EmitWriteLine( &quot;Hello World!&quot; );\n\n   // Generate the &#39;ret&#39; IL instruction.\n   myILGenerator-&gt;Emit( OpCodes::Ret );\n\n   // End the creation of the type.\n   myTypeBuilder-&gt;CreateType();\n\n   // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n   myAssemblyBuilder-&gt;SetEntryPoint( myMethodBuilder );\n   myAssemblyBuilder-&gt;Save( fileName );\n}\n\nint main()\n{\n   // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n   AssemblyName^ myAssemblyName = gcnew AssemblyName;\n\n   // Set the codebase to the physical directory were the assembly resides.\n   myAssemblyName-&gt;CodeBase = Directory::GetCurrentDirectory();\n\n   // Set the culture information of the assembly to &#39;English-American&#39;.\n   myAssemblyName-&gt;CultureInfo = gcnew CultureInfo( &quot;en-US&quot; );\n\n   // Set the hash algoritm to &#39;SHA1&#39;.\n   myAssemblyName-&gt;HashAlgorithm = AssemblyHashAlgorithm::SHA1;\n   myAssemblyName-&gt;VersionCompatibility = AssemblyVersionCompatibility::SameProcess;\n   myAssemblyName-&gt;Flags = AssemblyNameFlags::PublicKey;\n\n   // Provide this assembly with a strong name.\n   myAssemblyName-&gt;KeyPair = gcnew StrongNameKeyPair( File::Open( &quot;KeyPair.snk&quot;, FileMode::Open, FileAccess::Read ) );\n   myAssemblyName-&gt;Name = &quot;MyAssembly&quot;;\n   myAssemblyName-&gt;Version = gcnew Version( &quot;1.0.0.2001&quot; );\n   MakeAssembly( myAssemblyName, &quot;MyAssembly.exe&quot; );\n\n   // Get the assemblies loaded in the current application domain.\n   array&lt;Assembly^&gt;^myAssemblies = Thread::GetDomain()-&gt;GetAssemblies();\n\n   // Get the dynamic assembly named &#39;MyAssembly&#39;. \n   Assembly^ myAssembly = nullptr;\n   for ( int i = 0; i &lt; myAssemblies-&gt;Length; i++ )\n      if ( String::Compare( myAssemblies[ i ]-&gt;GetName()-&gt;Name, &quot;MyAssembly&quot; ) == 0 )\n            myAssembly = myAssemblies[ i ];\n\n   // Display the full assembly information to the console.\n   if ( myAssembly != nullptr )\n   {\n      Console::WriteLine( &quot;<br>Displaying the full assembly name.<br>&quot; );\n      Console::WriteLine( myAssembly-&gt;GetName()-&gt;FullName );\n      Console::WriteLine( &quot;<br>Displaying the public key.<br>&quot; );\n      array&lt;Byte&gt;^pk;\n      pk = myAssembly-&gt;GetName()-&gt;GetPublicKey();\n      for ( int i = 0; i &lt; pk-&gt;GetLength( 0 ); i++ )\n         Console::Write( &quot; {0:x2}&quot;, pk[ i ] );\n      Console::WriteLine();\n      Console::WriteLine( &quot;<br>Displaying the public key token.<br>&quot; );\n      array&lt;Byte&gt;^pt;\n      pt = myAssembly-&gt;GetName()-&gt;GetPublicKeyToken();\n      for ( int i = 0; i &lt; pt-&gt;GetLength( 0 ); i++ )\n         Console::Write(  &quot; {0:x2}&quot;, pt[ i ] );\n   }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_FullName\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_FullName_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">FullName</div>        \r\n          </div>\r\n    \r\n            <p>Gets the full name of the assembly, also known as the display name.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public string FullName { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </div>\r\n                  <p>A string that is the full name of the assembly, also known as the display name.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The display name typically consists of the simple name, version number, supported culture, and public key. For example:  </p>\n<pre><code>mylib, Version=1.2.1900.0, Culture=neutral, PublicKeyToken=a14f3033def15840  \n</code></pre><p> Writing your own code to parse display names is not recommended. Instead, pass the display name to the <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName__ctor_\" data-linktype=\"relative-path\">AssemblyName</a> constructor, which parses it and populates the appropriate fields of the new <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a>.  </p>\n<p> When an assembly is loaded, this value can also be obtained using the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_FullName_\" data-linktype=\"relative-path\">FullName</a> property.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example emits a dynamic assembly and saves it to the current directory. When the assembly is created, the code example sets the <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_Name_\" data-linktype=\"relative-path\">Name</a>, <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_Version_\" data-linktype=\"relative-path\">Version</a>, <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_CultureInfo_\" data-linktype=\"relative-path\">CultureInfo</a>, and <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_KeyPair_\" data-linktype=\"relative-path\">KeyPair</a> properties, which together comprise an assembly&#39;s full name, or display name. The FullName property is then used to retrieve the display name.  </p>\n<pre><code class=\"lang-cs\" name=\"AssemblyName_CodeBase#4\">\nusing System;\nusing System.Reflection;\nusing System.Threading;\nusing System.IO;\nusing System.Globalization;\nusing System.Reflection.Emit;\nusing System.Configuration.Assemblies;\n\npublic class AssemblyName_CodeBase\n{\n   public static void MakeAssembly(AssemblyName myAssemblyName, string fileName)\n   {\n      // Get the assembly builder from the application domain associated with the current thread.\n      AssemblyBuilder myAssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave);\n      // Create a dynamic module in the assembly.\n      ModuleBuilder myModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName);\n      // Create a type in the module.\n      TypeBuilder myTypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;);\n      // Create a method called &#39;Main&#39;.\n      MethodBuilder myMethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public | MethodAttributes.HideBySig |\n         MethodAttributes.Static, typeof(void), null);\n      // Get the Intermediate Language generator for the method.\n      ILGenerator myILGenerator = myMethodBuilder.GetILGenerator();\n      // Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;);\n      // Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret);\n      // End the creation of the type.\n      myTypeBuilder.CreateType();\n      // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder);\n      myAssemblyBuilder.Save(fileName);\n   }\n\n   public static void Main()\n   {\n\n\n\n      // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      AssemblyName myAssemblyName = new AssemblyName();\n      // Set the codebase to the physical directory were the assembly resides.\n      myAssemblyName.CodeBase = Directory.GetCurrentDirectory();\n      // Set the culture information of the assembly to &#39;English-American&#39;.\n      myAssemblyName.CultureInfo = new CultureInfo(&quot;en-US&quot;);\n      // Set the hash algoritm to &#39;SHA1&#39;.\n      myAssemblyName.HashAlgorithm = AssemblyHashAlgorithm.SHA1;\n      myAssemblyName.Name = &quot;MyAssembly&quot;;\n      myAssemblyName.Version = new Version(&quot;1.0.0.2001&quot;);\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;);\n\n      // Get all the assemblies currently loaded in the application domain.\n      Assembly[] myAssemblies = Thread.GetDomain().GetAssemblies();\n\n      // Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Assembly myAssembly = null;\n      for(int i = 0; i &lt; myAssemblies.Length; i++)\n      {\n         if(String.Compare(myAssemblies[i].GetName().Name, &quot;MyAssembly&quot;) == 0)\n            myAssembly = myAssemblies[i];\n      }\n      // Display the full assembly information to the console.\n      if(myAssembly != null)\n      {\n         Console.WriteLine(&quot;<br>Displaying the full assembly name<br>&quot;);\n         Console.WriteLine(myAssembly.GetName().FullName);\n      }\n   }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"AssemblyName_CodeBase#4\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Threading;\nusing namespace System::IO;\nusing namespace System::Globalization;\nusing namespace System::Reflection::Emit;\nusing namespace System::Configuration::Assemblies;\nstatic void MakeAssembly( AssemblyName^ myAssemblyName, String^ fileName )\n{\n   // Get the assembly builder from the application domain associated with the current thread.\n   AssemblyBuilder^ myAssemblyBuilder = Thread::GetDomain()-&gt;DefineDynamicAssembly( myAssemblyName, AssemblyBuilderAccess::RunAndSave );\n\n   // Create a dynamic module in the assembly.\n   ModuleBuilder^ myModuleBuilder = myAssemblyBuilder-&gt;DefineDynamicModule( &quot;MyModule&quot;, fileName );\n\n   // Create a type in the module.\n   TypeBuilder^ myTypeBuilder = myModuleBuilder-&gt;DefineType( &quot;MyType&quot; );\n\n   // Create a method called &#39;Main&#39;.\n   MethodBuilder^ myMethodBuilder = myTypeBuilder-&gt;DefineMethod( &quot;Main&quot;, static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::HideBySig | MethodAttributes::Static), void::typeid, nullptr );\n\n   // Get the Intermediate Language generator for the method.\n   ILGenerator^ myILGenerator = myMethodBuilder-&gt;GetILGenerator();\n\n   // Use the utility method to generate the IL instructions that print a String* to the console.\n   myILGenerator-&gt;EmitWriteLine( &quot;Hello World!&quot; );\n\n   // Generate the &#39;ret&#39; IL instruction.\n   myILGenerator-&gt;Emit( OpCodes::Ret );\n\n   // End the creation of the type.\n   myTypeBuilder-&gt;CreateType();\n\n   // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n   myAssemblyBuilder-&gt;SetEntryPoint( myMethodBuilder );\n   myAssemblyBuilder-&gt;Save( fileName );\n}\n\nint main()\n{\n   // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n   AssemblyName^ myAssemblyName = gcnew AssemblyName;\n\n   // Set the codebase to the physical directory were the assembly resides.\n   myAssemblyName-&gt;CodeBase = Directory::GetCurrentDirectory();\n\n   // Set the culture information of the assembly to &#39;English-American&#39;.\n   myAssemblyName-&gt;CultureInfo = gcnew CultureInfo( &quot;en-US&quot; );\n\n   // Set the hash algoritm to &#39;SHA1&#39;.\n   myAssemblyName-&gt;HashAlgorithm = AssemblyHashAlgorithm::SHA1;\n   myAssemblyName-&gt;Name = &quot;MyAssembly&quot;;\n   myAssemblyName-&gt;Version = gcnew Version( &quot;1.0.0.2001&quot; );\n   MakeAssembly( myAssemblyName, &quot;MyAssembly.exe&quot; );\n\n   // Get all the assemblies currently loaded in the application domain.\n   array&lt;Assembly^&gt;^myAssemblies = Thread::GetDomain()-&gt;GetAssemblies();\n\n   // Get the dynamic assembly named &#39;MyAssembly&#39;. \n   Assembly^ myAssembly = nullptr;\n   for ( int i = 0; i &lt; myAssemblies-&gt;Length; i++ )\n   {\n      if ( String::Compare( myAssemblies[ i ]-&gt;GetName()-&gt;Name, &quot;MyAssembly&quot; ) == 0 )\n            myAssembly = myAssemblies[ i ];\n   }\n   if ( myAssembly != nullptr )\n   {\n      Console::WriteLine( &quot;<br>Displaying the full assembly name<br>&quot; );\n      Console::WriteLine( myAssembly-&gt;GetName()-&gt;FullName );\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"AssemblyName_CodeBase#4\">\nImports System\nImports Microsoft.VisualBasic\nImports System.Reflection\nImports System.Threading\nImports System.IO\nImports System.Globalization\nImports System.Reflection.Emit\nImports System.Configuration.Assemblies\n\nPublic Class AssemblyName_CodeBase\n   \n   Public Shared Sub MakeAssembly(myAssemblyName As AssemblyName, fileName As String)\n      &#39; Get the assembly builder from the application domain associated with the current thread.\n      Dim myAssemblyBuilder As AssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave)\n      &#39; Create a dynamic module in the assembly.\n      Dim myModuleBuilder As ModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName)\n      &#39; Create a type in the module.\n      Dim myTypeBuilder As TypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;)\n      &#39; Create a method called &#39;Main&#39;.\n      Dim myMethodBuilder As MethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public Or MethodAttributes.HideBySig Or MethodAttributes.Static, GetType(object), Nothing)\n      &#39; Get the Intermediate Language generator for the method.\n      Dim myILGenerator As ILGenerator = myMethodBuilder.GetILGenerator()\n      &#39; Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;)\n      &#39; Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret)\n      &#39; End the creation of the type.\n      myTypeBuilder.CreateType()\n      &#39; Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder)\n      myAssemblyBuilder.Save(fileName)\n   End Sub &#39;MakeAssembly\n   \n   \n   Public Shared Sub Main()\n      \n      &#39; Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      Dim myAssemblyName As New AssemblyName()\n      &#39; Set the codebase to the physical directory were the assembly resides.\n      myAssemblyName.CodeBase = Directory.GetCurrentDirectory()\n      &#39; Set the culture information of the assembly to &#39;English-American&#39;.\n      myAssemblyName.CultureInfo = New CultureInfo(&quot;en-US&quot;)\n      &#39; Set the hash algoritm to &#39;SHA1&#39;.\n      myAssemblyName.HashAlgorithm = AssemblyHashAlgorithm.SHA1\n      myAssemblyName.Name = &quot;MyAssembly&quot;\n      myAssemblyName.Version = New Version(&quot;1.0.0.2001&quot;)\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;)\n      \n      &#39; Get all the assemblies currently loaded in the application domain.\n      Dim myAssemblies As [Assembly]() = Thread.GetDomain().GetAssemblies()\n      \n      &#39; Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Dim myAssembly As [Assembly] = Nothing\n      Dim i As Integer\n      For i = 0 To myAssemblies.Length - 1\n         If [String].Compare(myAssemblies(i).GetName().Name, &quot;MyAssembly&quot;) = 0 Then\n            myAssembly = myAssemblies(i)\n         End If\n      Next i &#39; Display the full assembly information to the console.\n      If Not (myAssembly Is Nothing) Then\n         Console.WriteLine(vbCrLf &amp; &quot;Displaying the full assembly name&quot; &amp; vbCrLf)\n         Console.WriteLine(myAssembly.GetName().FullName)\n      End If\n   End Sub \nEnd Class \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_HashAlgorithm\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_HashAlgorithm_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">HashAlgorithm</div>        \r\n          </div>\r\n    \r\n            <p>Gets or sets the hash algorithm used by the assembly manifest.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Configuration.Assemblies.AssemblyHashAlgorithm HashAlgorithm { get; set; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.configuration.assemblies.assemblyhashalgorithm\" data-linktype=\"relative-path\">AssemblyHashAlgorithm</a></div>\r\n                  </div>\r\n                  <p>The hash algorithm used by the assembly manifest.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <div class=\"IMPORTANT\"><h5>Important</h5><p> Starting with the .NET Framework 4, the HashAlgorithm property of an <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> object that is returned by the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_GetReferencedAssemblies_\" data-linktype=\"relative-path\">GetReferencedAssemblies</a> method is <a class=\"xref\" href=\"system.configuration.assemblies.assemblyhashalgorithm\" data-linktype=\"relative-path\">System.Configuration.Assemblies.AssemblyHashAlgorithm</a> if there is no hash algorithm for the referenced assembly, or if the hash algorithm of the referenced assembly is not identified by the <a class=\"xref\" href=\"system.configuration.assemblies.assemblyhashalgorithm\" data-linktype=\"relative-path\">System.Configuration.Assemblies.AssemblyHashAlgorithm</a> enumeration. In previous versions of the .NET Framework, the HashAlgorithm property returned <a class=\"xref\" href=\"system.configuration.assemblies.assemblyhashalgorithm\" data-linktype=\"relative-path\">System.Configuration.Assemblies.AssemblyHashAlgorithm</a> in this situation.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example emits a dynamic assembly and saves it to the current directory. When the assembly is created, the HashAlgorithm property is used to set the hash algorithm for the assembly manifest.  </p>\n<pre><code class=\"lang-cs\" name=\"AssemblyName_CodeBase#3\">\nusing System;\nusing System.Reflection;\nusing System.Threading;\nusing System.IO;\nusing System.Globalization;\nusing System.Reflection.Emit;\nusing System.Configuration.Assemblies;\n\npublic class AssemblyName_CodeBase\n{\n   public static void MakeAssembly(AssemblyName myAssemblyName, string fileName)\n   {\n      // Get the assembly builder from the application domain associated with the current thread.\n      AssemblyBuilder myAssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave);\n      // Create a dynamic module in the assembly.\n      ModuleBuilder myModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName);\n      // Create a type in the module.\n      TypeBuilder myTypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;);\n      // Create a method called &#39;Main&#39;.\n      MethodBuilder myMethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public | MethodAttributes.HideBySig |\n         MethodAttributes.Static, typeof(void), null);\n      // Get the Intermediate Language generator for the method.\n      ILGenerator myILGenerator = myMethodBuilder.GetILGenerator();\n      // Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;);\n      // Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret);\n      // End the creation of the type.\n      myTypeBuilder.CreateType();\n      // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder);\n      myAssemblyBuilder.Save(fileName);\n   }\n\n   public static void Main()\n   {\n\n\n\n      // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      AssemblyName myAssemblyName = new AssemblyName();\n      // Set the codebase to the physical directory were the assembly resides.\n      myAssemblyName.CodeBase = Directory.GetCurrentDirectory();\n      // Set the culture information of the assembly to &#39;English-American&#39;.\n      myAssemblyName.CultureInfo = new CultureInfo(&quot;en-US&quot;);\n      // Set the hash algoritm to &#39;SHA1&#39;.\n      myAssemblyName.HashAlgorithm = AssemblyHashAlgorithm.SHA1;\n      myAssemblyName.Name = &quot;MyAssembly&quot;;\n      myAssemblyName.Version = new Version(&quot;1.0.0.2001&quot;);\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;);\n\n      // Get all the assemblies currently loaded in the application domain.\n      Assembly[] myAssemblies = Thread.GetDomain().GetAssemblies();\n\n      // Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Assembly myAssembly = null;\n      for(int i = 0; i &lt; myAssemblies.Length; i++)\n      {\n         if(String.Compare(myAssemblies[i].GetName().Name, &quot;MyAssembly&quot;) == 0)\n            myAssembly = myAssemblies[i];\n      }\n      // Display the full assembly information to the console.\n      if(myAssembly != null)\n      {\n         Console.WriteLine(&quot;<br>Displaying the full assembly name<br>&quot;);\n         Console.WriteLine(myAssembly.GetName().FullName);\n      }\n   }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"AssemblyName_CodeBase#3\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Threading;\nusing namespace System::IO;\nusing namespace System::Globalization;\nusing namespace System::Reflection::Emit;\nusing namespace System::Configuration::Assemblies;\nstatic void MakeAssembly( AssemblyName^ myAssemblyName, String^ fileName )\n{\n   // Get the assembly builder from the application domain associated with the current thread.\n   AssemblyBuilder^ myAssemblyBuilder = Thread::GetDomain()-&gt;DefineDynamicAssembly( myAssemblyName, AssemblyBuilderAccess::RunAndSave );\n\n   // Create a dynamic module in the assembly.\n   ModuleBuilder^ myModuleBuilder = myAssemblyBuilder-&gt;DefineDynamicModule( &quot;MyModule&quot;, fileName );\n\n   // Create a type in the module.\n   TypeBuilder^ myTypeBuilder = myModuleBuilder-&gt;DefineType( &quot;MyType&quot; );\n\n   // Create a method called &#39;Main&#39;.\n   MethodBuilder^ myMethodBuilder = myTypeBuilder-&gt;DefineMethod( &quot;Main&quot;, static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::HideBySig | MethodAttributes::Static), void::typeid, nullptr );\n\n   // Get the Intermediate Language generator for the method.\n   ILGenerator^ myILGenerator = myMethodBuilder-&gt;GetILGenerator();\n\n   // Use the utility method to generate the IL instructions that print a String* to the console.\n   myILGenerator-&gt;EmitWriteLine( &quot;Hello World!&quot; );\n\n   // Generate the &#39;ret&#39; IL instruction.\n   myILGenerator-&gt;Emit( OpCodes::Ret );\n\n   // End the creation of the type.\n   myTypeBuilder-&gt;CreateType();\n\n   // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n   myAssemblyBuilder-&gt;SetEntryPoint( myMethodBuilder );\n   myAssemblyBuilder-&gt;Save( fileName );\n}\n\nint main()\n{\n   // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n   AssemblyName^ myAssemblyName = gcnew AssemblyName;\n\n   // Set the codebase to the physical directory were the assembly resides.\n   myAssemblyName-&gt;CodeBase = Directory::GetCurrentDirectory();\n\n   // Set the culture information of the assembly to &#39;English-American&#39;.\n   myAssemblyName-&gt;CultureInfo = gcnew CultureInfo( &quot;en-US&quot; );\n\n   // Set the hash algoritm to &#39;SHA1&#39;.\n   myAssemblyName-&gt;HashAlgorithm = AssemblyHashAlgorithm::SHA1;\n   myAssemblyName-&gt;Name = &quot;MyAssembly&quot;;\n   myAssemblyName-&gt;Version = gcnew Version( &quot;1.0.0.2001&quot; );\n   MakeAssembly( myAssemblyName, &quot;MyAssembly.exe&quot; );\n\n   // Get all the assemblies currently loaded in the application domain.\n   array&lt;Assembly^&gt;^myAssemblies = Thread::GetDomain()-&gt;GetAssemblies();\n\n   // Get the dynamic assembly named &#39;MyAssembly&#39;. \n   Assembly^ myAssembly = nullptr;\n   for ( int i = 0; i &lt; myAssemblies-&gt;Length; i++ )\n   {\n      if ( String::Compare( myAssemblies[ i ]-&gt;GetName()-&gt;Name, &quot;MyAssembly&quot; ) == 0 )\n            myAssembly = myAssemblies[ i ];\n   }\n   if ( myAssembly != nullptr )\n   {\n      Console::WriteLine( &quot;<br>Displaying the full assembly name<br>&quot; );\n      Console::WriteLine( myAssembly-&gt;GetName()-&gt;FullName );\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"AssemblyName_CodeBase#3\">\nImports System\nImports Microsoft.VisualBasic\nImports System.Reflection\nImports System.Threading\nImports System.IO\nImports System.Globalization\nImports System.Reflection.Emit\nImports System.Configuration.Assemblies\n\nPublic Class AssemblyName_CodeBase\n   \n   Public Shared Sub MakeAssembly(myAssemblyName As AssemblyName, fileName As String)\n      &#39; Get the assembly builder from the application domain associated with the current thread.\n      Dim myAssemblyBuilder As AssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave)\n      &#39; Create a dynamic module in the assembly.\n      Dim myModuleBuilder As ModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName)\n      &#39; Create a type in the module.\n      Dim myTypeBuilder As TypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;)\n      &#39; Create a method called &#39;Main&#39;.\n      Dim myMethodBuilder As MethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public Or MethodAttributes.HideBySig Or MethodAttributes.Static, GetType(object), Nothing)\n      &#39; Get the Intermediate Language generator for the method.\n      Dim myILGenerator As ILGenerator = myMethodBuilder.GetILGenerator()\n      &#39; Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;)\n      &#39; Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret)\n      &#39; End the creation of the type.\n      myTypeBuilder.CreateType()\n      &#39; Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder)\n      myAssemblyBuilder.Save(fileName)\n   End Sub &#39;MakeAssembly\n   \n   \n   Public Shared Sub Main()\n      \n      &#39; Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      Dim myAssemblyName As New AssemblyName()\n      &#39; Set the codebase to the physical directory were the assembly resides.\n      myAssemblyName.CodeBase = Directory.GetCurrentDirectory()\n      &#39; Set the culture information of the assembly to &#39;English-American&#39;.\n      myAssemblyName.CultureInfo = New CultureInfo(&quot;en-US&quot;)\n      &#39; Set the hash algoritm to &#39;SHA1&#39;.\n      myAssemblyName.HashAlgorithm = AssemblyHashAlgorithm.SHA1\n      myAssemblyName.Name = &quot;MyAssembly&quot;\n      myAssemblyName.Version = New Version(&quot;1.0.0.2001&quot;)\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;)\n      \n      &#39; Get all the assemblies currently loaded in the application domain.\n      Dim myAssemblies As [Assembly]() = Thread.GetDomain().GetAssemblies()\n      \n      &#39; Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Dim myAssembly As [Assembly] = Nothing\n      Dim i As Integer\n      For i = 0 To myAssemblies.Length - 1\n         If [String].Compare(myAssemblies(i).GetName().Name, &quot;MyAssembly&quot;) = 0 Then\n            myAssembly = myAssemblies(i)\n         End If\n      Next i &#39; Display the full assembly information to the console.\n      If Not (myAssembly Is Nothing) Then\n         Console.WriteLine(vbCrLf &amp; &quot;Displaying the full assembly name&quot; &amp; vbCrLf)\n         Console.WriteLine(myAssembly.GetName().FullName)\n      End If\n   End Sub \nEnd Class \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_KeyPair\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_KeyPair_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">KeyPair</div>        \r\n          </div>\r\n    \r\n            <p>Gets or sets the public and private cryptographic key pair that is used to create a strong name signature for the assembly.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.StrongNameKeyPair KeyPair { get; set; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.strongnamekeypair\" data-linktype=\"relative-path\">StrongNameKeyPair</a></div>\r\n                  </div>\r\n                  <p>The public and private cryptographic key pair to be used to create a strong name for the assembly.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>When the runtime loads an assembly, it does not set the KeyPair property. The getter for the property is only useful if the user set the property before using the <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> object to create a dynamic assembly, and subsequently wants to retrieve the key pair.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example emits a dynamic assembly and saves it to the current directory. When the assembly is created, the KeyPair property is used to set the assembly&#39;s public and private cryptographic keys. .  </p>\n<pre><code class=\"lang-vb\" name=\"AssemblyName_KeyPair#1\">Imports System\nImports System.Reflection\nImports System.Threading\nImports System.IO\nImports System.Globalization\nImports System.Reflection.Emit\nImports System.Configuration.Assemblies\nImports System.Text\nImports Microsoft.VisualBasic\n\n\nPublic Class AssemblyName_CodeBase\n   \n   Public Shared Sub MakeAssembly(myAssemblyName As AssemblyName, fileName As String)\n      &#39; Get the assembly builder from the application domain associated with the current thread.\n      Dim myAssemblyBuilder As AssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave)\n      &#39; Create a dynamic module in the assembly.\n      Dim myModuleBuilder As ModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName)\n      &#39; Create a type in the module.\n      Dim myTypeBuilder As TypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;)\n      &#39; Create a method called &#39;Main&#39;.\n      Dim myMethodBuilder As MethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public Or MethodAttributes.HideBySig Or MethodAttributes.Static, GetType(object), Nothing)\n      &#39; Get the Intermediate Language generator for the method.\n      Dim myILGenerator As ILGenerator = myMethodBuilder.GetILGenerator()\n      &#39; Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;)\n      &#39; Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret)\n      &#39; End the creation of the type.\n      myTypeBuilder.CreateType()\n      &#39; Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder)\n      myAssemblyBuilder.Save(fileName)\n   End Sub &#39;MakeAssembly\n   \n   \n   Public Shared Sub Main()\n      \n\n      &#39; Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      Dim myAssemblyName As New AssemblyName()\n      &#39; Set the codebase to the physical directory were the assembly resides.\n      myAssemblyName.CodeBase = Directory.GetCurrentDirectory()\n      &#39; Set the culture information of the assembly to &#39;English-American&#39;.\n      myAssemblyName.CultureInfo = New CultureInfo(&quot;en-US&quot;)\n      &#39; Set the hash algoritm to &#39;SHA1&#39;.\n      myAssemblyName.HashAlgorithm = AssemblyHashAlgorithm.SHA1\n      myAssemblyName.VersionCompatibility = AssemblyVersionCompatibility.SameProcess\n      myAssemblyName.Flags = AssemblyNameFlags.PublicKey\n      &#39; Provide this assembly with a strong name.\n      myAssemblyName.KeyPair = New StrongNameKeyPair(File.Open(&quot;KeyPair.snk&quot;, FileMode.Open, FileAccess.Read))\n      myAssemblyName.Name = &quot;MyAssembly&quot;\n      myAssemblyName.Version = New Version(&quot;1.0.0.2001&quot;)\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;)\n      \n      &#39; Get the assemblies loaded in the current application domain.\n      Dim myAssemblies As [Assembly]() = Thread.GetDomain().GetAssemblies()\n      \n      &#39; Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Dim myAssembly As [Assembly] = Nothing\n      Dim i As Integer\n      For i = 0 To myAssemblies.Length - 1\n         If [String].Compare(myAssemblies(i).GetName().Name, &quot;MyAssembly&quot;) = 0 Then\n            myAssembly = myAssemblies(i)\n         End If \n      Next i &#39; Display the full assembly information to the console.\n      If Not (myAssembly Is Nothing) Then\n      Console.WriteLine(ControlChars.CrLf +&quot;Displaying the full assembly name.&quot;+ ControlChars.CrLf)\n      Console.WriteLine(myAssembly.GetName().FullName)\n      Console.WriteLine(ControlChars.CrLf +&quot;Displaying the public key.&quot; + ControlChars.CrLf)\n      Dim pk() As Byte\n      pk = myAssembly.GetName().GetPublicKey()\n      For i = 0 To (pk.GetLength(0)) - 1\n         Console.Write(&quot;{0:x2}&quot;, pk(i))\n      Next i\n      Console.WriteLine()\n      Console.WriteLine(ControlChars.CrLf +&quot;Displaying the public key token.&quot;+ ControlChars.CrLf)\n      Dim pt() As Byte\n      pt = myAssembly.GetName().GetPublicKeyToken()\n      For i = 0 To (pt.GetLength(0)) - 1\n         Console.Write(&quot;{0:x2}&quot;, pt(i))\n      Next i\n      End If\n   End Sub &#39;Main \nEnd Class &#39;AssemblyName_CodeBase \n</code></pre><pre><code class=\"lang-cs\" name=\"AssemblyName_KeyPair#1\">\nusing System;\nusing System.Reflection;\nusing System.Threading;\nusing System.IO;\nusing System.Globalization;\nusing System.Reflection.Emit;\nusing System.Configuration.Assemblies;\nusing System.Text;\n\npublic class AssemblyName_CodeBase\n{\n   public static void MakeAssembly(AssemblyName myAssemblyName, string fileName)\n   {\n      // Get the assembly builder from the application domain associated with the current thread.\n      AssemblyBuilder myAssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave);\n      // Create a dynamic module in the assembly.\n      ModuleBuilder myModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName);\n      // Create a type in the module.\n      TypeBuilder myTypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;);\n      // Create a method called &#39;Main&#39;.\n      MethodBuilder myMethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public | MethodAttributes.HideBySig |\n         MethodAttributes.Static, typeof(void), null);\n      // Get the Intermediate Language generator for the method.\n      ILGenerator myILGenerator = myMethodBuilder.GetILGenerator();\n      // Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;);\n      // Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret);\n      // End the creation of the type.\n      myTypeBuilder.CreateType();\n      // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder);\n      myAssemblyBuilder.Save(fileName);\n   }\n\n   public static void Main()\n   {\n      // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      AssemblyName myAssemblyName = new AssemblyName();\n      // Set the codebase to the physical directory were the assembly resides.\n      myAssemblyName.CodeBase = Directory.GetCurrentDirectory();\n      // Set the culture information of the assembly to &#39;English-American&#39;.\n      myAssemblyName.CultureInfo = new CultureInfo(&quot;en-US&quot;);\n      // Set the hash algoritm to &#39;SHA1&#39;.\n      myAssemblyName.HashAlgorithm = AssemblyHashAlgorithm.SHA1;\n      myAssemblyName.VersionCompatibility = AssemblyVersionCompatibility.SameProcess;\n      myAssemblyName.Flags = AssemblyNameFlags.PublicKey;\n      // Provide this assembly with a strong name.\n      myAssemblyName.KeyPair = new StrongNameKeyPair(File.Open(&quot;KeyPair.snk&quot;, FileMode.Open, FileAccess.Read));\n      myAssemblyName.Name = &quot;MyAssembly&quot;;\n      myAssemblyName.Version = new Version(&quot;1.0.0.2001&quot;);\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;);\n      \n      // Get the assemblies loaded in the current application domain.\n      Assembly[] myAssemblies = Thread.GetDomain().GetAssemblies();\n\n      // Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Assembly myAssembly = null;\n      for(int i = 0; i &lt; myAssemblies.Length; i++)\n         if(String.Compare(myAssemblies[i].GetName().Name, &quot;MyAssembly&quot;) == 0)\n            myAssembly = myAssemblies[i];\n\n      // Display the full assembly information to the console.\n      if(myAssembly != null)\n      {\n         Console.WriteLine(&quot;<br>Displaying the full assembly name.<br>&quot;);\n         Console.WriteLine(myAssembly.GetName().FullName);\n         Console.WriteLine(&quot;<br>Displaying the public key.<br>&quot;);\n         byte []pk;\n         pk = myAssembly.GetName().GetPublicKey();\n \t     for (int i=0;i&lt;pk.GetLength(0);i++)\n \t\t    Console.Write (&quot;{0:x2}&quot;, pk[i]);\n         Console.WriteLine();\n         Console.WriteLine(&quot;<br>Displaying the public key token.<br>&quot;);\n         byte []pt;\n         pt = myAssembly.GetName().GetPublicKeyToken();\n         for (int i=0;i&lt;pt.GetLength(0);i++)\n \t\t    Console.Write (&quot;{0:x2}&quot;, pt[i]);\n      }\n   }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"AssemblyName_KeyPair#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Threading;\nusing namespace System::IO;\nusing namespace System::Globalization;\nusing namespace System::Reflection::Emit;\nusing namespace System::Configuration::Assemblies;\nusing namespace System::Text;\nstatic void MakeAssembly( AssemblyName^ myAssemblyName, String^ fileName )\n{\n   // Get the assembly builder from the application domain associated with the current thread.\n   AssemblyBuilder^ myAssemblyBuilder = Thread::GetDomain()-&gt;DefineDynamicAssembly( myAssemblyName, AssemblyBuilderAccess::RunAndSave );\n\n   // Create a dynamic module in the assembly.\n   ModuleBuilder^ myModuleBuilder = myAssemblyBuilder-&gt;DefineDynamicModule( &quot;MyModule&quot;, fileName );\n\n   // Create a type in the module.\n   TypeBuilder^ myTypeBuilder = myModuleBuilder-&gt;DefineType( &quot;MyType&quot; );\n\n   // Create a method called &#39;Main&#39;.\n   MethodBuilder^ myMethodBuilder = myTypeBuilder-&gt;DefineMethod( &quot;Main&quot;, static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::HideBySig | MethodAttributes::Static), void::typeid, nullptr );\n\n   // Get the Intermediate Language generator for the method.\n   ILGenerator^ myILGenerator = myMethodBuilder-&gt;GetILGenerator();\n\n   // Use the utility method to generate the IL instructions that print a String* to the console.\n   myILGenerator-&gt;EmitWriteLine( &quot;Hello World!&quot; );\n\n   // Generate the &#39;ret&#39; IL instruction.\n   myILGenerator-&gt;Emit( OpCodes::Ret );\n\n   // End the creation of the type.\n   myTypeBuilder-&gt;CreateType();\n\n   // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n   myAssemblyBuilder-&gt;SetEntryPoint( myMethodBuilder );\n   myAssemblyBuilder-&gt;Save( fileName );\n}\n\nint main()\n{\n   // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n   AssemblyName^ myAssemblyName = gcnew AssemblyName;\n\n   // Set the codebase to the physical directory were the assembly resides.\n   myAssemblyName-&gt;CodeBase = Directory::GetCurrentDirectory();\n\n   // Set the culture information of the assembly to &#39;English-American&#39;.\n   myAssemblyName-&gt;CultureInfo = gcnew CultureInfo( &quot;en-US&quot; );\n\n   // Set the hash algoritm to &#39;SHA1&#39;.\n   myAssemblyName-&gt;HashAlgorithm = AssemblyHashAlgorithm::SHA1;\n   myAssemblyName-&gt;VersionCompatibility = AssemblyVersionCompatibility::SameProcess;\n   myAssemblyName-&gt;Flags = AssemblyNameFlags::PublicKey;\n\n   // Provide this assembly with a strong name.\n   myAssemblyName-&gt;KeyPair = gcnew StrongNameKeyPair( File::Open( &quot;KeyPair.snk&quot;, FileMode::Open, FileAccess::Read ) );\n   myAssemblyName-&gt;Name = &quot;MyAssembly&quot;;\n   myAssemblyName-&gt;Version = gcnew Version( &quot;1.0.0.2001&quot; );\n   MakeAssembly( myAssemblyName, &quot;MyAssembly.exe&quot; );\n\n   // Get the assemblies loaded in the current application domain.\n   array&lt;Assembly^&gt;^myAssemblies = Thread::GetDomain()-&gt;GetAssemblies();\n\n   // Get the dynamic assembly named &#39;MyAssembly&#39;. \n   Assembly^ myAssembly = nullptr;\n   for ( int i = 0; i &lt; myAssemblies-&gt;Length; i++ )\n      if ( String::Compare( myAssemblies[ i ]-&gt;GetName()-&gt;Name, &quot;MyAssembly&quot; ) == 0 )\n            myAssembly = myAssemblies[ i ];\n\n   // Display the full assembly information to the console.\n   if ( myAssembly != nullptr )\n   {\n      Console::WriteLine( &quot;<br>Displaying the full assembly name.<br>&quot; );\n      Console::WriteLine( myAssembly-&gt;GetName()-&gt;FullName );\n      Console::WriteLine( &quot;<br>Displaying the public key.<br>&quot; );\n      array&lt;Byte&gt;^pk;\n      pk = myAssembly-&gt;GetName()-&gt;GetPublicKey();\n      for ( int i = 0; i &lt; pk-&gt;GetLength( 0 ); i++ )\n         Console::Write( &quot; {0:x2}&quot;, pk[ i ] );\n      Console::WriteLine();\n      Console::WriteLine( &quot;<br>Displaying the public key token.<br>&quot; );\n      array&lt;Byte&gt;^pt;\n      pt = myAssembly-&gt;GetName()-&gt;GetPublicKeyToken();\n      for ( int i = 0; i &lt; pt-&gt;GetLength( 0 ); i++ )\n         Console::Write(  &quot; {0:x2}&quot;, pt[ i ] );\n   }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_Name\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_Name_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Name</div>        \r\n          </div>\r\n    \r\n            <p>Gets or sets the simple name of the assembly. This is usually, but not necessarily, the file name of the manifest file of the assembly, minus its extension.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public string Name { get; set; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </div>\r\n                  <p>The simple name of the assembly.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The manifest file is the file that contains the assembly manifest.  </p>\n<p> For example, the simple name of a single-file assembly named &quot;MyAssembly.dll&quot; is &quot;MyAssembly&quot;.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example emits a dynamic assembly and saves it to the current directory. When the assembly is created, the Name property is used to set the simple name of the dynamic assembly.  </p>\n<pre><code class=\"lang-cpp\" name=\"AssemblyName_Constructor#2\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Threading;\nusing namespace System::Reflection::Emit;\nstatic void MakeAssembly( AssemblyName^ myAssemblyName, String^ fileName )\n{\n   // Get the assembly builder from the application domain associated with the current thread.\n   AssemblyBuilder^ myAssemblyBuilder = Thread::GetDomain()-&gt;DefineDynamicAssembly( myAssemblyName, AssemblyBuilderAccess::RunAndSave );\n\n   // Create a dynamic module in the assembly.\n   ModuleBuilder^ myModuleBuilder = myAssemblyBuilder-&gt;DefineDynamicModule( &quot;MyModule&quot;, fileName );\n\n   // Create a type in the module.\n   TypeBuilder^ myTypeBuilder = myModuleBuilder-&gt;DefineType( &quot;MyType&quot; );\n\n   // Create a method called &#39;Main&#39;.\n   MethodBuilder^ myMethodBuilder = myTypeBuilder-&gt;DefineMethod( &quot;Main&quot;, static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::HideBySig | MethodAttributes::Static), void::typeid, nullptr );\n\n   // Get the Intermediate Language generator for the method.\n   ILGenerator^ myILGenerator = myMethodBuilder-&gt;GetILGenerator();\n\n   // Use the utility method to generate the IL instructions that print a String* to the console.\n   myILGenerator-&gt;EmitWriteLine( &quot;Hello World!&quot; );\n\n   // Generate the &#39;ret&#39; IL instruction.\n   myILGenerator-&gt;Emit( OpCodes::Ret );\n\n   // End the creation of the type.\n   myTypeBuilder-&gt;CreateType();\n\n   // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n   myAssemblyBuilder-&gt;SetEntryPoint( myMethodBuilder );\n   myAssemblyBuilder-&gt;Save( fileName );\n}\n\nint main()\n{\n   // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n   AssemblyName^ myAssemblyName = gcnew AssemblyName;\n   myAssemblyName-&gt;Name = &quot;MyAssembly&quot;;\n   myAssemblyName-&gt;Version = gcnew Version( &quot;1.0.0.2001&quot; );\n   MakeAssembly( myAssemblyName, &quot;MyAssembly.exe&quot; );\n\n   // Get all the assemblies currently loaded in the application domain.\n   array&lt;Assembly^&gt;^myAssemblies = Thread::GetDomain()-&gt;GetAssemblies();\n\n   // Get the dynamic assembly named &#39;MyAssembly&#39;. \n   Assembly^ myAssembly = nullptr;\n   for ( int i = 0; i &lt; myAssemblies-&gt;Length; i++ )\n   {\n      if ( String::Compare( myAssemblies[ i ]-&gt;GetName()-&gt;Name, &quot;MyAssembly&quot; ) == 0 )\n            myAssembly = myAssemblies[ i ];\n   }\n   if ( myAssembly != nullptr )\n   {\n      Console::WriteLine(  &quot;<br>Displaying the assembly name<br>&quot; );\n      Console::WriteLine( myAssembly );\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"AssemblyName_Constructor#2\">Imports System\nImports System.Reflection\nImports System.Threading\nImports System.Reflection.Emit\nImports Microsoft.VisualBasic\n\nPublic Class AssemblyName_Constructor\n   \n   Public Shared Sub MakeAssembly(myAssemblyName As AssemblyName, fileName As String)\n      &#39; Get the assembly builder from the application domain associated with the current thread.\n      Dim myAssemblyBuilder As AssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave)\n      &#39; Create a dynamic module in the assembly.\n      Dim myModuleBuilder As ModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName)\n      &#39; Create a type in the module.\n      Dim myTypeBuilder As TypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;)\n      &#39; Create a method called &#39;Main&#39;.\n      Dim myMethodBuilder As MethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public Or MethodAttributes.HideBySig Or MethodAttributes.Static, GetType(object), Nothing)\n      Dim myILGenerator As ILGenerator = myMethodBuilder.GetILGenerator()\n      &#39; Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;)\n      &#39; Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret)\n      &#39; End the creation of the type.\n      myTypeBuilder.CreateType()\n      &#39; Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder)\n      myAssemblyBuilder.Save(fileName)\n   End Sub &#39;MakeAssembly\n   \n   \n   Public Shared Sub Main()\n      \n\n      &#39; Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      Dim myAssemblyName As New AssemblyName()\n      myAssemblyName.Name = &quot;MyAssembly&quot;\n      myAssemblyName.Version = New Version(&quot;1.0.0.2001&quot;)\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;)\n      \n      &#39; Get all the assemblies currently loaded in the application domain.\n      Dim myAssemblies As [Assembly]() = Thread.GetDomain().GetAssemblies()\n      \n      &#39; Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Dim myAssembly As [Assembly] = Nothing\n      Dim i As Integer\n      For i = 0 To myAssemblies.Length - 1\n         If [String].Compare(myAssemblies(i).GetName().Name, &quot;MyAssembly&quot;) = 0 Then\n            myAssembly = myAssemblies(i)\n         End If\n      Next i\n      If Not (myAssembly Is Nothing) Then\n         Console.WriteLine(ControlChars.Cr + &quot;Displaying the assembly name&quot; + ControlChars.Cr)\n         Console.WriteLine(myAssembly)\n      End If\n   End Sub &#39;Main \nEnd Class &#39;AssemblyName_Constructor \n</code></pre><pre><code class=\"lang-cs\" name=\"AssemblyName_Constructor#2\">\nusing System;\nusing System.Reflection;\nusing System.Threading;\nusing System.Reflection.Emit;\n\npublic class AssemblyName_Constructor\n{\n   public static void MakeAssembly(AssemblyName myAssemblyName, string fileName)\n   {\n      // Get the assembly builder from the application domain associated with the current thread.\n      AssemblyBuilder myAssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave);\n      // Create a dynamic module in the assembly.\n      ModuleBuilder myModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName);\n      // Create a type in the module.\n      TypeBuilder myTypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;);\n      // Create a method called &#39;Main&#39;.\n      MethodBuilder myMethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public | MethodAttributes.HideBySig |\n         MethodAttributes.Static, typeof(void), null);\n      // Get the Intermediate Language generator for the method.\n      ILGenerator myILGenerator = myMethodBuilder.GetILGenerator();\n      // Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;);\n      // Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret);\n      // End the creation of the type.\n      myTypeBuilder.CreateType();\n      // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder);\n      myAssemblyBuilder.Save(fileName);\n   }\n\n   public static void Main()\n   {\n\n\n      // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      AssemblyName myAssemblyName = new AssemblyName(); \n      myAssemblyName.Name = &quot;MyAssembly&quot;;\n      myAssemblyName.Version = new Version(&quot;1.0.0.2001&quot;);\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;);\n\n      // Get all the assemblies currently loaded in the application domain.\n      Assembly[] myAssemblies = Thread.GetDomain().GetAssemblies();\n\n      // Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Assembly myAssembly = null;\n      for(int i = 0; i &lt; myAssemblies.Length; i++)\n      {\n         if(String.Compare(myAssemblies[i].GetName().Name, &quot;MyAssembly&quot;) == 0)\n            myAssembly = myAssemblies[i];\n      }\n      if(myAssembly != null)\n      {\n         Console.WriteLine(&quot;<br>Displaying the assembly name<br>&quot;);\n         Console.WriteLine(myAssembly);\n      }\n   }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_ProcessorArchitecture\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_ProcessorArchitecture_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ProcessorArchitecture</div>        \r\n          </div>\r\n    \r\n            <p>Gets or sets a value that identifies the processor and bits-per-word of the platform targeted by an executable.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.ProcessorArchitecture ProcessorArchitecture { get; set; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.processorarchitecture\" data-linktype=\"relative-path\">ProcessorArchitecture</a></div>\r\n                  </div>\r\n                  <p>One of the enumeration values that identifies the processor and bits-per-word of the platform targeted by an executable.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Beginning with the .NET Framework 4, this property always returns <a class=\"xref\" href=\"system.reflection.processorarchitecture\" data-linktype=\"relative-path\">System.Reflection.ProcessorArchitecture</a> for reference assemblies.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_Version\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_Version_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Version</div>        \r\n          </div>\r\n    \r\n            <p>Gets or sets the major, minor, build, and revision numbers of the assembly.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public Version Version { get; set; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.version\" data-linktype=\"relative-path\">Version</a></div>\r\n                  </div>\r\n                  <p>An object that represents the major, minor, build, and revision numbers of the assembly.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>All components of the version must be integers greater than or equal to zero. Metadata restricts the major, minor, build, and revision components for an assembly to a maximum value of <a class=\"xref\" href=\"system.uint16#System_UInt16_MaxValue\" data-linktype=\"relative-path\">System.UInt16.MaxValue</a> - 1. If a component exceeds this value, no error is thrown; however, in a dynamic assembly, that component is zero.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>This section contains two examples. The first example shows how to retrieve the version of the currently executing assembly. The second example shows how to use the Version property to specify the assembly version when you emit a dynamic assembly.  </p>\n<p> <strong>Example 1</strong>  </p>\n<p> The following example retrieves and displays the version numbers of the currently executing assembly and the assembly that contains the <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a> class.  </p>\n<pre><code class=\"lang-cs\" name=\"AssemblyName.Version#1\">using System;\nusing System.Reflection;\n\n[assembly:AssemblyVersion(&quot;1.1.0.0&quot;)]\n\nclass Example\n{\n    static void Main()\n    {\n        Console.WriteLine(&quot;The version of the currently executing assembly is: {0}&quot;,\n            typeof(Example).Assembly.GetName().Version);\n\n        Console.WriteLine(&quot;The version of mscorlib.dll is: {0}&quot;,\n            typeof(String).Assembly.GetName().Version);\n    }\n}\n\n/* This example produces output similar to the following:\n\nThe version of the currently executing assembly is: 1.1.0.0\nThe version of mscorlib.dll is: 2.0.0.0\n */\n</code></pre><pre><code class=\"lang-cpp\" name=\"AssemblyName.Version#1\">using namespace System;\nusing namespace System::Reflection;\n\n[assembly:AssemblyVersion(&quot;1.1.0.0&quot;)];\n\nvoid main()\n{\n    Console::WriteLine(&quot;The version of the currently executing assembly is: {0}&quot;,\n        Assembly::GetExecutingAssembly()-&gt;GetName()-&gt;Version);\n\n    Console::WriteLine(&quot;The version of mscorlib.dll is: {0}&quot;,\n        String::typeid-&gt;Assembly-&gt;GetName()-&gt;Version);\n}\n\n/* This example produces output similar to the following:\n\nThe version of the currently executing assembly is: 1.1.0.0\nThe version of mscorlib.dll is: 2.0.0.0\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"AssemblyName.Version#1\">Imports System\nImports System.Reflection\n\n&lt;Assembly:AssemblyVersion(&quot;1.1.0.0&quot;)&gt;\n\nClass Example\n\n    Shared Sub Main()\n    \n        Console.WriteLine(&quot;The version of the currently executing assembly is: {0} &quot;, _\n            GetType(Example).Assembly.GetName().Version)\n\n        Console.WriteLine(&quot;The version of mscorlib.dll is: {0} &quot;, _\n            GetType(String).Assembly.GetName().Version)\n    End Sub\nEnd Class\n\n&#39; This example produces output similar to the following:\n&#39;\n&#39;The version of the currently executing assembly is: 1.1.0.0\n&#39;The version of mscorlib.dll is: 2.0.0.0\n</code></pre><p> <strong>Example 2</strong>  </p>\n<p> The following example emits a dynamic assembly and saves it to the current directory. When the assembly is created, the Version property is used to specify version information for the assembly.  </p>\n<pre><code class=\"lang-cpp\" name=\"AssemblyName_Constructor#3\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Threading;\nusing namespace System::Reflection::Emit;\nstatic void MakeAssembly( AssemblyName^ myAssemblyName, String^ fileName )\n{\n   // Get the assembly builder from the application domain associated with the current thread.\n   AssemblyBuilder^ myAssemblyBuilder = Thread::GetDomain()-&gt;DefineDynamicAssembly( myAssemblyName, AssemblyBuilderAccess::RunAndSave );\n\n   // Create a dynamic module in the assembly.\n   ModuleBuilder^ myModuleBuilder = myAssemblyBuilder-&gt;DefineDynamicModule( &quot;MyModule&quot;, fileName );\n\n   // Create a type in the module.\n   TypeBuilder^ myTypeBuilder = myModuleBuilder-&gt;DefineType( &quot;MyType&quot; );\n\n   // Create a method called &#39;Main&#39;.\n   MethodBuilder^ myMethodBuilder = myTypeBuilder-&gt;DefineMethod( &quot;Main&quot;, static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::HideBySig | MethodAttributes::Static), void::typeid, nullptr );\n\n   // Get the Intermediate Language generator for the method.\n   ILGenerator^ myILGenerator = myMethodBuilder-&gt;GetILGenerator();\n\n   // Use the utility method to generate the IL instructions that print a String* to the console.\n   myILGenerator-&gt;EmitWriteLine( &quot;Hello World!&quot; );\n\n   // Generate the &#39;ret&#39; IL instruction.\n   myILGenerator-&gt;Emit( OpCodes::Ret );\n\n   // End the creation of the type.\n   myTypeBuilder-&gt;CreateType();\n\n   // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n   myAssemblyBuilder-&gt;SetEntryPoint( myMethodBuilder );\n   myAssemblyBuilder-&gt;Save( fileName );\n}\n\nint main()\n{\n   // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n   AssemblyName^ myAssemblyName = gcnew AssemblyName;\n   myAssemblyName-&gt;Name = &quot;MyAssembly&quot;;\n   myAssemblyName-&gt;Version = gcnew Version( &quot;1.0.0.2001&quot; );\n   MakeAssembly( myAssemblyName, &quot;MyAssembly.exe&quot; );\n\n   // Get all the assemblies currently loaded in the application domain.\n   array&lt;Assembly^&gt;^myAssemblies = Thread::GetDomain()-&gt;GetAssemblies();\n\n   // Get the dynamic assembly named &#39;MyAssembly&#39;. \n   Assembly^ myAssembly = nullptr;\n   for ( int i = 0; i &lt; myAssemblies-&gt;Length; i++ )\n   {\n      if ( String::Compare( myAssemblies[ i ]-&gt;GetName()-&gt;Name, &quot;MyAssembly&quot; ) == 0 )\n            myAssembly = myAssemblies[ i ];\n   }\n   if ( myAssembly != nullptr )\n   {\n      Console::WriteLine(  &quot;<br>Displaying the assembly name<br>&quot; );\n      Console::WriteLine( myAssembly );\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"AssemblyName_Constructor#3\">Imports System\nImports System.Reflection\nImports System.Threading\nImports System.Reflection.Emit\nImports Microsoft.VisualBasic\n\nPublic Class AssemblyName_Constructor\n   \n   Public Shared Sub MakeAssembly(myAssemblyName As AssemblyName, fileName As String)\n      &#39; Get the assembly builder from the application domain associated with the current thread.\n      Dim myAssemblyBuilder As AssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave)\n      &#39; Create a dynamic module in the assembly.\n      Dim myModuleBuilder As ModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName)\n      &#39; Create a type in the module.\n      Dim myTypeBuilder As TypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;)\n      &#39; Create a method called &#39;Main&#39;.\n      Dim myMethodBuilder As MethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public Or MethodAttributes.HideBySig Or MethodAttributes.Static, GetType(object), Nothing)\n      Dim myILGenerator As ILGenerator = myMethodBuilder.GetILGenerator()\n      &#39; Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;)\n      &#39; Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret)\n      &#39; End the creation of the type.\n      myTypeBuilder.CreateType()\n      &#39; Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder)\n      myAssemblyBuilder.Save(fileName)\n   End Sub &#39;MakeAssembly\n   \n   \n   Public Shared Sub Main()\n      \n\n      &#39; Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      Dim myAssemblyName As New AssemblyName()\n      myAssemblyName.Name = &quot;MyAssembly&quot;\n      myAssemblyName.Version = New Version(&quot;1.0.0.2001&quot;)\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;)\n      \n      &#39; Get all the assemblies currently loaded in the application domain.\n      Dim myAssemblies As [Assembly]() = Thread.GetDomain().GetAssemblies()\n      \n      &#39; Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Dim myAssembly As [Assembly] = Nothing\n      Dim i As Integer\n      For i = 0 To myAssemblies.Length - 1\n         If [String].Compare(myAssemblies(i).GetName().Name, &quot;MyAssembly&quot;) = 0 Then\n            myAssembly = myAssemblies(i)\n         End If\n      Next i\n      If Not (myAssembly Is Nothing) Then\n         Console.WriteLine(ControlChars.Cr + &quot;Displaying the assembly name&quot; + ControlChars.Cr)\n         Console.WriteLine(myAssembly)\n      End If\n   End Sub &#39;Main \nEnd Class &#39;AssemblyName_Constructor \n</code></pre><pre><code class=\"lang-cs\" name=\"AssemblyName_Constructor#3\">\nusing System;\nusing System.Reflection;\nusing System.Threading;\nusing System.Reflection.Emit;\n\npublic class AssemblyName_Constructor\n{\n   public static void MakeAssembly(AssemblyName myAssemblyName, string fileName)\n   {\n      // Get the assembly builder from the application domain associated with the current thread.\n      AssemblyBuilder myAssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave);\n      // Create a dynamic module in the assembly.\n      ModuleBuilder myModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName);\n      // Create a type in the module.\n      TypeBuilder myTypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;);\n      // Create a method called &#39;Main&#39;.\n      MethodBuilder myMethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public | MethodAttributes.HideBySig |\n         MethodAttributes.Static, typeof(void), null);\n      // Get the Intermediate Language generator for the method.\n      ILGenerator myILGenerator = myMethodBuilder.GetILGenerator();\n      // Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;);\n      // Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret);\n      // End the creation of the type.\n      myTypeBuilder.CreateType();\n      // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder);\n      myAssemblyBuilder.Save(fileName);\n   }\n\n   public static void Main()\n   {\n\n\n      // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      AssemblyName myAssemblyName = new AssemblyName(); \n      myAssemblyName.Name = &quot;MyAssembly&quot;;\n      myAssemblyName.Version = new Version(&quot;1.0.0.2001&quot;);\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;);\n\n      // Get all the assemblies currently loaded in the application domain.\n      Assembly[] myAssemblies = Thread.GetDomain().GetAssemblies();\n\n      // Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Assembly myAssembly = null;\n      for(int i = 0; i &lt; myAssemblies.Length; i++)\n      {\n         if(String.Compare(myAssemblies[i].GetName().Name, &quot;MyAssembly&quot;) == 0)\n            myAssembly = myAssemblies[i];\n      }\n      if(myAssembly != null)\n      {\n         Console.WriteLine(&quot;<br>Displaying the assembly name<br>&quot;);\n         Console.WriteLine(myAssembly);\n      }\n   }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_VersionCompatibility\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_VersionCompatibility_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">VersionCompatibility</div>        \r\n          </div>\r\n    \r\n            <p>Gets or sets the information related to the assembly&#39;s compatibility with other assemblies.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Configuration.Assemblies.AssemblyVersionCompatibility VersionCompatibility { get; set; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.configuration.assemblies.assemblyversioncompatibility\" data-linktype=\"relative-path\">AssemblyVersionCompatibility</a></div>\r\n                  </div>\r\n                  <p>A value that represents information about the assembly&#39;s compatibility with other assemblies.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>VersionCompatibility information indicates, for example, that the assembly cannot execute side-by-side with other versions due to conflicts over a device driver.  </p>\n<p> Currently, VersionCompatibility always returns <a class=\"xref\" href=\"system.configuration.assemblies.assemblyversioncompatibility\" data-linktype=\"relative-path\">System.Configuration.Assemblies.AssemblyVersionCompatibility</a>, and is not used by the loader. This property is reserved for a future feature.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"methods\">\r\n        <h2>Methods\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_Clone\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_Clone_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Clone()</div>        \r\n          </div>\r\n    \r\n            <p>Makes a copy of this <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> object.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public object Clone ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a></div>\r\n                  </div>\r\n                  <p>An object that is a copy of this <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> object.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A new object is created, identical to the original.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_GetAssemblyName_System_String_\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_GetAssemblyName_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetAssemblyName(String)</div>        \r\n          </div>\r\n    \r\n            <p>Gets the <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> for a given file.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Reflection.AssemblyName GetAssemblyName (string assemblyFile);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>assemblyFile</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The path for the assembly whose <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> is to be returned.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a></div>\r\n                  </div>\r\n                  <p>An object that represents the given assembly file.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>assemblyFile</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>assemblyFile</code> is invalid, such as an assembly with an invalid culture.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.filenotfoundexception\" data-linktype=\"relative-path\">FileNotFoundException</a></div>\r\n                  </div>\r\n                  <p><code>assemblyFile</code> is not found.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.securityexception\" data-linktype=\"relative-path\">SecurityException</a></div>\r\n                  </div>\r\n                  <p>The caller does not have path discovery permission.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.badimageformatexception\" data-linktype=\"relative-path\">BadImageFormatException</a></div>\r\n                  </div>\r\n                  <p><code>assemblyFile</code> is not a valid assembly.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.fileloadexception\" data-linktype=\"relative-path\">FileLoadException</a></div>\r\n                  </div>\r\n                  <p>An assembly or module was loaded twice with two different sets of evidence.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This will only work if the file contains an assembly manifest. This method causes the file to be opened and closed, but the assembly is not added to this domain.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example gets the <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> for an assembly on disk. It will not run unless you replace the string &quot;MyAssembly.exe&quot; with the file name of an assembly (including the path, if necessary) on your hard disk. Alternatively, you can compile this example as &quot;MyAssembly.exe&quot;.  </p>\n<pre><code class=\"lang-cpp\" name=\"AssemblyName_GetAssemblyName#1\">#using &lt;system.dll&gt;\n\nusing namespace System;\nusing namespace System::Reflection;\nint main()\n{\n   \n   // Replace the string &quot;MyAssembly.exe&quot; with the name of an assembly,\n   // including a path if necessary. If you do not have another assembly\n   // to use, you can use whatever name you give to this assembly.\n   //\n   AssemblyName^ myAssemblyName = AssemblyName::GetAssemblyName( &quot;MyAssembly.exe&quot; );\n   Console::WriteLine( &quot;<br>Displaying assembly information:<br>&quot; );\n   Console::WriteLine( myAssemblyName );\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"AssemblyName_GetAssemblyName#1\">\nusing System;\nusing System.Reflection;\n\npublic class AssemblyName_GetAssemblyName\n{\n   public static void Main()\n   {\n      // Replace the string &quot;MyAssembly.exe&quot; with the name of an assembly,\n      // including a path if necessary. If you do not have another assembly\n      // to use, you can use whatever name you give to this assembly.\n      //\n      AssemblyName myAssemblyName = AssemblyName.GetAssemblyName(&quot;MyAssembly.exe&quot;);\n      Console.WriteLine(&quot;<br>Displaying assembly information:<br>&quot;);\n      Console.WriteLine(myAssemblyName.ToString());\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"AssemblyName_GetAssemblyName#1\">Imports System\nImports System.Reflection\nImports Microsoft.VisualBasic\n\nPublic Class AssemblyName_GetAssemblyName\n   \n   Public Shared Sub Main()\n      \n      &#39; Replace the string &quot;MyAssembly.exe&quot; with the name of an assembly,\n      &#39; including a path if necessary. If you do not have another assembly\n      &#39; to use, you can use whatever name you give to this assembly.\n      &#39;\n      Dim myAssemblyName As AssemblyName = AssemblyName.GetAssemblyName(&quot;MyAssembly.exe&quot;)\n      Console.WriteLine(vbCrLf &amp; &quot;Displaying assembly information:&quot; &amp; vbCrLf)\n      Console.WriteLine(myAssemblyName.ToString())\n   End Sub &#39;Main \nEnd Class &#39;AssemblyName_GetAssemblyName \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_GetObjectData_System_Runtime_Serialization_SerializationInfo_System_Runtime_Serialization_StreamingContext_\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_GetObjectData_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetObjectData(SerializationInfo,StreamingContext)</div>        \r\n          </div>\r\n    \r\n            <p>Gets serialization information with all the data needed to recreate an instance of this <code>AssemblyName</code>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>info</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtime.serialization.serializationinfo\" data-linktype=\"relative-path\">SerializationInfo</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object to be populated with serialization information.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>context</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtime.serialization.streamingcontext\" data-linktype=\"relative-path\">StreamingContext</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The destination context of the serialization.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>info</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_GetPublicKey\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_GetPublicKey_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetPublicKey()</div>        \r\n          </div>\r\n    \r\n            <p>Gets the public key of the assembly.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public byte[] GetPublicKey ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.byte\" data-linktype=\"relative-path\">Byte</a>[]</div>\r\n                  </div>\r\n                  <p>A byte array that contains the public key of the assembly.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.securityexception\" data-linktype=\"relative-path\">SecurityException</a></div>\r\n                  </div>\r\n                  <p>A public key was provided (for example, by using the <span class=\"xref\">stem.Reflection.AssemblyName.SetPublicKey*</span> method), but no public key token was provided.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example emits a dynamic assembly and saves it to the current directory. When the assembly is created, the <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_SetPublicKey_\" data-linktype=\"relative-path\">SetPublicKey</a> method is used to give the assembly a public key. The GetPublicKey method is then used to retrieve the public key, which is displayed to the console.  </p>\n<pre><code class=\"lang-vb\" name=\"AssemblyName_KeyPair#2\">Imports System\nImports System.Reflection\nImports System.Threading\nImports System.IO\nImports System.Globalization\nImports System.Reflection.Emit\nImports System.Configuration.Assemblies\nImports System.Text\nImports Microsoft.VisualBasic\n\n\nPublic Class AssemblyName_CodeBase\n   \n   Public Shared Sub MakeAssembly(myAssemblyName As AssemblyName, fileName As String)\n      &#39; Get the assembly builder from the application domain associated with the current thread.\n      Dim myAssemblyBuilder As AssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave)\n      &#39; Create a dynamic module in the assembly.\n      Dim myModuleBuilder As ModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName)\n      &#39; Create a type in the module.\n      Dim myTypeBuilder As TypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;)\n      &#39; Create a method called &#39;Main&#39;.\n      Dim myMethodBuilder As MethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public Or MethodAttributes.HideBySig Or MethodAttributes.Static, GetType(object), Nothing)\n      &#39; Get the Intermediate Language generator for the method.\n      Dim myILGenerator As ILGenerator = myMethodBuilder.GetILGenerator()\n      &#39; Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;)\n      &#39; Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret)\n      &#39; End the creation of the type.\n      myTypeBuilder.CreateType()\n      &#39; Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder)\n      myAssemblyBuilder.Save(fileName)\n   End Sub &#39;MakeAssembly\n   \n   \n   Public Shared Sub Main()\n      \n\n      &#39; Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      Dim myAssemblyName As New AssemblyName()\n      &#39; Set the codebase to the physical directory were the assembly resides.\n      myAssemblyName.CodeBase = Directory.GetCurrentDirectory()\n      &#39; Set the culture information of the assembly to &#39;English-American&#39;.\n      myAssemblyName.CultureInfo = New CultureInfo(&quot;en-US&quot;)\n      &#39; Set the hash algoritm to &#39;SHA1&#39;.\n      myAssemblyName.HashAlgorithm = AssemblyHashAlgorithm.SHA1\n      myAssemblyName.VersionCompatibility = AssemblyVersionCompatibility.SameProcess\n      myAssemblyName.Flags = AssemblyNameFlags.PublicKey\n      &#39; Provide this assembly with a strong name.\n      myAssemblyName.KeyPair = New StrongNameKeyPair(File.Open(&quot;KeyPair.snk&quot;, FileMode.Open, FileAccess.Read))\n      myAssemblyName.Name = &quot;MyAssembly&quot;\n      myAssemblyName.Version = New Version(&quot;1.0.0.2001&quot;)\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;)\n      \n      &#39; Get the assemblies loaded in the current application domain.\n      Dim myAssemblies As [Assembly]() = Thread.GetDomain().GetAssemblies()\n      \n      &#39; Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Dim myAssembly As [Assembly] = Nothing\n      Dim i As Integer\n      For i = 0 To myAssemblies.Length - 1\n         If [String].Compare(myAssemblies(i).GetName().Name, &quot;MyAssembly&quot;) = 0 Then\n            myAssembly = myAssemblies(i)\n         End If \n      Next i &#39; Display the full assembly information to the console.\n      If Not (myAssembly Is Nothing) Then\n      Console.WriteLine(ControlChars.CrLf +&quot;Displaying the full assembly name.&quot;+ ControlChars.CrLf)\n      Console.WriteLine(myAssembly.GetName().FullName)\n      Console.WriteLine(ControlChars.CrLf +&quot;Displaying the public key.&quot; + ControlChars.CrLf)\n      Dim pk() As Byte\n      pk = myAssembly.GetName().GetPublicKey()\n      For i = 0 To (pk.GetLength(0)) - 1\n         Console.Write(&quot;{0:x2}&quot;, pk(i))\n      Next i\n      Console.WriteLine()\n      Console.WriteLine(ControlChars.CrLf +&quot;Displaying the public key token.&quot;+ ControlChars.CrLf)\n      Dim pt() As Byte\n      pt = myAssembly.GetName().GetPublicKeyToken()\n      For i = 0 To (pt.GetLength(0)) - 1\n         Console.Write(&quot;{0:x2}&quot;, pt(i))\n      Next i\n      End If\n   End Sub &#39;Main \nEnd Class &#39;AssemblyName_CodeBase \n</code></pre><pre><code class=\"lang-cs\" name=\"AssemblyName_KeyPair#2\">\nusing System;\nusing System.Reflection;\nusing System.Threading;\nusing System.IO;\nusing System.Globalization;\nusing System.Reflection.Emit;\nusing System.Configuration.Assemblies;\nusing System.Text;\n\npublic class AssemblyName_CodeBase\n{\n   public static void MakeAssembly(AssemblyName myAssemblyName, string fileName)\n   {\n      // Get the assembly builder from the application domain associated with the current thread.\n      AssemblyBuilder myAssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave);\n      // Create a dynamic module in the assembly.\n      ModuleBuilder myModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName);\n      // Create a type in the module.\n      TypeBuilder myTypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;);\n      // Create a method called &#39;Main&#39;.\n      MethodBuilder myMethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public | MethodAttributes.HideBySig |\n         MethodAttributes.Static, typeof(void), null);\n      // Get the Intermediate Language generator for the method.\n      ILGenerator myILGenerator = myMethodBuilder.GetILGenerator();\n      // Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;);\n      // Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret);\n      // End the creation of the type.\n      myTypeBuilder.CreateType();\n      // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder);\n      myAssemblyBuilder.Save(fileName);\n   }\n\n   public static void Main()\n   {\n      // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      AssemblyName myAssemblyName = new AssemblyName();\n      // Set the codebase to the physical directory were the assembly resides.\n      myAssemblyName.CodeBase = Directory.GetCurrentDirectory();\n      // Set the culture information of the assembly to &#39;English-American&#39;.\n      myAssemblyName.CultureInfo = new CultureInfo(&quot;en-US&quot;);\n      // Set the hash algoritm to &#39;SHA1&#39;.\n      myAssemblyName.HashAlgorithm = AssemblyHashAlgorithm.SHA1;\n      myAssemblyName.VersionCompatibility = AssemblyVersionCompatibility.SameProcess;\n      myAssemblyName.Flags = AssemblyNameFlags.PublicKey;\n      // Provide this assembly with a strong name.\n      myAssemblyName.KeyPair = new StrongNameKeyPair(File.Open(&quot;KeyPair.snk&quot;, FileMode.Open, FileAccess.Read));\n      myAssemblyName.Name = &quot;MyAssembly&quot;;\n      myAssemblyName.Version = new Version(&quot;1.0.0.2001&quot;);\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;);\n      \n      // Get the assemblies loaded in the current application domain.\n      Assembly[] myAssemblies = Thread.GetDomain().GetAssemblies();\n\n      // Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Assembly myAssembly = null;\n      for(int i = 0; i &lt; myAssemblies.Length; i++)\n         if(String.Compare(myAssemblies[i].GetName().Name, &quot;MyAssembly&quot;) == 0)\n            myAssembly = myAssemblies[i];\n\n      // Display the full assembly information to the console.\n      if(myAssembly != null)\n      {\n         Console.WriteLine(&quot;<br>Displaying the full assembly name.<br>&quot;);\n         Console.WriteLine(myAssembly.GetName().FullName);\n         Console.WriteLine(&quot;<br>Displaying the public key.<br>&quot;);\n         byte []pk;\n         pk = myAssembly.GetName().GetPublicKey();\n \t     for (int i=0;i&lt;pk.GetLength(0);i++)\n \t\t    Console.Write (&quot;{0:x2}&quot;, pk[i]);\n         Console.WriteLine();\n         Console.WriteLine(&quot;<br>Displaying the public key token.<br>&quot;);\n         byte []pt;\n         pt = myAssembly.GetName().GetPublicKeyToken();\n         for (int i=0;i&lt;pt.GetLength(0);i++)\n \t\t    Console.Write (&quot;{0:x2}&quot;, pt[i]);\n      }\n   }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"AssemblyName_KeyPair#2\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Threading;\nusing namespace System::IO;\nusing namespace System::Globalization;\nusing namespace System::Reflection::Emit;\nusing namespace System::Configuration::Assemblies;\nusing namespace System::Text;\nstatic void MakeAssembly( AssemblyName^ myAssemblyName, String^ fileName )\n{\n   // Get the assembly builder from the application domain associated with the current thread.\n   AssemblyBuilder^ myAssemblyBuilder = Thread::GetDomain()-&gt;DefineDynamicAssembly( myAssemblyName, AssemblyBuilderAccess::RunAndSave );\n\n   // Create a dynamic module in the assembly.\n   ModuleBuilder^ myModuleBuilder = myAssemblyBuilder-&gt;DefineDynamicModule( &quot;MyModule&quot;, fileName );\n\n   // Create a type in the module.\n   TypeBuilder^ myTypeBuilder = myModuleBuilder-&gt;DefineType( &quot;MyType&quot; );\n\n   // Create a method called &#39;Main&#39;.\n   MethodBuilder^ myMethodBuilder = myTypeBuilder-&gt;DefineMethod( &quot;Main&quot;, static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::HideBySig | MethodAttributes::Static), void::typeid, nullptr );\n\n   // Get the Intermediate Language generator for the method.\n   ILGenerator^ myILGenerator = myMethodBuilder-&gt;GetILGenerator();\n\n   // Use the utility method to generate the IL instructions that print a String* to the console.\n   myILGenerator-&gt;EmitWriteLine( &quot;Hello World!&quot; );\n\n   // Generate the &#39;ret&#39; IL instruction.\n   myILGenerator-&gt;Emit( OpCodes::Ret );\n\n   // End the creation of the type.\n   myTypeBuilder-&gt;CreateType();\n\n   // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n   myAssemblyBuilder-&gt;SetEntryPoint( myMethodBuilder );\n   myAssemblyBuilder-&gt;Save( fileName );\n}\n\nint main()\n{\n   // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n   AssemblyName^ myAssemblyName = gcnew AssemblyName;\n\n   // Set the codebase to the physical directory were the assembly resides.\n   myAssemblyName-&gt;CodeBase = Directory::GetCurrentDirectory();\n\n   // Set the culture information of the assembly to &#39;English-American&#39;.\n   myAssemblyName-&gt;CultureInfo = gcnew CultureInfo( &quot;en-US&quot; );\n\n   // Set the hash algoritm to &#39;SHA1&#39;.\n   myAssemblyName-&gt;HashAlgorithm = AssemblyHashAlgorithm::SHA1;\n   myAssemblyName-&gt;VersionCompatibility = AssemblyVersionCompatibility::SameProcess;\n   myAssemblyName-&gt;Flags = AssemblyNameFlags::PublicKey;\n\n   // Provide this assembly with a strong name.\n   myAssemblyName-&gt;KeyPair = gcnew StrongNameKeyPair( File::Open( &quot;KeyPair.snk&quot;, FileMode::Open, FileAccess::Read ) );\n   myAssemblyName-&gt;Name = &quot;MyAssembly&quot;;\n   myAssemblyName-&gt;Version = gcnew Version( &quot;1.0.0.2001&quot; );\n   MakeAssembly( myAssemblyName, &quot;MyAssembly.exe&quot; );\n\n   // Get the assemblies loaded in the current application domain.\n   array&lt;Assembly^&gt;^myAssemblies = Thread::GetDomain()-&gt;GetAssemblies();\n\n   // Get the dynamic assembly named &#39;MyAssembly&#39;. \n   Assembly^ myAssembly = nullptr;\n   for ( int i = 0; i &lt; myAssemblies-&gt;Length; i++ )\n      if ( String::Compare( myAssemblies[ i ]-&gt;GetName()-&gt;Name, &quot;MyAssembly&quot; ) == 0 )\n            myAssembly = myAssemblies[ i ];\n\n   // Display the full assembly information to the console.\n   if ( myAssembly != nullptr )\n   {\n      Console::WriteLine( &quot;<br>Displaying the full assembly name.<br>&quot; );\n      Console::WriteLine( myAssembly-&gt;GetName()-&gt;FullName );\n      Console::WriteLine( &quot;<br>Displaying the public key.<br>&quot; );\n      array&lt;Byte&gt;^pk;\n      pk = myAssembly-&gt;GetName()-&gt;GetPublicKey();\n      for ( int i = 0; i &lt; pk-&gt;GetLength( 0 ); i++ )\n         Console::Write( &quot; {0:x2}&quot;, pk[ i ] );\n      Console::WriteLine();\n      Console::WriteLine( &quot;<br>Displaying the public key token.<br>&quot; );\n      array&lt;Byte&gt;^pt;\n      pt = myAssembly-&gt;GetName()-&gt;GetPublicKeyToken();\n      for ( int i = 0; i &lt; pt-&gt;GetLength( 0 ); i++ )\n         Console::Write(  &quot; {0:x2}&quot;, pt[ i ] );\n   }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_GetPublicKeyToken\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_GetPublicKeyToken_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetPublicKeyToken()</div>        \r\n          </div>\r\n    \r\n            <p>Gets the public key token, which is the last 8 bytes of the SHA-1 hash of the public key under which the application or assembly is signed.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public byte[] GetPublicKeyToken ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.byte\" data-linktype=\"relative-path\">Byte</a>[]</div>\r\n                  </div>\r\n                  <p>A byte array that contains the public key token.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example emits a dynamic assembly and saves it to the current directory. When the assembly is created, the <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_SetPublicKeyToken_\" data-linktype=\"relative-path\">SetPublicKeyToken</a> method is used to set the assembly&#39;s public key token. The GetPublicKeyToken method is then used to retrieve the public key token, which is displayed to the console.  </p>\n<pre><code class=\"lang-vb\" name=\"AssemblyName_KeyPair#3\">Imports System\nImports System.Reflection\nImports System.Threading\nImports System.IO\nImports System.Globalization\nImports System.Reflection.Emit\nImports System.Configuration.Assemblies\nImports System.Text\nImports Microsoft.VisualBasic\n\n\nPublic Class AssemblyName_CodeBase\n   \n   Public Shared Sub MakeAssembly(myAssemblyName As AssemblyName, fileName As String)\n      &#39; Get the assembly builder from the application domain associated with the current thread.\n      Dim myAssemblyBuilder As AssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave)\n      &#39; Create a dynamic module in the assembly.\n      Dim myModuleBuilder As ModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName)\n      &#39; Create a type in the module.\n      Dim myTypeBuilder As TypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;)\n      &#39; Create a method called &#39;Main&#39;.\n      Dim myMethodBuilder As MethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public Or MethodAttributes.HideBySig Or MethodAttributes.Static, GetType(object), Nothing)\n      &#39; Get the Intermediate Language generator for the method.\n      Dim myILGenerator As ILGenerator = myMethodBuilder.GetILGenerator()\n      &#39; Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;)\n      &#39; Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret)\n      &#39; End the creation of the type.\n      myTypeBuilder.CreateType()\n      &#39; Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder)\n      myAssemblyBuilder.Save(fileName)\n   End Sub &#39;MakeAssembly\n   \n   \n   Public Shared Sub Main()\n      \n\n      &#39; Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      Dim myAssemblyName As New AssemblyName()\n      &#39; Set the codebase to the physical directory were the assembly resides.\n      myAssemblyName.CodeBase = Directory.GetCurrentDirectory()\n      &#39; Set the culture information of the assembly to &#39;English-American&#39;.\n      myAssemblyName.CultureInfo = New CultureInfo(&quot;en-US&quot;)\n      &#39; Set the hash algoritm to &#39;SHA1&#39;.\n      myAssemblyName.HashAlgorithm = AssemblyHashAlgorithm.SHA1\n      myAssemblyName.VersionCompatibility = AssemblyVersionCompatibility.SameProcess\n      myAssemblyName.Flags = AssemblyNameFlags.PublicKey\n      &#39; Provide this assembly with a strong name.\n      myAssemblyName.KeyPair = New StrongNameKeyPair(File.Open(&quot;KeyPair.snk&quot;, FileMode.Open, FileAccess.Read))\n      myAssemblyName.Name = &quot;MyAssembly&quot;\n      myAssemblyName.Version = New Version(&quot;1.0.0.2001&quot;)\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;)\n      \n      &#39; Get the assemblies loaded in the current application domain.\n      Dim myAssemblies As [Assembly]() = Thread.GetDomain().GetAssemblies()\n      \n      &#39; Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Dim myAssembly As [Assembly] = Nothing\n      Dim i As Integer\n      For i = 0 To myAssemblies.Length - 1\n         If [String].Compare(myAssemblies(i).GetName().Name, &quot;MyAssembly&quot;) = 0 Then\n            myAssembly = myAssemblies(i)\n         End If \n      Next i &#39; Display the full assembly information to the console.\n      If Not (myAssembly Is Nothing) Then\n      Console.WriteLine(ControlChars.CrLf +&quot;Displaying the full assembly name.&quot;+ ControlChars.CrLf)\n      Console.WriteLine(myAssembly.GetName().FullName)\n      Console.WriteLine(ControlChars.CrLf +&quot;Displaying the public key.&quot; + ControlChars.CrLf)\n      Dim pk() As Byte\n      pk = myAssembly.GetName().GetPublicKey()\n      For i = 0 To (pk.GetLength(0)) - 1\n         Console.Write(&quot;{0:x2}&quot;, pk(i))\n      Next i\n      Console.WriteLine()\n      Console.WriteLine(ControlChars.CrLf +&quot;Displaying the public key token.&quot;+ ControlChars.CrLf)\n      Dim pt() As Byte\n      pt = myAssembly.GetName().GetPublicKeyToken()\n      For i = 0 To (pt.GetLength(0)) - 1\n         Console.Write(&quot;{0:x2}&quot;, pt(i))\n      Next i\n      End If\n   End Sub &#39;Main \nEnd Class &#39;AssemblyName_CodeBase \n</code></pre><pre><code class=\"lang-cs\" name=\"AssemblyName_KeyPair#3\">\nusing System;\nusing System.Reflection;\nusing System.Threading;\nusing System.IO;\nusing System.Globalization;\nusing System.Reflection.Emit;\nusing System.Configuration.Assemblies;\nusing System.Text;\n\npublic class AssemblyName_CodeBase\n{\n   public static void MakeAssembly(AssemblyName myAssemblyName, string fileName)\n   {\n      // Get the assembly builder from the application domain associated with the current thread.\n      AssemblyBuilder myAssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave);\n      // Create a dynamic module in the assembly.\n      ModuleBuilder myModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName);\n      // Create a type in the module.\n      TypeBuilder myTypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;);\n      // Create a method called &#39;Main&#39;.\n      MethodBuilder myMethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public | MethodAttributes.HideBySig |\n         MethodAttributes.Static, typeof(void), null);\n      // Get the Intermediate Language generator for the method.\n      ILGenerator myILGenerator = myMethodBuilder.GetILGenerator();\n      // Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;);\n      // Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret);\n      // End the creation of the type.\n      myTypeBuilder.CreateType();\n      // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder);\n      myAssemblyBuilder.Save(fileName);\n   }\n\n   public static void Main()\n   {\n      // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      AssemblyName myAssemblyName = new AssemblyName();\n      // Set the codebase to the physical directory were the assembly resides.\n      myAssemblyName.CodeBase = Directory.GetCurrentDirectory();\n      // Set the culture information of the assembly to &#39;English-American&#39;.\n      myAssemblyName.CultureInfo = new CultureInfo(&quot;en-US&quot;);\n      // Set the hash algoritm to &#39;SHA1&#39;.\n      myAssemblyName.HashAlgorithm = AssemblyHashAlgorithm.SHA1;\n      myAssemblyName.VersionCompatibility = AssemblyVersionCompatibility.SameProcess;\n      myAssemblyName.Flags = AssemblyNameFlags.PublicKey;\n      // Provide this assembly with a strong name.\n      myAssemblyName.KeyPair = new StrongNameKeyPair(File.Open(&quot;KeyPair.snk&quot;, FileMode.Open, FileAccess.Read));\n      myAssemblyName.Name = &quot;MyAssembly&quot;;\n      myAssemblyName.Version = new Version(&quot;1.0.0.2001&quot;);\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;);\n      \n      // Get the assemblies loaded in the current application domain.\n      Assembly[] myAssemblies = Thread.GetDomain().GetAssemblies();\n\n      // Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Assembly myAssembly = null;\n      for(int i = 0; i &lt; myAssemblies.Length; i++)\n         if(String.Compare(myAssemblies[i].GetName().Name, &quot;MyAssembly&quot;) == 0)\n            myAssembly = myAssemblies[i];\n\n      // Display the full assembly information to the console.\n      if(myAssembly != null)\n      {\n         Console.WriteLine(&quot;<br>Displaying the full assembly name.<br>&quot;);\n         Console.WriteLine(myAssembly.GetName().FullName);\n         Console.WriteLine(&quot;<br>Displaying the public key.<br>&quot;);\n         byte []pk;\n         pk = myAssembly.GetName().GetPublicKey();\n \t     for (int i=0;i&lt;pk.GetLength(0);i++)\n \t\t    Console.Write (&quot;{0:x2}&quot;, pk[i]);\n         Console.WriteLine();\n         Console.WriteLine(&quot;<br>Displaying the public key token.<br>&quot;);\n         byte []pt;\n         pt = myAssembly.GetName().GetPublicKeyToken();\n         for (int i=0;i&lt;pt.GetLength(0);i++)\n \t\t    Console.Write (&quot;{0:x2}&quot;, pt[i]);\n      }\n   }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"AssemblyName_KeyPair#3\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Threading;\nusing namespace System::IO;\nusing namespace System::Globalization;\nusing namespace System::Reflection::Emit;\nusing namespace System::Configuration::Assemblies;\nusing namespace System::Text;\nstatic void MakeAssembly( AssemblyName^ myAssemblyName, String^ fileName )\n{\n   // Get the assembly builder from the application domain associated with the current thread.\n   AssemblyBuilder^ myAssemblyBuilder = Thread::GetDomain()-&gt;DefineDynamicAssembly( myAssemblyName, AssemblyBuilderAccess::RunAndSave );\n\n   // Create a dynamic module in the assembly.\n   ModuleBuilder^ myModuleBuilder = myAssemblyBuilder-&gt;DefineDynamicModule( &quot;MyModule&quot;, fileName );\n\n   // Create a type in the module.\n   TypeBuilder^ myTypeBuilder = myModuleBuilder-&gt;DefineType( &quot;MyType&quot; );\n\n   // Create a method called &#39;Main&#39;.\n   MethodBuilder^ myMethodBuilder = myTypeBuilder-&gt;DefineMethod( &quot;Main&quot;, static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::HideBySig | MethodAttributes::Static), void::typeid, nullptr );\n\n   // Get the Intermediate Language generator for the method.\n   ILGenerator^ myILGenerator = myMethodBuilder-&gt;GetILGenerator();\n\n   // Use the utility method to generate the IL instructions that print a String* to the console.\n   myILGenerator-&gt;EmitWriteLine( &quot;Hello World!&quot; );\n\n   // Generate the &#39;ret&#39; IL instruction.\n   myILGenerator-&gt;Emit( OpCodes::Ret );\n\n   // End the creation of the type.\n   myTypeBuilder-&gt;CreateType();\n\n   // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n   myAssemblyBuilder-&gt;SetEntryPoint( myMethodBuilder );\n   myAssemblyBuilder-&gt;Save( fileName );\n}\n\nint main()\n{\n   // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n   AssemblyName^ myAssemblyName = gcnew AssemblyName;\n\n   // Set the codebase to the physical directory were the assembly resides.\n   myAssemblyName-&gt;CodeBase = Directory::GetCurrentDirectory();\n\n   // Set the culture information of the assembly to &#39;English-American&#39;.\n   myAssemblyName-&gt;CultureInfo = gcnew CultureInfo( &quot;en-US&quot; );\n\n   // Set the hash algoritm to &#39;SHA1&#39;.\n   myAssemblyName-&gt;HashAlgorithm = AssemblyHashAlgorithm::SHA1;\n   myAssemblyName-&gt;VersionCompatibility = AssemblyVersionCompatibility::SameProcess;\n   myAssemblyName-&gt;Flags = AssemblyNameFlags::PublicKey;\n\n   // Provide this assembly with a strong name.\n   myAssemblyName-&gt;KeyPair = gcnew StrongNameKeyPair( File::Open( &quot;KeyPair.snk&quot;, FileMode::Open, FileAccess::Read ) );\n   myAssemblyName-&gt;Name = &quot;MyAssembly&quot;;\n   myAssemblyName-&gt;Version = gcnew Version( &quot;1.0.0.2001&quot; );\n   MakeAssembly( myAssemblyName, &quot;MyAssembly.exe&quot; );\n\n   // Get the assemblies loaded in the current application domain.\n   array&lt;Assembly^&gt;^myAssemblies = Thread::GetDomain()-&gt;GetAssemblies();\n\n   // Get the dynamic assembly named &#39;MyAssembly&#39;. \n   Assembly^ myAssembly = nullptr;\n   for ( int i = 0; i &lt; myAssemblies-&gt;Length; i++ )\n      if ( String::Compare( myAssemblies[ i ]-&gt;GetName()-&gt;Name, &quot;MyAssembly&quot; ) == 0 )\n            myAssembly = myAssemblies[ i ];\n\n   // Display the full assembly information to the console.\n   if ( myAssembly != nullptr )\n   {\n      Console::WriteLine( &quot;<br>Displaying the full assembly name.<br>&quot; );\n      Console::WriteLine( myAssembly-&gt;GetName()-&gt;FullName );\n      Console::WriteLine( &quot;<br>Displaying the public key.<br>&quot; );\n      array&lt;Byte&gt;^pk;\n      pk = myAssembly-&gt;GetName()-&gt;GetPublicKey();\n      for ( int i = 0; i &lt; pk-&gt;GetLength( 0 ); i++ )\n         Console::Write( &quot; {0:x2}&quot;, pk[ i ] );\n      Console::WriteLine();\n      Console::WriteLine( &quot;<br>Displaying the public key token.<br>&quot; );\n      array&lt;Byte&gt;^pt;\n      pt = myAssembly-&gt;GetName()-&gt;GetPublicKeyToken();\n      for ( int i = 0; i &lt; pt-&gt;GetLength( 0 ); i++ )\n         Console::Write(  &quot; {0:x2}&quot;, pt[ i ] );\n   }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_OnDeserialization_System_Object_\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_OnDeserialization_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">OnDeserialization(Object)</div>        \r\n          </div>\r\n    \r\n            <p>Implements the <a class=\"xref\" href=\"system.runtime.serialization.iserializable\" data-linktype=\"relative-path\">ISerializable</a> interface and is called back by the deserialization event when deserialization is complete.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void OnDeserialization (object sender);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>sender</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The source of the deserialization event.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_ReferenceMatchesDefinition_System_Reflection_AssemblyName_System_Reflection_AssemblyName_\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_ReferenceMatchesDefinition_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ReferenceMatchesDefinition(AssemblyName,AssemblyName)</div>        \r\n          </div>\r\n    \r\n            <p>Returns a value indicating whether two assembly names are the same. The comparison is based on the simple assembly names.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool ReferenceMatchesDefinition (System.Reflection.AssemblyName reference, System.Reflection.AssemblyName definition);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>reference</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The reference assembly name.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>definition</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The assembly name that is compared to the reference assembly.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the simple assembly names are the same; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The comparison depends only on the simple assembly name. It ignores version, culture, and public key token.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_SetPublicKey_System_Byte___\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_SetPublicKey_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">SetPublicKey(Byte[])</div>        \r\n          </div>\r\n    \r\n            <p>Sets the public key identifying the assembly.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void SetPublicKey (byte[] publicKey);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>publicKey</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.byte\" data-linktype=\"relative-path\">Byte</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A byte array containing the public key of the assembly.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>You must also use the <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_SetPublicKeyToken_\" data-linktype=\"relative-path\">SetPublicKeyToken</a> method to provide a public key token. Otherwise, a <a class=\"xref\" href=\"system.security.securityexception\" data-linktype=\"relative-path\">SecurityException</a> is thrown when the <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_GetPublicKey_\" data-linktype=\"relative-path\">GetPublicKey</a> method is called.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example emits a dynamic assembly and saves it to the current directory. When the assembly is created, the SetPublicKey method is used to give the assembly a public key. The <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_GetPublicKey_\" data-linktype=\"relative-path\">GetPublicKey</a> method is then used to retrieve the public key, which is displayed to the console.  </p>\n<pre><code class=\"lang-cs\" name=\"AssemblyName_SetPublicKey#1\">using System;\nusing System.Reflection;\nusing System.Threading;\nusing System.IO;\nusing System.Globalization;\nusing System.Reflection.Emit;\nusing System.Configuration.Assemblies;\nusing System.Text;\n\npublic class AssemblyName_CodeBase\n{\n   public static void MakeAssembly(AssemblyName myAssemblyName, string fileName)\n   {\n      // Get the assembly builder from the application domain associated with the current thread.\n      AssemblyBuilder myAssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave);\n      // Create a dynamic module in the assembly.\n      ModuleBuilder myModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName);\n      // Create a type in the module.\n      TypeBuilder myTypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;);\n      // Create a method called &#39;Main&#39;.\n      MethodBuilder myMethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public | MethodAttributes.HideBySig |\n         MethodAttributes.Static, typeof(void), null);\n      // Get the Intermediate Language generator for the method.\n      ILGenerator myILGenerator = myMethodBuilder.GetILGenerator();\n      // Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;);\n      // Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret);\n      // End the creation of the type.\n      myTypeBuilder.CreateType();\n      // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder);\n      myAssemblyBuilder.Save(fileName);\n   }\n\n   public static void Main()\n   {\n      // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      AssemblyName myAssemblyName = new AssemblyName();\n      // Set the codebase to the physical directory were the assembly resides.\n      myAssemblyName.CodeBase = Directory.GetCurrentDirectory();\n      // Set the culture information of the assembly to &#39;English-American&#39;.\n      myAssemblyName.CultureInfo = new CultureInfo(&quot;en-US&quot;);\n      // Set the hash algoritm to &#39;SHA1&#39;.\n      myAssemblyName.HashAlgorithm = AssemblyHashAlgorithm.SHA1;\n      myAssemblyName.VersionCompatibility = AssemblyVersionCompatibility.SameProcess;\n      myAssemblyName.Flags = AssemblyNameFlags.PublicKey;\n      // Get the whole contents of the &#39;PublicKey.snk&#39; into a byte array.\n      FileStream publicKeyStream = File.Open(&quot;PublicKey.snk&quot;, FileMode.Open);\n      byte[] publicKey = new byte[publicKeyStream.Length];\n      publicKeyStream.Read(publicKey, 0, (int)publicKeyStream.Length);\n      // Provide the assembly with a public key.\n      myAssemblyName.SetPublicKey(publicKey);\n      // Get the whole contents of the &#39;PublicKeyToken.snk&#39; into a byte array.\n      FileStream publicKeyTokenStream = File.Open(&quot;PublicKeyToken.snk&quot;, FileMode.Open);\n      byte[] publicKeyToken = new Byte[publicKeyTokenStream.Length];\n      publicKeyTokenStream.Read(publicKeyToken, 0, (int)publicKeyToken.Length);\n      // Provide the assembly with a public key token.\n      myAssemblyName.SetPublicKeyToken(publicKeyToken);\n      myAssemblyName.Name = &quot;MyAssembly&quot;;\n      myAssemblyName.Version = new Version(&quot;1.0.0.2001&quot;);\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;);\n      \n      // Get the assemblies loaded in the current application domain.\n      Assembly[] myAssemblies = Thread.GetDomain().GetAssemblies();\n\n      // Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Assembly myAssembly = null;\n      for(int i = 0; i &lt; myAssemblies.Length; i++)\n         if(String.Compare(myAssemblies[i].GetName().Name, &quot;MyAssembly&quot;) == 0)\n            myAssembly = myAssemblies[i];\n  \n      // Display the full assembly information to the console.\n      if(myAssembly != null)\n      {\n         Console.WriteLine(&quot;<br>Displaying the full assembly name<br>&quot;);\n         string assemblyName = myAssembly.GetName().FullName;\n         Console.WriteLine(assemblyName);\n         Console.WriteLine(&quot;<br>Displaying the public key for the assembly<br>&quot;);\n         byte[] publicKeyBytes = myAssembly.GetName().GetPublicKey();\n         Console.WriteLine(Encoding.ASCII.GetString(publicKeyBytes));\n         Console.WriteLine(&quot;<br>Displaying the public key token for the assembly<br>&quot;);\n         byte[] publicKeyTokenBytes = myAssembly.GetName().GetPublicKeyToken();\n         Console.WriteLine(Encoding.ASCII.GetString(publicKeyTokenBytes));\n      }\n   }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"AssemblyName_SetPublicKey#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Threading;\nusing namespace System::IO;\nusing namespace System::Globalization;\nusing namespace System::Reflection::Emit;\nusing namespace System::Configuration::Assemblies;\nusing namespace System::Text;\n\nstatic void MakeAssembly( AssemblyName^ myAssemblyName, String^ fileName )\n{\n   // Get the assembly builder from the application domain associated with the current thread.\n   AssemblyBuilder^ myAssemblyBuilder = Thread::GetDomain()-&gt;DefineDynamicAssembly( myAssemblyName, AssemblyBuilderAccess::RunAndSave );\n\n   // Create a dynamic module in the assembly.\n   ModuleBuilder^ myModuleBuilder = myAssemblyBuilder-&gt;DefineDynamicModule( &quot;MyModule&quot;, fileName );\n\n   // Create a type in the module.\n   TypeBuilder^ myTypeBuilder = myModuleBuilder-&gt;DefineType( &quot;MyType&quot; );\n\n   // Create a method called &#39;Main&#39;.\n   MethodBuilder^ myMethodBuilder = myTypeBuilder-&gt;DefineMethod( &quot;Main&quot;, static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::HideBySig | MethodAttributes::Static), void::typeid, nullptr );\n\n   // Get the Intermediate Language generator for the method.\n   ILGenerator^ myILGenerator = myMethodBuilder-&gt;GetILGenerator();\n\n   // Use the utility method to generate the IL instructions that print a String* to the console.\n   myILGenerator-&gt;EmitWriteLine( &quot;Hello World!&quot; );\n\n   // Generate the &#39;ret&#39; IL instruction.\n   myILGenerator-&gt;Emit( OpCodes::Ret );\n\n   // End the creation of the type.\n   myTypeBuilder-&gt;CreateType();\n\n   // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n   myAssemblyBuilder-&gt;SetEntryPoint( myMethodBuilder );\n   myAssemblyBuilder-&gt;Save( fileName );\n}\n\nint main()\n{\n   // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n   AssemblyName^ myAssemblyName = gcnew AssemblyName;\n\n   // Set the codebase to the physical directory were the assembly resides.\n   myAssemblyName-&gt;CodeBase = Directory::GetCurrentDirectory();\n\n   // Set the culture information of the assembly to &#39;English-American&#39;.\n   myAssemblyName-&gt;CultureInfo = gcnew CultureInfo( &quot;en-US&quot; );\n\n   // Set the hash algoritm to &#39;SHA1&#39;.\n   myAssemblyName-&gt;HashAlgorithm = AssemblyHashAlgorithm::SHA1;\n   myAssemblyName-&gt;VersionCompatibility = AssemblyVersionCompatibility::SameProcess;\n   myAssemblyName-&gt;Flags = AssemblyNameFlags::PublicKey;\n\n   // Get the whole contents of the &#39;PublicKey.snk&#39; into a Byte array.\n   FileStream^ publicKeyStream = File::Open( &quot;PublicKey.snk&quot;, FileMode::Open );\n   array&lt;Byte&gt;^publicKey = gcnew array&lt;Byte&gt;(publicKeyStream-&gt;Length);\n   publicKeyStream-&gt;Read( publicKey, 0, (int)publicKeyStream-&gt;Length );\n\n   // Provide the assembly with a public key.\n   myAssemblyName-&gt;SetPublicKey( publicKey );\n\n   // Get the whole contents of the &#39;PublicKeyToken.snk&#39; into a Byte array.\n   FileStream^ publicKeyTokenStream = File::Open( &quot;PublicKeyToken.snk&quot;, FileMode::Open );\n   array&lt;Byte&gt;^publicKeyToken = gcnew array&lt;Byte&gt;(publicKeyTokenStream-&gt;Length);\n   publicKeyTokenStream-&gt;Read( publicKeyToken, 0, (int)publicKeyToken-&gt;Length );\n\n   // Provide the assembly with a public key token.\n   myAssemblyName-&gt;SetPublicKeyToken( publicKeyToken );\n   myAssemblyName-&gt;Name = &quot;MyAssembly&quot;;\n   myAssemblyName-&gt;Version = gcnew Version( &quot;1.0.0.2001&quot; );\n   MakeAssembly( myAssemblyName, &quot;MyAssembly.exe&quot; );\n\n   // Get the assemblies loaded in the current application domain.\n   array&lt;Assembly^&gt;^myAssemblies = Thread::GetDomain()-&gt;GetAssemblies();\n\n   // Get the dynamic assembly named &#39;MyAssembly&#39;. \n   Assembly^ myAssembly = nullptr;\n   for ( int i = 0; i &lt; myAssemblies-&gt;Length; i++ )\n      if ( String::Compare( myAssemblies[ i ]-&gt;GetName()-&gt;Name, &quot;MyAssembly&quot; ) == 0 )\n            myAssembly = myAssemblies[ i ];\n\n   // Display the full assembly information to the console.\n   if ( myAssembly != nullptr )\n   {\n      Console::WriteLine( &quot;<br>Displaying the full assembly name<br>&quot; );\n      String^ assemblyName = myAssembly-&gt;GetName()-&gt;FullName;\n      Console::WriteLine( assemblyName );\n      Console::WriteLine( &quot;<br>Displaying the public key for the assembly<br>&quot; );\n      array&lt;Byte&gt;^publicKeyBytes = myAssembly-&gt;GetName()-&gt;GetPublicKey();\n      Console::WriteLine( Encoding::ASCII-&gt;GetString( publicKeyBytes ) );\n      Console::WriteLine( &quot;<br>Displaying the public key token for the assembly<br>&quot; );\n      array&lt;Byte&gt;^publicKeyTokenBytes = myAssembly-&gt;GetName()-&gt;GetPublicKeyToken();\n      Console::WriteLine( Encoding::ASCII-&gt;GetString( publicKeyTokenBytes ) );\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"AssemblyName_SetPublicKey#1\">Imports System\nImports System.Reflection\nImports System.Threading\nImports System.IO\nImports System.Globalization\nImports System.Reflection.Emit\nImports System.Configuration.Assemblies\nImports System.Text\nImports Microsoft.VisualBasic\n\nPublic Class AssemblyName_CodeBase\n   \n   Public Shared Sub MakeAssembly(myAssemblyName As AssemblyName, fileName As String)\n      &#39; Get the assembly builder from the application domain associated with the current thread.\n      Dim myAssemblyBuilder As AssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave)\n      &#39; Create a dynamic module in the assembly.\n      Dim myModuleBuilder As ModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName)\n      &#39; Create a type in the module.\n      Dim myTypeBuilder As TypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;)\n      &#39; Create a method called &#39;Main&#39;.\n      Dim myMethodBuilder As MethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public Or MethodAttributes.HideBySig Or MethodAttributes.Static, GetType(object), Nothing)\n      &#39; Get the Intermediate Language generator for the method.\n      Dim myILGenerator As ILGenerator = myMethodBuilder.GetILGenerator()\n      &#39; Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;)\n      &#39; Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret)\n      &#39; End the creation of the type.\n      myTypeBuilder.CreateType()\n      &#39; Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder)\n      myAssemblyBuilder.Save(fileName)\n   End Sub &#39;MakeAssembly\n   \n   \n   Public Shared Sub Main()\n      &#39; Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      Dim myAssemblyName As New AssemblyName()\n      &#39; Set the codebase to the physical directory were the assembly resides.\n      myAssemblyName.CodeBase = Directory.GetCurrentDirectory()\n      &#39; Set the culture information of the assembly to &#39;English-American&#39;.\n      myAssemblyName.CultureInfo = New CultureInfo(&quot;en-US&quot;)\n      &#39; Set the hash algoritm to &#39;SHA1&#39;.\n      myAssemblyName.HashAlgorithm = AssemblyHashAlgorithm.SHA1\n      myAssemblyName.VersionCompatibility = AssemblyVersionCompatibility.SameProcess\n      myAssemblyName.Flags = AssemblyNameFlags.PublicKey\n      &#39; Get the whole contents of the &#39;PublicKey.snk&#39; into a byte array.\n      Dim publicKeyStream As FileStream = File.Open(&quot;PublicKey.snk&quot;, FileMode.Open)\n      Dim publicKey(publicKeyStream.Length) As Byte\n      publicKeyStream.Read(publicKey, 0, CInt(publicKeyStream.Length))\n      &#39; Provide the assembly with a public key.\n      myAssemblyName.SetPublicKey(publicKey)\n      &#39; Get the whole contents of the &#39;PublicKeyToken.snk&#39; into a byte array.\n      Dim publicKeyTokenStream As FileStream = File.Open(&quot;PublicKeyToken.snk&quot;, FileMode.Open)\n      Dim publicKeyToken() As Byte = New [Byte](publicKeyTokenStream.Length) {}\n      publicKeyTokenStream.Read(publicKeyToken, 0, CInt(publicKeyToken.Length))\n      &#39; Provide the assembly with a public key token.\n      myAssemblyName.SetPublicKeyToken(publicKeyToken)\n      myAssemblyName.Name = &quot;MyAssembly&quot;\n      myAssemblyName.Version = New Version(&quot;1.0.0.2001&quot;)\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;)\n      \n      &#39; Get the assemblies loaded in the current application domain.\n      Dim myAssemblies As [Assembly]() = Thread.GetDomain().GetAssemblies()\n      \n      &#39; Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Dim myAssembly As [Assembly] = Nothing\n      Dim i As Integer\n      For i = 0 To myAssemblies.Length - 1\n         If [String].Compare(myAssemblies(i).GetName().Name, &quot;MyAssembly&quot;) = 0 Then\n            myAssembly = myAssemblies(i)\n         End If \n      Next i &#39; Display the full assembly information to the console.\n      If Not (myAssembly Is Nothing) Then\n         Console.WriteLine(ControlChars.Cr + &quot;Displaying the full assembly name&quot; + ControlChars.Cr)\n         Dim assemblyName As String = myAssembly.GetName().FullName\n         Console.WriteLine(assemblyName)\n         Console.WriteLine(ControlChars.Cr + &quot;Displaying the public key for the assembly&quot; + ControlChars.Cr)\n         Dim publicKeyBytes As Byte() = myAssembly.GetName().GetPublicKey()\n         Console.WriteLine(Encoding.ASCII.GetString(publicKeyBytes))\n         Console.WriteLine(ControlChars.Cr + &quot;Displaying the public key token for the assembly&quot; + ControlChars.Cr)\n         Dim publicKeyTokenBytes As Byte() = myAssembly.GetName().GetPublicKeyToken()\n         Console.WriteLine(Encoding.ASCII.GetString(publicKeyTokenBytes))\n      End If\n   End Sub &#39;Main \nEnd Class &#39;AssemblyName_CodeBase \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_SetPublicKeyToken_System_Byte___\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_SetPublicKeyToken_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">SetPublicKeyToken(Byte[])</div>        \r\n          </div>\r\n    \r\n            <p>Sets the public key token, which is the last 8 bytes of the SHA-1 hash of the public key under which the application or assembly is signed.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void SetPublicKeyToken (byte[] publicKeyToken);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>publicKeyToken</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.byte\" data-linktype=\"relative-path\">Byte</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A byte array containing the public key token of the assembly.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>When you set the public key by calling the <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_SetPublicKey_\" data-linktype=\"relative-path\">SetPublicKey</a> method, you must also use the SetPublicKeyToken method to provide a public key token. Otherwise, a <a class=\"xref\" href=\"system.security.securityexception\" data-linktype=\"relative-path\">SecurityException</a> is thrown when the <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_GetPublicKey_\" data-linktype=\"relative-path\">GetPublicKey</a> method is called.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example emits a dynamic assembly and saves it to the current directory. When the assembly is created, the SetPublicKeyToken method is used to set the assembly&#39;s public key token. The <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_GetPublicKeyToken_\" data-linktype=\"relative-path\">GetPublicKeyToken</a> method is then used to retrieve the public key token, which is displayed to the console.  </p>\n<pre><code class=\"lang-cs\" name=\"AssemblyName_SetPublicKey#2\">using System;\nusing System.Reflection;\nusing System.Threading;\nusing System.IO;\nusing System.Globalization;\nusing System.Reflection.Emit;\nusing System.Configuration.Assemblies;\nusing System.Text;\n\npublic class AssemblyName_CodeBase\n{\n   public static void MakeAssembly(AssemblyName myAssemblyName, string fileName)\n   {\n      // Get the assembly builder from the application domain associated with the current thread.\n      AssemblyBuilder myAssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave);\n      // Create a dynamic module in the assembly.\n      ModuleBuilder myModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName);\n      // Create a type in the module.\n      TypeBuilder myTypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;);\n      // Create a method called &#39;Main&#39;.\n      MethodBuilder myMethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public | MethodAttributes.HideBySig |\n         MethodAttributes.Static, typeof(void), null);\n      // Get the Intermediate Language generator for the method.\n      ILGenerator myILGenerator = myMethodBuilder.GetILGenerator();\n      // Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;);\n      // Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret);\n      // End the creation of the type.\n      myTypeBuilder.CreateType();\n      // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder);\n      myAssemblyBuilder.Save(fileName);\n   }\n\n   public static void Main()\n   {\n      // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      AssemblyName myAssemblyName = new AssemblyName();\n      // Set the codebase to the physical directory were the assembly resides.\n      myAssemblyName.CodeBase = Directory.GetCurrentDirectory();\n      // Set the culture information of the assembly to &#39;English-American&#39;.\n      myAssemblyName.CultureInfo = new CultureInfo(&quot;en-US&quot;);\n      // Set the hash algoritm to &#39;SHA1&#39;.\n      myAssemblyName.HashAlgorithm = AssemblyHashAlgorithm.SHA1;\n      myAssemblyName.VersionCompatibility = AssemblyVersionCompatibility.SameProcess;\n      myAssemblyName.Flags = AssemblyNameFlags.PublicKey;\n      // Get the whole contents of the &#39;PublicKey.snk&#39; into a byte array.\n      FileStream publicKeyStream = File.Open(&quot;PublicKey.snk&quot;, FileMode.Open);\n      byte[] publicKey = new byte[publicKeyStream.Length];\n      publicKeyStream.Read(publicKey, 0, (int)publicKeyStream.Length);\n      // Provide the assembly with a public key.\n      myAssemblyName.SetPublicKey(publicKey);\n      // Get the whole contents of the &#39;PublicKeyToken.snk&#39; into a byte array.\n      FileStream publicKeyTokenStream = File.Open(&quot;PublicKeyToken.snk&quot;, FileMode.Open);\n      byte[] publicKeyToken = new Byte[publicKeyTokenStream.Length];\n      publicKeyTokenStream.Read(publicKeyToken, 0, (int)publicKeyToken.Length);\n      // Provide the assembly with a public key token.\n      myAssemblyName.SetPublicKeyToken(publicKeyToken);\n      myAssemblyName.Name = &quot;MyAssembly&quot;;\n      myAssemblyName.Version = new Version(&quot;1.0.0.2001&quot;);\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;);\n      \n      // Get the assemblies loaded in the current application domain.\n      Assembly[] myAssemblies = Thread.GetDomain().GetAssemblies();\n\n      // Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Assembly myAssembly = null;\n      for(int i = 0; i &lt; myAssemblies.Length; i++)\n         if(String.Compare(myAssemblies[i].GetName().Name, &quot;MyAssembly&quot;) == 0)\n            myAssembly = myAssemblies[i];\n  \n      // Display the full assembly information to the console.\n      if(myAssembly != null)\n      {\n         Console.WriteLine(&quot;<br>Displaying the full assembly name<br>&quot;);\n         string assemblyName = myAssembly.GetName().FullName;\n         Console.WriteLine(assemblyName);\n         Console.WriteLine(&quot;<br>Displaying the public key for the assembly<br>&quot;);\n         byte[] publicKeyBytes = myAssembly.GetName().GetPublicKey();\n         Console.WriteLine(Encoding.ASCII.GetString(publicKeyBytes));\n         Console.WriteLine(&quot;<br>Displaying the public key token for the assembly<br>&quot;);\n         byte[] publicKeyTokenBytes = myAssembly.GetName().GetPublicKeyToken();\n         Console.WriteLine(Encoding.ASCII.GetString(publicKeyTokenBytes));\n      }\n   }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"AssemblyName_SetPublicKey#2\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Threading;\nusing namespace System::IO;\nusing namespace System::Globalization;\nusing namespace System::Reflection::Emit;\nusing namespace System::Configuration::Assemblies;\nusing namespace System::Text;\n\nstatic void MakeAssembly( AssemblyName^ myAssemblyName, String^ fileName )\n{\n   // Get the assembly builder from the application domain associated with the current thread.\n   AssemblyBuilder^ myAssemblyBuilder = Thread::GetDomain()-&gt;DefineDynamicAssembly( myAssemblyName, AssemblyBuilderAccess::RunAndSave );\n\n   // Create a dynamic module in the assembly.\n   ModuleBuilder^ myModuleBuilder = myAssemblyBuilder-&gt;DefineDynamicModule( &quot;MyModule&quot;, fileName );\n\n   // Create a type in the module.\n   TypeBuilder^ myTypeBuilder = myModuleBuilder-&gt;DefineType( &quot;MyType&quot; );\n\n   // Create a method called &#39;Main&#39;.\n   MethodBuilder^ myMethodBuilder = myTypeBuilder-&gt;DefineMethod( &quot;Main&quot;, static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::HideBySig | MethodAttributes::Static), void::typeid, nullptr );\n\n   // Get the Intermediate Language generator for the method.\n   ILGenerator^ myILGenerator = myMethodBuilder-&gt;GetILGenerator();\n\n   // Use the utility method to generate the IL instructions that print a String* to the console.\n   myILGenerator-&gt;EmitWriteLine( &quot;Hello World!&quot; );\n\n   // Generate the &#39;ret&#39; IL instruction.\n   myILGenerator-&gt;Emit( OpCodes::Ret );\n\n   // End the creation of the type.\n   myTypeBuilder-&gt;CreateType();\n\n   // Set the method with name &#39;Main&#39; as the entry point in the assembly.\n   myAssemblyBuilder-&gt;SetEntryPoint( myMethodBuilder );\n   myAssemblyBuilder-&gt;Save( fileName );\n}\n\nint main()\n{\n   // Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n   AssemblyName^ myAssemblyName = gcnew AssemblyName;\n\n   // Set the codebase to the physical directory were the assembly resides.\n   myAssemblyName-&gt;CodeBase = Directory::GetCurrentDirectory();\n\n   // Set the culture information of the assembly to &#39;English-American&#39;.\n   myAssemblyName-&gt;CultureInfo = gcnew CultureInfo( &quot;en-US&quot; );\n\n   // Set the hash algoritm to &#39;SHA1&#39;.\n   myAssemblyName-&gt;HashAlgorithm = AssemblyHashAlgorithm::SHA1;\n   myAssemblyName-&gt;VersionCompatibility = AssemblyVersionCompatibility::SameProcess;\n   myAssemblyName-&gt;Flags = AssemblyNameFlags::PublicKey;\n\n   // Get the whole contents of the &#39;PublicKey.snk&#39; into a Byte array.\n   FileStream^ publicKeyStream = File::Open( &quot;PublicKey.snk&quot;, FileMode::Open );\n   array&lt;Byte&gt;^publicKey = gcnew array&lt;Byte&gt;(publicKeyStream-&gt;Length);\n   publicKeyStream-&gt;Read( publicKey, 0, (int)publicKeyStream-&gt;Length );\n\n   // Provide the assembly with a public key.\n   myAssemblyName-&gt;SetPublicKey( publicKey );\n\n   // Get the whole contents of the &#39;PublicKeyToken.snk&#39; into a Byte array.\n   FileStream^ publicKeyTokenStream = File::Open( &quot;PublicKeyToken.snk&quot;, FileMode::Open );\n   array&lt;Byte&gt;^publicKeyToken = gcnew array&lt;Byte&gt;(publicKeyTokenStream-&gt;Length);\n   publicKeyTokenStream-&gt;Read( publicKeyToken, 0, (int)publicKeyToken-&gt;Length );\n\n   // Provide the assembly with a public key token.\n   myAssemblyName-&gt;SetPublicKeyToken( publicKeyToken );\n   myAssemblyName-&gt;Name = &quot;MyAssembly&quot;;\n   myAssemblyName-&gt;Version = gcnew Version( &quot;1.0.0.2001&quot; );\n   MakeAssembly( myAssemblyName, &quot;MyAssembly.exe&quot; );\n\n   // Get the assemblies loaded in the current application domain.\n   array&lt;Assembly^&gt;^myAssemblies = Thread::GetDomain()-&gt;GetAssemblies();\n\n   // Get the dynamic assembly named &#39;MyAssembly&#39;. \n   Assembly^ myAssembly = nullptr;\n   for ( int i = 0; i &lt; myAssemblies-&gt;Length; i++ )\n      if ( String::Compare( myAssemblies[ i ]-&gt;GetName()-&gt;Name, &quot;MyAssembly&quot; ) == 0 )\n            myAssembly = myAssemblies[ i ];\n\n   // Display the full assembly information to the console.\n   if ( myAssembly != nullptr )\n   {\n      Console::WriteLine( &quot;<br>Displaying the full assembly name<br>&quot; );\n      String^ assemblyName = myAssembly-&gt;GetName()-&gt;FullName;\n      Console::WriteLine( assemblyName );\n      Console::WriteLine( &quot;<br>Displaying the public key for the assembly<br>&quot; );\n      array&lt;Byte&gt;^publicKeyBytes = myAssembly-&gt;GetName()-&gt;GetPublicKey();\n      Console::WriteLine( Encoding::ASCII-&gt;GetString( publicKeyBytes ) );\n      Console::WriteLine( &quot;<br>Displaying the public key token for the assembly<br>&quot; );\n      array&lt;Byte&gt;^publicKeyTokenBytes = myAssembly-&gt;GetName()-&gt;GetPublicKeyToken();\n      Console::WriteLine( Encoding::ASCII-&gt;GetString( publicKeyTokenBytes ) );\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"AssemblyName_SetPublicKey#2\">Imports System\nImports System.Reflection\nImports System.Threading\nImports System.IO\nImports System.Globalization\nImports System.Reflection.Emit\nImports System.Configuration.Assemblies\nImports System.Text\nImports Microsoft.VisualBasic\n\nPublic Class AssemblyName_CodeBase\n   \n   Public Shared Sub MakeAssembly(myAssemblyName As AssemblyName, fileName As String)\n      &#39; Get the assembly builder from the application domain associated with the current thread.\n      Dim myAssemblyBuilder As AssemblyBuilder = Thread.GetDomain().DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.RunAndSave)\n      &#39; Create a dynamic module in the assembly.\n      Dim myModuleBuilder As ModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;MyModule&quot;, fileName)\n      &#39; Create a type in the module.\n      Dim myTypeBuilder As TypeBuilder = myModuleBuilder.DefineType(&quot;MyType&quot;)\n      &#39; Create a method called &#39;Main&#39;.\n      Dim myMethodBuilder As MethodBuilder = myTypeBuilder.DefineMethod(&quot;Main&quot;, MethodAttributes.Public Or MethodAttributes.HideBySig Or MethodAttributes.Static, GetType(object), Nothing)\n      &#39; Get the Intermediate Language generator for the method.\n      Dim myILGenerator As ILGenerator = myMethodBuilder.GetILGenerator()\n      &#39; Use the utility method to generate the IL instructions that print a string to the console.\n      myILGenerator.EmitWriteLine(&quot;Hello World!&quot;)\n      &#39; Generate the &#39;ret&#39; IL instruction.\n      myILGenerator.Emit(OpCodes.Ret)\n      &#39; End the creation of the type.\n      myTypeBuilder.CreateType()\n      &#39; Set the method with name &#39;Main&#39; as the entry point in the assembly.\n      myAssemblyBuilder.SetEntryPoint(myMethodBuilder)\n      myAssemblyBuilder.Save(fileName)\n   End Sub &#39;MakeAssembly\n   \n   \n   Public Shared Sub Main()\n      &#39; Create a dynamic assembly with name &#39;MyAssembly&#39; and build version &#39;1.0.0.2001&#39;.\n      Dim myAssemblyName As New AssemblyName()\n      &#39; Set the codebase to the physical directory were the assembly resides.\n      myAssemblyName.CodeBase = Directory.GetCurrentDirectory()\n      &#39; Set the culture information of the assembly to &#39;English-American&#39;.\n      myAssemblyName.CultureInfo = New CultureInfo(&quot;en-US&quot;)\n      &#39; Set the hash algoritm to &#39;SHA1&#39;.\n      myAssemblyName.HashAlgorithm = AssemblyHashAlgorithm.SHA1\n      myAssemblyName.VersionCompatibility = AssemblyVersionCompatibility.SameProcess\n      myAssemblyName.Flags = AssemblyNameFlags.PublicKey\n      &#39; Get the whole contents of the &#39;PublicKey.snk&#39; into a byte array.\n      Dim publicKeyStream As FileStream = File.Open(&quot;PublicKey.snk&quot;, FileMode.Open)\n      Dim publicKey(publicKeyStream.Length) As Byte\n      publicKeyStream.Read(publicKey, 0, CInt(publicKeyStream.Length))\n      &#39; Provide the assembly with a public key.\n      myAssemblyName.SetPublicKey(publicKey)\n      &#39; Get the whole contents of the &#39;PublicKeyToken.snk&#39; into a byte array.\n      Dim publicKeyTokenStream As FileStream = File.Open(&quot;PublicKeyToken.snk&quot;, FileMode.Open)\n      Dim publicKeyToken() As Byte = New [Byte](publicKeyTokenStream.Length) {}\n      publicKeyTokenStream.Read(publicKeyToken, 0, CInt(publicKeyToken.Length))\n      &#39; Provide the assembly with a public key token.\n      myAssemblyName.SetPublicKeyToken(publicKeyToken)\n      myAssemblyName.Name = &quot;MyAssembly&quot;\n      myAssemblyName.Version = New Version(&quot;1.0.0.2001&quot;)\n      MakeAssembly(myAssemblyName, &quot;MyAssembly.exe&quot;)\n      \n      &#39; Get the assemblies loaded in the current application domain.\n      Dim myAssemblies As [Assembly]() = Thread.GetDomain().GetAssemblies()\n      \n      &#39; Get the dynamic assembly named &#39;MyAssembly&#39;. \n      Dim myAssembly As [Assembly] = Nothing\n      Dim i As Integer\n      For i = 0 To myAssemblies.Length - 1\n         If [String].Compare(myAssemblies(i).GetName().Name, &quot;MyAssembly&quot;) = 0 Then\n            myAssembly = myAssemblies(i)\n         End If \n      Next i &#39; Display the full assembly information to the console.\n      If Not (myAssembly Is Nothing) Then\n         Console.WriteLine(ControlChars.Cr + &quot;Displaying the full assembly name&quot; + ControlChars.Cr)\n         Dim assemblyName As String = myAssembly.GetName().FullName\n         Console.WriteLine(assemblyName)\n         Console.WriteLine(ControlChars.Cr + &quot;Displaying the public key for the assembly&quot; + ControlChars.Cr)\n         Dim publicKeyBytes As Byte() = myAssembly.GetName().GetPublicKey()\n         Console.WriteLine(Encoding.ASCII.GetString(publicKeyBytes))\n         Console.WriteLine(ControlChars.Cr + &quot;Displaying the public key token for the assembly&quot; + ControlChars.Cr)\n         Dim publicKeyTokenBytes As Byte() = myAssembly.GetName().GetPublicKeyToken()\n         Console.WriteLine(Encoding.ASCII.GetString(publicKeyTokenBytes))\n      End If\n   End Sub &#39;Main \nEnd Class &#39;AssemblyName_CodeBase \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_ToString\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_ToString_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ToString()</div>        \r\n          </div>\r\n    \r\n            <p>Returns the full name of the assembly, also known as the display name.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override string ToString ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </div>\r\n                  <p>The full name of the assembly, or the class name if the full name cannot be determined.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>See the description of <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> for the format of the returned string.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example gets an <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> object for a hypothetical <code>MyAssembly.exe</code> assembly, and then uses the ToString method to retrieve the full assembly name, or display name.  </p>\n<pre><code class=\"lang-cpp\" name=\"AssemblyName_GetAssemblyName#2\">#using &lt;system.dll&gt;\n\nusing namespace System;\nusing namespace System::Reflection;\nint main()\n{\n   \n   // Replace the string &quot;MyAssembly.exe&quot; with the name of an assembly,\n   // including a path if necessary. If you do not have another assembly\n   // to use, you can use whatever name you give to this assembly.\n   //\n   AssemblyName^ myAssemblyName = AssemblyName::GetAssemblyName( &quot;MyAssembly.exe&quot; );\n   Console::WriteLine( &quot;<br>Displaying assembly information:<br>&quot; );\n   Console::WriteLine( myAssemblyName );\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"AssemblyName_GetAssemblyName#2\">\nusing System;\nusing System.Reflection;\n\npublic class AssemblyName_GetAssemblyName\n{\n   public static void Main()\n   {\n      // Replace the string &quot;MyAssembly.exe&quot; with the name of an assembly,\n      // including a path if necessary. If you do not have another assembly\n      // to use, you can use whatever name you give to this assembly.\n      //\n      AssemblyName myAssemblyName = AssemblyName.GetAssemblyName(&quot;MyAssembly.exe&quot;);\n      Console.WriteLine(&quot;<br>Displaying assembly information:<br>&quot;);\n      Console.WriteLine(myAssemblyName.ToString());\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"AssemblyName_GetAssemblyName#2\">Imports System\nImports System.Reflection\nImports Microsoft.VisualBasic\n\nPublic Class AssemblyName_GetAssemblyName\n   \n   Public Shared Sub Main()\n      \n      &#39; Replace the string &quot;MyAssembly.exe&quot; with the name of an assembly,\n      &#39; including a path if necessary. If you do not have another assembly\n      &#39; to use, you can use whatever name you give to this assembly.\n      &#39;\n      Dim myAssemblyName As AssemblyName = AssemblyName.GetAssemblyName(&quot;MyAssembly.exe&quot;)\n      Console.WriteLine(vbCrLf &amp; &quot;Displaying assembly information:&quot; &amp; vbCrLf)\n      Console.WriteLine(myAssemblyName.ToString())\n   End Sub &#39;Main \nEnd Class &#39;AssemblyName_GetAssemblyName \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"eii\">\r\n        <h2>Explicit Interface Implementations\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_System_Runtime_InteropServices__AssemblyName_GetIDsOfNames_System_Guid__System_IntPtr_System_UInt32_System_UInt32_System_IntPtr_\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_System_Runtime_InteropServices__AssemblyName_GetIDsOfNames_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_AssemblyName.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)</div>        \r\n          </div>\r\n    \r\n            <p>Maps a set of names to a corresponding set of dispatch identifiers.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">void _AssemblyName.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>riid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.guid\" data-linktype=\"relative-path\">Guid</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Reserved for future use. Must be IID_NULL.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>rgszNames</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Passed-in array of names to be mapped.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>cNames</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Count of the names to be mapped.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>lcid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The locale context in which to interpret the names.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>rgDispId</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Caller-allocated array that receives the IDs corresponding to the names.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notimplementedexception\" data-linktype=\"relative-path\">NotImplementedException</a></div>\r\n                  </div>\r\n                  <p>Late-bound access using the COM <code>IDispatch</code> interface is not supported.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <code>IDispatch::GetIDsOfNames</code>, see the MSDN Library.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_System_Runtime_InteropServices__AssemblyName_GetTypeInfo_System_UInt32_System_UInt32_System_IntPtr_\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_System_Runtime_InteropServices__AssemblyName_GetTypeInfo_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_AssemblyName.GetTypeInfo(UInt32,UInt32,IntPtr)</div>        \r\n          </div>\r\n    \r\n            <p>Retrieves the type information for an object, which can then be used to get the type information for an interface.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">void _AssemblyName.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>iTInfo</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The type information to return.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>lcid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The locale identifier for the type information.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>ppTInfo</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Receives a pointer to the requested type information object.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notimplementedexception\" data-linktype=\"relative-path\">NotImplementedException</a></div>\r\n                  </div>\r\n                  <p>Late-bound access using the COM <code>IDispatch</code> interface is not supported.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <code>IDispatch::GetTypeInfo</code>, see the MSDN Library.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_System_Runtime_InteropServices__AssemblyName_GetTypeInfoCount_System_UInt32__\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_System_Runtime_InteropServices__AssemblyName_GetTypeInfoCount_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_AssemblyName.GetTypeInfoCount(UInt32)</div>        \r\n          </div>\r\n    \r\n            <p>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">void _AssemblyName.GetTypeInfoCount (out uint pcTInfo);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>pcTInfo</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Points to a location that receives the number of type information interfaces provided by the object.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notimplementedexception\" data-linktype=\"relative-path\">NotImplementedException</a></div>\r\n                  </div>\r\n                  <p>Late-bound access using the COM <code>IDispatch</code> interface is not supported.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <code>IDispatch::GetTypeInfoCount</code>, see the MSDN Library.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_AssemblyName_System_Runtime_InteropServices__AssemblyName_Invoke_System_UInt32_System_Guid__System_UInt32_System_Int16_System_IntPtr_System_IntPtr_System_IntPtr_System_IntPtr_\">\r\n    \r\n            <a id=\"System_Reflection_AssemblyName_System_Runtime_InteropServices__AssemblyName_Invoke_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_AssemblyName.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)</div>        \r\n          </div>\r\n    \r\n            <p>Provides access to properties and methods exposed by an object.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">void _AssemblyName.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>dispIdMember</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Identifies the member.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>riid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.guid\" data-linktype=\"relative-path\">Guid</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Reserved for future use. Must be IID_NULL.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>lcid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The locale context in which to interpret arguments.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>wFlags</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int16\" data-linktype=\"relative-path\">Int16</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Flags describing the context of the call.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>pDispParams</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Pointer to a structure containing an array of arguments, an array of argument DispIDs for named arguments, and counts for the number of elements in the arrays.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>pVarResult</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Pointer to the location where the result is to be stored.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>pExcepInfo</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Pointer to a structure that contains exception information.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>puArgErr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The index of the first argument that has an error.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notimplementedexception\" data-linktype=\"relative-path\">NotImplementedException</a></div>\r\n                  </div>\r\n                  <p>Late-bound access using the COM <code>IDispatch</code> interface is not supported.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <code>IDispatch::Invoke</code>, see the MSDN Library.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n","outputRootRelativePath":"./","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"breadcrumb_path\" content=\"breadcrumb/toc.json\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"fulldocset\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.fulldocset\">\r\n<meta name=\"ref_skeleton_gitcommit\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Reflection.AssemblyName.yml\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Reflection.AssemblyName.yml\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName..ctor\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName.Clone\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName.CodeBase\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName.ContentType\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName.CultureInfo\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName.CultureName\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName.EscapedCodeBase\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName.Flags\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName.FullName\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName.GetAssemblyName\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName.GetObjectData\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName.GetPublicKey\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName.GetPublicKeyToken\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName.HashAlgorithm\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName.KeyPair\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName.Name\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName.OnDeserialization\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName.ProcessorArchitecture\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName.ReferenceMatchesDefinition\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName.SetPublicKey\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName.SetPublicKeyToken\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName._AssemblyName.GetIDsOfNames\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName._AssemblyName.GetTypeInfo\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName._AssemblyName.GetTypeInfoCount\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName._AssemblyName.Invoke\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName.ToString\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName.Version\">\r\n<meta name=\"APIName\" content=\"System.Reflection.AssemblyName.VersionCompatibility\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-01 01:37 AM\">\r\n<meta name=\"document_id\" content=\"f99a0600-d542-c6d3-6cb7-d34c001ed4eb\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Describes an assembly&amp;#39;s unique identity in full.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/System.Reflection/toc.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Reflection.AssemblyName\">\r\n","rawMetadata":{"author":"dotnet-bot","breadcrumb_path":"breadcrumb/toc.json","search.ms_sitename":"Docs","search.ms_docsetname":"fulldocset","version":null,"_op_canonicalUrlPrefix":"https://ppe.docs.microsoft.com/en-us/fulldotnet/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":true,"depot_name":"MSDN.fulldocset","_op_gitRefSkeletonCommitHistory":[{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"use plugin in master","commit_sha":"501959ac03e19ac52a27aa4c6bbeb980f8b11c8c","commit_date":"2017-03-01 09:31:20 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"fix pointer ref","commit_sha":"76befb0e7f7b41839ec719047e5b39a5981298f3","commit_date":"2017-02-28 15:47:23 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"switch from platform to version","commit_sha":"78cdacb5ca782478af490a6b30c3a2cb2b6b873e","commit_date":"2017-02-28 15:09:51 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"update platforms","commit_sha":"39ad5a8919a59afc93a79ac4bd8e07c3b471b37a","commit_date":"2017-02-28 10:38:59 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"checkin yml","commit_sha":"da161b792852497df7140d7768cee2eccd9cb43f","commit_date":"2017-02-28 09:36:15 +0800"}],"ref_skeleton_gitcommit":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Reflection.AssemblyName.yml","original_ref_skeleton_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Reflection.AssemblyName.yml","open_to_public_contributors":true,"api_name":["System.Reflection.AssemblyName","System.Reflection.AssemblyName..ctor","System.Reflection.AssemblyName.Clone","System.Reflection.AssemblyName.CodeBase","System.Reflection.AssemblyName.ContentType","System.Reflection.AssemblyName.CultureInfo","System.Reflection.AssemblyName.CultureName","System.Reflection.AssemblyName.EscapedCodeBase","System.Reflection.AssemblyName.Flags","System.Reflection.AssemblyName.FullName","System.Reflection.AssemblyName.GetAssemblyName","System.Reflection.AssemblyName.GetObjectData","System.Reflection.AssemblyName.GetPublicKey","System.Reflection.AssemblyName.GetPublicKeyToken","System.Reflection.AssemblyName.HashAlgorithm","System.Reflection.AssemblyName.KeyPair","System.Reflection.AssemblyName.Name","System.Reflection.AssemblyName.OnDeserialization","System.Reflection.AssemblyName.ProcessorArchitecture","System.Reflection.AssemblyName.ReferenceMatchesDefinition","System.Reflection.AssemblyName.SetPublicKey","System.Reflection.AssemblyName.SetPublicKeyToken","System.Reflection.AssemblyName._AssemblyName.GetIDsOfNames","System.Reflection.AssemblyName._AssemblyName.GetTypeInfo","System.Reflection.AssemblyName._AssemblyName.GetTypeInfoCount","System.Reflection.AssemblyName._AssemblyName.Invoke","System.Reflection.AssemblyName.ToString","System.Reflection.AssemblyName.Version","System.Reflection.AssemblyName.VersionCompatibility"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Reflection.AssemblyName","System::Reflection::AssemblyName","System.Reflection.AssemblyName.#ctor","System::Reflection::AssemblyName::#ctor","System.Reflection.AssemblyName.Clone","System::Reflection::AssemblyName::Clone","System.Reflection.AssemblyName.CodeBase","System::Reflection::AssemblyName::CodeBase","System.Reflection.AssemblyName.ContentType","System::Reflection::AssemblyName::ContentType","System.Reflection.AssemblyName.CultureInfo","System::Reflection::AssemblyName::CultureInfo","System.Reflection.AssemblyName.CultureName","System::Reflection::AssemblyName::CultureName","System.Reflection.AssemblyName.EscapedCodeBase","System::Reflection::AssemblyName::EscapedCodeBase","System.Reflection.AssemblyName.Flags","System::Reflection::AssemblyName::Flags","System.Reflection.AssemblyName.FullName","System::Reflection::AssemblyName::FullName","System.Reflection.AssemblyName.GetAssemblyName","System::Reflection::AssemblyName::GetAssemblyName","System.Reflection.AssemblyName.GetObjectData","System::Reflection::AssemblyName::GetObjectData","System.Reflection.AssemblyName.GetPublicKey","System::Reflection::AssemblyName::GetPublicKey","System.Reflection.AssemblyName.GetPublicKeyToken","System::Reflection::AssemblyName::GetPublicKeyToken","System.Reflection.AssemblyName.HashAlgorithm","System::Reflection::AssemblyName::HashAlgorithm","System.Reflection.AssemblyName.KeyPair","System::Reflection::AssemblyName::KeyPair","System.Reflection.AssemblyName.Name","System::Reflection::AssemblyName::Name","System.Reflection.AssemblyName.OnDeserialization","System::Reflection::AssemblyName::OnDeserialization","System.Reflection.AssemblyName.ProcessorArchitecture","System::Reflection::AssemblyName::ProcessorArchitecture","System.Reflection.AssemblyName.ReferenceMatchesDefinition","System::Reflection::AssemblyName::ReferenceMatchesDefinition","System.Reflection.AssemblyName.SetPublicKey","System::Reflection::AssemblyName::SetPublicKey","System.Reflection.AssemblyName.SetPublicKeyToken","System::Reflection::AssemblyName::SetPublicKeyToken","System.Reflection.AssemblyName.System#Runtime#InteropServices#_AssemblyName#GetIDsOfNames","System::Reflection::AssemblyName::System#Runtime#InteropServices#_AssemblyName#GetIDsOfNames","System.Reflection.AssemblyName.System#Runtime#InteropServices#_AssemblyName#GetTypeInfo","System::Reflection::AssemblyName::System#Runtime#InteropServices#_AssemblyName#GetTypeInfo","System.Reflection.AssemblyName.System#Runtime#InteropServices#_AssemblyName#GetTypeInfoCount","System::Reflection::AssemblyName::System#Runtime#InteropServices#_AssemblyName#GetTypeInfoCount","System.Reflection.AssemblyName.System#Runtime#InteropServices#_AssemblyName#Invoke","System::Reflection::AssemblyName::System#Runtime#InteropServices#_AssemblyName#Invoke","System.Reflection.AssemblyName.ToString","System::Reflection::AssemblyName::ToString","System.Reflection.AssemblyName.Version","System::Reflection::AssemblyName::Version","System.Reflection.AssemblyName.VersionCompatibility","System::Reflection::AssemblyName::VersionCompatibility"],"dev_langs":["csharp"],"updated_at":"2017-03-01 01:37 AM","document_id":"f99a0600-d542-c6d3-6cb7-d34c001ed4eb","content_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/xml/System.Reflection/AssemblyName.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"AssemblyName class | Microsoft Docs","_op_ogTitle":"AssemblyName class","description":"Describes an assembly&#39;s unique identity in full.\n","toc_asset_id":"_splitted/System.Reflection/toc.json","toc_rel":"_splitted/System.Reflection/toc.json","source_url":"","ms.assetid":"System.Reflection.AssemblyName","canonical_url":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.reflection.assemblyname","_op_canonicalUrl":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.reflection.assemblyname","fileRelativePath":"System.Reflection.AssemblyName.html"},"themesRelativePathToOutputRoot":"_themes/"}