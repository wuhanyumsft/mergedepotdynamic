{"content":"    \r\n    <h1 id=\"System_IDisposable\">\r\n      <span class=\"lang-csharp\">IDisposable</span>\r\n        Interface\r\n    </h1>\r\n    \r\n    \r\n    <nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n      <h3>In this Article</h3>\r\n    </nav><div class=\"summary\">\r\n    \t<p>Provides a mechanism for releasing unmanaged resources.  </p>\n<p> To browse the .NET Framework source code for this type, see the <a href=\"http://referencesource.microsoft.com/#mscorlib/system/idisposable.cs#1f55292c3174123d\" data-linktype=\"external\">Reference Source</a>.</p>\n\r\n    </div><h2>Syntax</h2>\r\n    \r\n    \t<h3>Declaration</h3>\r\n    \t<pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ComVisible(true)]\npublic interface IDisposable</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n      <h2>Remarks</h2>\r\n      <div class=\"NOTE\"><h5>Note</h5><p> To view the .NET Framework source code for this type, see the <a href=\"http://referencesource.microsoft.com/#mscorlib/system/idisposable.cs#1f55292c3174123d\" data-linktype=\"external\">Reference Source</a>. You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <a href=\"http://referencesource.microsoft.com/\" data-linktype=\"external\">instructions</a>.  </p>\n</div>\n<p> The primary use of this interface is to release unmanaged resources. The garbage collector automatically releases the memory allocated to a managed object when that object is no longer used. However, it is not possible to predict when garbage collection will occur. Furthermore, the garbage collector has no knowledge of unmanaged resources such as window handles, or open files and streams.  </p>\n<p> Use the <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose_\" data-linktype=\"relative-path\">Dispose</a> method of this interface to explicitly release unmanaged resources in conjunction with the garbage collector. The consumer of an object can call this method when the object is no longer needed.  </p>\n<div class=\"WARNING\"><h5>Warning</h5><p> It is a breaking change to add the IDisposable interface to an existing class. Because pre-existing consumers of your type cannot call <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose_\" data-linktype=\"relative-path\">Dispose</a>, you cannot be certain that unmanaged resources held by your type will be released.  </p>\n</div>\n<p> Because the <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose_\" data-linktype=\"relative-path\">Dispose</a> implementation is called by the consumer of a type when the resources owned by an instance are no longer needed, you should either wrap the managed object in a <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> (the recommended alternative), or you should override <a class=\"xref\" href=\"system.object#System_Object_Finalize_\" data-linktype=\"relative-path\">Finalize</a> to free unmanaged resources in the event that the consumer forgets to call <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose_\" data-linktype=\"relative-path\">Dispose</a>.  </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> In the .NET Framework, the C++ compiler supports deterministic disposal of resources and does not allow direct implementation of the <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose_\" data-linktype=\"relative-path\">Dispose</a> method.  </p>\n</div>\n<p> For a detailed discussion about how this interface and the <a class=\"xref\" href=\"system.object#System_Object_Finalize_\" data-linktype=\"relative-path\">Finalize</a> method are used, see the <a href=\"../Topic/Garbage%20Collection.md\" data-linktype=\"relative-path\">Garbage Collection</a> and <a href=\"../Topic/Implementing%20a%20Dispose%20Method.md\" data-linktype=\"relative-path\">Implementing a Dispose Method</a> topics.  </p>\n<h2 id=\"using-an-object-that-implements-idisposable\">Using an object that implements IDisposable</h2>\n<p> Implement IDisposable only if you are using unmanaged resources directly. If your app simply uses an object that implements IDisposable, don&#39;t provide an IDisposable implementation. Instead, you should call the object&#39;s <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose_\" data-linktype=\"relative-path\">Dispose</a> implementation when you are finished using it. Depending on your programming language, you can do this in one of two ways:  </p>\n<ul>\n<li><p>By using a language construct such as the <code>using</code> statement in C# and Visual Basic.  </p>\n</li>\n<li><p>By wrapping the call to the <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose_\" data-linktype=\"relative-path\">Dispose</a> implementation in a <code>try</code>/<code>catch</code> block.  </p>\n</li>\n</ul>\n<div class=\"NOTE\"><h5>Note</h5><p> Documentation for types that implement IDisposable note that fact and include a reminder to call its <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose_\" data-linktype=\"relative-path\">Dispose</a> implementation.  </p>\n</div>\n<p><a name=\"Using\"></a>   </p>\n<h3 id=\"the-c-and-visual-basic-using-statement\">The C# and Visual Basic Using statement</h3>\n<p> If your language supports a construct such as the <a href=\"../Topic/using%20(C%23%20Reference).md\" data-linktype=\"relative-path\">using</a> statement in C# and the <a href=\"../Topic/Using%20Statement%20(Visual%20Basic).md\" data-linktype=\"relative-path\">Using</a> statement in Visual Basic, you can use it instead of explicitly calling <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose_\" data-linktype=\"relative-path\">Dispose</a> yourself. The following example uses this approach in defining a <code>WordCount</code> class that preserves information about a file and the number of words in it.  </p>\n<pre><code class=\"lang-cs\" name=\"System.IDisposable#1\">using System;\nusing System.IO;\nusing System.Text.RegularExpressions;\n\npublic class WordCount\n{\n   private String filename = String.Empty;\n   private int nWords = 0;\n   private String pattern = @&quot;\\b\\w+\\b&quot;; \n\n   public WordCount(string filename)\n   {\n      if (! File.Exists(filename))\n         throw new FileNotFoundException(&quot;The file does not exist.&quot;);\n      \n      this.filename = filename;\n      string txt = String.Empty;\n      using (StreamReader sr = new StreamReader(filename)) {\n         txt = sr.ReadToEnd();\n      }\n      nWords = Regex.Matches(txt, pattern).Count;\n   }\n   \n   public string FullName\n   { get { return filename; } }\n   \n   public string Name\n   { get { return Path.GetFileName(filename); } }\n   \n   public int Count \n   { get { return nWords; } }\n}   \n</code></pre><pre><code class=\"lang-vb\" name=\"System.IDisposable#1\">Imports System.IO\nImports System.Text.RegularExpressions\n\nPublic Class WordCount\n   Private filename As String\n   Private nWords As Integer\n   Private pattern As String = &quot;\\b\\w+\\b&quot; \n\n   Public Sub New(filename As String)\n      If Not File.Exists(filename) Then\n         Throw New FileNotFoundException(&quot;The file does not exist.&quot;)\n      End If   \n      \n      Me.filename = filename\n      Dim txt As String = String.Empty\n      Using sr As New StreamReader(filename)\n         txt = sr.ReadToEnd()\n      End Using\n      nWords = Regex.Matches(txt, pattern).Count\n   End Sub\n   \n   Public ReadOnly Property FullName As String\n      Get\n         Return filename\n      End Get   \n   End Property\n   \n   Public ReadOnly Property Name As String\n      Get\n         Return Path.GetFileName(filename)\n      End Get   \n   End Property\n   \n   Public ReadOnly Property Count As Integer\n      Get\n         Return nWords\n      End Get\n   End Property\nEnd Class\n</code></pre><p> The <code>using</code> statement is actually a syntactic convenience. At compile time, the language compiler implements the intermediate language (IL) for a <code>try</code>/<code>catch</code> block.  </p>\n<p> For more information about the <code>using</code> statement, see the <a href=\"../Topic/Using%20Statement%20(Visual%20Basic).md\" data-linktype=\"relative-path\">Using Statement</a> or <a href=\"../Topic/using%20Statement%20(C%23%20Reference).md\" data-linktype=\"relative-path\">using Statement</a> topics.  </p>\n<h3 id=\"the-trycatch-block\">The Try/Catch block</h3>\n<p> If your programming language does not support a construct like the <code>using</code> statement in C# or Visual Basic, or if you prefer not to use it, you can call the <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose_\" data-linktype=\"relative-path\">Dispose</a> implementation from the <code>finally</code> block of a <code>try</code>/<code>catch</code> statement. The following example replaces the <code>using</code> block in the previous example with a <code>try</code>/<code>catch</code>/<code>finally</code> block.  </p>\n<pre><code class=\"lang-vb\" name=\"System.IDisposable#2\">Imports System.IO\nImports System.Text.RegularExpressions\n\nPublic Class WordCount\n   Private filename As String\n   Private nWords As Integer\n   Private pattern As String = &quot;\\b\\w+\\b&quot; \n\n   Public Sub New(filename As String)\n      If Not File.Exists(filename) Then\n         Throw New FileNotFoundException(&quot;The file does not exist.&quot;)\n      End If   \n      \n      Me.filename = filename\n      Dim txt As String = String.Empty\n      Dim sr As StreamReader = Nothing\n      Try\n         sr = New StreamReader(filename)\n         txt = sr.ReadToEnd()\n      Finally\n         If sr IsNot Nothing Then sr.Dispose() \n      End Try\n      nWords = Regex.Matches(txt, pattern).Count\n   End Sub\n   \n   Public ReadOnly Property FullName As String\n      Get\n         Return filename\n      End Get   \n   End Property\n   \n   Public ReadOnly Property Name As String\n      Get\n         Return Path.GetFileName(filename)\n      End Get   \n   End Property\n   \n   Public ReadOnly Property Count As Integer\n      Get\n         Return nWords\n      End Get\n   End Property\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"System.IDisposable#2\">using System;\nusing System.IO;\nusing System.Text.RegularExpressions;\n\npublic class WordCount\n{\n   private String filename = String.Empty;\n   private int nWords = 0;\n   private String pattern = @&quot;\\b\\w+\\b&quot;; \n\n   public WordCount(string filename)\n   {\n      if (! File.Exists(filename))\n         throw new FileNotFoundException(&quot;The file does not exist.&quot;);\n      \n      this.filename = filename;\n      string txt = String.Empty;\n      StreamReader sr = null;\n      try {\n         sr = new StreamReader(filename);\n         txt = sr.ReadToEnd();\n      }\n      finally {\n         if (sr != null) sr.Dispose();     \n      }\n      nWords = Regex.Matches(txt, pattern).Count;\n   }\n   \n   public string FullName\n   { get { return filename; } }\n   \n   public string Name\n   { get { return Path.GetFileName(filename); } }\n   \n   public int Count \n   { get { return nWords; } }\n}   \n</code></pre><p> For more information about the <code>try</code>/<code>finally</code> pattern, see <a href=\"../Topic/Try...Catch...Finally%20Statement%20(Visual%20Basic).md\" data-linktype=\"relative-path\">Try...Catch...Finally Statement</a>, <a href=\"../Topic/try-finally%20(C%23%20Reference).md\" data-linktype=\"relative-path\">try-finally</a>, or <a href=\"../Topic/try-finally%20Statement%20(C).md\" data-linktype=\"relative-path\">try-finally Statement</a>.  </p>\n<h2 id=\"implementing-idisposable\">Implementing IDisposable</h2>\n<p> You should implement IDisposable only if your type uses unmanaged resources directly. The consumers of your type can call your <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose_\" data-linktype=\"relative-path\">Dispose</a> implementation to free resources when the instance is no longer needed. To handle cases in which they fail to call <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose_\" data-linktype=\"relative-path\">Dispose</a>, you should either use a class derived from <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> to wrap the unmanaged resources, or you should override the <a class=\"xref\" href=\"system.object#System_Object_Finalize_\" data-linktype=\"relative-path\">Finalize</a> method for a reference type. In either case, you use the <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose_\" data-linktype=\"relative-path\">Dispose</a> method to perform whatever cleanup is necessary after using the unmanaged resources, such as freeing, releasing, or resetting the unmanaged resources.  </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> If you are defining a base class that uses unmanaged resources and that either has, or is likely to have, subclasses that should be disposed, you should implement the <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose_\" data-linktype=\"relative-path\">Dispose</a> method and provide a second overload of <code>Dispose</code>, as discussed in the next section.  </p>\n</div>\n<p><a name=\"BaseClasses\"></a>   </p>\n<h2 id=\"idisposable-and-the-inheritance-hierarchy\">IDisposable and the inheritance hierarchy</h2>\n<p> A base class with subclasses that should be disposable must implement IDisposable as follows. You should use this pattern whenever you implement IDisposable on any type that isn&#39;t <code>sealed</code> (<code>NotInheritable</code> in Visual Basic).  </p>\n<ul>\n<li><p>It should provide one public, non-virtual <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose\" data-linktype=\"relative-path\">Dispose()</a> method and a protected virtual <code>Dispose(Boolean</code> <code>disposing``)</code> method.  </p>\n</li>\n<li><p>The <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose\" data-linktype=\"relative-path\">Dispose()</a> method must call <code>Dispose(true)</code> and should suppress finalization for performance.  </p>\n</li>\n<li><p>The base type should not include any finalizers.  </p>\n<p>The following code fragment reflects the dispose pattern for base classes. It assumes that your type does not override the <a class=\"xref\" href=\"system.object#System_Object_Finalize_\" data-linktype=\"relative-path\">Finalize</a> method.  </p>\n<pre><code class=\"lang-cs\" name=\"System.IDisposable#3\">using Microsoft.Win32.SafeHandles;\nusing System;\nusing System.Runtime.InteropServices;\n\nclass BaseClass : IDisposable\n{\n   // Flag: Has Dispose already been called?\n   bool disposed = false;\n   // Instantiate a SafeHandle instance.\n   SafeHandle handle = new SafeFileHandle(IntPtr.Zero, true);\n   \n   // Public implementation of Dispose pattern callable by consumers.\n   public void Dispose()\n   { \n      Dispose(true);\n      GC.SuppressFinalize(this);           \n   }\n   \n   // Protected implementation of Dispose pattern.\n   protected virtual void Dispose(bool disposing)\n   {\n      if (disposed)\n         return; \n      \n      if (disposing) {\n         handle.Dispose();\n         // Free any other managed objects here.\n         //\n      }\n      \n      // Free any unmanaged objects here.\n      //\n      disposed = true;\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.IDisposable#3\">Imports Microsoft.Win32.SafeHandles\nImports System.Runtime.InteropServices\n\nClass BaseClass : Implements IDisposable\n   &#39; Flag: Has Dispose already been called?\n   Dim disposed As Boolean = False\n   &#39; Instantiate a SafeHandle instance.\n   Dim handle As SafeHandle = New SafeFileHandle(IntPtr.Zero, True)\n\n   &#39; Public implementation of Dispose pattern callable by consumers.\n   Public Sub Dispose() _\n              Implements IDisposable.Dispose\n      Dispose(True)\n      GC.SuppressFinalize(Me)           \n   End Sub\n   \n   &#39; Protected implementation of Dispose pattern.\n   Protected Overridable Sub Dispose(disposing As Boolean)\n      If disposed Then Return\n      \n      If disposing Then\n         handle.Dispose()\n         &#39; Free any other managed objects here.\n         &#39;\n      End If\n      \n      &#39; Free any unmanaged objects here.\n      &#39;\n      disposed = True\n   End Sub\nEnd Class\n</code></pre><p>If you do override the <a class=\"xref\" href=\"system.object#System_Object_Finalize_\" data-linktype=\"relative-path\">Finalize</a> method, your class should implement the following pattern.  </p>\n<pre><code class=\"lang-cs\" name=\"System.IDisposable#5\">using System;\n\nclass BaseClass : IDisposable\n{\n   // Flag: Has Dispose already been called?\n   bool disposed = false;\n   \n   // Public implementation of Dispose pattern callable by consumers.\n   public void Dispose()\n   { \n      Dispose(true);\n      GC.SuppressFinalize(this);           \n   }\n   \n   // Protected implementation of Dispose pattern.\n   protected virtual void Dispose(bool disposing)\n   {\n      if (disposed)\n         return; \n      \n      if (disposing) {\n         // Free any other managed objects here.\n         //\n      }\n      \n      // Free any unmanaged objects here.\n      //\n      disposed = true;\n   }\n\n   ~BaseClass()\n   {\n      Dispose(false);\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.IDisposable#5\">Class BaseClass : Implements IDisposable\n   &#39; Flag: Has Dispose already been called?\n   Dim disposed As Boolean = False\n   \n   &#39; Public implementation of Dispose pattern callable by consumers.\n   Public Sub Dispose() _\n              Implements IDisposable.Dispose\n      Dispose(True)\n      GC.SuppressFinalize(Me)           \n   End Sub\n   \n   &#39; Protected implementation of Dispose pattern.\n   Protected Overridable Sub Dispose(disposing As Boolean)\n      If disposed Then Return\n      \n      If disposing Then\n         &#39; Free any other managed objects here.\n         &#39;\n      End If\n      \n      &#39; Free any unmanaged objects here.\n      &#39;\n      disposed = True\n   End Sub\n\n   Protected Overrides Sub Finalize()\n      Dispose(False)      \n   End Sub\nEnd Class\n</code></pre><p>Subclasses should implement the disposable pattern as follows:  </p>\n</li>\n<li><p>They must override <code>Dispose(Boolean)</code> and call the base class <code>Dispose(Boolean)</code> implementation.  </p>\n</li>\n<li><p>They can provide a finalizer if needed. The finalizer must call <code>Dispose(false)</code>.  </p>\n<p>Note that derived classes do not themselves implement the IDisposable interface and do not include a parameterless <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose_\" data-linktype=\"relative-path\">Dispose</a> method. They only override the base class <code>Dispose(Boolean)</code> method.  </p>\n<p>The following code fragment reflects the dispose pattern for derived classes. It assumes that your type does not override the <a class=\"xref\" href=\"system.object#System_Object_Finalize_\" data-linktype=\"relative-path\">Finalize</a> method.  </p>\n<pre><code class=\"lang-vb\" name=\"System.IDisposable#4\">Imports Microsoft.Win32.SafeHandles\nImports System.Runtime.InteropServices\n\nClass DerivedClass : Inherits BaseClass \n   &#39; Flag: Has Dispose already been called?\n   Dim disposed As Boolean = False\n   &#39; Instantiate a SafeHandle instance.\n   Dim handle As SafeHandle = New SafeFileHandle(IntPtr.Zero, True)\n\n   &#39; Protected implementation of Dispose pattern.\n   Protected Overrides Sub Dispose(disposing As Boolean)\n      If disposed Then Return\n      \n      If disposing Then\n         handle.Dispose()\n         &#39; Free any other managed objects here.\n         &#39;\n      End If\n      \n      &#39; Free any unmanaged objects here.\n      &#39;\n      disposed = True\n      \n      &#39; Call base class implementation.\n      MyBase.Dispose(disposing)\n   End Sub\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"System.IDisposable#4\">using Microsoft.Win32.SafeHandles;\nusing System;\nusing System.Runtime.InteropServices;\n\nclass DerivedClass : BaseClass\n{\n   // Flag: Has Dispose already been called?\n   bool disposed = false;\n   // Instantiate a SafeHandle instance.\n   SafeHandle handle = new SafeFileHandle(IntPtr.Zero, true);\n\n   // Protected implementation of Dispose pattern.\n   protected override void Dispose(bool disposing)\n   {\n      if (disposed)\n         return; \n      \n      if (disposing) {\n         handle.Dispose();\n         // Free any other managed objects here.\n         //\n      }\n      \n      // Free any unmanaged objects here.\n      //\n\n      disposed = true;\n      // Call base class implementation.\n      base.Dispose(disposing);\n   }\n}\n</code></pre></li>\n</ul>\n\r\n    \r\n    \r\n    <h2>Methods\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_IDisposable_Dispose\" data-linktype=\"self-bookmark\">Dispose()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"methods\">\r\n        <h2>Methods\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_IDisposable_Dispose\">\r\n    \r\n            <a id=\"System_IDisposable_Dispose_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Dispose()</div>        \r\n          </div>\r\n    \r\n            <p>Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void Dispose ();</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Use this method to close or release unmanaged resources such as files, streams, and handles held by an instance of the class that implements this interface. By convention, this method is used for all tasks associated with freeing resources held by an object, or preparing an object for reuse.  </p>\n<div class=\"WARNING\"><h5>Warning</h5><p> If you are using a class that implements the <a class=\"xref\" href=\"system.idisposable\" data-linktype=\"relative-path\">IDisposable</a> interface, you should call its Dispose implementation when you are finished using the class. For more information, see the &quot;Using an object that implements IDisposable&quot; section in the <a class=\"xref\" href=\"system.idisposable\" data-linktype=\"relative-path\">IDisposable</a> topic.  </p>\n</div>\n<p> When implementing this method, ensure that all held resources are freed by propagating the call through the containment hierarchy. For example, if an object A allocates an object B, and object B allocates an object C, then A&#39;s Dispose implementation must call Dispose on B, which must in turn call Dispose on C.  </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> The C++ compiler supports deterministic disposal of resources and does not allow direct implementation of the Dispose method.  </p>\n</div>\n<p> An object must also call the Dispose method of its base class if the base class implements <a class=\"xref\" href=\"system.idisposable\" data-linktype=\"relative-path\">IDisposable</a>. For more information about implementing <a class=\"xref\" href=\"system.idisposable\" data-linktype=\"relative-path\">IDisposable</a> on a base class and its subclasses, see the &quot;IDisposable and the inheritance hierarchy&quot; section in the <a class=\"xref\" href=\"system.idisposable\" data-linktype=\"relative-path\">IDisposable</a> topic.  </p>\n<p> If an object&#39;s Dispose method is called more than once, the object must ignore all calls after the first one. The object must not throw an exception if its Dispose method is called multiple times. Instance methods other than Dispose can throw an <a class=\"xref\" href=\"system.objectdisposedexception\" data-linktype=\"relative-path\">ObjectDisposedException</a> when resources are already disposed.  </p>\n<p> Users might expect a resource type to use a particular convention to denote an allocated state versus a freed state. An example of this is stream classes, which are traditionally thought of as open or closed. The implementer of a class that has such a convention might choose to implement a public method with a customized name, such as <code>Close</code>, that calls the Dispose method.  </p>\n<p> Because the Dispose method must be called explicitly, there is always a danger that the unmanaged resources will not be released, because the consumer of an object fails to call its Dispose method. There are two ways to avoid this:  </p>\n<ul>\n<li><p>Wrap the managed resource in an object derived from <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">System.Runtime.InteropServices.SafeHandle</a>. Your Dispose implementation then calls the Dispose method of the <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">System.Runtime.InteropServices.SafeHandle</a> instances. For more information, see &quot;The SafeHandle alternative&quot; section in the <a class=\"xref\" href=\"system.object#System_Object_Finalize_\" data-linktype=\"relative-path\">Finalize</a> topic.  </p>\n</li>\n<li><p>Implement a finalizer to free resources when Dispose is not called. By default, the garbage collector automatically calls an object&#39;s finalizer before reclaiming its memory. However, if the Dispose method has been called, it is typically unnecessary for the garbage collector to call the disposed object&#39;s finalizer. To prevent automatic finalization, Dispose implementations can call the <a class=\"xref\" href=\"system.gc#System_GC_SuppressFinalize_\" data-linktype=\"relative-path\">SuppressFinalize</a> method.  </p>\n<p>When you use an object that accesses unmanaged resources, such as a <a class=\"xref\" href=\"system.io.streamwriter\" data-linktype=\"relative-path\">StreamWriter</a>, a good practice is to create the instance with a <code>using</code> statement. The <code>using</code> statement automatically closes the stream and calls Dispose on the object when the code that is using it has completed. For an example, see the <a class=\"xref\" href=\"system.io.streamwriter\" data-linktype=\"relative-path\">StreamWriter</a> class.</p>\n</li>\n</ul>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example shows how you can implement the Dispose method.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.IDisposable.Dispose Example#1\">#using &lt;System.dll&gt;\n#using &lt;System.Windows.Forms.dll&gt;\n\nusing namespace System;\nusing namespace System::ComponentModel;\nusing namespace System::Windows::Forms;\n\n// The following example demonstrates how to create a class that \n// implements the IDisposable interface and the IDisposable.Dispose\n// method with finalization to clean up unmanaged resources. \n//\npublic ref class MyResource: public IDisposable\n{\nprivate:\n\n   // Pointer to an external unmanaged resource.\n   IntPtr handle;\n\n   // A managed resource this class uses.\n   Component^ component;\n\n   // Track whether Dispose has been called.\n   bool disposed;\n\npublic:\n   // The class constructor.\n   MyResource( IntPtr handle, Component^ component )\n   {\n      this-&gt;handle = handle;\n      this-&gt;component = component;\n      disposed = false;\n   }\n\n   // This method is called if the user explicitly disposes of the\n   // object (by calling the Dispose method in other managed languages, \n   // or the destructor in C++). The compiler emits as a call to \n   // GC::SuppressFinalize( this ) for you, so there is no need to \n   // call it here.\n   ~MyResource() \n   {\n      // Dispose of managed resources.\n      component-&gt;~Component();\n\n      // Call C++ finalizer to clean up unmanaged resources.\n      this-&gt;!MyResource();\n\n      // Mark the class as disposed. This flag allows you to throw an\n      // exception if a disposed object is accessed.\n      disposed = true;\n   }\n\n   // Use interop to call the method necessary to clean up the \n   // unmanaged resource.\n   //\n   [System::Runtime::InteropServices::DllImport(&quot;Kernel32&quot;)]\n   static Boolean CloseHandle( IntPtr handle );\n\n   // The C++ finalizer destructor ensures that unmanaged resources get\n   // released if the user releases the object without explicitly \n   // disposing of it.\n   //\n   !MyResource()\n   {      \n      // Call the appropriate methods to clean up unmanaged \n      // resources here. If disposing is false when Dispose(bool,\n      // disposing) is called, only the following code is executed.\n      CloseHandle( handle );\n      handle = IntPtr::Zero;\n   }\n\n};\n\nvoid main()\n{\n   // Insert code here to create and use the MyResource object.\n   MyResource^ mr = gcnew MyResource((IntPtr) 42, (Component^) gcnew Button());\n   mr-&gt;~MyResource();\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"System.IDisposable.Dispose Example#1\">using System;\nusing System.ComponentModel;\n\n// The following example demonstrates how to create\n// a resource class that implements the IDisposable interface\n// and the IDisposable.Dispose method.\n\npublic class DisposeExample\n{\n    // A base class that implements IDisposable.\n    // By implementing IDisposable, you are announcing that\n    // instances of this type allocate scarce resources.\n    public class MyResource: IDisposable\n    {\n        // Pointer to an external unmanaged resource.\n        private IntPtr handle;\n        // Other managed resource this class uses.\n        private Component component = new Component();\n        // Track whether Dispose has been called.\n        private bool disposed = false;\n\n        // The class constructor.\n        public MyResource(IntPtr handle)\n        {\n            this.handle = handle;\n        }\n\n        // Implement IDisposable.\n        // Do not make this method virtual.\n        // A derived class should not be able to override this method.\n        public void Dispose()\n        {\n            Dispose(true);\n            // This object will be cleaned up by the Dispose method.\n            // Therefore, you should call GC.SupressFinalize to\n            // take this object off the finalization queue\n            // and prevent finalization code for this object\n            // from executing a second time.\n            GC.SuppressFinalize(this);\n        }\n\n        // Dispose(bool disposing) executes in two distinct scenarios.\n        // If disposing equals true, the method has been called directly\n        // or indirectly by a user&#39;s code. Managed and unmanaged resources\n        // can be disposed.\n        // If disposing equals false, the method has been called by the\n        // runtime from inside the finalizer and you should not reference\n        // other objects. Only unmanaged resources can be disposed.\n        protected virtual void Dispose(bool disposing)\n        {\n            // Check to see if Dispose has already been called.\n            if(!this.disposed)\n            {\n                // If disposing equals true, dispose all managed\n                // and unmanaged resources.\n                if(disposing)\n                {\n                    // Dispose managed resources.\n                    component.Dispose();\n                }\n\n                // Call the appropriate methods to clean up\n                // unmanaged resources here.\n                // If disposing is false,\n                // only the following code is executed.\n                CloseHandle(handle);\n                handle = IntPtr.Zero;\n\n                // Note disposing has been done.\n                disposed = true;\n\n            }\n        }\n\n        // Use interop to call the method necessary\n        // to clean up the unmanaged resource.\n        [System.Runtime.InteropServices.DllImport(&quot;Kernel32&quot;)]\n        private extern static Boolean CloseHandle(IntPtr handle);\n\n        // Use C# destructor syntax for finalization code.\n        // This destructor will run only if the Dispose method\n        // does not get called.\n        // It gives your base class the opportunity to finalize.\n        // Do not provide destructors in types derived from this class.\n        ~MyResource()\n        {\n            // Do not re-create Dispose clean-up code here.\n            // Calling Dispose(false) is optimal in terms of\n            // readability and maintainability.\n            Dispose(false);\n        }\n    }\n    public static void Main()\n    {\n        // Insert code here to create\n        // and use the MyResource object.\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.IDisposable.Dispose Example#1\">Imports System\nImports System.ComponentModel\n\n&#39; The following example demonstrates how to create\n&#39; a resource class that implements the IDisposable interface\n&#39; and the IDisposable.Dispose method.\nPublic Class DisposeExample\n\n   &#39; A class that implements IDisposable.\n   &#39; By implementing IDisposable, you are announcing that \n   &#39; instances of this type allocate scarce resources.\n   Public Class MyResource\n      Implements IDisposable\n      &#39; Pointer to an external unmanaged resource.\n      Private handle As IntPtr\n      &#39; Other managed resource this class uses.\n      Private component As component\n      &#39; Track whether Dispose has been called.\n      Private disposed As Boolean = False\n\n      &#39; The class constructor.\n      Public Sub New(ByVal handle As IntPtr)\n         Me.handle = handle\n      End Sub\n\n      &#39; Implement IDisposable.\n      &#39; Do not make this method virtual.\n      &#39; A derived class should not be able to override this method.\n      Public Overloads Sub Dispose() Implements IDisposable.Dispose\n         Dispose(True)\n         &#39; This object will be cleaned up by the Dispose method.\n         &#39; Therefore, you should call GC.SupressFinalize to\n         &#39; take this object off the finalization queue \n         &#39; and prevent finalization code for this object\n         &#39; from executing a second time.\n         GC.SuppressFinalize(Me)\n      End Sub\n\n      &#39; Dispose(bool disposing) executes in two distinct scenarios.\n      &#39; If disposing equals true, the method has been called directly\n      &#39; or indirectly by a user&#39;s code. Managed and unmanaged resources\n      &#39; can be disposed.\n      &#39; If disposing equals false, the method has been called by the \n      &#39; runtime from inside the finalizer and you should not reference \n      &#39; other objects. Only unmanaged resources can be disposed.\n      Protected Overridable Overloads Sub Dispose(ByVal disposing As Boolean)\n         &#39; Check to see if Dispose has already been called.\n         If Not Me.disposed Then\n            &#39; If disposing equals true, dispose all managed \n            &#39; and unmanaged resources.\n            If disposing Then\n               &#39; Dispose managed resources.\n               component.Dispose()\n            End If\n\n            &#39; Call the appropriate methods to clean up \n            &#39; unmanaged resources here.\n            &#39; If disposing is false, \n            &#39; only the following code is executed.\n            CloseHandle(handle)\n            handle = IntPtr.Zero\n\n            &#39; Note disposing has been done.\n            disposed = True\n\n         End If\n      End Sub\n\n      &#39; Use interop to call the method necessary  \n      &#39; to clean up the unmanaged resource.\n      &lt;System.Runtime.InteropServices.DllImport(&quot;Kernel32&quot;)&gt; _\n      Private Shared Function CloseHandle(ByVal handle As IntPtr) As [Boolean]\n      End Function\n\n      &#39; This finalizer will run only if the Dispose method \n      &#39; does not get called.\n      &#39; It gives your base class the opportunity to finalize.\n      &#39; Do not provide finalize methods in types derived from this class.\n      Protected Overrides Sub Finalize()\n         &#39; Do not re-create Dispose clean-up code here.\n         &#39; Calling Dispose(false) is optimal in terms of\n         &#39; readability and maintainability.\n         Dispose(False)\n         MyBase.Finalize()\n      End Sub\n   End Class\n\n   Public Shared Sub Main()\n      &#39; Insert code here to create\n      &#39; and use the MyResource object.\n   End Sub\n\nEnd Class\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n","outputRootRelativePath":"./","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"breadcrumb_path\" content=\"breadcrumb/toc.json\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"fulldocset\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.fulldocset\">\r\n<meta name=\"ref_skeleton_gitcommit\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.IDisposable.yml\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.IDisposable.yml\">\r\n<meta name=\"APIName\" content=\"System.IDisposable\">\r\n<meta name=\"APIName\" content=\"System.IDisposable.Dispose\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-01 01:37 AM\">\r\n<meta name=\"document_id\" content=\"661e617c-753e-be11-f6ec-c299c46ce73f\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Provides a mechanism for releasing unmanaged resources.  \n To browse the .NET Framework source code for this type, see the Reference Source.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/System/toc.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.IDisposable\">\r\n","rawMetadata":{"author":"dotnet-bot","breadcrumb_path":"breadcrumb/toc.json","search.ms_sitename":"Docs","search.ms_docsetname":"fulldocset","version":null,"_op_canonicalUrlPrefix":"https://ppe.docs.microsoft.com/en-us/fulldotnet/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":true,"depot_name":"MSDN.fulldocset","_op_gitRefSkeletonCommitHistory":[{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"use plugin in master","commit_sha":"501959ac03e19ac52a27aa4c6bbeb980f8b11c8c","commit_date":"2017-03-01 09:31:20 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"switch from platform to version","commit_sha":"78cdacb5ca782478af490a6b30c3a2cb2b6b873e","commit_date":"2017-02-28 15:09:51 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"update platforms","commit_sha":"39ad5a8919a59afc93a79ac4bd8e07c3b471b37a","commit_date":"2017-02-28 10:38:59 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"checkin yml","commit_sha":"da161b792852497df7140d7768cee2eccd9cb43f","commit_date":"2017-02-28 09:36:15 +0800"}],"ref_skeleton_gitcommit":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.IDisposable.yml","original_ref_skeleton_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.IDisposable.yml","open_to_public_contributors":true,"api_name":["System.IDisposable","System.IDisposable.Dispose"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.IDisposable","System::IDisposable","System.IDisposable.Dispose","System::IDisposable::Dispose"],"dev_langs":["csharp"],"updated_at":"2017-03-01 01:37 AM","document_id":"661e617c-753e-be11-f6ec-c299c46ce73f","content_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/xml/System/IDisposable.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"IDisposable interface | Microsoft Docs","_op_ogTitle":"IDisposable interface","description":"Provides a mechanism for releasing unmanaged resources.  \n To browse the .NET Framework source code for this type, see the Reference Source.\n","toc_asset_id":"_splitted/System/toc.json","toc_rel":"_splitted/System/toc.json","source_url":"","ms.assetid":"System.IDisposable","canonical_url":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.idisposable","_op_canonicalUrl":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.idisposable","fileRelativePath":"System.IDisposable.html"},"themesRelativePathToOutputRoot":"_themes/"}