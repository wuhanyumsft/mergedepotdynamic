{"content":"\r\n<div style=\"display:none\">\r\n\t\r\n</div>\r\n\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">Random</span>\r\n    \t\t\t\tClass\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Represents a pseudo-random number generator, which is a device that produces a sequence of numbers that meet certain statistical requirements for randomness.  </p>\n<p> To browse the .NET Framework source code for this type, see the <a href=\"http://referencesource.microsoft.com/#mscorlib/system/random.cs#bb77e610694e64ca\" data-linktype=\"external\">Reference Source</a>.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ComVisible(true)]\npublic class Random</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a></span></div>\r\n  \t\t\t<span class=\"lang-csharp\">Random</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \r\n  \r\n  \t<h3 class=\"accented\">Inherited Members</h3>\r\n  \t<h4 class=\"accented\"></h4>\r\n  \t<div class=\"cdlHolder\">\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object,Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object,Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a></span></div>\r\n  \t</div>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<div class=\"NOTE\"><h5>Note</h5><p> To view the .NET Framework source code for this type, see the <a href=\"http://referencesource.microsoft.com/#mscorlib/system/random.cs#bb77e610694e64ca\" data-linktype=\"external\">Reference Source</a>. You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <a href=\"http://referencesource.microsoft.com/\" data-linktype=\"external\">instructions</a>.  </p>\n</div>\n<p> Pseudo-random numbers are chosen with equal probability from a finite set of numbers. The chosen numbers are not completely random because a mathematical algorithm is used to select them, but they are sufficiently random for practical purposes. The current implementation of the Random class is based on a modified version of Donald E. Knuth&#39;s subtractive random number generator algorithm. For more information, see D. E. Knuth. <em>The Art of Computer Programming, Volume 2: Seminumerical Algorithms</em>. Addison-Wesley, Reading, MA, third edition, 1997.  </p>\n<p> To generate a cryptographically secure random number, such as one that&#39;s suitable for creating a random password, use the <a class=\"xref\" href=\"system.security.cryptography.rngcryptoserviceprovider\" data-linktype=\"relative-path\">RNGCryptoServiceProvider</a> class or derive a class from <a class=\"xref\" href=\"system.security.cryptography.randomnumbergenerator\" data-linktype=\"relative-path\">System.Security.Cryptography.RandomNumberGenerator</a>.  </p>\n<p> In this topic:  </p>\n<p> <a href=\"#Instantiate\" data-linktype=\"self-bookmark\">Instantiating the random number generator</a><br> <a href=\"#Multiple\" data-linktype=\"self-bookmark\">Avoiding multiple instantiations</a><br> <a href=\"#ThreadSafety\" data-linktype=\"self-bookmark\">The System.Random class and thread safety</a><br> <a href=\"#Functionality\" data-linktype=\"self-bookmark\">Generating different types of random numbers</a><br> <a href=\"#Overriding\" data-linktype=\"self-bookmark\">Substituting your own algorithm</a><br> <a href=\"#Operations\" data-linktype=\"self-bookmark\">How do you use System.Random toâ€¦</a><br> <a href=\"#Same\" data-linktype=\"self-bookmark\">Retrieve the same sequence of random values</a><br> <a href=\"#Unique\" data-linktype=\"self-bookmark\">Retrieve unique sequences of random values</a><br> <a href=\"#Range\" data-linktype=\"self-bookmark\">Retrieve integers in a specified range</a><br> <a href=\"#Digits\" data-linktype=\"self-bookmark\">Retrieve integers with a specified number of digits</a><br> <a href=\"#Floats\" data-linktype=\"self-bookmark\">Retrieve floating-point values in a specified range</a><br> <a href=\"#Boolean\" data-linktype=\"self-bookmark\">Generate random Boolean values</a><br> <a href=\"#Long\" data-linktype=\"self-bookmark\">Generate random 64-bit integers</a><br> <a href=\"#Bytes\" data-linktype=\"self-bookmark\">Retrieve bytes in a specified range</a><br> <a href=\"#Array\" data-linktype=\"self-bookmark\">Retrieve an element from an array or collection at random</a><br> <a href=\"#UniqueArray\" data-linktype=\"self-bookmark\">Retrieve a unique element from an array or collection</a>  </p>\n<p><a name=\"Instantiate\"></a>   </p>\n<h2 id=\"instantiating-the-random-number-generator\">Instantiating the random number generator</h2>\n<p> You instantiate the random number generator by providing a seed value (a starting value for the pseudo-random number generation algorithm) to a <a class=\"xref\" href=\"system.random#System_Random__ctor_\" data-linktype=\"relative-path\">Random</a> class constructor.  You can supply the seed value either explicitly or implicitly:  </p>\n<ul>\n<li><p>The <a class=\"xref\" href=\"system.random#System_Random__ctor_System_Int32_\" data-linktype=\"relative-path\">Random(Int32)</a> constructor uses an explicit seed value that you supply.  </p>\n</li>\n<li><p>The <a class=\"xref\" href=\"system.random#System_Random__ctor\" data-linktype=\"relative-path\">Random()</a> constructor uses the system clock to provide a seed value. This is the most common way of instantiating the random number generator.  </p>\n<p>If the same seed is used for separate Random objects, they will generate the same series of random numbers. This can be useful for creating a test suite that processes random values, or for replaying games that derive their data from random numbers. However, note that Random objects in processes running under different versions of the .NET Framework may return different series of random numbers even if they&#39;re instantiated with identical seed values.  </p>\n<p>To produce different sequences of random numbers, you can make the seed value time-dependent, thereby producing a different series with each new instance of Random. The parameterized <a class=\"xref\" href=\"system.random#System_Random__ctor_System_Int32_\" data-linktype=\"relative-path\">Random(Int32)</a> constructor can take an <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a> value based on the number of ticks in the current time, whereas the parameterless <a class=\"xref\" href=\"system.random#System_Random__ctor\" data-linktype=\"relative-path\">Random()</a> constructor uses the system clock to generate its seed value. However, because the clock has finite resolution, using the parameterless constructor to create different Random objects in close succession creates random number generators that produce identical sequences of random numbers. The following example illustrates how two Random objects that are instantiated in close succession generate an identical series of random numbers. On most Windows systems, Random objects created within 15 milliseconds of one another are likely to have identical seed values.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Random#1\">using namespace System;\n\nvoid main()\n{\n   array&lt;Byte&gt;^ bytes1 = gcnew array&lt;Byte&gt;(100);\n   array&lt;Byte&gt;^ bytes2 = gcnew array&lt;Byte&gt;(100);\n   Random^ rnd1 = gcnew Random();\n   Random^ rnd2 = gcnew Random();\n   \n   rnd1-&gt;NextBytes(bytes1);\n   rnd2-&gt;NextBytes(bytes2);\n   \n   Console::WriteLine(&quot;First Series:&quot;);\n   for (int ctr = bytes1-&gt;GetLowerBound(0);\n        ctr &lt;= bytes1-&gt;GetUpperBound(0);\n        ctr++) { \n      Console::Write(&quot;{0, 5}&quot;, bytes1[ctr]);\n      if ((ctr + 1) % 10 == 0) Console::WriteLine();\n   } \n   Console::WriteLine();\n   Console::WriteLine(&quot;Second Series:&quot;);\n   for (int ctr = bytes2-&gt;GetLowerBound(0);\n        ctr &lt;= bytes2-&gt;GetUpperBound(0);\n        ctr++) {\n      Console::Write(&quot;{0, 5}&quot;, bytes2[ctr]);\n      if ((ctr + 1) % 10 == 0) Console::WriteLine();\n   }   \n}\n// The example displays output like the following:\n//       First Series:\n//          97  129  149   54   22  208  120  105   68  177\n//         113  214   30  172   74  218  116  230   89   18\n//          12  112  130  105  116  180  190  200  187  120\n//           7  198  233  158   58   51   50  170   98   23\n//          21    1  113   74  146  245   34  255   96   24\n//         232  255   23    9  167  240  255   44  194   98\n//          18  175  173  204  169  171  236  127  114   23\n//         167  202  132   65  253   11  254   56  214  127\n//         145  191  104  163  143    7  174  224  247   73\n//          52    6  231  255    5  101   83  165  160  231\n//       \n//       Second Series:\n//          97  129  149   54   22  208  120  105   68  177\n//         113  214   30  172   74  218  116  230   89   18\n//          12  112  130  105  116  180  190  200  187  120\n//           7  198  233  158   58   51   50  170   98   23\n//          21    1  113   74  146  245   34  255   96   24\n//         232  255   23    9  167  240  255   44  194   98\n//          18  175  173  204  169  171  236  127  114   23\n//         167  202  132   65  253   11  254   56  214  127\n//         145  191  104  163  143    7  174  224  247   73\n//          52    6  231  255    5  101   83  165  160  231        \n</code></pre><pre><code class=\"lang-vb\" name=\"System.Random#1\">Module modMain\n\n   Public Sub Main()\n      Dim bytes1(99), bytes2(99) As Byte\n      Dim rnd1 As New Random()\n      Dim rnd2 As New Random()\n      \n      rnd1.NextBytes(bytes1)\n      rnd2.NextBytes(bytes2)\n      \n      Console.WriteLine(&quot;First Series:&quot;)\n      For ctr As Integer = bytes1.GetLowerBound(0) to bytes1.GetUpperBound(0)\n         Console.Write(&quot;{0, 5}&quot;, bytes1(ctr))\n         If (ctr + 1) Mod 10 = 0 Then Console.WriteLine()\n      Next \n      Console.WriteLine()\n      Console.WriteLine(&quot;Second Series:&quot;)        \n      For ctr As Integer = bytes2.GetLowerBound(0) to bytes2.GetUpperBound(0)\n         Console.Write(&quot;{0, 5}&quot;, bytes2(ctr))\n         If (ctr + 1) Mod 10 = 0 Then Console.WriteLine()\n      Next   \n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;       First Series:\n&#39;          97  129  149   54   22  208  120  105   68  177\n&#39;         113  214   30  172   74  218  116  230   89   18\n&#39;          12  112  130  105  116  180  190  200  187  120\n&#39;           7  198  233  158   58   51   50  170   98   23\n&#39;          21    1  113   74  146  245   34  255   96   24\n&#39;         232  255   23    9  167  240  255   44  194   98\n&#39;          18  175  173  204  169  171  236  127  114   23\n&#39;         167  202  132   65  253   11  254   56  214  127\n&#39;         145  191  104  163  143    7  174  224  247   73\n&#39;          52    6  231  255    5  101   83  165  160  231\n&#39;       \n&#39;       Second Series:\n&#39;          97  129  149   54   22  208  120  105   68  177\n&#39;         113  214   30  172   74  218  116  230   89   18\n&#39;          12  112  130  105  116  180  190  200  187  120\n&#39;           7  198  233  158   58   51   50  170   98   23\n&#39;          21    1  113   74  146  245   34  255   96   24\n&#39;         232  255   23    9  167  240  255   44  194   98\n&#39;          18  175  173  204  169  171  236  127  114   23\n&#39;         167  202  132   65  253   11  254   56  214  127\n&#39;         145  191  104  163  143    7  174  224  247   73\n&#39;          52    6  231  255    5  101   83  165  160  231      \n</code></pre><pre><code class=\"lang-cs\" name=\"System.Random#1\">using System;\n\npublic class Class1\n{\n   public static void Main()\n   {\n      byte[] bytes1 = new byte[100];\n      byte[] bytes2 = new byte[100];\n      Random rnd1 = new Random();\n      Random rnd2 = new Random();\n      \n      rnd1.NextBytes(bytes1);\n      rnd2.NextBytes(bytes2);\n      \n      Console.WriteLine(&quot;First Series:&quot;);\n      for (int ctr = bytes1.GetLowerBound(0); \n           ctr &lt;= bytes1.GetUpperBound(0); \n           ctr++) { \n         Console.Write(&quot;{0, 5}&quot;, bytes1[ctr]);\n         if ((ctr + 1) % 10 == 0) Console.WriteLine();\n      } \n      Console.WriteLine();\n      Console.WriteLine(&quot;Second Series:&quot;);        \n      for (int ctr = bytes2.GetLowerBound(0);\n           ctr &lt;= bytes2.GetUpperBound(0);\n           ctr++) {\n         Console.Write(&quot;{0, 5}&quot;, bytes2[ctr]);\n         if ((ctr + 1) % 10 == 0) Console.WriteLine();\n      }   \n   }\n}\n// The example displays output like the following:\n//       First Series:\n//          97  129  149   54   22  208  120  105   68  177\n//         113  214   30  172   74  218  116  230   89   18\n//          12  112  130  105  116  180  190  200  187  120\n//           7  198  233  158   58   51   50  170   98   23\n//          21    1  113   74  146  245   34  255   96   24\n//         232  255   23    9  167  240  255   44  194   98\n//          18  175  173  204  169  171  236  127  114   23\n//         167  202  132   65  253   11  254   56  214  127\n//         145  191  104  163  143    7  174  224  247   73\n//          52    6  231  255    5  101   83  165  160  231\n//       \n//       Second Series:\n//          97  129  149   54   22  208  120  105   68  177\n//         113  214   30  172   74  218  116  230   89   18\n//          12  112  130  105  116  180  190  200  187  120\n//           7  198  233  158   58   51   50  170   98   23\n//          21    1  113   74  146  245   34  255   96   24\n//         232  255   23    9  167  240  255   44  194   98\n//          18  175  173  204  169  171  236  127  114   23\n//         167  202  132   65  253   11  254   56  214  127\n//         145  191  104  163  143    7  174  224  247   73\n//          52    6  231  255    5  101   83  165  160  231        \n</code></pre><p>To avoid this problem, create a single Random object instead of multiple objects.  </p>\n</li>\n</ul>\n<p><a name=\"Multiple\"></a>   </p>\n<h2 id=\"avoiding-multiple-instantiations\">Avoiding multiple instantiations</h2>\n<p> Initializing two random number generators in a tight loop or in rapid succession creates two random number generators that can produce identical sequences of random numbers. In most cases, this is not the developer&#39;s intent and can lead to performance issues, because instantiating and initializing a random number generator is a relatively expensive process.  </p>\n<p> Both to improve performance and to avoid inadvertently creating separate random number generators that generate identical numeric sequences, we recommend that you create one Random object to generate many random numbers over time, instead of creating new Random objects to generate one random number.  </p>\n<p> However, the Random class isn&#39;t thread safe. If you call Random methods from multiple threads, follow the guidelines discussed in the next section.  </p>\n<p><a name=\"ThreadSafety\"></a>   </p>\n<h2 id=\"the-systemrandom-class-and-thread-safety\">The System.Random class and thread safety</h2>\n<p> Instead of instantiating individual Random objects, we recommend that you create a single Random instance to generate all the random numbers needed by your app. However, Random objects are not thread safe. If your app calls Random methods from multiple threads, you must use a synchronization object to ensure that only one thread can access the random number generator at a time. If you don&#39;t ensure that the Random object is accessed in a thread-safe way, calls to methods that return random numbers return 0.  </p>\n<p> The following example uses the C# <a href=\"../Topic/lock%20Statement%20(C%23%20Reference).md\" data-linktype=\"relative-path\">lock Statement</a> and the Visual Basic <a href=\"../Topic/SyncLock%20Statement.md\" data-linktype=\"relative-path\">SyncLock statement</a> to ensure that a single random number generator is accessed by 11 threads in a thread-safe manner. Each thread generates 2 million random numbers, counts the number of random numbers generated and calculates their sum, and then updates the totals for all threads when it finishes executing.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Random#3\">using namespace System;\nusing namespace System::Threading;\n\nref class Example\n{\nprivate:\n   [ThreadStatic] static double previous = 0.0;\n   [ThreadStatic] static int perThreadCtr = 0;\n   [ThreadStatic] static double perThreadTotal = 0.0;  \n   static CancellationTokenSource^ source;\n   static CountdownEvent^ countdown;\n   static Object^ randLock;\n   static Object^ numericLock;\n   static Random^ rand;\n   double totalValue = 0.0;\n   int totalCount = 0;\n   \npublic:\n   Example()\n   { \n      rand = gcnew Random();\n      randLock = gcnew Object();\n      numericLock = gcnew Object();\n      countdown = gcnew CountdownEvent(1);\n      source = gcnew CancellationTokenSource();\n   } \n\n   void Execute()\n   {   \n      CancellationToken^ token = source-&gt;Token;\n\n      for (int threads = 1; threads &lt;= 10; threads++)\n      {\n         Thread^ newThread = gcnew Thread(gcnew ParameterizedThreadStart(this, &amp;Example::GetRandomNumbers));\n         newThread-&gt;Name = threads.ToString();\n         newThread-&gt;Start(token);\n      }\n      this-&gt;GetRandomNumbers(token);\n      \n      countdown-&gt;Signal();\n      // Make sure all threads have finished.\n      countdown-&gt;Wait();\n\n      Console::WriteLine(&quot;\\nTotal random numbers generated: {0:N0}&quot;, totalCount);\n      Console::WriteLine(&quot;Total sum of all random numbers: {0:N2}&quot;, totalValue);\n      Console::WriteLine(&quot;Random number mean: {0:N4}&quot;, totalValue/totalCount);\n   }\n\nprivate:\n   void GetRandomNumbers(Object^ o)\n   {\n      CancellationToken^ token = (CancellationToken) o;\n      double result = 0.0;\n      countdown-&gt;AddCount(1);\n         \n      try { \n         for (int ctr = 0; ctr &lt; 2000000; ctr++)\n         {\n            // Make sure there&#39;s no corruption of Random.\n            token-&gt;ThrowIfCancellationRequested();\n\n            Monitor::Enter(randLock);\n            result = rand-&gt;NextDouble();\n            Monitor::Exit(randLock);\n            // Check for corruption of Random instance.\n            if ((result == previous) &amp;&amp; result == 0) {\n               source-&gt;Cancel();\n            }\n            else {\n               previous = result;\n            }\n            perThreadCtr++;\n            perThreadTotal += result;\n         }      \n       \n         Console::WriteLine(&quot;Thread {0} finished execution.&quot;, \n                           Thread::CurrentThread-&gt;Name);\n         Console::WriteLine(&quot;Random numbers generated: {0:N0}&quot;, perThreadCtr);\n         Console::WriteLine(&quot;Sum of random numbers: {0:N2}&quot;, perThreadTotal);\n         Console::WriteLine(&quot;Random number mean: {0:N4}\\n&quot;, perThreadTotal/perThreadCtr);\n\n         // Update overall totals.\n         Monitor::Enter(numericLock);\n         totalCount += perThreadCtr;\n         totalValue += perThreadTotal;  \n         Monitor::Exit(numericLock);\n      }\n      catch (OperationCanceledException^ e) {\n         Console::WriteLine(&quot;Corruption in Thread {1}&quot;, e-&gt;GetType()-&gt;Name,\n                            Thread::CurrentThread-&gt;Name);\n      }\n      finally {\n         countdown-&gt;Signal();\n      }\n   }\n};\n\nvoid main()\n{\n   Example^ ex = gcnew Example();\n   Thread::CurrentThread-&gt;Name = &quot;Main&quot;;\n   ex-&gt;Execute();\n}\n// The example displays output like the following:\n//       Thread 6 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 1,000,491.05\n//       Random number mean: 0.5002\n//       \n//       Thread 10 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 999,329.64\n//       Random number mean: 0.4997\n//       \n//       Thread 4 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 1,000,166.89\n//       Random number mean: 0.5001\n//       \n//       Thread 8 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 999,628.37\n//       Random number mean: 0.4998\n//       \n//       Thread Main finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 999,920.89\n//       Random number mean: 0.5000\n//       \n//       Thread 3 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 999,370.45\n//       Random number mean: 0.4997\n//       \n//       Thread 7 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 999,330.92\n//       Random number mean: 0.4997\n//       \n//       Thread 9 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 1,000,172.79\n//       Random number mean: 0.5001\n//       \n//       Thread 5 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 1,000,079.43\n//       Random number mean: 0.5000\n//       \n//       Thread 1 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 999,817.91\n//       Random number mean: 0.4999\n//       \n//       Thread 2 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 999,930.63\n//       Random number mean: 0.5000\n//       \n//       \n//       Total random numbers generated: 22,000,000\n//       Total sum of all random numbers: 10,998,238.98\n//       Random number mean: 0.4999\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Random#3\">using System;\nusing System.Threading;\n\npublic class Example\n{\n   [ThreadStatic] static double previous = 0.0;\n   [ThreadStatic] static int perThreadCtr = 0;\n   [ThreadStatic] static double perThreadTotal = 0.0;  \n   static CancellationTokenSource source;\n   static CountdownEvent countdown; \n   static Object randLock, numericLock;\n   static Random rand;\n   double totalValue = 0.0;\n   int totalCount = 0;\n   \n   public Example()\n   { \n      rand = new Random();\n      randLock = new Object();\n      numericLock = new Object();\n      countdown = new CountdownEvent(1);\n      source = new CancellationTokenSource();\n   } \n\n   public static void Main()\n   {\n      Example ex = new Example();\n      Thread.CurrentThread.Name = &quot;Main&quot;;\n      ex.Execute();\n   }\n\n   private void Execute()\n   {   \n      CancellationToken token = source.Token; \n\n      for (int threads = 1; threads &lt;= 10; threads++)\n      {\n         Thread newThread = new Thread(this.GetRandomNumbers);\n         newThread.Name = threads.ToString();\n         newThread.Start(token);\n      }\n      this.GetRandomNumbers(token);\n      \n      countdown.Signal();\n      // Make sure all threads have finished.\n      countdown.Wait();\n      source.Dispose();\n\n      Console.WriteLine(&quot;\\nTotal random numbers generated: {0:N0}&quot;, totalCount);\n      Console.WriteLine(&quot;Total sum of all random numbers: {0:N2}&quot;, totalValue);\n      Console.WriteLine(&quot;Random number mean: {0:N4}&quot;, totalValue/totalCount);\n   }\n\n   private void GetRandomNumbers(Object o)\n   {\n      CancellationToken token = (CancellationToken) o;\n      double result = 0.0;\n      countdown.AddCount(1);\n         \n      try { \n         for (int ctr = 0; ctr &lt; 2000000; ctr++)\n         {\n            // Make sure there&#39;s no corruption of Random.\n            token.ThrowIfCancellationRequested();\n\n            lock (randLock) {\n               result = rand.NextDouble();\n            }\n            // Check for corruption of Random instance.\n            if ((result == previous) &amp;&amp; result == 0) {\n               source.Cancel();\n            }\n            else {\n               previous = result;\n            }\n            perThreadCtr++;\n            perThreadTotal += result;\n         }      \n       \n         Console.WriteLine(&quot;Thread {0} finished execution.&quot;, \n                           Thread.CurrentThread.Name);\n         Console.WriteLine(&quot;Random numbers generated: {0:N0}&quot;, perThreadCtr);\n         Console.WriteLine(&quot;Sum of random numbers: {0:N2}&quot;, perThreadTotal);\n         Console.WriteLine(&quot;Random number mean: {0:N4}\\n&quot;, perThreadTotal/perThreadCtr);\n\n         // Update overall totals.\n         lock (numericLock) {\n            totalCount += perThreadCtr;\n            totalValue += perThreadTotal;  \n         }\n      }\n      catch (OperationCanceledException e) {\n         Console.WriteLine(&quot;Corruption in Thread {1}&quot;, e.GetType().Name, Thread.CurrentThread.Name);\n      }\n      finally {\n         countdown.Signal();        \n      }\n   }\n}\n// The example displays output like the following:\n//       Thread 6 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 1,000,491.05\n//       Random number mean: 0.5002\n//       \n//       Thread 10 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 999,329.64\n//       Random number mean: 0.4997\n//       \n//       Thread 4 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 1,000,166.89\n//       Random number mean: 0.5001\n//       \n//       Thread 8 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 999,628.37\n//       Random number mean: 0.4998\n//       \n//       Thread Main finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 999,920.89\n//       Random number mean: 0.5000\n//       \n//       Thread 3 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 999,370.45\n//       Random number mean: 0.4997\n//       \n//       Thread 7 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 999,330.92\n//       Random number mean: 0.4997\n//       \n//       Thread 9 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 1,000,172.79\n//       Random number mean: 0.5001\n//       \n//       Thread 5 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 1,000,079.43\n//       Random number mean: 0.5000\n//       \n//       Thread 1 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 999,817.91\n//       Random number mean: 0.4999\n//       \n//       Thread 2 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 999,930.63\n//       Random number mean: 0.5000\n//       \n//       \n//       Total random numbers generated: 22,000,000\n//       Total sum of all random numbers: 10,998,238.98\n//       Random number mean: 0.4999\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Random#3\">Imports System.Threading\n\nModule Example\n   &lt;ThreadStatic&gt; Dim previous As Double = 0.0\n   &lt;ThreadStatic&gt; Dim perThreadCtr As Integer = 0\n   &lt;ThreadStatic&gt; Dim perThreadTotal As Double = 0.0  \n   Dim source As New CancellationTokenSource()\n   Dim countdown As New CountdownEvent(1) \n   Dim randLock As New Object()\n   Dim numericLock As New Object()\n   Dim rand As New Random()\n   Dim totalValue As Double = 0.0\n   Dim totalCount As Integer = 0\n   \n   Public Sub Main()\n      Thread.CurrentThread.Name = &quot;Main&quot;\n\n      Dim token As CancellationToken = source.Token \n      For threads As Integer = 1 To 10\n         Dim newThread As New Thread(AddressOf GetRandomNumbers)\n         newThread.Name = threads.ToString()\n         newThread.Start(token)\n      Next\n      GetRandomNumbers(token)\n      \n      countdown.Signal()\n      &#39; Make sure all threads have finished.\n      countdown.Wait()\n\n      Console.WriteLine()\n      Console.WriteLine(&quot;Total random numbers generated: {0:N0}&quot;, totalCount)\n      Console.WriteLine(&quot;Total sum of all random numbers: {0:N2}&quot;, totalValue)\n      Console.WriteLine(&quot;Random number mean: {0:N4}&quot;, totalValue/totalCount)\n   End Sub\n\n   Private Sub GetRandomNumbers(o As Object)\n      Dim token As CancellationToken = CType(o, CancellationToken)\n      Dim result As Double = 0.0\n      countdown.AddCount(1)\n         \n      Try  \n         For ctr As Integer = 1 To 2000000\n            &#39; Make sure there&#39;s no corruption of Random.\n            token.ThrowIfCancellationRequested()\n\n            SyncLock randLock\n               result = rand.NextDouble()\n            End SyncLock\n            &#39; Check for corruption of Random instance.\n            If result = previous AndAlso result = 0 Then \n               source.Cancel()\n            Else \n               previous = result\n            End If\n            perThreadCtr += 1\n            perThreadTotal += result\n         Next      \n       \n         Console.WriteLine(&quot;Thread {0} finished execution.&quot;, \n                           Thread.CurrentThread.Name)\n         Console.WriteLine(&quot;Random numbers generated: {0:N0}&quot;, perThreadCtr)\n         Console.WriteLine(&quot;Sum of random numbers: {0:N2}&quot;, perThreadTotal)\n         Console.WriteLine(&quot;Random number mean: {0:N4}&quot;, perThreadTotal/perThreadCtr)\n         Console.WriteLine()\n         \n         &#39; Update overall totals.\n         SyncLock numericLock\n            totalCount += perThreadCtr\n            totalValue += perThreadTotal  \n         End SyncLock\n      Catch e As OperationCanceledException\n         Console.WriteLine(&quot;Corruption in Thread {1}&quot;, e.GetType().Name, Thread.CurrentThread.Name)\n      Finally \n         countdown.Signal()\n         source.Dispose()\n      End Try\n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;       Thread 6 finished execution.\n&#39;       Random numbers generated: 2,000,000\n&#39;       Sum of random numbers: 1,000,491.05\n&#39;       Random number mean: 0.5002\n&#39;       \n&#39;       Thread 10 finished execution.\n&#39;       Random numbers generated: 2,000,000\n&#39;       Sum of random numbers: 999,329.64\n&#39;       Random number mean: 0.4997\n&#39;       \n&#39;       Thread 4 finished execution.\n&#39;       Random numbers generated: 2,000,000\n&#39;       Sum of random numbers: 1,000,166.89\n&#39;       Random number mean: 0.5001\n&#39;       \n&#39;       Thread 8 finished execution.\n&#39;       Random numbers generated: 2,000,000\n&#39;       Sum of random numbers: 999,628.37\n&#39;       Random number mean: 0.4998\n&#39;       \n&#39;       Thread Main finished execution.\n&#39;       Random numbers generated: 2,000,000\n&#39;       Sum of random numbers: 999,920.89\n&#39;       Random number mean: 0.5000\n&#39;       \n&#39;       Thread 3 finished execution.\n&#39;       Random numbers generated: 2,000,000\n&#39;       Sum of random numbers: 999,370.45\n&#39;       Random number mean: 0.4997\n&#39;       \n&#39;       Thread 7 finished execution.\n&#39;       Random numbers generated: 2,000,000\n&#39;       Sum of random numbers: 999,330.92\n&#39;       Random number mean: 0.4997\n&#39;       \n&#39;       Thread 9 finished execution.\n&#39;       Random numbers generated: 2,000,000\n&#39;       Sum of random numbers: 1,000,172.79\n&#39;       Random number mean: 0.5001\n&#39;       \n&#39;       Thread 5 finished execution.\n&#39;       Random numbers generated: 2,000,000\n&#39;       Sum of random numbers: 1,000,079.43\n&#39;       Random number mean: 0.5000\n&#39;       \n&#39;       Thread 1 finished execution.\n&#39;       Random numbers generated: 2,000,000\n&#39;       Sum of random numbers: 999,817.91\n&#39;       Random number mean: 0.4999\n&#39;       \n&#39;       Thread 2 finished execution.\n&#39;       Random numbers generated: 2,000,000\n&#39;       Sum of random numbers: 999,930.63\n&#39;       Random number mean: 0.5000\n&#39;       \n&#39;       \n&#39;       Total random numbers generated: 22,000,000\n&#39;       Total sum of all random numbers: 10,998,238.98\n&#39;       Random number mean: 0.4999\n</code></pre><p> The example ensures thread-safety in the following ways:  </p>\n<ul>\n<li><p>The <a class=\"xref\" href=\"system.threadstaticattribute\" data-linktype=\"relative-path\">ThreadStaticAttribute</a> attribute is used to define thread-local variables that track the total number of random numbers generated and their sum for each thread.  </p>\n</li>\n<li><p>A lock (the <code>lock</code> statement in C# and the <code>SyncLock</code> statement in Visual Basic) protects access to the variables for the total count and sum of all random numbers generated on all threads.  </p>\n</li>\n<li><p>A semaphore (the <a class=\"xref\" href=\"system.threading.countdownevent\" data-linktype=\"relative-path\">CountdownEvent</a> object) is used to ensure that the main thread blocks until all other threads complete execution.  </p>\n</li>\n<li><p>The example checks whether the random number generator has become corrupted by determining whether two consecutive calls to random number generation methods return 0. If corruption is detected, the example uses the <a class=\"xref\" href=\"system.threading.cancellationtokensource\" data-linktype=\"relative-path\">CancellationTokenSource</a> object to signal that all threads should be canceled.  </p>\n</li>\n<li><p>Before generating each random number, each thread checks the state of the <a class=\"xref\" href=\"system.threading.cancellationtoken\" data-linktype=\"relative-path\">CancellationToken</a> object. If cancellation is requested, the example calls the <a class=\"xref\" href=\"system.threading.cancellationtoken#System_Threading_CancellationToken_ThrowIfCancellationRequested_\" data-linktype=\"relative-path\">ThrowIfCancellationRequested</a> method to cancel the thread.  </p>\n<p>The following example is identical to the first, except that it uses a <a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a> object and a lambda expression instead of <a class=\"xref\" href=\"system.threading.thread\" data-linktype=\"relative-path\">Thread</a> objects.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Random#4\">using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\n\npublic class Example\n{\n   static Object randLock, numericLock;\n   static Random rand;\n   static CancellationTokenSource source;\n   double totalValue = 0.0;\n   int totalCount = 0;\n   \n   public Example()\n   { \n      rand = new Random();\n      randLock = new Object();\n      numericLock = new Object();\n      source = new CancellationTokenSource();\n   } \n\n   public static void Main()\n   {\n      Example ex = new Example();\n      Thread.CurrentThread.Name = &quot;Main&quot;;\n      ex.Execute();\n   }\n\n   private void Execute()\n   {   \n      List&lt;Task&gt; tasks = new List&lt;Task&gt;();\n      \n      for (int ctr = 0; ctr &lt;= 10; ctr++)\n      {\n         CancellationToken token = source.Token; \n         int taskNo = ctr;\n         tasks.Add(Task.Run( () =&gt;\n            {\n               double previous = 0.0;\n               int taskCtr = 0;\n               double taskTotal = 0.0;  \n               double result = 0.0;\n                               \n               for (int n = 0; n &lt; 2000000; n++)\n               {\n                  // Make sure there&#39;s no corruption of Random.\n                  token.ThrowIfCancellationRequested();\n\n                  lock (randLock) {\n                     result = rand.NextDouble();\n                  }\n                  // Check for corruption of Random instance.\n                  if ((result == previous) &amp;&amp; result == 0) {\n                     source.Cancel();\n                  }\n                  else {\n                     previous = result;\n                  }\n                  taskCtr++;\n                  taskTotal += result;\n               }\n\n               // Show result.\n               Console.WriteLine(&quot;Task {0} finished execution.&quot;, taskNo);\n               Console.WriteLine(&quot;Random numbers generated: {0:N0}&quot;, taskCtr);\n               Console.WriteLine(&quot;Sum of random numbers: {0:N2}&quot;, taskTotal);\n               Console.WriteLine(&quot;Random number mean: {0:N4}\\n&quot;, taskTotal/taskCtr);\n         \n               // Update overall totals.\n               lock (numericLock) {\n                  totalCount += taskCtr;\n                  totalValue += taskTotal;  \n               }\n            }, \n         token));\n      }\n      try {\n         Task.WaitAll(tasks.ToArray());\n         Console.WriteLine(&quot;\\nTotal random numbers generated: {0:N0}&quot;, totalCount);\n         Console.WriteLine(&quot;Total sum of all random numbers: {0:N2}&quot;, totalValue);\n         Console.WriteLine(&quot;Random number mean: {0:N4}&quot;, totalValue/totalCount);\n      }\n      catch (AggregateException e) {\n         foreach (Exception inner in e.InnerExceptions) {\n            TaskCanceledException canc = inner as TaskCanceledException;\n            if (canc != null)\n               Console.WriteLine(&quot;Task #{0} cancelled.&quot;, canc.Task.Id);\n            else\n               Console.WriteLine(&quot;Exception: {0}&quot;, inner.GetType().Name);\n         }         \n      }\n      finally {\n         source.Dispose();\n      }\n   }\n}\n// The example displays output like the following:\n//       Task 1 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 1,000,502.47\n//       Random number mean: 0.5003\n//       \n//       Task 0 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 1,000,445.63\n//       Random number mean: 0.5002\n//       \n//       Task 2 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 1,000,556.04\n//       Random number mean: 0.5003\n//       \n//       Task 3 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 1,000,178.87\n//       Random number mean: 0.5001\n//       \n//       Task 4 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 999,819.17\n//       Random number mean: 0.4999\n//       \n//       Task 5 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 1,000,190.58\n//       Random number mean: 0.5001\n//       \n//       Task 6 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 999,720.21\n//       Random number mean: 0.4999\n//       \n//       Task 7 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 999,000.96\n//       Random number mean: 0.4995\n//       \n//       Task 8 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 999,499.33\n//       Random number mean: 0.4997\n//       \n//       Task 9 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 1,000,193.25\n//       Random number mean: 0.5001\n//       \n//       Task 10 finished execution.\n//       Random numbers generated: 2,000,000\n//       Sum of random numbers: 999,960.82\n//       Random number mean: 0.5000\n//       \n//       \n//       Total random numbers generated: 22,000,000\n//       Total sum of all random numbers: 11,000,067.33\n//       Random number mean: 0.5000\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Random#4\">Imports System.Collections.Generic\nImports System.Threading\nImports System.Threading.Tasks\n\nModule Example\n   Dim source As New CancellationTokenSource()\n   Dim randLock As New Object()\n   Dim numericLock As New Object()\n   Dim rand As New Random()\n   Dim totalValue As Double = 0.0\n   Dim totalCount As Integer = 0\n   \n   Public Sub Main()\n      Dim tasks As New List(Of Task)()\n      \n      For ctr As Integer = 1 To 10\n         Dim token As CancellationToken = source.Token \n         Dim taskNo As Integer = ctr\n         tasks.Add(Task.Run( \n                   Sub()\n                      Dim previous As Double = 0.0\n                      Dim taskCtr As Integer = 0\n                      Dim taskTotal As Double = 0.0\n                      Dim result As Double = 0.0\n\n                      For n As Integer = 1 To 2000000\n                         &#39; Make sure there&#39;s no corruption of Random.\n                         token.ThrowIfCancellationRequested()\n      \n                         SyncLock randLock\n                           result = rand.NextDouble()\n                         End SyncLock\n                         &#39; Check for corruption of Random instance.\n                         If result = previous AndAlso result = 0 Then\n                           source.Cancel()\n                         Else \n                           previous = result\n                         End If\n                        taskCtr += 1\n                        taskTotal += result\n                      Next   \n\n                      &#39; Show result.\n                     Console.WriteLine(&quot;Task {0} finished execution.&quot;, taskNo)\n                     Console.WriteLine(&quot;Random numbers generated: {0:N0}&quot;, taskCtr)\n                     Console.WriteLine(&quot;Sum of random numbers: {0:N2}&quot;, taskTotal)\n                     Console.WriteLine(&quot;Random number mean: {0:N4}&quot;, taskTotal/taskCtr)\n                     Console.WriteLine()\n                     \n                     &#39; Update overall totals.\n                     SyncLock numericLock\n                        totalCount += taskCtr\n                        totalValue += taskTotal  \n                     End SyncLock\n                   End Sub, token))\n      Next\n\n      Try\n         Task.WaitAll(tasks.ToArray())\n         Console.WriteLine()\n         Console.WriteLine(&quot;Total random numbers generated: {0:N0}&quot;, totalCount)\n         Console.WriteLine(&quot;Total sum of all random numbers: {0:N2}&quot;, totalValue)\n         Console.WriteLine(&quot;Random number mean: {0:N4}&quot;, totalValue/totalCount)\n      Catch e As AggregateException\n         For Each inner As Exception In e.InnerExceptions\n            Dim canc As TaskCanceledException = TryCast(inner, TaskCanceledException)\n            If canc IsNot Nothing Then\n               Console.WriteLine(&quot;Task #{0} cancelled.&quot;, canc.Task.Id)\n            Else\n               Console.WriteLine(&quot;Exception: {0}&quot;, inner.GetType().Name)\n            End If   \n         Next         \n      Finally\n         source.Dispose()\n      End Try\n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;       Task 1 finished execution.\n&#39;       Random numbers generated: 2,000,000\n&#39;       Sum of random numbers: 1,000,502.47\n&#39;       Random number mean: 0.5003\n&#39;       \n&#39;       Task 0 finished execution.\n&#39;       Random numbers generated: 2,000,000\n&#39;       Sum of random numbers: 1,000,445.63\n&#39;       Random number mean: 0.5002\n&#39;       \n&#39;       Task 2 finished execution.\n&#39;       Random numbers generated: 2,000,000\n&#39;       Sum of random numbers: 1,000,556.04\n&#39;       Random number mean: 0.5003\n&#39;       \n&#39;       Task 3 finished execution.\n&#39;       Random numbers generated: 2,000,000\n&#39;       Sum of random numbers: 1,000,178.87\n&#39;       Random number mean: 0.5001\n&#39;       \n&#39;       Task 4 finished execution.\n&#39;       Random numbers generated: 2,000,000\n&#39;       Sum of random numbers: 999,819.17\n&#39;       Random number mean: 0.4999\n&#39;       \n&#39;       Task 5 finished execution.\n&#39;       Random numbers generated: 2,000,000\n&#39;       Sum of random numbers: 1,000,190.58\n&#39;       Random number mean: 0.5001\n&#39;       \n&#39;       Task 6 finished execution.\n&#39;       Random numbers generated: 2,000,000\n&#39;       Sum of random numbers: 999,720.21\n&#39;       Random number mean: 0.4999\n&#39;       \n&#39;       Task 7 finished execution.\n&#39;       Random numbers generated: 2,000,000\n&#39;       Sum of random numbers: 999,000.96\n&#39;       Random number mean: 0.4995\n&#39;       \n&#39;       Task 8 finished execution.\n&#39;       Random numbers generated: 2,000,000\n&#39;       Sum of random numbers: 999,499.33\n&#39;       Random number mean: 0.4997\n&#39;       \n&#39;       Task 9 finished execution.\n&#39;       Random numbers generated: 2,000,000\n&#39;       Sum of random numbers: 1,000,193.25\n&#39;       Random number mean: 0.5001\n&#39;       \n&#39;       Task 10 finished execution.\n&#39;       Random numbers generated: 2,000,000\n&#39;       Sum of random numbers: 999,960.82\n&#39;       Random number mean: 0.5000\n&#39;       \n&#39;       \n&#39;       Total random numbers generated: 22,000,000\n&#39;       Total sum of all random numbers: 11,000,067.33\n&#39;       Random number mean: 0.5000\n</code></pre><p>It differs from the first example in the following ways:  </p>\n</li>\n<li><p>The variables to keep track of the number of random numbers generated and their sum in each task are local to the task, so there is no need to use the <a class=\"xref\" href=\"system.threadstaticattribute\" data-linktype=\"relative-path\">ThreadStaticAttribute</a> attribute.  </p>\n</li>\n<li><p>The static <a class=\"xref\" href=\"system.threading.tasks.task#System_Threading_Tasks_Task_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method is used to ensure that the main thread doesn&#39;t complete before all tasks have finished. There is no need for the <a class=\"xref\" href=\"system.threading.countdownevent\" data-linktype=\"relative-path\">CountdownEvent</a> object.  </p>\n</li>\n<li><p>The exception that results from task cancellation is surfaced in the <a class=\"xref\" href=\"system.threading.tasks.task#System_Threading_Tasks_Task_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method. In the previous example, it is handled by each thread.  </p>\n</li>\n</ul>\n<p><a name=\"Functionality\"></a>   </p>\n<h2 id=\"generating-different-types-of-random-numbers\">Generating different types of random numbers</h2>\n<p> The random number generator provides methods that let you generate the following kinds of random numbers:  </p>\n<ul>\n<li><p>A series of <a class=\"xref\" href=\"system.byte\" data-linktype=\"relative-path\">Byte</a> values. You determine the number of byte values by passing an array initialized to the number of elements you want the method to return to the <a class=\"xref\" href=\"system.random#System_Random_NextBytes_\" data-linktype=\"relative-path\">NextBytes</a> method. The following example generates 20 bytes.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Random#5\">using namespace System;\n\nvoid main()\n{\n   Random^ rnd = gcnew Random();\n   array&lt;Byte&gt;^ bytes = gcnew array&lt;Byte&gt;(20);\n   rnd-&gt;NextBytes(bytes);\n   for (int ctr = 1; ctr &lt;= bytes-&gt;Length; ctr++) {\n      Console::Write(&quot;{0,3}   &quot;, bytes[ctr - 1]);\n      if (ctr % 10 == 0) Console::WriteLine();\n   } \n}\n// The example displays output like the following:\n//       141    48   189    66   134   212   211    71   161    56\n//       181   166   220   133     9   252   222    57    62    62\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Random#5\">Module Example\n   Public Sub Main()\n      Dim rnd As New Random()\n      Dim bytes(19) As Byte\n      rnd.NextBytes(bytes)  \n      For ctr As Integer = 1 To bytes.Length\n         Console.Write(&quot;{0,3}   &quot;, bytes(ctr - 1))\n         If ctr Mod 10 = 0 Then Console.WriteLine()\n      Next \n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;       141    48   189    66   134   212   211    71   161    56\n&#39;       181   166   220   133     9   252   222    57    62    62\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Random#5\">using System;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Random rnd = new Random();\n      Byte[] bytes = new Byte[20];\n      rnd.NextBytes(bytes);  \n      for (int ctr = 1; ctr &lt;= bytes.Length; ctr++) {\n         Console.Write(&quot;{0,3}   &quot;, bytes[ctr - 1]);\n         if (ctr % 10 == 0) Console.WriteLine();\n      } \n   }\n}\n// The example displays output like the following:\n//       141    48   189    66   134   212   211    71   161    56\n//       181   166   220   133     9   252   222    57    62    62\n</code></pre></li>\n<li><p>A single integer. You can choose whether you want an integer from 0 to a maximum value (<a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">System.Int32.MaxValue</a> â€“ 1) by calling the <a class=\"xref\" href=\"system.random#System_Random_Next\" data-linktype=\"relative-path\">Next()</a> method, an integer between 0 and a specific value by calling the <a class=\"xref\" href=\"system.random#System_Random_Next_System_Int32_\" data-linktype=\"relative-path\">Next(Int32)</a> method, or an integer within a range of values by calling the <a class=\"xref\" href=\"system.random#System_Random_Next_System_Int32_System_Int32_\" data-linktype=\"relative-path\">Next(Int32,Int32)</a> method. In the parameterized overloads, the specified maximum value is exclusive; that is, the actual maximum number generated is one less than the specified value.  </p>\n<p> The following example calls the <a class=\"xref\" href=\"system.random#System_Random_Next_System_Int32_System_Int32_\" data-linktype=\"relative-path\">Next(Int32,Int32)</a> method to generate 10 random numbers between -10 and 10. Note that the second argument to the method specifies the exclusive upper bound of the range of random values returned by the method. In other words, the largest integer that the method can return is one less than this value.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Random#6\">using namespace System;\n\nvoid main()\n{\n   Random^ rnd = gcnew Random();\n   for (int ctr = 0; ctr &lt; 10; ctr++) {\n      Console::Write(&quot;{0,3}   &quot;, rnd-&gt;Next(-10, 11));\n   }\n}\n// The example displays output like the following:\n//    2     9    -3     2     4    -7    -3    -8    -8     5\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Random#6\">using System;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Random rnd = new Random();\n      for (int ctr = 0; ctr &lt; 10; ctr++) {\n         Console.Write(&quot;{0,3}   &quot;, rnd.Next(-10, 11));\n      }\n   }\n}\n// The example displays output like the following:\n//    2     9    -3     2     4    -7    -3    -8    -8     5\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Random#6\">Module Example\n   Public Sub Main()\n      Dim rnd As New Random()\n      For ctr As Integer = 0 To 9\n         Console.Write(&quot;{0,3}   &quot;, rnd.Next(-10, 11))\n      Next\n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;    2     9    -3     2     4    -7    -3    -8    -8     5\n</code></pre></li>\n<li><p>A single floating-point value from 0.0 to less than 1.0 by calling the <a class=\"xref\" href=\"system.random#System_Random_NextDouble_\" data-linktype=\"relative-path\">NextDouble</a> method. The exclusive upper bound of the random number returned by the method is 1, so its actual upper bound is 0.99999999999999978. The following example generates 10 random floating-point numbers.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Random#7\">using namespace System;\n\nvoid main()\n{\n   Random^ rnd = gcnew Random();\n   for (int ctr = 0; ctr &lt; 10; ctr++) {\n      Console::Write(&quot;{0,-19:R}   &quot;, rnd-&gt;NextDouble());\n      if ((ctr + 1) % 3 == 0) Console::WriteLine();\n   }\n}\n// The example displays output like the following:\n//    0.7911680553998649    0.0903414949264105    0.79776258291572455    \n//    0.615568345233597     0.652644504165577     0.84023809378977776   \n//    0.099662564741290441   0.91341467383942321  0.96018602045261581   \n//    0.74772306473354022\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Random#7\">using System;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Random rnd = new Random();\n      for (int ctr = 0; ctr &lt; 10; ctr++) {\n         Console.Write(&quot;{0,-19:R}   &quot;, rnd.NextDouble());\n         if ((ctr + 1) % 3 == 0) Console.WriteLine();\n      }\n   }\n}\n// The example displays output like the following:\n//    0.7911680553998649    0.0903414949264105    0.79776258291572455    \n//    0.615568345233597     0.652644504165577     0.84023809378977776   \n//    0.099662564741290441   0.91341467383942321  0.96018602045261581   \n//    0.74772306473354022\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Random#7\">Module Example\n   Public Sub Main()\n      Dim rnd As New Random()\n      For ctr As Integer = 0 To 9\n         Console.Write(&quot;{0,-19:R}   &quot;, rnd.NextDouble())\n         If (ctr + 1) Mod 3 = 0 Then Console.WriteLine()\n      Next\n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;    0.7911680553998649    0.0903414949264105    0.79776258291572455    \n&#39;    0.615568345233597     0.652644504165577     0.84023809378977776   \n&#39;    0.099662564741290441  0.91341467383942321   0.96018602045261581   \n&#39;    0.74772306473354022\n</code></pre></li>\n</ul>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> The <a class=\"xref\" href=\"system.random#System_Random_Next_System_Int32_System_Int32_\" data-linktype=\"relative-path\">Next(Int32,Int32)</a> method allows you to specify the range of the returned random number. However, the <code>maxValue</code> parameter, which specifies the upper range returned number, is an exclusive, not an inclusive, value. This means that the method call <code>Next(0, 100)</code> returns a value between 0 and 99, and not between 0 and 100.  </p>\n</div>\n<p> You can also use the Random class for such tasks as generating <a href=\"#Boolean\" data-linktype=\"self-bookmark\">random T:System.Boolean values</a>, generating <a href=\"#Floats\" data-linktype=\"self-bookmark\">random floating point values with a range other than 0 to 1</a>, generating <a href=\"#Long\" data-linktype=\"self-bookmark\">random 64-bit integers</a>, and <a href=\"#UniqueArray\" data-linktype=\"self-bookmark\">randomly retrieving a unique element from an array or collection</a>. For these and other common tasks, see the <a href=\"#Operations\" data-linktype=\"self-bookmark\">How do you use System.Random toâ€¦</a> section.  </p>\n<p><a name=\"Overriding\"></a>   </p>\n<h2 id=\"substituting-your-own-algorithm\">Substituting your own algorithm</h2>\n<p> You can implement your own random number generator by inheriting from the Random class and supplying your random number generation algorithm. To supply your own algorithm, you must override the <a class=\"xref\" href=\"system.random#System_Random_Sample_\" data-linktype=\"relative-path\">Sample</a> method, which implements the random number generation algorithm. You should also override the <a class=\"xref\" href=\"system.random#System_Random_Next\" data-linktype=\"relative-path\">Next()</a>, <a class=\"xref\" href=\"system.random#System_Random_Next_System_Int32_System_Int32_\" data-linktype=\"relative-path\">Next(Int32,Int32)</a>, and <a class=\"xref\" href=\"system.random#System_Random_NextBytes_\" data-linktype=\"relative-path\">NextBytes</a> methods to ensure that they call your overridden <a class=\"xref\" href=\"system.random#System_Random_Sample_\" data-linktype=\"relative-path\">Sample</a> method. You don&#39;t have to override the <a class=\"xref\" href=\"system.random#System_Random_Next_System_Int32_\" data-linktype=\"relative-path\">Next(Int32)</a> and <a class=\"xref\" href=\"system.random#System_Random_NextDouble_\" data-linktype=\"relative-path\">NextDouble</a> methods.  </p>\n<p> For an example that derives from the Random class and modifies its default pseudo-random number generator, see the <a class=\"xref\" href=\"system.random#System_Random_Sample_\" data-linktype=\"relative-path\">Sample</a> reference page.  </p>\n<p><a name=\"Operations\"></a>   </p>\n<h2 id=\"how-do-you-use-systemrandom-to\">How do you use System.Random toâ€¦</h2>\n<p> The following sections discuss and provide sample code for some of the ways you might want to use random numbers in your app.  </p>\n<p><a name=\"Same\"></a>   </p>\n<h3 id=\"retrieve-the-same-sequence-of-random-values\">Retrieve the same sequence of random values</h3>\n<p> Sometimes you want to generate the same sequence of random numbers in software test scenarios and in game playing. Testing with the same sequence of random numbers allows you to detect regressions and confirm bug fixes. Using the same sequence of random number in games allows you to replay previous games.  </p>\n<p> You can generate the same sequence of random numbers by providing the same seed value to the <a class=\"xref\" href=\"system.random#System_Random__ctor_System_Int32_\" data-linktype=\"relative-path\">Random(Int32)</a> constructor. The seed value provides a starting value for the pseudo-random number generation algorithm. The following example uses 100100 as an arbitrary seed value to instantiate the Random object, displays 20 random floating-point values, and persists the seed value. It then restores the seed value, instantiates a new random number generator, and displays the same 20 random floating-point values.  Note that the example may produce different sequences of random numbers if run on different versions of the .NET Framework.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Random#12\">using System;\nusing System.IO;\n\npublic class Example\n{\n   public static void Main()\n   {\n      int seed = 100100;\n      ShowRandomNumbers(seed);\n      Console.WriteLine();\n      \n      PersistSeed(seed);\n      \n      DisplayNewRandomNumbers(); \n   }\n   \n   private static void ShowRandomNumbers(int seed)\n   {\n      Random rnd = new Random(seed);\n      for (int ctr = 0; ctr &lt;= 20; ctr++)\n         Console.WriteLine(rnd.NextDouble());\n   }\n   \n   private static void PersistSeed(int seed)\n   {\n      FileStream fs = new FileStream(@&quot;.\\seed.dat&quot;, FileMode.Create);\n      BinaryWriter bin = new BinaryWriter(fs);\n      bin.Write(seed);\n      bin.Close();\n   }\n   \n   private static void DisplayNewRandomNumbers()\n   {\n      FileStream fs = new FileStream(@&quot;.\\seed.dat&quot;, FileMode.Open);\n      BinaryReader bin = new BinaryReader(fs);\n      int seed = bin.ReadInt32();\n      bin.Close();\n      \n      Random rnd = new Random(seed);\n      for (int ctr = 0; ctr &lt;= 20; ctr++)\n         Console.WriteLine(rnd.NextDouble());\n   }\n}\n// The example displays output like the following:\n//       0.500193602172748\n//       0.0209461245783354\n//       0.465869495396442\n//       0.195512794514891\n//       0.928583675496552\n//       0.729333720509584\n//       0.381455668891527\n//       0.0508996467343064\n//       0.019261200921266\n//       0.258578445417145\n//       0.0177532266908107\n//       0.983277184415272\n//       0.483650274334313\n//       0.0219647376900375\n//       0.165910115077118\n//       0.572085966622497\n//       0.805291457942357\n//       0.927985211335116\n//       0.4228545699375\n//       0.523320379910674\n//       0.157783938645285\n//       \n//       0.500193602172748\n//       0.0209461245783354\n//       0.465869495396442\n//       0.195512794514891\n//       0.928583675496552\n//       0.729333720509584\n//       0.381455668891527\n//       0.0508996467343064\n//       0.019261200921266\n//       0.258578445417145\n//       0.0177532266908107\n//       0.983277184415272\n//       0.483650274334313\n//       0.0219647376900375\n//       0.165910115077118\n//       0.572085966622497\n//       0.805291457942357\n//       0.927985211335116\n//       0.4228545699375\n//       0.523320379910674\n//       0.157783938645285\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Random#12\">Imports System.IO\n\nModule Example\n   Public Sub Main()\n      Dim seed As Integer = 100100\n      ShowRandomNumbers(seed)\n      Console.WriteLine()\n      \n      PersistSeed(seed)\n      \n      DisplayNewRandomNumbers() \n   End Sub\n   \n   Private Sub ShowRandomNumbers(seed As Integer)\n      Dim rnd As New Random(seed)\n      For ctr As Integer = 0 To 20\n         Console.WriteLine(rnd.NextDouble())\n      Next\n   End Sub\n   \n   Private Sub PersistSeed(seed As Integer)\n      Dim fs As New FileStream(&quot;.\\seed.dat&quot;, FileMode.Create)\n      Dim bin As New BinaryWriter(fs)\n      bin.Write(seed)\n      bin.Close()\n   End Sub\n   \n   Private Sub DisplayNewRandomNumbers()\n      Dim fs As New FileStream(&quot;.\\seed.dat&quot;, FileMode.Open)\n      Dim bin As New BinaryReader(fs)\n      Dim seed As Integer = bin.ReadInt32()\n      bin.Close()\n      \n      Dim rnd As New Random(seed)\n      For ctr As Integer = 0 To 20\n         Console.WriteLine(rnd.NextDouble())\n      Next\n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;       0.500193602172748\n&#39;       0.0209461245783354\n&#39;       0.465869495396442\n&#39;       0.195512794514891\n&#39;       0.928583675496552\n&#39;       0.729333720509584\n&#39;       0.381455668891527\n&#39;       0.0508996467343064\n&#39;       0.019261200921266\n&#39;       0.258578445417145\n&#39;       0.0177532266908107\n&#39;       0.983277184415272\n&#39;       0.483650274334313\n&#39;       0.0219647376900375\n&#39;       0.165910115077118\n&#39;       0.572085966622497\n&#39;       0.805291457942357\n&#39;       0.927985211335116\n&#39;       0.4228545699375\n&#39;       0.523320379910674\n&#39;       0.157783938645285\n&#39;       \n&#39;       0.500193602172748\n&#39;       0.0209461245783354\n&#39;       0.465869495396442\n&#39;       0.195512794514891\n&#39;       0.928583675496552\n&#39;       0.729333720509584\n&#39;       0.381455668891527\n&#39;       0.0508996467343064\n&#39;       0.019261200921266\n&#39;       0.258578445417145\n&#39;       0.0177532266908107\n&#39;       0.983277184415272\n&#39;       0.483650274334313\n&#39;       0.0219647376900375\n&#39;       0.165910115077118\n&#39;       0.572085966622497\n&#39;       0.805291457942357\n&#39;       0.927985211335116\n&#39;       0.4228545699375\n&#39;       0.523320379910674\n&#39;       0.157783938645285\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Random#12\">using namespace System;\nusing namespace System::IO;\n\nref class RandomMethods\n{\ninternal:\n   static void ShowRandomNumbers(int seed)\n   {\n      Random^ rnd = gcnew Random(seed);\n      for (int ctr = 0; ctr &lt;= 20; ctr++)\n         Console::WriteLine(rnd-&gt;NextDouble());\n   }\n   \n   static void PersistSeed(int seed)\n   {\n      FileStream^ fs = gcnew FileStream(&quot;.\\\\seed.dat&quot;, FileMode::Create);\n      BinaryWriter^ bin = gcnew BinaryWriter(fs);\n      bin-&gt;Write(seed);\n      bin-&gt;Close();\n   }\n   \n   static void DisplayNewRandomNumbers()\n   {\n      FileStream^ fs = gcnew FileStream(&quot;.\\\\seed.dat&quot;, FileMode::Open);\n      BinaryReader^ bin = gcnew BinaryReader(fs);\n      int seed = bin-&gt;ReadInt32();\n      bin-&gt;Close();\n      \n      Random^ rnd = gcnew Random(seed);\n      for (int ctr = 0; ctr &lt;= 20; ctr++)\n         Console::WriteLine(rnd-&gt;NextDouble());\n   }\n};\n\nvoid main()\n{\n   int seed = 100100;\n   RandomMethods::ShowRandomNumbers(seed);\n   Console::WriteLine();\n\n   RandomMethods::PersistSeed(seed);\n\n   RandomMethods::DisplayNewRandomNumbers();\n}\n// The example displays output like the following:\n//       0.500193602172748\n//       0.0209461245783354\n//       0.465869495396442\n//       0.195512794514891\n//       0.928583675496552\n//       0.729333720509584\n//       0.381455668891527\n//       0.0508996467343064\n//       0.019261200921266\n//       0.258578445417145\n//       0.0177532266908107\n//       0.983277184415272\n//       0.483650274334313\n//       0.0219647376900375\n//       0.165910115077118\n//       0.572085966622497\n//       0.805291457942357\n//       0.927985211335116\n//       0.4228545699375\n//       0.523320379910674\n//       0.157783938645285\n//       \n//       0.500193602172748\n//       0.0209461245783354\n//       0.465869495396442\n//       0.195512794514891\n//       0.928583675496552\n//       0.729333720509584\n//       0.381455668891527\n//       0.0508996467343064\n//       0.019261200921266\n//       0.258578445417145\n//       0.0177532266908107\n//       0.983277184415272\n//       0.483650274334313\n//       0.0219647376900375\n//       0.165910115077118\n//       0.572085966622497\n//       0.805291457942357\n//       0.927985211335116\n//       0.4228545699375\n//       0.523320379910674\n//       0.157783938645285\n</code></pre><p><a name=\"Unique\"></a>   </p>\n<h3 id=\"retrieve-unique-sequences-of-random-numbers\">Retrieve unique sequences of random numbers</h3>\n<p> Providing different seed values to instances of the Random class causes each random number generator to produce a different sequence of values. You can provide a seed value either explicitly by calling the <a class=\"xref\" href=\"system.random#System_Random__ctor_System_Int32_\" data-linktype=\"relative-path\">Random(Int32)</a> constructor, or implicitly by calling the <a class=\"xref\" href=\"system.random#System_Random__ctor\" data-linktype=\"relative-path\">Random()</a> constructor. Most developers call the parameterless constructor, which uses the system clock. The following example uses this approach to instantiate two Random instances. Each instance displays a series of 10 random integers.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Random#13\">using namespace System;\nusing namespace System::Threading;\n\nvoid main()\n{\n   Console::WriteLine(&quot;Instantiating two random number generators...&quot;);\n   Random^ rnd1 = gcnew Random();\n   Thread::Sleep(2000);\n   Random^ rnd2 = gcnew Random();\n   \n   Console::WriteLine(&quot;\\nThe first random number generator:&quot;);\n   for (int ctr = 1; ctr &lt;= 10; ctr++)\n      Console::WriteLine(&quot;   {0}&quot;, rnd1-&gt;Next());\n\n   Console::WriteLine(&quot;\\nThe second random number generator:&quot;);\n   for (int ctr = 1; ctr &lt;= 10; ctr++)\n      Console::WriteLine(&quot;   {0}&quot;, rnd2-&gt;Next());\n}\n// The example displays output like the following:\n//       Instantiating two random number generators...\n//       \n//       The first random number generator:\n//          643164361\n//          1606571630\n//          1725607587\n//          2138048432\n//          496874898\n//          1969147632\n//          2034533749\n//          1840964542\n//          412380298\n//          47518930\n//       \n//       The second random number generator:\n//          1251659083\n//          1514185439\n//          1465798544\n//          517841554\n//          1821920222\n//          195154223\n//          1538948391\n//          1548375095\n//          546062716\n//          897797880\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Random#13\">using System;\nusing System.Threading;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Console.WriteLine(&quot;Instantiating two random number generators...&quot;);\n      Random rnd1 = new Random();\n      Thread.Sleep(2000);\n      Random rnd2 = new Random();\n      \n      Console.WriteLine(&quot;\\nThe first random number generator:&quot;);\n      for (int ctr = 1; ctr &lt;= 10; ctr++)\n         Console.WriteLine(&quot;   {0}&quot;, rnd1.Next());\n\n      Console.WriteLine(&quot;\\nThe second random number generator:&quot;);\n      for (int ctr = 1; ctr &lt;= 10; ctr++)\n         Console.WriteLine(&quot;   {0}&quot;, rnd2.Next());\n   }\n}\n// The example displays output like the following:\n//       Instantiating two random number generators...\n//       \n//       The first random number generator:\n//          643164361\n//          1606571630\n//          1725607587\n//          2138048432\n//          496874898\n//          1969147632\n//          2034533749\n//          1840964542\n//          412380298\n//          47518930\n//       \n//       The second random number generator:\n//          1251659083\n//          1514185439\n//          1465798544\n//          517841554\n//          1821920222\n//          195154223\n//          1538948391\n//          1548375095\n//          546062716\n//          897797880\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Random#13\">Imports System.Threading\n\nModule Example\n   Public Sub Main()\n      Console.WriteLine(&quot;Instantiating two random number generators...&quot;)\n      Dim rnd1 As New Random()\n      Thread.Sleep(2000)\n      Dim rnd2 As New Random()\n      Console.WriteLine()\n      \n      Console.WriteLine(&quot;The first random number generator:&quot;)\n      For ctr As Integer = 1 To 10\n         Console.WriteLine(&quot;   {0}&quot;, rnd1.Next())\n      Next  \n      Console.WriteLine()\n       \n      Console.WriteLine(&quot;The second random number generator:&quot;)\n      For ctr As Integer = 1 To 10\n         Console.WriteLine(&quot;   {0}&quot;, rnd2.Next())\n      Next   \n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;       Instantiating two random number generators...\n&#39;       \n&#39;       The first random number generator:\n&#39;          643164361\n&#39;          1606571630\n&#39;          1725607587\n&#39;          2138048432\n&#39;          496874898\n&#39;          1969147632\n&#39;          2034533749\n&#39;          1840964542\n&#39;          412380298\n&#39;          47518930\n&#39;       \n&#39;       The second random number generator:\n&#39;          1251659083\n&#39;          1514185439\n&#39;          1465798544\n&#39;          517841554\n&#39;          1821920222\n&#39;          195154223\n&#39;          1538948391\n&#39;          1548375095\n&#39;          546062716\n&#39;          897797880\n</code></pre><p> However, because of its finite resolution, the system clock doesn&#39;t detect time differences that are less than approximately 15 milliseconds. Therefore, if your code calls the <a class=\"xref\" href=\"system.random#System_Random__ctor\" data-linktype=\"relative-path\">Random()</a> overload to instantiate two Random objects in succession, you might inadvertently be providing the objects with identical seed values. To see this in the previous example, comment out the <a class=\"xref\" href=\"system.threading.thread#System_Threading_Thread_Sleep_\" data-linktype=\"relative-path\">Sleep</a> method call, and compile and run the example again.  </p>\n<p> To prevent this from happening, we recommend that you instantiate a single Random object rather than multiple ones. However, since Random isn&#39;t thread safe, you must use some synchronization device if you access a Random instance from multiple threads; for more information, see <a href=\"#ThreadSafety\" data-linktype=\"self-bookmark\">The Random class and thread safety</a> earlier in this topic. Alternately, you can use a delay mechanism, such as the <a class=\"xref\" href=\"system.threading.thread#System_Threading_Thread_Sleep_\" data-linktype=\"relative-path\">Sleep</a> method used in the previous example, to ensure that the instantiations occur more than 15 millisecond apart.  </p>\n<p><a name=\"Range\"></a>   </p>\n<h3 id=\"retrieve-integers-in-a-specified-range\">Retrieve integers in a specified range</h3>\n<p> You can retrieve integers in a specified range by calling the <a class=\"xref\" href=\"system.random#System_Random_Next_System_Int32_System_Int32_\" data-linktype=\"relative-path\">Next(Int32,Int32)</a> method, which lets you specify both the lower and the upper bound of the numbers you&#39;d like the random number generator to return. The upper bound is an exclusive, not an inclusive, value. That is, it isn&#39;t included in the range of values returned by the method. The following example uses this method to generate random integers between -10 and 10. Note that it specifies 11, which is one greater than the desired value, as the value of the <code>maxValue</code> argument in the method call.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Random#15\">using namespace System;\n\nvoid main()\n{\n   Random^ rnd = gcnew Random();\n   for (int ctr = 1; ctr &lt;= 15; ctr++) {\n      Console::Write(&quot;{0,3}    &quot;, rnd-&gt;Next(-10, 11));\n      if(ctr % 5 == 0) Console::WriteLine();\n   }\n}\n// The example displays output like the following:\n//        -2     -5     -1     -2     10\n//        -3      6     -4     -8      3\n//        -7     10      5     -2      4\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Random#15\">using System;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Random rnd = new Random();\n      for (int ctr = 1; ctr &lt;= 15; ctr++) {\n         Console.Write(&quot;{0,3}    &quot;, rnd.Next(-10, 11));\n         if(ctr % 5 == 0) Console.WriteLine();\n      }   \n   }\n}\n// The example displays output like the following:\n//        -2     -5     -1     -2     10\n//        -3      6     -4     -8      3\n//        -7     10      5     -2      4\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Random#15\">Module Example\n   Public Sub Main()\n      Dim rnd As New Random()\n      For ctr As Integer = 1 To 15\n         Console.Write(&quot;{0,3}    &quot;, rnd.Next(-10, 11))\n         If ctr Mod 5 = 0 Then Console.WriteLine()\n      Next   \n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;        -2     -5     -1     -2     10\n&#39;        -3      6     -4     -8      3\n&#39;        -7     10      5     -2      4\n</code></pre><p><a name=\"Digits\"></a>   </p>\n<h3 id=\"retrieve-integers-with-a-specified-number-of-digits\">Retrieve integers with a specified number of digits</h3>\n<p> You can call the <a class=\"xref\" href=\"system.random#System_Random_Next_System_Int32_System_Int32_\" data-linktype=\"relative-path\">Next(Int32,Int32)</a> method to retrieve numbers with a specified number of digits. For example, to retrieve numbers with four digits (that is, numbers that range from 1000 to 9999), you call the <a class=\"xref\" href=\"system.random#System_Random_Next_System_Int32_System_Int32_\" data-linktype=\"relative-path\">Next(Int32,Int32)</a> method with a <code>minValue</code> value of 1000 and a <code>maxValue</code> value of 10000, as the following example shows.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Random#16\">using namespace System;\n\nvoid main()\n{\n   Random^ rnd = gcnew Random();\n   for (int ctr = 1; ctr &lt;= 50; ctr++) {\n      Console::Write(&quot;{0,3}   &quot;, rnd-&gt;Next(1000, 10000));\n      if(ctr % 10 == 0) Console::WriteLine();\n   }   \n}\n// The example displays output like the following:\n//    9570    8979    5770    1606    3818    4735    8495    7196    7070    2313\n//    5279    6577    5104    5734    4227    3373    7376    6007    8193    5540\n//    7558    3934    3819    7392    1113    7191    6947    4963    9179    7907\n//    3391    6667    7269    1838    7317    1981    5154    7377    3297    5320\n//    9869    8694    2684    4949    2999    3019    2357    5211    9604    2593\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Random#16\">using System;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Random rnd = new Random();\n      for (int ctr = 1; ctr &lt;= 50; ctr++) {\n         Console.Write(&quot;{0,3}    &quot;, rnd.Next(1000, 10000));\n         if(ctr % 10 == 0) Console.WriteLine();\n      }   \n   }\n}\n// The example displays output like the following:\n//    9570    8979    5770    1606    3818    4735    8495    7196    7070    2313\n//    5279    6577    5104    5734    4227    3373    7376    6007    8193    5540\n//    7558    3934    3819    7392    1113    7191    6947    4963    9179    7907\n//    3391    6667    7269    1838    7317    1981    5154    7377    3297    5320\n//    9869    8694    2684    4949    2999    3019    2357    5211    9604    2593\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Random#16\">Module Example\n   Public Sub Main()\n      Dim rnd As New Random()\n      For ctr As Integer = 1 To 50\n         Console.Write(&quot;{0,3}    &quot;, rnd.Next(1000, 10000))\n         If ctr Mod 10 = 0 Then Console.WriteLine()\n      Next   \n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;    9570    8979    5770    1606    3818    4735    8495    7196    7070    2313\n&#39;    5279    6577    5104    5734    4227    3373    7376    6007    8193    5540\n&#39;    7558    3934    3819    7392    1113    7191    6947    4963    9179    7907\n&#39;    3391    6667    7269    1838    7317    1981    5154    7377    3297    5320\n&#39;    9869    8694    2684    4949    2999    3019    2357    5211    9604    2593\n</code></pre><p><a name=\"Floats\"></a>   </p>\n<h3 id=\"retrieve-floating-point-values-in-a-specified-range\">Retrieve floating-point values in a specified range</h3>\n<p> The <a class=\"xref\" href=\"system.random#System_Random_NextDouble_\" data-linktype=\"relative-path\">NextDouble</a> method returns random floating-point values that range from 0 to less than 1. However, you&#39;ll often want to generate random values in some other range.  </p>\n<p> If the interval between the minimum and maximum desired values is 1, you can add the difference between the desired starting interval and 0 to the number returned by the <a class=\"xref\" href=\"system.random#System_Random_NextDouble_\" data-linktype=\"relative-path\">NextDouble</a> method. The following example does this to generate 10 random numbers between -1 and 0.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Random#17\">Module Example\n   Public Sub Main()\n      Dim rnd As New Random()\n      For ctr As Integer = 1 To 10\n         Console.WriteLine(rnd.NextDouble() - 1)\n      Next\n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;       -0.930412760437658\n&#39;       -0.164699016215605\n&#39;       -0.9851692803135\n&#39;       -0.43468508843085\n&#39;       -0.177202483255976\n&#39;       -0.776813320245972\n&#39;       -0.0713201854710096\n&#39;       -0.0912875561468711\n&#39;       -0.540621722368813\n&#39;       -0.232211863730201\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Random#17\">using namespace System;\n\nvoid main()\n{\n   Random^ rnd = gcnew Random();\n   for (int ctr = 1; ctr &lt;= 10; ctr++)\n      Console::WriteLine(rnd-&gt;NextDouble() - 1);\n}\n// The example displays output like the following:\n//       -0.930412760437658\n//       -0.164699016215605\n//       -0.9851692803135\n//       -0.43468508843085\n//       -0.177202483255976\n//       -0.776813320245972\n//       -0.0713201854710096\n//       -0.0912875561468711\n//       -0.540621722368813\n//       -0.232211863730201\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Random#17\">using System;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Random rnd = new Random();\n      for (int ctr = 1; ctr &lt;= 10; ctr++)\n         Console.WriteLine(rnd.NextDouble() - 1);\n   }\n}\n// The example displays output like the following:\n//       -0.930412760437658\n//       -0.164699016215605\n//       -0.9851692803135\n//       -0.43468508843085\n//       -0.177202483255976\n//       -0.776813320245972\n//       -0.0713201854710096\n//       -0.0912875561468711\n//       -0.540621722368813\n//       -0.232211863730201\n</code></pre><p> To generate random floating-point numbers whose lower bound is 0 but upper bound is greater than 1 (or, in the case of negative numbers, whose lower bound is less than -1 and upper bound is 0), multiply the random number by the non-zero bound. The following example does this to generate 20 million random floating-point numbers that range from 0 to <a class=\"xref\" href=\"system.int64#System_Int64_MaxValue\" data-linktype=\"relative-path\">System.Int64.MaxValue</a>. In also displays the distribution of the random values generated by the method.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Random#18\">using namespace System;\n\nvoid main()\n{\n   const Int64 ONE_TENTH = 922337203685477581;\n   Random^ rnd = gcnew Random();\n   double number;\n   array&lt;int&gt;^ count = gcnew array&lt;int&gt;(10);\n   \n   // Generate 20 million integer values between.\n   for (int ctr = 1; ctr &lt;= 20000000; ctr++) {\n      number = rnd-&gt;NextDouble() * Int64::MaxValue;\n      // Categorize random numbers into 10 groups.\n      int value = (int) (number / ONE_TENTH);\n      count[value]++;\n   }\n\n   // Display breakdown by range.\n   Console::WriteLine(&quot;{0,28} {1,32}   {2,7}\\n&quot;, &quot;Range&quot;, &quot;Count&quot;, &quot;Pct.&quot;);\n   for (int ctr = 0; ctr &lt;= 9; ctr++)\n      Console::WriteLine(&quot;{0,25:N0}-{1,25:N0}  {2,8:N0}   {3,7:P2}&quot;, ctr * ONE_TENTH,\n                         ctr &lt; 9 ? ctr * ONE_TENTH + ONE_TENTH - 1 : Int64::MaxValue,\n                         count[ctr], count[ctr]/20000000.0);\n}\n// The example displays output like the following:\n//                           Range                            Count      Pct.\n//    \n//                            0-  922,337,203,685,477,580  1,996,148    9.98 %\n//      922,337,203,685,477,581-1,844,674,407,370,955,161  2,000,293   10.00 %\n//    1,844,674,407,370,955,162-2,767,011,611,056,432,742  2,000,094   10.00 %\n//    2,767,011,611,056,432,743-3,689,348,814,741,910,323  2,000,159   10.00 %\n//    3,689,348,814,741,910,324-4,611,686,018,427,387,904  1,999,552   10.00 %\n//    4,611,686,018,427,387,905-5,534,023,222,112,865,485  1,998,248    9.99 %\n//    5,534,023,222,112,865,486-6,456,360,425,798,343,066  2,000,696   10.00 %\n//    6,456,360,425,798,343,067-7,378,697,629,483,820,647  2,001,637   10.01 %\n//    7,378,697,629,483,820,648-8,301,034,833,169,298,228  2,002,870   10.01 %\n//    8,301,034,833,169,298,229-9,223,372,036,854,775,807  2,000,303   10.00 %\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Random#18\">using System;\n\npublic class Example\n{\n   public static void Main()\n   {\n      const long ONE_TENTH = 922337203685477581;\n\n      Random rnd = new Random();\n      double number;\n      int[] count = new int[10];\n      \n      // Generate 20 million integer values between.\n      for (int ctr = 1; ctr &lt;= 20000000; ctr++) {\n         number = rnd.NextDouble() * Int64.MaxValue;\n         // Categorize random numbers into 10 groups.\n         count[(int) (number / ONE_TENTH)]++;\n      }\n      // Display breakdown by range.\n      Console.WriteLine(&quot;{0,28} {1,32}   {2,7}\\n&quot;, &quot;Range&quot;, &quot;Count&quot;, &quot;Pct.&quot;);\n      for (int ctr = 0; ctr &lt;= 9; ctr++)\n         Console.WriteLine(&quot;{0,25:N0}-{1,25:N0}  {2,8:N0}   {3,7:P2}&quot;, ctr * ONE_TENTH,\n                            ctr &lt; 9 ? ctr * ONE_TENTH + ONE_TENTH - 1 : Int64.MaxValue, \n                            count[ctr], count[ctr]/20000000.0);\n   }\n}\n// The example displays output like the following:\n//                           Range                            Count      Pct.\n//    \n//                            0-  922,337,203,685,477,580  1,996,148    9.98 %\n//      922,337,203,685,477,581-1,844,674,407,370,955,161  2,000,293   10.00 %\n//    1,844,674,407,370,955,162-2,767,011,611,056,432,742  2,000,094   10.00 %\n//    2,767,011,611,056,432,743-3,689,348,814,741,910,323  2,000,159   10.00 %\n//    3,689,348,814,741,910,324-4,611,686,018,427,387,904  1,999,552   10.00 %\n//    4,611,686,018,427,387,905-5,534,023,222,112,865,485  1,998,248    9.99 %\n//    5,534,023,222,112,865,486-6,456,360,425,798,343,066  2,000,696   10.00 %\n//    6,456,360,425,798,343,067-7,378,697,629,483,820,647  2,001,637   10.01 %\n//    7,378,697,629,483,820,648-8,301,034,833,169,298,228  2,002,870   10.01 %\n//    8,301,034,833,169,298,229-9,223,372,036,854,775,807  2,000,303   10.00 %\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Random#18\">Module Example\n   Public Sub Main()\n      Const ONE_TENTH As Long = 922337203685477581\n\n      Dim rnd As New Random()\n      Dim number As Long\n      Dim count(9) As Integer\n      \n      &#39; Generate 20 million integer values.\n      For ctr As Integer = 1 To 20000000\n         number = CLng(rnd.NextDouble() * Int64.MaxValue)\n         &#39; Categorize random numbers.\n         count(CInt(number \\ ONE_TENTH)) += 1\n      Next\n      &#39; Display breakdown by range.\n      Console.WriteLine(&quot;{0,28} {1,32}   {2,7}&quot;, &quot;Range&quot;, &quot;Count&quot;, &quot;Pct.&quot;)\n      Console.WriteLine()\n      For ctr As Integer = 0 To 9\n         Console.WriteLine(&quot;{0,25:N0}-{1,25:N0}  {2,8:N0}   {3,7:P2}&quot;, ctr * ONE_TENTH,\n                            If(ctr &lt; 9, ctr * ONE_TENTH + ONE_TENTH - 1, Int64.MaxValue), \n                            count(ctr), count(ctr)/20000000)\n      Next\n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;                           Range                            Count      Pct.\n&#39;    \n&#39;                            0-  922,337,203,685,477,580  1,996,148    9.98 %\n&#39;      922,337,203,685,477,581-1,844,674,407,370,955,161  2,000,293   10.00 %\n&#39;    1,844,674,407,370,955,162-2,767,011,611,056,432,742  2,000,094   10.00 %\n&#39;    2,767,011,611,056,432,743-3,689,348,814,741,910,323  2,000,159   10.00 %\n&#39;    3,689,348,814,741,910,324-4,611,686,018,427,387,904  1,999,552   10.00 %\n&#39;    4,611,686,018,427,387,905-5,534,023,222,112,865,485  1,998,248    9.99 %\n&#39;    5,534,023,222,112,865,486-6,456,360,425,798,343,066  2,000,696   10.00 %\n&#39;    6,456,360,425,798,343,067-7,378,697,629,483,820,647  2,001,637   10.01 %\n&#39;    7,378,697,629,483,820,648-8,301,034,833,169,298,228  2,002,870   10.01 %\n&#39;    8,301,034,833,169,298,229-9,223,372,036,854,775,807  2,000,303   10.00 %\n</code></pre><p> To generate random floating-point numbers between two arbitrary values, like the <a class=\"xref\" href=\"system.random#System_Random_Next_System_Int32_System_Int32_\" data-linktype=\"relative-path\">Next(Int32,Int32)</a> method does for integers, use the following formula:  </p>\n<pre><code>Random.NextDouble() * (maxValue â€“ minValue) + minValue  \n</code></pre><p> The following example generates 1 million random numbers that range from 10.0 to 11.0, and displays their distribution.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Random#19\">using namespace System;\n\nvoid main()\n{\n   Random^ rnd = gcnew Random();\n   int lowerBound = 10;\n   int upperBound = 11;\n   array&lt;int&gt;^ range = gcnew array&lt;int&gt;(10);\n   for (int ctr = 1; ctr &lt;= 1000000; ctr++) {\n      Double value = rnd-&gt;NextDouble() * (upperBound - lowerBound) + lowerBound;\n      range[(int) Math::Truncate((value - lowerBound) * 10)]++;\n   }\n   \n   for (int ctr = 0; ctr &lt;= 9; ctr++) {\n      Double lowerRange = 10 + ctr * .1;\n      Console::WriteLine(&quot;{0:N1} to {1:N1}: {2,8:N0}  ({3,7:P2})&quot;,\n                         lowerRange, lowerRange + .1, range[ctr],\n                         range[ctr] / 1000000.0);\n   } \n}\n// The example displays output like the following:\n//       10.0 to 10.1:   99,929  ( 9.99 %)\n//       10.1 to 10.2:  100,189  (10.02 %)\n//       10.2 to 10.3:   99,384  ( 9.94 %)\n//       10.3 to 10.4:  100,240  (10.02 %)\n//       10.4 to 10.5:   99,397  ( 9.94 %)\n//       10.5 to 10.6:  100,580  (10.06 %)\n//       10.6 to 10.7:  100,293  (10.03 %)\n//       10.7 to 10.8:  100,135  (10.01 %)\n//       10.8 to 10.9:   99,905  ( 9.99 %)\n//       10.9 to 11.0:   99,948  ( 9.99 %)\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Random#19\">using System;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Random rnd = new Random();\n      int lowerBound = 10;\n      int upperBound = 11;\n      int[] range = new int[10];\n      for (int ctr = 1; ctr &lt;= 1000000; ctr++) {\n         Double value = rnd.NextDouble() * (upperBound - lowerBound) + lowerBound;\n         range[(int) Math.Truncate((value - lowerBound) * 10)]++; \n      }\n      \n      for (int ctr = 0; ctr &lt;= 9; ctr++) {\n         Double lowerRange = 10 + ctr * .1;\n         Console.WriteLine(&quot;{0:N1} to {1:N1}: {2,8:N0}  ({3,7:P2})&quot;, \n                           lowerRange, lowerRange + .1, range[ctr], \n                           range[ctr] / 1000000.0);\n      } \n   }\n}\n// The example displays output like the following:\n//       10.0 to 10.1:   99,929  ( 9.99 %)\n//       10.1 to 10.2:  100,189  (10.02 %)\n//       10.2 to 10.3:   99,384  ( 9.94 %)\n//       10.3 to 10.4:  100,240  (10.02 %)\n//       10.4 to 10.5:   99,397  ( 9.94 %)\n//       10.5 to 10.6:  100,580  (10.06 %)\n//       10.6 to 10.7:  100,293  (10.03 %)\n//       10.7 to 10.8:  100,135  (10.01 %)\n//       10.8 to 10.9:   99,905  ( 9.99 %)\n//       10.9 to 11.0:   99,948  ( 9.99 %)\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Random#19\">Module Example\n   Public Sub Main()\n      Dim rnd As New Random()\n      Dim lowerBound As Integer = 10\n      Dim upperBound As Integer = 11\n      Dim range(9) As Integer\n      For ctr As Integer = 1 To 1000000\n         Dim value As Double = rnd.NextDouble() * (upperBound - lowerBound) + lowerBound\n         range(CInt(Math.Truncate((value - lowerBound) * 10))) += 1 \n      Next\n      \n      For ctr As Integer = 0 To 9\n         Dim lowerRange As Double = 10 + ctr * .1\n         Console.WriteLine(&quot;{0:N1} to {1:N1}: {2,8:N0}  ({3,7:P2})&quot;, \n                           lowerRange, lowerRange + .1, range(ctr), \n                           range(ctr) / 1000000.0)\n      Next \n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;       10.0 to 10.1:   99,929  ( 9.99 %)\n&#39;       10.1 to 10.2:  100,189  (10.02 %)\n&#39;       10.2 to 10.3:   99,384  ( 9.94 %)\n&#39;       10.3 to 10.4:  100,240  (10.02 %)\n&#39;       10.4 to 10.5:   99,397  ( 9.94 %)\n&#39;       10.5 to 10.6:  100,580  (10.06 %)\n&#39;       10.6 to 10.7:  100,293  (10.03 %)\n&#39;       10.7 to 10.8:  100,135  (10.01 %)\n&#39;       10.8 to 10.9:   99,905  ( 9.99 %)\n&#39;       10.9 to 11.0:   99,948  ( 9.99 %)\n</code></pre><p><a name=\"Boolean\"></a>   </p>\n<h3 id=\"generate-random-boolean-values\">Generate random Boolean values</h3>\n<p> The Random class doesn&#39;t provide methods that generate <a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a> values. However, you can define your own class or method to do that. The following example defines a class, <code>BooleanGenerator</code>, with a single method, <code>NextBoolean</code>. The <code>BooleanGenerator</code> class stores a Random object as a private variable. The <code>NextBoolean</code> method calls the <a class=\"xref\" href=\"system.random#System_Random_Next_System_Int32_System_Int32_\" data-linktype=\"relative-path\">System.Random.Next(Int32,Int32)</a> method and passes the result to the <a class=\"xref\" href=\"system.convert#System_Convert_ToBoolean_System_Int32_\" data-linktype=\"relative-path\">System.Convert.ToBoolean(Int32)</a> method. Note that 2 is used as the argument to specify the upper bound of the random number. Since this is an exclusive value, the method call returns either 0 or 1.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Random#8\">using namespace System;\n\npublic ref class BooleanGenerator\n{\n   private:\n      Random^ rnd;\n\n   public:\n      BooleanGenerator()\n      {\n         rnd = gcnew Random();\n      }\n\n      bool NextBoolean()\n      {\n         return Convert::ToBoolean(rnd-&gt;Next(0, 2));\n      }\n};\n\nvoid main()\n{\n   // Instantiate the Boolean generator.\n   BooleanGenerator^ boolGen = gcnew BooleanGenerator();\n   int totalTrue = 0, totalFalse = 0;\n   \n   // Generate 1,0000 random Booleans, and keep a running total.\n   for (int ctr = 0; ctr &lt; 1000000; ctr++) {\n       bool value = boolGen-&gt;NextBoolean();\n       if (value)\n          totalTrue++;\n       else\n          totalFalse++;\n   }\n   Console::WriteLine(&quot;Number of true values:  {0,7:N0} ({1:P3})&quot;,\n                      totalTrue,\n                      ((double) totalTrue)/(totalTrue + totalFalse));\n   Console::WriteLine(&quot;Number of false values: {0,7:N0} ({1:P3})&quot;,\n                     totalFalse, \n                     ((double) totalFalse)/(totalTrue + totalFalse));\n}\n\n// The example displays output like the following:\n//       Number of true values:  500,004 (50.000 %)\n//       Number of false values: 499,996 (50.000 %)\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Random#8\">using System;\n\npublic class Example\n{\n   public static void Main()\n   {\n      // Instantiate the Boolean generator.\n      BooleanGenerator boolGen = new BooleanGenerator();\n      int totalTrue = 0, totalFalse = 0;\n      \n      // Generate 1,0000 random Booleans, and keep a running total.\n      for (int ctr = 0; ctr &lt; 1000000; ctr++) {\n          bool value = boolGen.NextBoolean();\n          if (value)\n             totalTrue++;\n          else\n             totalFalse++;\n      }\n      Console.WriteLine(&quot;Number of true values:  {0,7:N0} ({1:P3})&quot;, \n                        totalTrue, \n                        ((double) totalTrue)/(totalTrue + totalFalse));\n      Console.WriteLine(&quot;Number of false values: {0,7:N0} ({1:P3})&quot;, \n                        totalFalse, \n                        ((double) totalFalse)/(totalTrue + totalFalse));\n   }\n}\n\npublic class BooleanGenerator\n{\n   Random rnd;\n   \n   public BooleanGenerator()\n   {\n      rnd = new Random();\n   }\n\n   public bool NextBoolean()\n   {\n      return Convert.ToBoolean(rnd.Next(0, 2));\n   }\n}\n// The example displays output like the following:\n//       Number of true values:  500,004 (50.000 %)\n//       Number of false values: 499,996 (50.000 %)\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Random#8\">Module Example\n   Public Sub Main()\n      &#39; Instantiate the Boolean generator.\n      Dim boolGen As New BooleanGenerator()\n      Dim totalTrue, totalFalse As Integer \n      \n      &#39; Generate 1,0000 random Booleans, and keep a running total.\n      For ctr As Integer = 0 To 9999999\n          Dim value As Boolean = boolGen.NextBoolean()\n          If value Then\n             totalTrue += 1\n          Else\n             totalFalse += 1\n          End If\n      Next\n      Console.WriteLine(&quot;Number of true values:  {0,7:N0} ({1:P3})&quot;, \n                        totalTrue, \n                        totalTrue/(totalTrue + totalFalse))\n      Console.WriteLine(&quot;Number of false values: {0,7:N0} ({1:P3})&quot;, \n                        totalFalse, \n                        totalFalse/(totalTrue + totalFalse))\n   End Sub                     \nEnd Module\n\nPublic Class BooleanGenerator\n   Dim rnd As Random\n   \n   Public Sub New()\n      rnd = New Random()\n   End Sub\n\n   Public Function NextBoolean() As Boolean\n      Return Convert.ToBoolean(rnd.Next(0, 2))\n   End Function\nEnd Class\n&#39; The example displays the following output:\n&#39;       Number of true values:  500,004 (50.000 %)\n&#39;       Number of false values: 499,996 (50.000 %)\n</code></pre><p> Instead of creating a separate class to generate random <a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a> values, the example could simply have defined a single method. In that case, however, the Random object should have been defined as a class-level variable to avoid instantiating a new Random instance in each method call. In Visual Basic, the Random instance can be defined as a <a href=\"../Topic/Static%20(Visual%20Basic).md\" data-linktype=\"relative-path\">Static</a> variable in the <code>NextBoolean</code> method.  The following example provides an implementation.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Random#20\">using namespace System;\n\nref class Example\n{\nprivate:\n   static Random^ rnd = gcnew Random();\n\npublic:\n   static void Execute()\n   {\n      int totalTrue = 0, totalFalse = 0;\n      \n      // Generate 1,0000 random Booleans, and keep a running total.\n      for (int ctr = 0; ctr &lt; 1000000; ctr++) {\n          bool value = NextBoolean();\n          if (value)\n             totalTrue++;\n          else\n             totalFalse++;\n      }\n      Console::WriteLine(&quot;Number of true values:  {0,7:N0} ({1:P3})&quot;,\n                        totalTrue, \n                        ((double) totalTrue)/(totalTrue + totalFalse));\n      Console::WriteLine(&quot;Number of false values: {0,7:N0} ({1:P3})&quot;,\n                        totalFalse, \n                        ((double) totalFalse)/(totalTrue + totalFalse));\n   }\n\n   static bool NextBoolean()\n   {\n      return Convert::ToBoolean(rnd-&gt;Next(0, 2));\n   }\n};\n\nvoid main()\n{\n   Example::Execute();\n}\n// The example displays output like the following:\n//       Number of true values:  499,777 (49.978 %)\n//       Number of false values: 500,223 (50.022 %)\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Random#20\">using System;\n\npublic class Example\n{\n   private static Random rnd = new Random();\n\n   public static void Main()\n   {\n      int totalTrue = 0, totalFalse = 0;\n      \n      // Generate 1,0000 random Booleans, and keep a running total.\n      for (int ctr = 0; ctr &lt; 1000000; ctr++) {\n          bool value = NextBoolean();\n          if (value)\n             totalTrue++;\n          else\n             totalFalse++;\n      }\n      Console.WriteLine(&quot;Number of true values:  {0,7:N0} ({1:P3})&quot;, \n                        totalTrue, \n                        ((double) totalTrue)/(totalTrue + totalFalse));\n      Console.WriteLine(&quot;Number of false values: {0,7:N0} ({1:P3})&quot;, \n                        totalFalse, \n                        ((double) totalFalse)/(totalTrue + totalFalse));\n   }\n\n   public static bool NextBoolean()\n   {\n      return Convert.ToBoolean(rnd.Next(0, 2));\n   }\n}\n// The example displays output like the following:\n//       Number of true values:  499,777 (49.978 %)\n//       Number of false values: 500,223 (50.022 %)\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Random#20\">Module Example\n   Public Sub Main()\n      Dim totalTrue, totalFalse As Integer \n      \n      &#39; Generate 1,0000 random Booleans, and keep a running total.\n      For ctr As Integer = 0 To 9999999\n          Dim value As Boolean = NextBoolean()\n          If value Then\n             totalTrue += 1\n          Else\n             totalFalse += 1\n          End If\n      Next\n      Console.WriteLine(&quot;Number of true values:  {0,7:N0} ({1:P3})&quot;, \n                        totalTrue, \n                        totalTrue/(totalTrue + totalFalse))\n      Console.WriteLine(&quot;Number of false values: {0,7:N0} ({1:P3})&quot;, \n                        totalFalse, \n                        totalFalse/(totalTrue + totalFalse))\n   End Sub \n                       \n   Public Function NextBoolean() As Boolean\n      Static rnd As New Random()\n      Return Convert.ToBoolean(rnd.Next(0, 2))\n   End Function\nEnd Module\n&#39; The example displays the following output:\n&#39;       Number of true values:  499,777 (49.978 %)\n&#39;       Number of false values: 500,223 (50.022 %)\n</code></pre><p><a name=\"Long\"></a>   </p>\n<h3 id=\"generate-random-64-bit-integers\">Generate random 64-bit integers</h3>\n<p> The overloads of the <a class=\"xref\" href=\"system.random#System_Random_Next_\" data-linktype=\"relative-path\">Next</a> method return 32-bit integers. However, in some cases, you might want to work with 64-bit integers. You can do this as follows:  </p>\n<ol>\n<li><p>Call the <a class=\"xref\" href=\"system.random#System_Random_NextDouble_\" data-linktype=\"relative-path\">NextDouble</a> method to retrieve a double-precision floating point value.  </p>\n</li>\n<li><p>Multiply that value by <a class=\"xref\" href=\"system.int64#System_Int64_MaxValue\" data-linktype=\"relative-path\">System.Int64.MaxValue</a>.  </p>\n<p>The following example uses this technique to generate 20 million random long integers and categorizes them in 10 equal groups. It then evaluates the distribution of the random numbers by counting the number in each group from 0 to <a class=\"xref\" href=\"system.int64#System_Int64_MaxValue\" data-linktype=\"relative-path\">System.Int64.MaxValue</a>. As the output from the example shows, the numbers are distributed more or less equally through the range of a long integer.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Random#14\">using namespace System;\n\nvoid main()\n{\n   const Int64 ONE_TENTH = 922337203685477581;\n\n   Random^ rnd = gcnew Random();\n   Int64 number;\n   array&lt;int&gt;^ count = gcnew array&lt;int&gt;(10);\n   \n   // Generate 20 million long integers.\n   for (int ctr = 1; ctr &lt;= 20000000; ctr++) {\n      number = (Int64) (rnd-&gt;NextDouble() * Int64::MaxValue);\n      // Categorize random numbers.\n      count[(int) (number / ONE_TENTH)]++;\n   }\n   // Display breakdown by range.\n   Console::WriteLine(&quot;{0,28} {1,32}   {2,7}\\n&quot;, &quot;Range&quot;, &quot;Count&quot;, &quot;Pct.&quot;);\n   for (int ctr = 0; ctr &lt;= 9; ctr++)\n      Console::WriteLine(&quot;{0,25:N0}-{1,25:N0}  {2,8:N0}   {3,7:P2}&quot;, ctr * ONE_TENTH,\n                         ctr &lt; 9 ? ctr * ONE_TENTH + ONE_TENTH - 1 : Int64::MaxValue,\n                         count[ctr], count[ctr]/20000000.0);\n}\n// The example displays output like the following:\n//                           Range                            Count      Pct.\n//    \n//                            0-  922,337,203,685,477,580  1,996,148    9.98 %\n//      922,337,203,685,477,581-1,844,674,407,370,955,161  2,000,293   10.00 %\n//    1,844,674,407,370,955,162-2,767,011,611,056,432,742  2,000,094   10.00 %\n//    2,767,011,611,056,432,743-3,689,348,814,741,910,323  2,000,159   10.00 %\n//    3,689,348,814,741,910,324-4,611,686,018,427,387,904  1,999,552   10.00 %\n//    4,611,686,018,427,387,905-5,534,023,222,112,865,485  1,998,248    9.99 %\n//    5,534,023,222,112,865,486-6,456,360,425,798,343,066  2,000,696   10.00 %\n//    6,456,360,425,798,343,067-7,378,697,629,483,820,647  2,001,637   10.01 %\n//    7,378,697,629,483,820,648-8,301,034,833,169,298,228  2,002,870   10.01 %\n//    8,301,034,833,169,298,229-9,223,372,036,854,775,807  2,000,303   10.00 %\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Random#14\">Module Example\n   Public Sub Main()\n      Const ONE_TENTH As Long = 922337203685477581\n\n      Dim rnd As New Random()\n      Dim number As Long\n      Dim count(9) As Integer\n      \n      &#39; Generate 20 million long integers.\n      For ctr As Integer = 1 To 20000000\n         number = CLng(rnd.NextDouble() * Int64.MaxValue)\n         &#39; Categorize random numbers.\n         count(CInt(number \\ ONE_TENTH)) += 1\n      Next\n      &#39; Display breakdown by range.\n      Console.WriteLine(&quot;{0,28} {1,32}   {2,7}&quot;, &quot;Range&quot;, &quot;Count&quot;, &quot;Pct.&quot;)\n      Console.WriteLine()\n      For ctr As Integer = 0 To 9\n         Console.WriteLine(&quot;{0,25:N0}-{1,25:N0}  {2,8:N0}   {3,7:P2}&quot;, ctr * ONE_TENTH,\n                            If(ctr &lt; 9, ctr * ONE_TENTH + ONE_TENTH - 1, Int64.MaxValue), \n                            count(ctr), count(ctr)/20000000)\n      Next\n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;                           Range                            Count      Pct.\n&#39;    \n&#39;                            0-  922,337,203,685,477,580  1,996,148    9.98 %\n&#39;      922,337,203,685,477,581-1,844,674,407,370,955,161  2,000,293   10.00 %\n&#39;    1,844,674,407,370,955,162-2,767,011,611,056,432,742  2,000,094   10.00 %\n&#39;    2,767,011,611,056,432,743-3,689,348,814,741,910,323  2,000,159   10.00 %\n&#39;    3,689,348,814,741,910,324-4,611,686,018,427,387,904  1,999,552   10.00 %\n&#39;    4,611,686,018,427,387,905-5,534,023,222,112,865,485  1,998,248    9.99 %\n&#39;    5,534,023,222,112,865,486-6,456,360,425,798,343,066  2,000,696   10.00 %\n&#39;    6,456,360,425,798,343,067-7,378,697,629,483,820,647  2,001,637   10.01 %\n&#39;    7,378,697,629,483,820,648-8,301,034,833,169,298,228  2,002,870   10.01 %\n&#39;    8,301,034,833,169,298,229-9,223,372,036,854,775,807  2,000,303   10.00 %\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Random#14\">using System;\n\npublic class Example\n{\n   public static void Main()\n   {\n      const long ONE_TENTH = 922337203685477581;\n\n      Random rnd = new Random();\n      long number;\n      int[] count = new int[10];\n      \n      // Generate 20 million long integers.\n      for (int ctr = 1; ctr &lt;= 20000000; ctr++) {\n         number = (long) (rnd.NextDouble() * Int64.MaxValue);\n         // Categorize random numbers.\n         count[(int) (number / ONE_TENTH)]++;\n      }\n      // Display breakdown by range.\n      Console.WriteLine(&quot;{0,28} {1,32}   {2,7}\\n&quot;, &quot;Range&quot;, &quot;Count&quot;, &quot;Pct.&quot;);\n      for (int ctr = 0; ctr &lt;= 9; ctr++)\n         Console.WriteLine(&quot;{0,25:N0}-{1,25:N0}  {2,8:N0}   {3,7:P2}&quot;, ctr * ONE_TENTH,\n                            ctr &lt; 9 ? ctr * ONE_TENTH + ONE_TENTH - 1 : Int64.MaxValue, \n                            count[ctr], count[ctr]/20000000.0);\n   }\n}\n// The example displays output like the following:\n//                           Range                            Count      Pct.\n//    \n//                            0-  922,337,203,685,477,580  1,996,148    9.98 %\n//      922,337,203,685,477,581-1,844,674,407,370,955,161  2,000,293   10.00 %\n//    1,844,674,407,370,955,162-2,767,011,611,056,432,742  2,000,094   10.00 %\n//    2,767,011,611,056,432,743-3,689,348,814,741,910,323  2,000,159   10.00 %\n//    3,689,348,814,741,910,324-4,611,686,018,427,387,904  1,999,552   10.00 %\n//    4,611,686,018,427,387,905-5,534,023,222,112,865,485  1,998,248    9.99 %\n//    5,534,023,222,112,865,486-6,456,360,425,798,343,066  2,000,696   10.00 %\n//    6,456,360,425,798,343,067-7,378,697,629,483,820,647  2,001,637   10.01 %\n//    7,378,697,629,483,820,648-8,301,034,833,169,298,228  2,002,870   10.01 %\n//    8,301,034,833,169,298,229-9,223,372,036,854,775,807  2,000,303   10.00 %\n</code></pre><p>An alternative technique that uses bit manipulation does not generate truly random numbers. This technique calls <a class=\"xref\" href=\"system.random#System_Random_Next\" data-linktype=\"relative-path\">Next()</a> to generate two integers, left-shifts one by 32 bits, and ORs them together. This technique has two limitations:  </p>\n</li>\n<li><p>Because bit 31 is the sign bit, the value in bit 31 of the resulting long integer is always 0.  This can be addressed by generating a random 0 or 1, left-shifting it 31 bits, and ORing it with the original random long integer.  </p>\n</li>\n<li><p>More seriously, because the probability that the value returned by <a class=\"xref\" href=\"system.random#System_Random_Next\" data-linktype=\"relative-path\">Next()</a> will be 0, there will be few if any random numbers in the range 0x0-0x00000000FFFFFFFF.  </p>\n</li>\n</ol>\n<p><a name=\"Bytes\"></a>   </p>\n<h3 id=\"retrieve-bytes-in-a-specified-range\">Retrieve bytes in a specified range</h3>\n<p> The overloads of the <a class=\"xref\" href=\"system.random#System_Random_Next_\" data-linktype=\"relative-path\">Next</a> method allow you to specify the range of random numbers, but the <a class=\"xref\" href=\"system.random#System_Random_NextBytes_\" data-linktype=\"relative-path\">NextBytes</a> method does not. The following example implements a <code>NextBytes</code> method that lets you specify the range of the returned bytes. It defines a <code>Random2</code> class that derives from Random and overloads its <code>NextBytes</code> method.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Random#9\">using namespace System;\n\nref class Random2 : Random\n{\npublic:\n   Random2()\n   {}\n\n   Random2(int seed) : Random(seed)\n   {}\n\n   void NextBytes(array&lt;Byte&gt;^ bytes, Byte minValue, Byte maxValue)\n   {\n      for (int ctr = bytes-&gt;GetLowerBound(0); ctr &lt;= bytes-&gt;GetUpperBound(0); ctr++)\n         bytes[ctr] = (Byte) Next(minValue, maxValue);\n   }\n};\n\nvoid main()\n{\n    Random2^ rnd = gcnew Random2();\n    array&lt;Byte&gt;^ bytes = gcnew array&lt;Byte&gt;(10000);\n    array&lt;int&gt;^ total = gcnew array&lt;int&gt;(101);\n    rnd-&gt;NextBytes(bytes, 0, 101);\n\n    // Calculate how many of each value we have.\n    for each (Byte value in bytes)\n       total[value]++;\n\n    // Display the results.\n    for (int ctr = 0; ctr &lt; total-&gt;Length; ctr++) {\n        Console::Write(&quot;{0,3}: {1,-3}   &quot;, ctr, total[ctr]);\n        if ((ctr + 1) % 5 == 0) Console::WriteLine();\n    }\n}\n// The example displays output like the following:\n//         0: 115     1: 119     2: 92      3: 98      4: 92\n//         5: 102     6: 103     7: 84      8: 93      9: 116\n//        10: 91     11: 98     12: 106    13: 91     14: 92\n//        15: 101    16: 100    17: 96     18: 97     19: 100\n//        20: 101    21: 106    22: 112    23: 82     24: 85\n//        25: 102    26: 107    27: 98     28: 106    29: 102\n//        30: 109    31: 108    32: 94     33: 101    34: 107\n//        35: 101    36: 86     37: 100    38: 101    39: 102\n//        40: 113    41: 95     42: 96     43: 89     44: 99\n//        45: 81     46: 89     47: 105    48: 100    49: 85\n//        50: 103    51: 103    52: 93     53: 89     54: 91\n//        55: 97     56: 105    57: 97     58: 110    59: 86\n//        60: 116    61: 94     62: 117    63: 98     64: 110\n//        65: 93     66: 102    67: 100    68: 105    69: 83\n//        70: 81     71: 97     72: 85     73: 70     74: 98\n//        75: 100    76: 110    77: 114    78: 83     79: 90\n//        80: 96     81: 112    82: 102    83: 102    84: 99\n//        85: 81     86: 100    87: 93     88: 99     89: 118\n//        90: 95     91: 124    92: 108    93: 96     94: 104\n//        95: 106    96: 99     97: 99     98: 92     99: 99\n//       100: 108\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Random#9\">using System;\n\npublic class Example\n{\n   public static void Main()\n   {\n       Random2 rnd = new Random2();\n       Byte[] bytes = new Byte[10000];\n       int[] total = new int[101];\n       rnd.NextBytes(bytes, 0, 101);\n       \n       // Calculate how many of each value we have.\n       foreach (var value in bytes)\n          total[value]++;\n       \n       // Display the results.\n       for (int ctr = 0; ctr &lt; total.Length; ctr++) {\n           Console.Write(&quot;{0,3}: {1,-3}   &quot;, ctr, total[ctr]);\n           if ((ctr + 1) % 5 == 0) Console.WriteLine();\n       }   \n   }\n}\n\npublic class Random2 : Random\n{\n   public Random2() : base()\n   {}\n\n   public Random2(int seed) : base(seed)\n   {}\n\n   public void NextBytes(byte[] bytes, byte minValue, byte maxValue)\n   {\n      for (int ctr = bytes.GetLowerBound(0); ctr &lt;= bytes.GetUpperBound(0); ctr++)\n         bytes[ctr] = (byte) Next(minValue, maxValue);\n   }\n}\n// The example displays output like the following:\n//         0: 115     1: 119     2: 92      3: 98      4: 92\n//         5: 102     6: 103     7: 84      8: 93      9: 116\n//        10: 91     11: 98     12: 106    13: 91     14: 92\n//        15: 101    16: 100    17: 96     18: 97     19: 100\n//        20: 101    21: 106    22: 112    23: 82     24: 85\n//        25: 102    26: 107    27: 98     28: 106    29: 102\n//        30: 109    31: 108    32: 94     33: 101    34: 107\n//        35: 101    36: 86     37: 100    38: 101    39: 102\n//        40: 113    41: 95     42: 96     43: 89     44: 99\n//        45: 81     46: 89     47: 105    48: 100    49: 85\n//        50: 103    51: 103    52: 93     53: 89     54: 91\n//        55: 97     56: 105    57: 97     58: 110    59: 86\n//        60: 116    61: 94     62: 117    63: 98     64: 110\n//        65: 93     66: 102    67: 100    68: 105    69: 83\n//        70: 81     71: 97     72: 85     73: 70     74: 98\n//        75: 100    76: 110    77: 114    78: 83     79: 90\n//        80: 96     81: 112    82: 102    83: 102    84: 99\n//        85: 81     86: 100    87: 93     88: 99     89: 118\n//        90: 95     91: 124    92: 108    93: 96     94: 104\n//        95: 106    96: 99     97: 99     98: 92     99: 99\n//       100: 108\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Random#9\">Module Example\n   Public Sub Main()\n       Dim rnd As New Random2()\n       Dim bytes(9999) As Byte\n       Dim total(100) As Integer\n       rnd.NextBytes(bytes, 0, 101)\n       \n       &#39; Calculate how many of each value we have.\n       For Each value In bytes\n          total(value) += 1\n       Next\n       \n       &#39; Display the results.\n       For ctr As Integer = 0 To total.Length - 1\n           Console.Write(&quot;{0,3}: {1,-3}   &quot;, ctr, total(ctr))\n           If (ctr + 1) Mod 5 = 0 Then Console.WriteLine()\n       Next   \n   End Sub\nEnd Module\n\nPublic Class Random2 : Inherits Random\n   Public Sub New()\n      MyBase.New()\n   End Sub   \n\n   Public Sub New(seed As Integer)\n      MyBase.New(seed)\n   End Sub\n\n   Public Overloads Sub NextBytes(bytes() As Byte, \n                                  minValue As Byte, maxValue As Byte)\n      For ctr As Integer = bytes.GetLowerbound(0) To bytes.GetUpperBound(0)\n         bytes(ctr) = CByte(MyBase.Next(minValue, maxValue))\n      Next\n   End Sub\nEnd Class \n&#39; The example displays output like the following:\n&#39;         0: 115     1: 119     2: 92      3: 98      4: 92\n&#39;         5: 102     6: 103     7: 84      8: 93      9: 116\n&#39;        10: 91     11: 98     12: 106    13: 91     14: 92\n&#39;        15: 101    16: 100    17: 96     18: 97     19: 100\n&#39;        20: 101    21: 106    22: 112    23: 82     24: 85\n&#39;        25: 102    26: 107    27: 98     28: 106    29: 102\n&#39;        30: 109    31: 108    32: 94     33: 101    34: 107\n&#39;        35: 101    36: 86     37: 100    38: 101    39: 102\n&#39;        40: 113    41: 95     42: 96     43: 89     44: 99\n&#39;        45: 81     46: 89     47: 105    48: 100    49: 85\n&#39;        50: 103    51: 103    52: 93     53: 89     54: 91\n&#39;        55: 97     56: 105    57: 97     58: 110    59: 86\n&#39;        60: 116    61: 94     62: 117    63: 98     64: 110\n&#39;        65: 93     66: 102    67: 100    68: 105    69: 83\n&#39;        70: 81     71: 97     72: 85     73: 70     74: 98\n&#39;        75: 100    76: 110    77: 114    78: 83     79: 90\n&#39;        80: 96     81: 112    82: 102    83: 102    84: 99\n&#39;        85: 81     86: 100    87: 93     88: 99     89: 118\n&#39;        90: 95     91: 124    92: 108    93: 96     94: 104\n&#39;        95: 106    96: 99     97: 99     98: 92     99: 99\n&#39;       100: 108\n</code></pre><p> The <code>NextBytes(Byte[], Byte, Byte)</code> method wraps a call to the <a class=\"xref\" href=\"system.random#System_Random_Next_System_Int32_System_Int32_\" data-linktype=\"relative-path\">Next(Int32,Int32)</a> method and specifies the minimum value and one greater than the maximum value (in this case, 0 and 101) that we want returned in the byte array. Because we are sure that the integer values returned by the <a class=\"xref\" href=\"system.random#System_Random_Next_\" data-linktype=\"relative-path\">Next</a> method are within the range of the <a class=\"xref\" href=\"system.byte\" data-linktype=\"relative-path\">Byte</a> data type, we can safely cast them (in C#) or convert them (in Visual Basic) from integers to bytes.  </p>\n<p><a name=\"Array\"></a>   </p>\n<h3 id=\"retrieve-an-element-from-an-array-or-collection-at-random\">Retrieve an element from an array or collection at random</h3>\n<p> Random numbers often serve as indexes to retrieve values from arrays or collections. To retrieve a random index value, you can call the <a class=\"xref\" href=\"system.random#System_Random_Next_System_Int32_System_Int32_\" data-linktype=\"relative-path\">Next(Int32,Int32)</a> method, and use the lower bound of the array as the value of its <code>minValue</code> argument and one greater than the upper bound of the array as the value of its <code>maxValue</code> argument. For a zero-based array, this is equivalent to its <a class=\"xref\" href=\"system.array#System_Array_Length_\" data-linktype=\"relative-path\">Length</a> property, or one greater than the value returned by the <a class=\"xref\" href=\"system.array#System_Array_GetUpperBound_\" data-linktype=\"relative-path\">GetUpperBound</a> method. The following example randomly retrieves the name of a city in the United States from an array of cities.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Random#10\">using namespace System;\n\nvoid main()\n{\n   array&lt;String^&gt;^ cities = { &quot;Atlanta&quot;, &quot;Boston&quot;, &quot;Chicago&quot;, &quot;Detroit&quot;,\n                              &quot;Fort Wayne&quot;, &quot;Greensboro&quot;, &quot;Honolulu&quot;, &quot;Indianapolis&quot;,\n                              &quot;Jersey City&quot;, &quot;Kansas City&quot;, &quot;Los Angeles&quot;,\n                              &quot;Milwaukee&quot;, &quot;New York&quot;, &quot;Omaha&quot;, &quot;Philadelphia&quot;,\n                              &quot;Raleigh&quot;, &quot;San Francisco&quot;, &quot;Tulsa&quot;, &quot;Washington&quot; };\n   Random^ rnd = gcnew Random();\n   int index = rnd-&gt;Next(0, cities-&gt;Length);\n   Console::WriteLine(&quot;Today&#39;s city of the day: {0}&quot;,\n                      cities[index]);\n}\n// The example displays output like the following:\n//   Today&#39;s city of the day: Honolulu\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Random#10\">using System;\n\npublic class Example\n{\n   public static void Main()\n   {\n      String[] cities = { &quot;Atlanta&quot;, &quot;Boston&quot;, &quot;Chicago&quot;, &quot;Detroit&quot;, \n                          &quot;Fort Wayne&quot;, &quot;Greensboro&quot;, &quot;Honolulu&quot;, &quot;Indianapolis&quot;, \n                          &quot;Jersey City&quot;, &quot;Kansas City&quot;, &quot;Los Angeles&quot;, \n                          &quot;Milwaukee&quot;, &quot;New York&quot;, &quot;Omaha&quot;, &quot;Philadelphia&quot;, \n                          &quot;Raleigh&quot;, &quot;San Francisco&quot;, &quot;Tulsa&quot;, &quot;Washington&quot; };\n      Random rnd = new Random();\n      int index = rnd.Next(0, cities.Length);\n      Console.WriteLine(&quot;Today&#39;s city of the day: {0}&quot;,\n                        cities[index]);                           \n   }\n}\n// The example displays output like the following:\n//   Today&#39;s city of the day: Honolulu\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Random#10\">Module Example\n   Public Sub Main()\n      Dim cities() As String = { &quot;Atlanta&quot;, &quot;Boston&quot;, &quot;Chicago&quot;, &quot;Detroit&quot;, \n                                 &quot;Fort Wayne&quot;, &quot;Greensboro&quot;, &quot;Honolulu&quot;, &quot;Indianapolis&quot;, \n                                 &quot;Jersey City&quot;, &quot;Kansas City&quot;, &quot;Los Angeles&quot;, \n                                 &quot;Milwaukee&quot;, &quot;New York&quot;, &quot;Omaha&quot;, &quot;Philadelphia&quot;, \n                                 &quot;Raleigh&quot;, &quot;San Francisco&quot;, &quot;Tulsa&quot;, &quot;Washington&quot; }\n      Dim rnd As New Random()\n      Dim index As Integer = rnd.Next(0, cities.Length)\n      Console.WriteLine(&quot;Today&#39;s city of the day: {0}&quot;,\n                        cities(index))                           \n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;   Today&#39;s city of the day: Honolulu\n</code></pre><p><a name=\"UniqueArray\"></a>   </p>\n<h3 id=\"retrieve-a-unique-element-from-an-array-or-collection\">Retrieve a unique element from an array or collection</h3>\n<p> A random number generator can always return duplicate values. As the range of numbers becomes smaller or the number of values generated becomes larger, the probability of duplicates grows. If random values must be unique, more numbers are generated to compensate for duplicates, resulting in increasingly poor performance.  </p>\n<p> There are a number of techniques to handle this scenario. One common solution is to create an array or collection that contains the values to be retrieved, and a parallel array that contains random floating-point numbers. The second array is populated with random numbers at the time the first array is created, and the <a class=\"xref\" href=\"system.array#System_Array_Sort_System_Array_System_Array_\" data-linktype=\"relative-path\">System.Array.Sort(Array,Array)</a> method is used to sort the first array by using the values in the parallel array.  </p>\n<p> For example, if you&#39;re developing a Solitaire game, you want to ensure that each card is used only once. Instead of generating random numbers to retrieve a card and tracking whether that card has already been dealt, you can create a parallel array of random numbers that can be used to sort the deck. Once the deck is sorted, your app can maintain a pointer to indicate the index of the next card on the deck.  </p>\n<p> The following example illustrates this approach. It defines a <code>Card</code> class that represents a playing card and a <code>Dealer</code> class that deals a deck of shuffled cards. The <code>Dealer</code> class constructor populates two arrays: a <code>deck</code> array that has class scope and that represents all the cards in the deck; and a local <code>order</code> array that has the same number of elements as the <code>deck</code> array and is populated with randomly generated <a class=\"xref\" href=\"system.double\" data-linktype=\"relative-path\">Double</a> values.  The <a class=\"xref\" href=\"system.array#System_Array_Sort_System_Array_System_Array_\" data-linktype=\"relative-path\">System.Array.Sort(Array,Array)</a> method is then called to sort the <code>deck</code> array based on the values in the <code>order</code> array.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Random#11\">&#39; A class that represents an individual card in a playing deck.\nPublic Class Card\n   Public Suit As Suit\n   Public FaceValue As FaceValue\n   \n   Public Overrides Function ToString() As String\n      Return String.Format(&quot;{0:F} of {1:F}&quot;, Me.FaceValue, Me.Suit)\n   End Function\nEnd Class\n\nPublic Enum Suit As Integer\n   Hearts = 0\n   Diamonds = 1\n   Spades = 2\n   Clubs = 3\nEnd Enum\n\nPublic Enum FaceValue As Integer\n   Ace = 1\n   Two = 2\n   Three = 3\n   Four = 4\n   Five = 5\n   Six = 6\n   Seven = 7\n   Eight = 8\n   Nine = 9\n   Ten = 10\n   Jack = 11\n   Queen = 12\n   King = 13\nEnd Enum\n\nPublic Class Dealer\n   Dim rnd As Random\n   &#39; A deck of cards, without Jokers.\n   Dim deck(51) As Card\n   &#39; Parallel array for sorting cards.\n   Dim order(51) As Double\n   &#39; A pointer to the next card to deal.\n   Dim ptr As Integer = 0\n   &#39; A flag to indicate the deck is used.\n   Dim mustReshuffle As Boolean\n   \n   Public Sub New()\n      rnd = New Random()\n      &#39; Initialize the deck.\n      Dim deckCtr As Integer = 0\n      For Each Suit In [Enum].GetValues(GetType(Suit))\n         For Each faceValue In [Enum].GetValues(GetType(FaceValue))\n            Dim card As New Card()\n            card.Suit = CType(Suit, Suit)\n            card.FaceValue = CType(faceValue, FaceValue)\n            deck(deckCtr) = card  \n            deckCtr += 1\n         Next\n      Next\n      For ctr As Integer = 0 To order.Length - 1\n         order(ctr) = rnd.NextDouble()   \n      Next   \n      Array.Sort(order, deck)\n   End Sub\n\n   Public Function Deal(numberToDeal As Integer) As Card()\n      If mustReshuffle Then\n         Console.WriteLine(&quot;There are no cards left in the deck&quot;)\n         Return Nothing\n      End If\n      \n      Dim cardsDealt(numberToDeal - 1) As Card\n      For ctr As Integer = 0 To numberToDeal - 1\n         cardsDealt(ctr) = deck(ptr)\n         ptr += 1\n         If ptr = deck.Length Then \n            mustReshuffle = True\n         End If\n         If mustReshuffle And ctr &lt; numberToDeal - 1\n            Console.WriteLine(&quot;Can only deal the {0} cards remaining on the deck.&quot;, \n                              ctr + 1)\n            Return cardsDealt\n         End If\n      Next\n      Return cardsDealt\n   End Function\nEnd Class\n\nPublic Module Example\n   Public Sub Main()\n      Dim dealer As New Dealer()\n      ShowCards(dealer.Deal(20))\n   End Sub\n   \n   Private Sub ShowCards(cards() As Card)\n      For Each card In cards\n         If card IsNot Nothing Then _\n            Console.WriteLine(&quot;{0} of {1}&quot;, card.FaceValue, card.Suit)\n      Next\n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;       Six of Diamonds\n&#39;       King of Clubs\n&#39;       Eight of Clubs\n&#39;       Seven of Clubs\n&#39;       Queen of Clubs\n&#39;       King of Hearts\n&#39;       Three of Spades\n&#39;       Ace of Clubs\n&#39;       Four of Hearts\n&#39;       Three of Diamonds\n&#39;       Nine of Diamonds\n&#39;       Two of Hearts\n&#39;       Ace of Hearts\n&#39;       Three of Hearts\n&#39;       Four of Spades\n&#39;       Eight of Hearts\n&#39;       Queen of Diamonds\n&#39;       Two of Clubs\n&#39;       Four of Diamonds\n&#39;       Jack of Hearts\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Random#11\">using namespace System;\n\npublic enum class Suit { Hearts, Diamonds, Spades, Clubs };\n\npublic enum class FaceValue  { Ace = 1, Two, Three, Four, Five, Six,\n                               Seven, Eight, Nine, Ten, Jack, Queen,\n                               King };\n\n// A class that represents an individual card in a playing deck.\nref class Card\n{\npublic:\n   Suit Suit;\n   FaceValue FaceValue;\n   \n   String^ ToString() override\n   {\n      return String::Format(&quot;{0:F} of {1:F}&quot;, this-&gt;FaceValue, this-&gt;Suit);\n   }\n};\n\nref class Dealer\n{\nprivate:\n   Random^ rnd;\n   // A deck of cards, without Jokers.\n   array&lt;Card^&gt;^ deck = gcnew array&lt;Card^&gt;(52);\n   // Parallel array for sorting cards.\n   array&lt;Double&gt;^ order = gcnew array&lt;Double&gt;(52);\n   // A pointer to the next card to deal.\n   int ptr = 0;\n   // A flag to indicate the deck is used.\n   bool mustReshuffle = false;\n   \npublic:\n   Dealer()\n   {\n      rnd = gcnew Random();\n      // Initialize the deck.\n      int deckCtr = 0;\n      for each (auto suit in Enum::GetValues(Suit::typeid)) {\n         for each (FaceValue faceValue in Enum::GetValues(FaceValue::typeid)) {\n            Card^ card = gcnew Card();\n            card-&gt;Suit = (Suit) suit;\n            card-&gt;FaceValue = (FaceValue) faceValue;\n            deck[deckCtr] = card;  \n            deckCtr++;\n         }\n      }\n      \n      for (int ctr = 0; ctr &lt; order-&gt;Length; ctr++)\n         order[ctr] = rnd-&gt;NextDouble();\n\n      Array::Sort(order, deck);\n   }\n\n   array&lt;Card^&gt;^ Deal(int numberToDeal)\n   {\n      if (mustReshuffle) {\n         Console::WriteLine(&quot;There are no cards left in the deck&quot;);\n         return nullptr;\n      }\n      \n      array&lt;Card^&gt;^ cardsDealt = gcnew array&lt;Card^&gt;(numberToDeal);\n      for (int ctr = 0; ctr &lt; numberToDeal; ctr++) {\n         cardsDealt[ctr] = deck[ptr];\n         ptr++;\n         if (ptr == deck-&gt;Length)\n            mustReshuffle = true;\n\n         if (mustReshuffle &amp; ctr &lt; numberToDeal - 1) {\n            Console::WriteLine(&quot;Can only deal the {0} cards remaining on the deck.&quot;,\n                               ctr + 1);\n            return cardsDealt;\n         }\n      }\n      return cardsDealt;\n   }\n};\n\nvoid ShowCards(array&lt;Card^&gt;^ cards)\n{\n   for each (Card^ card in cards)\n      if (card != nullptr)\n         Console::WriteLine(&quot;{0} of {1}&quot;, card-&gt;FaceValue, card-&gt;Suit);\n};\n\nvoid main()\n{\n   Dealer^ dealer = gcnew Dealer();\n   ShowCards(dealer-&gt;Deal(20));\n}\n\n// The example displays output like the following:\n//       Six of Diamonds\n//       King of Clubs\n//       Eight of Clubs\n//       Seven of Clubs\n//       Queen of Clubs\n//       King of Hearts\n//       Three of Spades\n//       Ace of Clubs\n//       Four of Hearts\n//       Three of Diamonds\n//       Nine of Diamonds\n//       Two of Hearts\n//       Ace of Hearts\n//       Three of Hearts\n//       Four of Spades\n//       Eight of Hearts\n//       Queen of Diamonds\n//       Two of Clubs\n//       Four of Diamonds\n//       Jack of Hearts\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Random#11\">using System;\n\n// A class that represents an individual card in a playing deck.\npublic class Card\n{\n   public Suit Suit; \n   public FaceValue FaceValue;\n   \n   public override String ToString() \n   {\n      return String.Format(&quot;{0:F} of {1:F}&quot;, this.FaceValue, this.Suit);\n   }\n}\n\npublic enum Suit { Hearts, Diamonds, Spades, Clubs };\n\npublic enum FaceValue  { Ace = 1, Two, Three, Four, Five, Six,\n                         Seven, Eight, Nine, Ten, Jack, Queen,\n                         King };\n\npublic class Dealer\n{\n   Random rnd;\n   // A deck of cards, without Jokers.\n   Card[] deck = new Card[52];\n   // Parallel array for sorting cards.\n   Double[] order = new Double[52];\n   // A pointer to the next card to deal.\n   int ptr = 0;\n   // A flag to indicate the deck is used.\n   bool mustReshuffle = false;\n   \n   public Dealer()\n   {\n      rnd = new Random();\n      // Initialize the deck.\n      int deckCtr = 0;\n      foreach (var suit in Enum.GetValues(typeof(Suit))) {\n         foreach (var faceValue in Enum.GetValues(typeof(FaceValue))) { \n            Card card = new Card();\n            card.Suit = (Suit) suit;\n            card.FaceValue = (FaceValue) faceValue;\n            deck[deckCtr] = card;  \n            deckCtr++;\n         }\n      }\n      \n      for (int ctr = 0; ctr &lt; order.Length; ctr++)\n         order[ctr] = rnd.NextDouble();   \n\n      Array.Sort(order, deck);\n   }\n\n   public Card[] Deal(int numberToDeal)\n   {\n      if (mustReshuffle) {\n         Console.WriteLine(&quot;There are no cards left in the deck&quot;);\n         return null;\n      }\n      \n      Card[] cardsDealt = new Card[numberToDeal];\n      for (int ctr = 0; ctr &lt; numberToDeal; ctr++) {\n         cardsDealt[ctr] = deck[ptr];\n         ptr++;\n         if (ptr == deck.Length) \n            mustReshuffle = true;\n\n         if (mustReshuffle &amp; ctr &lt; numberToDeal - 1) {\n            Console.WriteLine(&quot;Can only deal the {0} cards remaining on the deck.&quot;, \n                              ctr + 1);\n            return cardsDealt;\n         }\n      }\n      return cardsDealt;\n   }\n}\n\n\npublic class Example\n{\n   public static void Main()\n   {\n      Dealer dealer = new Dealer();\n      ShowCards(dealer.Deal(20));\n   }\n   \n   private static void ShowCards(Card[] cards)\n   {\n      foreach (var card in cards)\n         if (card != null)\n            Console.WriteLine(&quot;{0} of {1}&quot;, card.FaceValue, card.Suit);\n   }\n}\n// The example displays output like the following:\n//       Six of Diamonds\n//       King of Clubs\n//       Eight of Clubs\n//       Seven of Clubs\n//       Queen of Clubs\n//       King of Hearts\n//       Three of Spades\n//       Ace of Clubs\n//       Four of Hearts\n//       Three of Diamonds\n//       Nine of Diamonds\n//       Two of Hearts\n//       Ace of Hearts\n//       Three of Hearts\n//       Four of Spades\n//       Eight of Hearts\n//       Queen of Diamonds\n//       Two of Clubs\n//       Four of Diamonds\n//       Jack of Hearts\n</code></pre>\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Constructors\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Random__ctor\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Random()</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Initializes a new instance of the <a class=\"xref\" href=\"system.random\" data-linktype=\"relative-path\">Random</a> class, using a time-dependent default seed value.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public Random ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The default seed value is derived from the system clock and has finite resolution. As a result, different <a class=\"xref\" href=\"system.random\" data-linktype=\"relative-path\">Random</a> objects that are created in close succession by a call to the default constructor will have identical default seed values and, therefore, will produce identical sets of random numbers. This problem can be avoided by using a single <a class=\"xref\" href=\"system.random\" data-linktype=\"relative-path\">Random</a> object to generate all random numbers. You can also work around it by modifying the seed value returned by the system clock and then explicitly providing this new seed value to the <a class=\"xref\" href=\"system.random#System_Random__ctor_System_Int32_\" data-linktype=\"relative-path\">Random(Int32)</a> constructor. For more information, see the <a class=\"xref\" href=\"system.random#System_Random__ctor_System_Int32_\" data-linktype=\"relative-path\">Random(Int32)</a> constructor.  </p>\n<p> Call this constructor if you want your random number generator to generate a random sequence of numbers. To generate a fixed  sequence of random numbers that will be the same for different random number generators, call the <a class=\"xref\" href=\"system.random#System_Random__ctor_System_Int32_\" data-linktype=\"relative-path\">Random(Int32)</a> constructor with a fixed seed value . This <a class=\"xref\" href=\"system.random\" data-linktype=\"relative-path\">Random</a> constructor overload is frequently used when testing apps that use random numbers.  </p>\n<p> Once you&#39;ve instantiated the random number generator, you call individual <a class=\"xref\" href=\"system.random\" data-linktype=\"relative-path\">Random</a> methods, such as <a class=\"xref\" href=\"system.random#System_Random_Next\" data-linktype=\"relative-path\">Next()</a> or <a class=\"xref\" href=\"system.random#System_Random_NextDouble\" data-linktype=\"relative-path\">NextDouble()</a>, to generate random numbers.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Random__ctor_System_Int32_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Random(Int32)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Initializes a new instance of the <a class=\"xref\" href=\"system.random\" data-linktype=\"relative-path\">Random</a> class, using the specified seed value.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public Random (int Seed);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>Seed</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A number used to calculate a starting value for the pseudo-random number sequence. If a negative number is specified, the absolute value of the number is used.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>Providing an identical seed value to different <a class=\"xref\" href=\"system.random\" data-linktype=\"relative-path\">Random</a> objects causes each instance to produce identical sequences of random numbers. This is often done when testing apps that rely on random number generators.  </p>\n<p> If your application requires different random number sequences, invoke this constructor repeatedly with different seed values. One way to produce a unique seed value is to make it time-dependent. For example, derive the seed value from the system clock, as the <a class=\"xref\" href=\"system.random#System_Random__ctor\" data-linktype=\"relative-path\">Random()</a> overload does. However, the system clock might not have sufficient resolution to provide different invocations of this constructor with a different seed value. This results in random number generators that generate identical sequences of pseudo-random numbers, as illustrated by the first two <a class=\"xref\" href=\"system.random\" data-linktype=\"relative-path\">Random</a> objects in the following example. To prevent this, apply an algorithm to differentiate the seed value in each invocation, or call the <a class=\"xref\" href=\"system.threading.thread#System_Threading_Thread_Sleep_\" data-linktype=\"relative-path\">Sleep</a> method to ensure that you provide each constructor with a different seed value.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Random.Ctor#4\">Imports System.Threading\n\nModule RandomNumbers\n   Public Sub Main()\n      Dim rand1 As New Random(CInt(Date.Now.Ticks And &amp;h0000FFFF))\n      Dim rand2 As New Random(CInt(Date.Now.Ticks And &amp;h0000FFFF))\n      Thread.Sleep(20)\n      Dim rand3 As New Random(CInt(Date.Now.Ticks And &amp;h0000FFFF))\n      ShowRandomNumbers(rand1)\n      ShowRandomNumbers(rand2)\n      ShowRandomNumbers(rand3)\n   End Sub\n   \n   Private Sub ShowRandomNumbers(rand As Random)\n      Console.WriteLine()\n      Dim values(4) As Byte\n      rand.NextBytes(values)\n      For Each value As Byte In values\n         Console.Write(&quot;{0, 5}&quot;, value)\n      Next      \n      Console.WriteLine() \n   End Sub\nEnd Module\n&#39; The example displays output similar to the following:\n&#39;      145  214  177  134  173\n&#39;    \n&#39;      145  214  177  134  173\n&#39;    \n&#39;      126  185  175  249  157\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Random.Ctor#4\">using System;\nusing System.Threading;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Random rand1 = new Random((int) DateTime.Now.Ticks &amp; 0x0000FFFF);\n      Random rand2 = new Random((int) DateTime.Now.Ticks &amp; 0x0000FFFF);\n      Thread.Sleep(20);\n      Random rand3 = new Random((int) DateTime.Now.Ticks &amp; 0x0000FFFF);\n      ShowRandomNumbers(rand1);\n      ShowRandomNumbers(rand2);\n      ShowRandomNumbers(rand3);\n   }\n\n   private static void ShowRandomNumbers(Random rand)\n   {\n      Console.WriteLine();\n      byte[] values = new byte[4];\n      rand.NextBytes(values);\n      foreach (var value in values)\n         Console.Write(&quot;{0, 5}&quot;, value);\n\n      Console.WriteLine(); \n   }\n}\n// The example displays output similar to the following:\n//   145  214  177  134  173\n// \n//   145  214  177  134  173\n// \n//   126  185  175  249  157\n</code></pre><p> Another option is to instantiate a single <a class=\"xref\" href=\"system.random\" data-linktype=\"relative-path\">Random</a> object that you use to generate all the random numbers in your application. This yields slightly better performance, since instantiating a random number generator is fairly expensive.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t  \r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Methods\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Random_Next\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Next()</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Returns a non-negative random integer.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public virtual int Next ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A 32-bit signed integer that is greater than or equal to 0 and less than <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>Next generates a random number whose value ranges from 0 to less than <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">System.Int32</a>. To generate a random number whose value ranges from 0 to some other positive number, use the <a class=\"xref\" href=\"system.random#System_Random_Next_System_Int32_\" data-linktype=\"relative-path\">System.Random.Next(Int32)</a> method overload. To generate a random number within a different range, use the <a class=\"xref\" href=\"system.random#System_Random_Next_System_Int32_System_Int32_\" data-linktype=\"relative-path\">System.Random.Next(Int32,Int32)</a> method overload.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Random_Next_System_Int32_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Next(Int32)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Returns a non-negative random integer that is less than the specified maximum.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public virtual int Next (int maxValue);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>maxValue</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The exclusive upper bound of the random number to be generated. <code>maxValue</code> must be greater than or equal to 0.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A 32-bit signed integer that is greater than or equal to 0, and less than <code>maxValue</code>; that is, the range of return values ordinarily includes 0 but not <code>maxValue</code>. However, if <code>maxValue</code> equals 0, <code>maxValue</code> is returned.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>maxValue</code> is less than 0.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The Next overload returns random integers that range from 0 to <code>maxValue</code> â€“ 1. However, if <code>maxValue</code> is 0, the method returns 0.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Random_Next_System_Int32_System_Int32_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Next(Int32,Int32)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Returns a random integer that is within a specified range.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public virtual int Next (int minValue, int maxValue);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>minValue</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The inclusive lower bound of the random number returned.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>maxValue</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The exclusive upper bound of the random number returned. <code>maxValue</code> must be greater than or equal to <code>minValue</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A 32-bit signed integer greater than or equal to <code>minValue</code> and less than <code>maxValue</code>; that is, the range of return values includes <code>minValue</code> but not <code>maxValue</code>. If <code>minValue</code> equals <code>maxValue</code>, <code>minValue</code> is returned.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>minValue</code> is greater than <code>maxValue</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The Next overload returns random integers that range from <code>minValue</code> to <code>maxValue</code> â€“ 1. However, if <code>maxValue</code> equals <code>minValue</code>, the method returns <code>minValue</code>.  </p>\n<p> Unlike the other overloads of the <a class=\"xref\" href=\"system.random#System_Random_Next_\" data-linktype=\"relative-path\">Next</a> method, which return only non-negative values, this method can return a negative random integer.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Random_NextBytes_System_Byte___\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">NextBytes(Byte[])</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Fills the elements of a specified array of bytes with random numbers.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public virtual void NextBytes (byte[] buffer);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>buffer</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.byte\" data-linktype=\"relative-path\">Byte</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An array of bytes to contain random numbers.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>buffer</code> is <code>null</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>Each element of the array of bytes is set to a random number greater than or equal to 0, and less than or equal to <a class=\"xref\" href=\"system.byte\" data-linktype=\"relative-path\">Byte</a>.  </p>\n<p> For example, to generate a cryptographically secured random number suitable for creating a random password, use a method such as <a class=\"xref\" href=\"system.security.cryptography.rngcryptoserviceprovider#System_Security_Cryptography_RNGCryptoServiceProvider_GetBytes_\" data-linktype=\"relative-path\">GetBytes</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Random_NextDouble\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">NextDouble()</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public virtual double NextDouble ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.double\" data-linktype=\"relative-path\">Double</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The actual upper bound of the random number returned by this method is 0.99999999999999978.  </p>\n<p> To retrieve random floating-point values within a range other than 0.0 and 1.0, see the &quot;Retrieve floating-point values in a specified range&quot; section of the <a class=\"xref\" href=\"system.random\" data-linktype=\"relative-path\">Random</a> class topic.  </p>\n<p> This method is the public version of the protected method, <a class=\"xref\" href=\"system.random#System_Random_Sample_\" data-linktype=\"relative-path\">Sample</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Random_Sample\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Sample()</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Returns a random floating-point number between 0.0 and 1.0.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">protected virtual double Sample ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.double\" data-linktype=\"relative-path\">Double</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>To produce a different random distribution or a different random number generator principle, derive a class from the <a class=\"xref\" href=\"system.random\" data-linktype=\"relative-path\">Random</a> class and override the Sample method.  </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> The Sample method is <code>protected</code>, which means that it is accessible only within the <a class=\"xref\" href=\"system.random\" data-linktype=\"relative-path\">Random</a> class and its derived classes. To generate a random number between 0 and 1 from a <a class=\"xref\" href=\"system.random\" data-linktype=\"relative-path\">Random</a> instance, call the <a class=\"xref\" href=\"system.random#System_Random_NextDouble_\" data-linktype=\"relative-path\">NextDouble</a> method.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t  \r\n  \t\t</section>\r\n  \r\n  \r\n","outputRootRelativePath":"./","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"breadcrumb_path\" content=\"breadcrumb/toc.json\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"fulldocset\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.fulldocset\">\r\n<meta name=\"ref_skeleton_gitcommit\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Random.yml\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Random.yml\">\r\n<meta name=\"APIName\" content=\"System.Random\">\r\n<meta name=\"APIName\" content=\"System.Random..ctor\">\r\n<meta name=\"APIName\" content=\"System.Random.Next\">\r\n<meta name=\"APIName\" content=\"System.Random.NextBytes\">\r\n<meta name=\"APIName\" content=\"System.Random.NextDouble\">\r\n<meta name=\"APIName\" content=\"System.Random.Sample\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-01 01:37 AM\">\r\n<meta name=\"document_id\" content=\"e6980362-2e16-e39f-9508-df72561b9b18\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Represents a pseudo-random number generator, which is a device that produces a sequence of numbers that meet certain statistical requirements for randomness.  \n To browse the .NET Framework source coâ€¦\">\r\n<meta name=\"toc_rel\" content=\"_splitted/System/toc.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Random\">\r\n","rawMetadata":{"author":"dotnet-bot","breadcrumb_path":"breadcrumb/toc.json","search.ms_sitename":"Docs","search.ms_docsetname":"fulldocset","version":null,"_op_canonicalUrlPrefix":"https://ppe.docs.microsoft.com/en-us/fulldotnet/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":true,"depot_name":"MSDN.fulldocset","_op_gitRefSkeletonCommitHistory":[{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"use plugin in master","commit_sha":"501959ac03e19ac52a27aa4c6bbeb980f8b11c8c","commit_date":"2017-03-01 09:31:20 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"fix pointer ref","commit_sha":"76befb0e7f7b41839ec719047e5b39a5981298f3","commit_date":"2017-02-28 15:47:23 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"switch from platform to version","commit_sha":"78cdacb5ca782478af490a6b30c3a2cb2b6b873e","commit_date":"2017-02-28 15:09:51 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"update platforms","commit_sha":"39ad5a8919a59afc93a79ac4bd8e07c3b471b37a","commit_date":"2017-02-28 10:38:59 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"checkin yml","commit_sha":"da161b792852497df7140d7768cee2eccd9cb43f","commit_date":"2017-02-28 09:36:15 +0800"}],"ref_skeleton_gitcommit":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Random.yml","original_ref_skeleton_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Random.yml","open_to_public_contributors":true,"api_name":["System.Random","System.Random..ctor","System.Random.Next","System.Random.NextBytes","System.Random.NextDouble","System.Random.Sample"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Random","System::Random","System.Random.#ctor","System::Random::#ctor","System.Random.Next","System::Random::Next","System.Random.NextBytes","System::Random::NextBytes","System.Random.NextDouble","System::Random::NextDouble","System.Random.Sample","System::Random::Sample"],"dev_langs":["csharp"],"updated_at":"2017-03-01 01:37 AM","document_id":"e6980362-2e16-e39f-9508-df72561b9b18","content_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/xml/System/Random.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"Random class | Microsoft Docs","_op_ogTitle":"Random class","description":"Represents a pseudo-random number generator, which is a device that produces a sequence of numbers that meet certain statistical requirements for randomness.  \n To browse the .NET Framework source coâ€¦","toc_asset_id":"_splitted/System/toc.json","toc_rel":"_splitted/System/toc.json","source_url":"","ms.assetid":"System.Random","canonical_url":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.random","_op_canonicalUrl":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.random","fileRelativePath":"System.Random.html"},"themesRelativePathToOutputRoot":"_themes/"}