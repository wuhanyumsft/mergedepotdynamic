{"content":"\r\n<div style=\"display:none\">\r\n\t\r\n</div>\r\n\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">WaitHandle</span>\r\n    \t\t\t\tClass\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Encapsulates operating system–specific objects that wait for exclusive access to shared resources.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ComVisible(true)]\npublic abstract class WaitHandle : MarshalByRefObject, IDisposable</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></span></div>\r\n  \t\t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.marshalbyrefobject\" data-linktype=\"relative-path\">System.MarshalByRefObject</a></span></div>\r\n  \t\t\t<span class=\"lang-csharp\">WaitHandle</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \r\n  \r\n  \t<h3 class=\"accented\">Inherited Members</h3>\r\n  \t<h4 class=\"accented\"></h4>\r\n  \t<div class=\"cdlHolder\">\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.marshalbyrefobject#System_MarshalByRefObject_CreateObjRef_System_Type_\" data-linktype=\"relative-path\">CreateObjRef(Type)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.marshalbyrefobject#System_MarshalByRefObject_GetLifetimeService\" data-linktype=\"relative-path\">GetLifetimeService()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.marshalbyrefobject#System_MarshalByRefObject_InitializeLifetimeService\" data-linktype=\"relative-path\">InitializeLifetimeService()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.marshalbyrefobject#System_MarshalByRefObject_MemberwiseClone_System_Boolean_\" data-linktype=\"relative-path\">MemberwiseClone(Boolean)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object,Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object,Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a></span></div>\r\n  \t</div>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>The WaitHandle class encapsulates Win32 synchronization handles, and is used to represent all synchronization objects in the runtime that allow multiple wait operations. For a comparison of wait handles with other synchronization objects, see <a href=\"../Topic/Overview%20of%20Synchronization%20Primitives.md\" data-linktype=\"relative-path\">Overview of Synchronization Primitives</a>.  </p>\n<p> The WaitHandle class itself is abstract. Classes derived from WaitHandle define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited WaitHandle methods to block while waiting for access to shared resources. The classes derived from WaitHandle include:  </p>\n<ul>\n<li><p>The <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> class. See <a href=\"../Topic/Mutexes.md\" data-linktype=\"relative-path\">Mutexes</a>.  </p>\n</li>\n<li><p>The <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> class and its derived classes, <a class=\"xref\" href=\"system.threading.autoresetevent\" data-linktype=\"relative-path\">AutoResetEvent</a> and <a class=\"xref\" href=\"system.threading.manualresetevent\" data-linktype=\"relative-path\">ManualResetEvent</a>. See <a href=\"../Topic/EventWaitHandle,%20AutoResetEvent,%20CountdownEvent,%20ManualResetEvent.md\" data-linktype=\"relative-path\">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</a>.  </p>\n</li>\n<li><p>The <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> class. See <a href=\"../Topic/Semaphore%20and%20SemaphoreSlim.md\" data-linktype=\"relative-path\">Semaphore and SemaphoreSlim</a>.  </p>\n<p>Threads can block on an individual wait handle by calling the instance method <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a>, which is inherited by classes derived from WaitHandle.  </p>\n<p>The derived classes of WaitHandle differ in their thread affinity. Event wait handles (<a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a>, <a class=\"xref\" href=\"system.threading.autoresetevent\" data-linktype=\"relative-path\">AutoResetEvent</a>, and <a class=\"xref\" href=\"system.threading.manualresetevent\" data-linktype=\"relative-path\">ManualResetEvent</a>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore. Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_ReleaseMutex_\" data-linktype=\"relative-path\">ReleaseMutex</a> method on a mutex that it does not own.  </p>\n<p>Because the WaitHandle class derives from <a class=\"xref\" href=\"system.marshalbyrefobject\" data-linktype=\"relative-path\">MarshalByRefObject</a>, these classes can be used to synchronize the activities of threads across application domain boundaries.  </p>\n<p>In addition to its derived classes, the WaitHandle class has a number of static methods that block a thread until one or more synchronization objects receive a signal.. These include:  </p>\n</li>\n<li><p><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SignalAndWait_\" data-linktype=\"relative-path\">SignalAndWait</a>, which allows a thread to signal one wait handle and immediately wait on another.  </p>\n</li>\n<li><p><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a>, which allows a thread to wait until all the wait handles in an array receive a signal.  </p>\n</li>\n<li><p><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a>, which allows a thread to wait until any one of a specified set of wait handles has been signaled .  </p>\n<p>The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.  </p>\n</li>\n</ul>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> This type implements the <a class=\"xref\" href=\"system.idisposable\" data-linktype=\"relative-path\">IDisposable</a> interface. When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Close_\" data-linktype=\"relative-path\">Close</a> method in a <code>try</code>/<code>catch</code> block. To dispose of it indirectly, use a language construct such as <code>using</code> (in C#) or <code>Using</code> (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <a class=\"xref\" href=\"system.idisposable\" data-linktype=\"relative-path\">IDisposable</a> interface topic.  </p>\n</div>\n<p> WaitHandle implements the <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose_\" data-linktype=\"relative-path\">Dispose</a> pattern. See <a href=\"../Topic/Dispose%20Pattern.md\" data-linktype=\"relative-path\">Dispose Pattern</a>. When you derive from WaitHandle, use the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SafeWaitHandle_\" data-linktype=\"relative-path\">SafeWaitHandle</a> property to store your native handle operating system handle. You do not need to override the protected <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Dispose_\" data-linktype=\"relative-path\">Dispose</a> method unless you use additional unmanaged resources.</p>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Constructors\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle__ctor\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">WaitHandle()</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> class.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">protected WaitHandle ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t  \r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Fields\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_InvalidHandle\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">InvalidHandle</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Represents an invalid native operating system handle. This field is read-only.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">protected static readonly IntPtr InvalidHandle;</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>Used internally to initialize the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Handle_\" data-linktype=\"relative-path\">Handle</a> property.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_WaitTimeout\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">WaitTimeout</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Indicates that a <span class=\"xref\">stem.Threading.WaitHandle.WaitAny*</span> operation timed out before any of the wait handles were signaled. This field is constant.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public const int WaitTimeout = 258;</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This field is one of the possible return values of <code>WaitAny</code>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t  \r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Properties\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_Handle\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Handle</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets or sets the native operating system handle.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public virtual IntPtr Handle { get; set; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An <code>IntPtr</code> representing the native operating system handle. The default is the value of the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_InvalidHandle\" data-linktype=\"relative-path\">InvalidHandle</a> field.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>Assigning a new value to the Handle property does not close the previous handle. This can result in a leaked handle.  </p>\n<p> Do not use this property in the .NET Framework version 2.0 or later; use the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SafeWaitHandle_\" data-linktype=\"relative-path\">SafeWaitHandle</a> property instead. Setting this property to a valid handle also sets the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SafeWaitHandle_\" data-linktype=\"relative-path\">SafeWaitHandle</a> property, but setting it to <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_InvalidHandle\" data-linktype=\"relative-path\">InvalidHandle</a> can result in a leaked handle.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_SafeWaitHandle\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">SafeWaitHandle</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets or sets the native operating system handle.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"microsoft.win32.safehandles.safewaithandle\" data-linktype=\"relative-path\">SafeWaitHandle</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <a class=\"xref\" href=\"microsoft.win32.safehandles.safewaithandle\" data-linktype=\"relative-path\">SafeWaitHandle</a> representing the native operating system handle.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>When you assign a new value to the SafeWaitHandle property, the previous handle will be closed when the previous <a class=\"xref\" href=\"microsoft.win32.safehandles.safewaithandle\" data-linktype=\"relative-path\">SafeWaitHandle</a> object is collected. Do not manually close the handle, because this results in an <a class=\"xref\" href=\"system.objectdisposedexception\" data-linktype=\"relative-path\">ObjectDisposedException</a> when the <a class=\"xref\" href=\"microsoft.win32.safehandles.safewaithandle\" data-linktype=\"relative-path\">SafeWaitHandle</a> attempts to close the handle.  </p>\n<p> <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> implements the <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose_\" data-linktype=\"relative-path\">Dispose</a> pattern. See <a href=\"../Topic/Dispose%20Pattern.md\" data-linktype=\"relative-path\">Dispose Pattern</a>. When you derive from <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>, use the SafeWaitHandle property to store your native handle operating system handle. You do not need to override the protected <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Dispose_\" data-linktype=\"relative-path\">Dispose</a> method unless you use additional unmanaged resources.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t  \r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Methods\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_Close\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Close()</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Releases all resources held by the current <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public virtual void Close ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This method is the public implementation of the <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose_\" data-linktype=\"relative-path\">Dispose</a> method for the <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> class and its derived classes. It provides a standard implementation that calls the <code>Dispose(Boolean)</code> overload with a <code>true</code> argument and then calls the <a class=\"xref\" href=\"system.gc#System_GC_SuppressFinalize_\" data-linktype=\"relative-path\">SuppressFinalize</a> method. Call this method to release all resources held by an instance of <code>WaitHandle</code> or a derived class.  </p>\n<p> Once this method is called, references to the current instance cause undefined behavior.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Always call Close or <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Dispose\" data-linktype=\"relative-path\">Dispose()</a> before you release your last reference to the <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>. Otherwise, the resources it is using will not be freed.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_Dispose\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Dispose()</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Releases all resources used by the current instance of the <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> class.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void Dispose ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This method is equivalent to the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Close_\" data-linktype=\"relative-path\">Close</a> method.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Always call <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Close_\" data-linktype=\"relative-path\">Close</a> or Dispose before you release your last reference to the <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>. Otherwise, the resources it is using will not be freed.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_Dispose_System_Boolean_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Dispose(Boolean)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>When overridden in a derived class, releases the unmanaged resources used by the <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>, and optionally releases the managed resources.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">protected virtual void Dispose (bool explicitDisposing);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>explicitDisposing</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> to release both managed and unmanaged resources; <code>false</code> to release only unmanaged resources.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This method is called by the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Close_\" data-linktype=\"relative-path\">Close</a> and the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Dispose\" data-linktype=\"relative-path\">Dispose()</a> methods with the <code>explicitDisposing</code> parameter set to <code>true</code>.  When the <code>explicitDisposing</code> parameter is <code>true</code>, this method releases all resources held by any managed objects that this <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> object references.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_SignalAndWait_System_Threading_WaitHandle_System_Threading_WaitHandle_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">SignalAndWait(WaitHandle,WaitHandle)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Signals one <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> and waits on another.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>toSignal</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> to signal.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>toWaitOn</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> to wait on.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>toSignal</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>toWaitOn</code> is <code>null</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The method was called on a thread that has <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.platformnotsupportedexception\" data-linktype=\"relative-path\">PlatformNotSupportedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>This method is not supported on Windows 98 or Windows Millennium Edition.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>toSignal</code> is a semaphore, and it already has a full count.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This operation is not guaranteed to be atomic. After the current thread signals <code>toSignal</code> but before it waits on <code>toWaitOn</code>, a thread that is running on another processor might signal <code>toWaitOn</code> or wait on it.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_SignalAndWait_System_Threading_WaitHandle_System_Threading_WaitHandle_System_Int32_System_Boolean_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">SignalAndWait(WaitHandle,WaitHandle,Int32,Boolean)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Signals one <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>toSignal</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> to signal.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>toWaitOn</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> to wait on.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>millisecondsTimeout</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An integer that represents the interval to wait. If the value is <a class=\"xref\" href=\"system.threading.timeout#System_Threading_Timeout_Infinite\" data-linktype=\"relative-path\">Infinite</a>, that is, -1, the wait is infinite.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>exitContext</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> if both the signal and the wait completed successfully, or <code>false</code> if the signal completed but the wait timed out.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>toSignal</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>toWaitOn</code> is <code>null</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The method is called on a thread that has <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.platformnotsupportedexception\" data-linktype=\"relative-path\">PlatformNotSupportedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>This method is not supported on Windows 98 or Windows Millennium Edition.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> cannot be signaled because it would exceed its maximum count.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This operation is not guaranteed to be atomic. After the current thread signals <code>toSignal</code> but before it waits on <code>toWaitOn</code>, a thread that is running on another processor might signal <code>toWaitOn</code> or wait on it.  </p>\n<p> If <code>millisecondsTimeout</code> is zero, the method does not block. It tests the state of the <code>toWaitOn</code> and returns immediately.  </p>\n<h2 id=\"notes-on-exiting-the-context\">Notes on Exiting the Context</h2>\n<p> The <code>exitContext</code> parameter has no effect unless the SignalAndWait method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>. Even if you are currently executing a method on a class that does not derive from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>, like <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>, you can be in a nondefault context if a <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a> is on your stack in the current application domain.  </p>\n<p> When your code is executing in a nondefault context, specifying <code>true</code> for <code>exitContext</code> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the SignalAndWait method. The thread returns to the original nondefault context after the call to the SignalAndWait method completes.  </p>\n<p> This can be useful when the context-bound class has <a class=\"xref\" href=\"system.runtime.remoting.contexts.synchronizationattribute\" data-linktype=\"relative-path\">SynchronizationAttribute</a>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the SignalAndWait method and specifies <code>true</code> for <code>exitContext</code>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the SignalAndWait method returns, the thread that made the call must wait to reenter the synchronization domain.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_SignalAndWait_System_Threading_WaitHandle_System_Threading_WaitHandle_System_TimeSpan_System_Boolean_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">SignalAndWait(WaitHandle,WaitHandle,TimeSpan,Boolean)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Signals one <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> and waits on another, specifying the time-out interval as a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> and specifying whether to exit the synchronization domain for the context before entering the wait.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>toSignal</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> to signal.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>toWaitOn</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> to wait on.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>timeout</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents the interval to wait. If the value is -1, the wait is infinite.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>exitContext</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> if both the signal and the wait completed successfully, or <code>false</code> if the signal completed but the wait timed out.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>toSignal</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>toWaitOn</code> is <code>null</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The method was called on a thread that has <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.platformnotsupportedexception\" data-linktype=\"relative-path\">PlatformNotSupportedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>This method is not supported on Windows 98 or Windows Millennium Edition.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>toSignal</code> is a semaphore, and it already has a full count.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>timeout</code> evaluates to a negative number of milliseconds other than -1.  </p>\n<p> -or-  </p>\n<p> <code>timeout</code> is greater than <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">MaxValue</a>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This operation is not guaranteed to be atomic. After the current thread signals <code>toSignal</code> but before it waits on <code>toWaitOn</code>, a thread that is running on another processor might signal <code>toWaitOn</code> or wait on it.  </p>\n<p> The maximum value for <code>timeout</code> is <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">System.Int32.MaxValue</a>.  </p>\n<p> If <code>timeout</code> is zero, the method does not block. It tests the state of the <code>toWaitOn</code> and returns immediately.  </p>\n<h2 id=\"notes-on-exiting-the-context\">Notes on Exiting the Context</h2>\n<p> The <code>exitContext</code> parameter has no effect unless the SignalAndWait method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>. Even if you are currently executing a method on a class that does not derive from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>, like <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>, you can be in a nondefault context if a <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a> is on your stack in the current application domain.  </p>\n<p> When your code is executing in a nondefault context, specifying <code>true</code> for <code>exitContext</code> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the SignalAndWait method. The thread returns to the original nondefault context after the call to the SignalAndWait method completes.  </p>\n<p> This can be useful when the context-bound class has <a class=\"xref\" href=\"system.runtime.remoting.contexts.synchronizationattribute\" data-linktype=\"relative-path\">SynchronizationAttribute</a>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the SignalAndWait method and specifies <code>true</code> for <code>exitContext</code>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the SignalAndWait method returns, the thread that made the call must wait to reenter the synchronization domain.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">WaitAll(WaitHandle[])</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Waits for all the elements in the specified array to receive a signal.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>waitHandles</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <code>WaitHandle</code> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> when every element in <code>waitHandles</code> has received a signal; otherwise the method never returns.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>waitHandles</code> parameter is <code>null</code>. -or-  </p>\n<p> One or more of the objects in the <code>waitHandles</code> array are <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>waitHandles</code> is an array with no elements and the .NET Framework version is 2.0 or later.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.duplicatewaitobjectexception\" data-linktype=\"relative-path\">DuplicateWaitObjectException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"alert NOTE\"><br> In the <a href=\"http://go.microsoft.com/fwlink/?LinkID=247912\" data-linktype=\"external\">.NET for Windows Store apps</a> or the <a href=\"../Topic/Cross-Platform%20Development%20with%20the%20Portable%20Class%20Library.md\" data-linktype=\"relative-path\">Portable Class Library</a>, catch the base class exception, <a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a>, instead.<br>\n</div>  \n\n<p> The <code>waitHandles</code> array contains elements that are duplicates.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The number of objects in <code>waitHandles</code> is greater than the system permits.  </p>\n<p> -or-  </p>\n<p> The <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>waitHandles</code> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>waitHandles</code> array contains a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> is new in the .NET Framework version 2.0. In previous versions, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method returns <code>true</code> when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method returns when all the handles are signaled. On some implementations, if more than 64 handles are passed, a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> is thrown. If the array contains duplicates, the call fails with a <a class=\"xref\" href=\"system.duplicatewaitobjectexception\" data-linktype=\"relative-path\">DuplicateWaitObjectException</a>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method is not supported on threads that have <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a>.  </p>\n</div>\n<p> Calling this method overload is equivalent to calling the [WaitAll(WaitHandle&lt;xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29&gt; method overload and specifying -1 (or <a class=\"xref\" href=\"system.threading.timeout#System_Threading_Timeout_Infinite\" data-linktype=\"relative-path\">System.Threading.Timeout.Infinite</a>) for <code>millisecondsTimeout</code>and <code>true</code> for <code>exitContext</code>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_Int32_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">WaitAll(WaitHandle[],Int32)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Waits for all the elements in the specified array to receive a signal, using an <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a> value to specify the time interval.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>waitHandles</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <code>WaitHandle</code> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object (duplicates).</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>millisecondsTimeout</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The number of milliseconds to wait, or <a class=\"xref\" href=\"system.threading.timeout#System_Threading_Timeout_Infinite\" data-linktype=\"relative-path\">Infinite</a> (-1) to wait indefinitely.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> when every element in <code>waitHandles</code> has received a signal; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>waitHandles</code> parameter is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One or more of the objects in the <code>waitHandles</code> array is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>waitHandles</code> is an array with no elements.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.duplicatewaitobjectexception\" data-linktype=\"relative-path\">DuplicateWaitObjectException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"alert NOTE\"><br> In the <a href=\"http://go.microsoft.com/fwlink/?LinkID=247912\" data-linktype=\"external\">.NET for Windows Store apps</a> or the <a href=\"../Topic/Cross-Platform%20Development%20with%20the%20Portable%20Class%20Library.md\" data-linktype=\"relative-path\">Portable Class Library</a>, catch the base class exception, <a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a>, instead.<br>\n</div>  \n\n<p> The <code>waitHandles</code> array contains elements that are duplicates.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The number of objects in <code>waitHandles</code> is greater than the system permits.  </p>\n<p> -or-  </p>\n<p> The <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>waitHandles</code> array contains a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>If <code>millisecondsTimeout</code> is zero, the method does not block. It tests the state of the wait handles and returns immediately.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs. On some implementations, if more than 64 handles are passed, a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> is thrown. If there are duplicates in the array, the call fails with a <a class=\"xref\" href=\"system.duplicatewaitobjectexception\" data-linktype=\"relative-path\">DuplicateWaitObjectException</a>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method is not supported on threads that have <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a>.  </p>\n</div>\n<p> Calling this method overload is the same as calling the [WaitAll(WaitHandle&lt;xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29&gt; overload and specifying <code>false</code> for <code>exitContext</code>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_TimeSpan_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">WaitAll(WaitHandle[],TimeSpan)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Waits for all the elements in the specified array to receive a signal, using a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> value to specify the time interval.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>waitHandles</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <code>WaitHandle</code> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>timeout</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents the number of milliseconds to wait, or a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents -1 milliseconds, to wait indefinitely.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> when every element in <code>waitHandles</code> has received a signal; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>waitHandles</code> parameter is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One or more of the objects in the <code>waitHandles</code> array is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>waitHandles</code> is an array with no elements.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.duplicatewaitobjectexception\" data-linktype=\"relative-path\">DuplicateWaitObjectException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"alert NOTE\"><br> In the <a href=\"http://go.microsoft.com/fwlink/?LinkID=247912\" data-linktype=\"external\">.NET for Windows Store apps</a> or the <a href=\"../Topic/Cross-Platform%20Development%20with%20the%20Portable%20Class%20Library.md\" data-linktype=\"relative-path\">Portable Class Library</a>, catch the base class exception, <a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a>, instead.<br>\n</div>  \n\n<p> The <code>waitHandles</code> array contains elements that are duplicates.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The number of objects in <code>waitHandles</code> is greater than the system permits.  </p>\n<p> -or-  </p>\n<p> The <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out.  </p>\n<p> -or-  </p>\n<p> <code>timeout</code> is greater than <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">MaxValue</a>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>waitHandles</code> array contains a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>If <code>timeout</code> is zero, the method does not block. It tests the state of the wait handles and returns immediately.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs. On some implementations, if more than 64 handles are passed, a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> is thrown. If the array contains duplicates, the call will fail.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method is not supported on threads that have <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a>.  </p>\n</div>\n<p> The maximum value for <code>timeout</code> is <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">System.Int32.MaxValue</a>.  </p>\n<p> Calling this method overload is the same as calling the [WaitAll(WaitHandle&lt;xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29&gt; overload and specifying <code>false</code> for <code>exitContext</code>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_Int32_System_Boolean_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">WaitAll(WaitHandle[],Int32,Boolean)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Waits for all the elements in the specified array to receive a signal, using an <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>waitHandles</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <code>WaitHandle</code> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object (duplicates).</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>millisecondsTimeout</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The number of milliseconds to wait, or <a class=\"xref\" href=\"system.threading.timeout#System_Threading_Timeout_Infinite\" data-linktype=\"relative-path\">Infinite</a> (-1) to wait indefinitely.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>exitContext</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> when every element in <code>waitHandles</code> has received a signal; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>waitHandles</code> parameter is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One or more of the objects in the <code>waitHandles</code> array is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>waitHandles</code> is an array with no elements and the .NET Framework version is 2.0 or later.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.duplicatewaitobjectexception\" data-linktype=\"relative-path\">DuplicateWaitObjectException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>waitHandles</code> array contains elements that are duplicates.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The number of objects in <code>waitHandles</code> is greater than the system permits.  </p>\n<p> -or-  </p>\n<p> The <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>waitHandles</code> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>waitHandles</code> array contains a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>If <code>millisecondsTimeout</code> is zero, the method does not block. It tests the state of the wait handles and returns immediately.  </p>\n<p> <a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> is new in the .NET Framework version 2.0. In previous versions, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method returns <code>true</code> when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs. On some implementations, if more than 64 handles are passed, a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> is thrown. If there are duplicates in the array, the call fails with a <a class=\"xref\" href=\"system.duplicatewaitobjectexception\" data-linktype=\"relative-path\">DuplicateWaitObjectException</a>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method is not supported on threads that have <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a>.  </p>\n</div>\n<h2 id=\"notes-on-exiting-the-context\">Notes on Exiting the Context</h2>\n<p> The <code>exitContext</code> parameter has no effect unless the WaitAll method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>. Even if you are currently executing a method on a class that is not derived from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>, like <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>, you can be in a nondefault context if a <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a> is on your stack in the current application domain.  </p>\n<p> When your code is executing in a nondefault context, specifying <code>true</code> for <code>exitContext</code> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the WaitAll method. The thread returns to the original nondefault context after the call to the WaitAll method completes.  </p>\n<p> This can be useful when the context-bound class has the <a class=\"xref\" href=\"system.runtime.remoting.contexts.synchronizationattribute\" data-linktype=\"relative-path\">SynchronizationAttribute</a> attribute. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the WaitAll method and specifies <code>true</code> for <code>exitContext</code>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the WaitAll method returns, the thread that made the call must wait to reenter the synchronization domain.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_TimeSpan_System_Boolean_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">WaitAll(WaitHandle[],TimeSpan,Boolean)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Waits for all the elements in the specified array to receive a signal, using a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>waitHandles</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <code>WaitHandle</code> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>timeout</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents the number of milliseconds to wait, or a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents -1 milliseconds, to wait indefinitely.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>exitContext</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> when every element in <code>waitHandles</code> has received a signal; otherwise <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>waitHandles</code> parameter is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One or more of the objects in the <code>waitHandles</code> array is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>waitHandles</code> is an array with no elements and the .NET Framework version is 2.0 or later.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.duplicatewaitobjectexception\" data-linktype=\"relative-path\">DuplicateWaitObjectException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>waitHandles</code> array contains elements that are duplicates.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The number of objects in <code>waitHandles</code> is greater than the system permits.  </p>\n<p> -or-  </p>\n<p> The <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>waitHandles</code> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out.  </p>\n<p> -or-  </p>\n<p> <code>timeout</code> is greater than <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">MaxValue</a>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>waitHandles</code> array contains a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>If <code>timeout</code> is zero, the method does not block. It tests the state of the wait handles and returns immediately.  </p>\n<p> <a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> is new in the .NET Framework version 2.0. In previous versions, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method returns <code>true</code> when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs. On some implementations, if more than 64 handles are passed, a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> is thrown. If the array contains duplicates, the call will fail.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method is not supported on threads that have <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a>.  </p>\n</div>\n<p> The maximum value for <code>timeout</code> is <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">System.Int32.MaxValue</a>.  </p>\n<h2 id=\"notes-on-exiting-the-context\">Notes on Exiting the Context</h2>\n<p> The <code>exitContext</code> parameter has no effect unless the WaitAll method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>. Even if you are currently executing a method on a class that is not derived from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>, like <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>, you can be in a nondefault context if a <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a> is on your stack in the current application domain.  </p>\n<p> When your code is executing in a nondefault context, specifying <code>true</code> for <code>exitContext</code> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the WaitAll method. It returns to the original nondefault context after the call to the WaitAll method completes.  </p>\n<p> This can be useful when the context-bound class has <a class=\"xref\" href=\"system.runtime.remoting.contexts.synchronizationattribute\" data-linktype=\"relative-path\">SynchronizationAttribute</a>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the WaitAll method and specifies <code>true</code> for <code>exitContext</code>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the WaitAll method returns, the thread that made the call must wait to reenter the synchronization domain.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">WaitAny(WaitHandle[])</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Waits for any of the elements in the specified array to receive a signal.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public static int WaitAny (System.Threading.WaitHandle[] waitHandles);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>waitHandles</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <code>WaitHandle</code> array containing the objects for which the current instance will wait.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The array index of the object that satisfied the wait.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>waitHandles</code> parameter is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One or more of the objects in the <code>waitHandles</code> array is <code>null</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The number of objects in <code>waitHandles</code> is greater than the system permits.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>waitHandles</code> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>waitHandles</code> is an array with no elements, and the .NET Framework version is 2.0 or later.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>waitHandles</code> array contains a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> is new in the .NET Framework version 2.0. In previous versions, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method returns <code>true</code> if the wait completes because a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method throws an <a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> only when the wait completes because of an abandoned mutex. If <code>waitHandles</code> contains a released mutex with a lower index number than the abandoned mutex, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method completes normally and the exception is not thrown.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a>, and that <code>Mutex</code> is at index 0 (zero) in a <code>WaitAny</code> array on another thread, the index returned by <code>WaitAny</code> is 128 instead of 0.  </p>\n</div>\n<p> This method returns when any handle is signaled. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> is thrown.  </p>\n<p> Calling this method overload is equivalent to calling the [WaitAny(WaitHandle&lt;xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29&gt; method overload and specifying -1 (or <a class=\"xref\" href=\"system.threading.timeout#System_Threading_Timeout_Infinite\" data-linktype=\"relative-path\">System.Threading.Timeout.Infinite</a>) for <code>millisecondsTimeout</code>and <code>true</code> for <code>exitContext</code>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_Int32_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">WaitAny(WaitHandle[],Int32)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>waitHandles</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <code>WaitHandle</code> array containing the objects for which the current instance will wait.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>millisecondsTimeout</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The number of milliseconds to wait, or <a class=\"xref\" href=\"system.threading.timeout#System_Threading_Timeout_Infinite\" data-linktype=\"relative-path\">Infinite</a> (-1) to wait indefinitely.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The array index of the object that satisfied the wait, or <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitTimeout\" data-linktype=\"relative-path\">WaitTimeout</a> if no object satisfied the wait and a time interval equivalent to <code>millisecondsTimeout</code> has passed.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>waitHandles</code> parameter is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One or more of the objects in the <code>waitHandles</code> array is <code>null</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The number of objects in <code>waitHandles</code> is greater than the system permits.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>waitHandles</code> is an array with no elements.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>waitHandles</code> array contains a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>If <code>millisecondsTimeout</code> is zero, the method does not block. It tests the state of the wait handles and returns immediately.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method throws an <a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> only when the wait completes because of an abandoned mutex. If <code>waitHandles</code> contains a released mutex with a lower index number than the abandoned mutex, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method completes normally and the exception is not thrown.  </p>\n<p> This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> is thrown.  </p>\n<p> Calling this method overload is the same as calling the [WaitAny(WaitHandle&lt;xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29&gt; overload and specifying <code>false</code> for <code>exitContext</code>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_TimeSpan_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">WaitAny(WaitHandle[],TimeSpan)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Waits for any of the elements in the specified array to receive a signal, using a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> to specify the time interval.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>waitHandles</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <code>WaitHandle</code> array containing the objects for which the current instance will wait.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>timeout</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents the number of milliseconds to wait, or a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents -1 milliseconds to wait indefinitely.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The array index of the object that satisfied the wait, or <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitTimeout\" data-linktype=\"relative-path\">WaitTimeout</a> if no object satisfied the wait and a time interval equivalent to <code>timeout</code> has passed.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>waitHandles</code> parameter is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One or more of the objects in the <code>waitHandles</code> array is <code>null</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The number of objects in <code>waitHandles</code> is greater than the system permits.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out.  </p>\n<p> -or-  </p>\n<p> <code>timeout</code> is greater than <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">MaxValue</a>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>waitHandles</code> is an array with no elements.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>waitHandles</code> array contains a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>If <code>timeout</code> is zero, the method does not block. It tests the state of the wait handles and returns immediately.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method throws an <a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> only when the wait completes because of an abandoned mutex. If <code>waitHandles</code> contains a released mutex with a lower index number than the abandoned mutex, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method completes normally and the exception is not thrown.  </p>\n<p> This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> is thrown.  </p>\n<p> The maximum value for <code>timeout</code> is <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">System.Int32.MaxValue</a>.  </p>\n<p> Calling this method overload is the same as calling the [WaitAny(WaitHandle&lt;xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29&gt; overload and specifying <code>false</code> for <code>exitContext</code>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_Int32_System_Boolean_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">WaitAny(WaitHandle[],Int32,Boolean)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>waitHandles</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <code>WaitHandle</code> array containing the objects for which the current instance will wait.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>millisecondsTimeout</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The number of milliseconds to wait, or <a class=\"xref\" href=\"system.threading.timeout#System_Threading_Timeout_Infinite\" data-linktype=\"relative-path\">Infinite</a> (-1) to wait indefinitely.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>exitContext</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The array index of the object that satisfied the wait, or <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitTimeout\" data-linktype=\"relative-path\">WaitTimeout</a> if no object satisfied the wait and a time interval equivalent to <code>millisecondsTimeout</code> has passed.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>waitHandles</code> parameter is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One or more of the objects in the <code>waitHandles</code> array is <code>null</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The number of objects in <code>waitHandles</code> is greater than the system permits.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>waitHandles</code> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>waitHandles</code> is an array with no elements, and the .NET Framework version is 2.0 or later.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>waitHandles</code> array contains a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>If <code>millisecondsTimeout</code> is zero, the method does not block. It tests the state of the wait handles and returns immediately.  </p>\n<p> <a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> is new in the .NET Framework version 2.0. In previous versions, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method returns <code>true</code> if the wait completes because a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method throws an <a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> only when the wait completes because of an abandoned mutex. If <code>waitHandles</code> contains a released mutex with a lower index number than the abandoned mutex, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method completes normally and the exception is not thrown.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a>, and that <code>Mutex</code> is at index 0 (zero) in a <code>WaitAny</code> array on another thread, the index returned by <code>WaitAny</code> is 128 instead of 0.  </p>\n</div>\n<p> This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> is thrown.  </p>\n<h2 id=\"notes-on-exiting-the-context\">Notes on Exiting the Context</h2>\n<p> The <code>exitContext</code> parameter has no effect unless the WaitAny method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>. Even if you are currently executing a method on a class that does not derive from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>, like <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>, you can be in a nondefault context if a <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a> is on your stack in the current application domain.  </p>\n<p> When your code is executing in a nondefault context, specifying <code>true</code> for <code>exitContext</code> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the WaitAny method. The thread returns to the original nondefault context after the call to the WaitAny method completes.  </p>\n<p> This can be useful when the context-bound class has <a class=\"xref\" href=\"system.runtime.remoting.contexts.synchronizationattribute\" data-linktype=\"relative-path\">SynchronizationAttribute</a>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the WaitAny method and specifies <code>true</code> for <code>exitContext</code>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the WaitAny method returns, the thread that made the call must wait to reenter the synchronization domain.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_TimeSpan_System_Boolean_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">WaitAny(WaitHandle[],TimeSpan,Boolean)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Waits for any of the elements in the specified array to receive a signal, using a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>waitHandles</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>[]</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <code>WaitHandle</code> array containing the objects for which the current instance will wait.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>timeout</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents the number of milliseconds to wait, or a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents -1 milliseconds to wait indefinitely.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>exitContext</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The array index of the object that satisfied the wait, or <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitTimeout\" data-linktype=\"relative-path\">WaitTimeout</a> if no object satisfied the wait and a time interval equivalent to <code>timeout</code> has passed.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>waitHandles</code> parameter is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One or more of the objects in the <code>waitHandles</code> array is <code>null</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The number of objects in <code>waitHandles</code> is greater than the system permits.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>waitHandles</code> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out.  </p>\n<p> -or-  </p>\n<p> <code>timeout</code> is greater than <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">MaxValue</a>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>waitHandles</code> is an array with no elements, and the .NET Framework version is 2.0 or later.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>waitHandles</code> array contains a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>If <code>timeout</code> is zero, the method does not block. It tests the state of the wait handles and returns immediately.  </p>\n<p> <a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> is new in the .NET Framework version 2.0. In previous versions, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method returns <code>true</code> if the wait completes because a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method throws an <a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> only when the wait completes because of an abandoned mutex. If <code>waitHandles</code> contains a released mutex with a lower index number than the abandoned mutex, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method completes normally and the exception is not thrown.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a>, and that <code>Mutex</code> is at index 0 (zero) in a <code>WaitAny</code> array on another thread, the index returned by <code>WaitAny</code> is 128 instead of 0.  </p>\n</div>\n<p> This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> is thrown.  </p>\n<p> The maximum value for <code>timeout</code> is <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">System.Int32.MaxValue</a>.  </p>\n<h2 id=\"notes-on-exiting-the-context\">Notes on Exiting the Context</h2>\n<p> The <code>exitContext</code> parameter has no effect unless the WaitAny method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>. Even if you are currently executing a method on a class that does not derive from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>, like <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>, you can be in a nondefault context if a <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a> is on your stack in the current application domain.  </p>\n<p> When your code is executing in a nondefault context, specifying <code>true</code> for <code>exitContext</code> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the WaitAny method. The thread returns to the original nondefault context after the call to the WaitAny method completes.  </p>\n<p> This can be useful when the context-bound class has <a class=\"xref\" href=\"system.runtime.remoting.contexts.synchronizationattribute\" data-linktype=\"relative-path\">SynchronizationAttribute</a>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the WaitAny method and specifies <code>true</code> for <code>exitContext</code>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the WaitAny method returns, the thread that made the call must wait to reenter the synchronization domain.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_WaitOne\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">WaitOne()</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Blocks the current thread until the current <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> receives a signal.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public virtual bool WaitOne ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> if the current instance receives a signal. If the current instance is never signaled, <span class=\"xref\">stem.Threading.WaitHandle.WaitOne*</span> never returns.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.objectdisposedexception\" data-linktype=\"relative-path\">ObjectDisposedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The current instance has already been disposed.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The current instance is a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> is new in the .NET Framework version 2.0. In previous versions, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> method returns <code>true</code> when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  </p>\n<p> The caller of this method blocks indefinitely until the current instance receives a signal. Use this method to block until a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <a class=\"xref\" href=\"system.iasyncresult\" data-linktype=\"relative-path\">IAsyncResult</a> interface.  </p>\n<p> Calling this method overload is equivalent to calling the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_System_Int32_System_Boolean_\" data-linktype=\"relative-path\">WaitOne(Int32,Boolean)</a> method overload and specifying -1 or <a class=\"xref\" href=\"system.threading.timeout#System_Threading_Timeout_Infinite\" data-linktype=\"relative-path\">System.Threading.Timeout.Infinite</a> for the first parameter and <code>false</code> for the second parameter.  </p>\n<p> Override this method to customize the behavior of derived classes.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_WaitOne_System_Int32_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">WaitOne(Int32)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Blocks the current thread until the current <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public virtual bool WaitOne (int millisecondsTimeout);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>millisecondsTimeout</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The number of milliseconds to wait, or <a class=\"xref\" href=\"system.threading.timeout#System_Threading_Timeout_Infinite\" data-linktype=\"relative-path\">Infinite</a> (-1) to wait indefinitely.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> if the current instance receives a signal; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.objectdisposedexception\" data-linktype=\"relative-path\">ObjectDisposedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The current instance has already been disposed.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The current instance is a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>If <code>millisecondsTimeout</code> is zero, the method does not block. It tests the state of the wait handle and returns immediately.  </p>\n<p> The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <a class=\"xref\" href=\"system.iasyncresult\" data-linktype=\"relative-path\">IAsyncResult</a> interface.  </p>\n<p> Override this method to customize the behavior of derived classes.  </p>\n<p> Calling this method overload is the same as calling the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_System_Int32_System_Boolean_\" data-linktype=\"relative-path\">WaitOne(Int32,Boolean)</a> overload and specifying <code>false</code> for <code>exitContext</code>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_WaitOne_System_TimeSpan_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">WaitOne(TimeSpan)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Blocks the current thread until the current instance receives a signal, using a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> to specify the time interval.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public virtual bool WaitOne (TimeSpan timeout);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>timeout</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents the number of milliseconds to wait, or a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents -1 milliseconds to wait indefinitely.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> if the current instance receives a signal; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.objectdisposedexception\" data-linktype=\"relative-path\">ObjectDisposedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The current instance has already been disposed.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out.  </p>\n<p> -or-  </p>\n<p> <code>timeout</code> is greater than <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">MaxValue</a>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The current instance is a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>If <code>timeout</code> is zero, the method does not block. It tests the state of the wait handle and returns immediately.  </p>\n<p> The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <a class=\"xref\" href=\"system.iasyncresult\" data-linktype=\"relative-path\">IAsyncResult</a> interface.  </p>\n<p> Override this method to customize the behavior of derived classes.  </p>\n<p> The maximum value for <code>timeout</code> is <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">System.Int32.MaxValue</a>.  </p>\n<p> Calling this method overload is the same as calling the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_System_TimeSpan_System_Boolean_\" data-linktype=\"relative-path\">WaitOne(TimeSpan,Boolean)</a> overload and specifying <code>false</code> for <code>exitContext</code>.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_WaitOne_System_Int32_System_Boolean_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">WaitOne(Int32,Boolean)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Blocks the current thread until the current <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>millisecondsTimeout</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The number of milliseconds to wait, or <a class=\"xref\" href=\"system.threading.timeout#System_Threading_Timeout_Infinite\" data-linktype=\"relative-path\">Infinite</a> (-1) to wait indefinitely.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>exitContext</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> if the current instance receives a signal; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.objectdisposedexception\" data-linktype=\"relative-path\">ObjectDisposedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The current instance has already been disposed.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The current instance is a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>If <code>millisecondsTimeout</code> is zero, the method does not block. It tests the state of the wait handle and returns immediately.  </p>\n<p> <a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> is new in the .NET Framework version 2.0. In previous versions, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> method returns <code>true</code> when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  </p>\n<p> The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <a class=\"xref\" href=\"system.iasyncresult\" data-linktype=\"relative-path\">IAsyncResult</a> interface.  </p>\n<p> Override this method to customize the behavior of derived classes.  </p>\n<h2 id=\"notes-on-exiting-the-context\">Notes on Exiting the Context</h2>\n<p> The <code>exitContext</code> parameter has no effect unless the WaitOne method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>. Even if you are currently executing a method on a class that does not derive from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>, like <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>, you can be in a nondefault context if a <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a> is on your stack in the current application domain.  </p>\n<p> When your code is executing in a nondefault context, specifying <code>true</code> for <code>exitContext</code> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the WaitOne method. The thread returns to the original nondefault context after the call to the WaitOne method completes.  </p>\n<p> This can be useful when the context-bound class has <a class=\"xref\" href=\"system.runtime.remoting.contexts.synchronizationattribute\" data-linktype=\"relative-path\">SynchronizationAttribute</a>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the WaitOne method and specifies <code>true</code> for <code>exitContext</code>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the WaitOne method returns, the thread that made the call must wait to reenter the synchronization domain.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Threading_WaitHandle_WaitOne_System_TimeSpan_System_Boolean_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">WaitOne(TimeSpan,Boolean)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Blocks the current thread until the current instance receives a signal, using a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public virtual bool WaitOne (TimeSpan timeout, bool exitContext);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>timeout</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents the number of milliseconds to wait, or a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents -1 milliseconds to wait indefinitely.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>exitContext</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> if the current instance receives a signal; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.objectdisposedexception\" data-linktype=\"relative-path\">ObjectDisposedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The current instance has already been disposed.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out.  </p>\n<p> -or-  </p>\n<p> <code>timeout</code> is greater than <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">MaxValue</a>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The current instance is a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>If <code>timeout</code> is zero, the method does not block. It tests the state of the wait handle and returns immediately.  </p>\n<p> <a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> is new in the .NET Framework version 2.0. In previous versions, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> method returns <code>true</code> when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  </p>\n<p> The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <a class=\"xref\" href=\"system.iasyncresult\" data-linktype=\"relative-path\">IAsyncResult</a> interface.  </p>\n<p> Override this method to customize the behavior of derived classes.  </p>\n<p> The maximum value for <code>timeout</code> is <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">System.Int32.MaxValue</a>.  </p>\n<h2 id=\"notes-on-exiting-the-context\">Notes on Exiting the Context</h2>\n<p> The <code>exitContext</code> parameter has no effect unless the WaitOne method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>. Even if you are currently executing a method on a class that does not derive from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>, like <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>, you can be in a nondefault context if a <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a> is on your stack in the current application domain.  </p>\n<p> When your code is executing in a nondefault context, specifying <code>true</code> for <code>exitContext</code> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the WaitOne method. The thread returns to the original nondefault context after the call to the WaitOne method completes.  </p>\n<p> This can be useful when the context-bound class has <a class=\"xref\" href=\"system.runtime.remoting.contexts.synchronizationattribute\" data-linktype=\"relative-path\">SynchronizationAttribute</a>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the WaitOne method and specifies <code>true</code> for <code>exitContext</code>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the WaitOne method returns, the thread that made the call must wait to reenter the synchronization domain.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t  \r\n  \t\t</section>\r\n  \r\n  \r\n","outputRootRelativePath":"./","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"breadcrumb_path\" content=\"breadcrumb/toc.json\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"fulldocset\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.fulldocset\">\r\n<meta name=\"ref_skeleton_gitcommit\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Threading.WaitHandle.yml\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Threading.WaitHandle.yml\">\r\n<meta name=\"APIName\" content=\"System.Threading.WaitHandle\">\r\n<meta name=\"APIName\" content=\"System.Threading.WaitHandle..ctor\">\r\n<meta name=\"APIName\" content=\"System.Threading.WaitHandle.Close\">\r\n<meta name=\"APIName\" content=\"System.Threading.WaitHandle.Dispose\">\r\n<meta name=\"APIName\" content=\"System.Threading.WaitHandle.Handle\">\r\n<meta name=\"APIName\" content=\"System.Threading.WaitHandle.InvalidHandle\">\r\n<meta name=\"APIName\" content=\"System.Threading.WaitHandle.SafeWaitHandle\">\r\n<meta name=\"APIName\" content=\"System.Threading.WaitHandle.SignalAndWait\">\r\n<meta name=\"APIName\" content=\"System.Threading.WaitHandle.WaitAll\">\r\n<meta name=\"APIName\" content=\"System.Threading.WaitHandle.WaitAny\">\r\n<meta name=\"APIName\" content=\"System.Threading.WaitHandle.WaitOne\">\r\n<meta name=\"APIName\" content=\"System.Threading.WaitHandle.WaitTimeout\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-01 01:37 AM\">\r\n<meta name=\"document_id\" content=\"81064bf3-f23d-02d2-f193-7031ccd2f1cf\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Encapsulates operating system–specific objects that wait for exclusive access to shared resources.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/System.Threading/toc.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Threading.WaitHandle\">\r\n","rawMetadata":{"author":"dotnet-bot","breadcrumb_path":"breadcrumb/toc.json","search.ms_sitename":"Docs","search.ms_docsetname":"fulldocset","version":null,"_op_canonicalUrlPrefix":"https://ppe.docs.microsoft.com/en-us/fulldotnet/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":true,"depot_name":"MSDN.fulldocset","_op_gitRefSkeletonCommitHistory":[{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"use plugin in master","commit_sha":"501959ac03e19ac52a27aa4c6bbeb980f8b11c8c","commit_date":"2017-03-01 09:31:20 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"fix pointer ref","commit_sha":"76befb0e7f7b41839ec719047e5b39a5981298f3","commit_date":"2017-02-28 15:47:23 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"switch from platform to version","commit_sha":"78cdacb5ca782478af490a6b30c3a2cb2b6b873e","commit_date":"2017-02-28 15:09:51 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"update platforms","commit_sha":"39ad5a8919a59afc93a79ac4bd8e07c3b471b37a","commit_date":"2017-02-28 10:38:59 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"checkin yml","commit_sha":"da161b792852497df7140d7768cee2eccd9cb43f","commit_date":"2017-02-28 09:36:15 +0800"}],"ref_skeleton_gitcommit":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Threading.WaitHandle.yml","original_ref_skeleton_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Threading.WaitHandle.yml","open_to_public_contributors":true,"api_name":["System.Threading.WaitHandle","System.Threading.WaitHandle..ctor","System.Threading.WaitHandle.Close","System.Threading.WaitHandle.Dispose","System.Threading.WaitHandle.Handle","System.Threading.WaitHandle.InvalidHandle","System.Threading.WaitHandle.SafeWaitHandle","System.Threading.WaitHandle.SignalAndWait","System.Threading.WaitHandle.WaitAll","System.Threading.WaitHandle.WaitAny","System.Threading.WaitHandle.WaitOne","System.Threading.WaitHandle.WaitTimeout"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Threading.WaitHandle","System::Threading::WaitHandle","System.Threading.WaitHandle.#ctor","System::Threading::WaitHandle::#ctor","System.Threading.WaitHandle.Close","System::Threading::WaitHandle::Close","System.Threading.WaitHandle.Dispose","System::Threading::WaitHandle::Dispose","System.Threading.WaitHandle.Handle","System::Threading::WaitHandle::Handle","System.Threading.WaitHandle.InvalidHandle","System::Threading::WaitHandle::InvalidHandle","System.Threading.WaitHandle.SafeWaitHandle","System::Threading::WaitHandle::SafeWaitHandle","System.Threading.WaitHandle.SignalAndWait","System::Threading::WaitHandle::SignalAndWait","System.Threading.WaitHandle.WaitAll","System::Threading::WaitHandle::WaitAll","System.Threading.WaitHandle.WaitAny","System::Threading::WaitHandle::WaitAny","System.Threading.WaitHandle.WaitOne","System::Threading::WaitHandle::WaitOne","System.Threading.WaitHandle.WaitTimeout","System::Threading::WaitHandle::WaitTimeout"],"dev_langs":["csharp"],"updated_at":"2017-03-01 01:37 AM","document_id":"81064bf3-f23d-02d2-f193-7031ccd2f1cf","content_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/xml/System.Threading/WaitHandle.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"WaitHandle class | Microsoft Docs","_op_ogTitle":"WaitHandle class","description":"Encapsulates operating system–specific objects that wait for exclusive access to shared resources.\n","toc_asset_id":"_splitted/System.Threading/toc.json","toc_rel":"_splitted/System.Threading/toc.json","source_url":"","ms.assetid":"System.Threading.WaitHandle","canonical_url":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.threading.waithandle","_op_canonicalUrl":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.threading.waithandle","fileRelativePath":"System.Threading.WaitHandle.html"},"themesRelativePathToOutputRoot":"_themes/"}