{"content":"    \r\n    <h1 id=\"System_Threading_WaitHandle\">\r\n      <span class=\"lang-csharp\">WaitHandle</span>\r\n        Class\r\n    </h1>\r\n    \r\n    \r\n    <nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n      <h3>In this Article</h3>\r\n    </nav><div class=\"summary\">\r\n    \t<p>Encapsulates operating system–specific objects that wait for exclusive access to shared resources.</p>\n\r\n    </div><h2>Syntax</h2>\r\n    \r\n    \t<h3>Declaration</h3>\r\n    \t<pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ComVisible(true)]\npublic abstract class WaitHandle : MarshalByRefObject, IDisposable</code></pre>\r\n    \r\n    \r\n    \r\n    <h3>Inheritance Hierarchy</h3>\r\n    <ul class=\"inheritance\">\r\n        <li class=\"l0\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>\r\n          </div>\r\n        </li>\r\n        <li class=\"l1\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.marshalbyrefobject\" data-linktype=\"relative-path\">System.MarshalByRefObject</a>\r\n          </div>\r\n        </li>\r\n      <li class=\"l2\">\r\n        <div class=\"xref\">\r\n          <div class=\"lang-csharp\">WaitHandle</div>\r\n        </div>\r\n      </li>\r\n    </ul>\r\n    \r\n      <div class=\"referencebox inheritedMembers\">\r\n        <h3>Inherited Members</h3>\r\n        <h4></h4>\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.marshalbyrefobject#System_MarshalByRefObject_CreateObjRef_System_Type_\" data-linktype=\"relative-path\">CreateObjRef(Type)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.marshalbyrefobject#System_MarshalByRefObject_GetLifetimeService\" data-linktype=\"relative-path\">GetLifetimeService()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.marshalbyrefobject#System_MarshalByRefObject_InitializeLifetimeService\" data-linktype=\"relative-path\">InitializeLifetimeService()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.marshalbyrefobject#System_MarshalByRefObject_MemberwiseClone_System_Boolean_\" data-linktype=\"relative-path\">MemberwiseClone(Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a>\r\n          </div>\r\n          \r\n      </div>\r\n    \r\n    \r\n      <h2>Remarks</h2>\r\n      <p>The WaitHandle class encapsulates Win32 synchronization handles, and is used to represent all synchronization objects in the runtime that allow multiple wait operations. For a comparison of wait handles with other synchronization objects, see <a href=\"../Topic/Overview%20of%20Synchronization%20Primitives.md\" data-linktype=\"relative-path\">Overview of Synchronization Primitives</a>.  </p>\n<p> The WaitHandle class itself is abstract. Classes derived from WaitHandle define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited WaitHandle methods to block while waiting for access to shared resources. The classes derived from WaitHandle include:  </p>\n<ul>\n<li><p>The <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> class. See <a href=\"../Topic/Mutexes.md\" data-linktype=\"relative-path\">Mutexes</a>.  </p>\n</li>\n<li><p>The <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> class and its derived classes, <a class=\"xref\" href=\"system.threading.autoresetevent\" data-linktype=\"relative-path\">AutoResetEvent</a> and <a class=\"xref\" href=\"system.threading.manualresetevent\" data-linktype=\"relative-path\">ManualResetEvent</a>. See <a href=\"../Topic/EventWaitHandle,%20AutoResetEvent,%20CountdownEvent,%20ManualResetEvent.md\" data-linktype=\"relative-path\">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</a>.  </p>\n</li>\n<li><p>The <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> class. See <a href=\"../Topic/Semaphore%20and%20SemaphoreSlim.md\" data-linktype=\"relative-path\">Semaphore and SemaphoreSlim</a>.  </p>\n<p>Threads can block on an individual wait handle by calling the instance method <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a>, which is inherited by classes derived from WaitHandle.  </p>\n<p>The derived classes of WaitHandle differ in their thread affinity. Event wait handles (<a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a>, <a class=\"xref\" href=\"system.threading.autoresetevent\" data-linktype=\"relative-path\">AutoResetEvent</a>, and <a class=\"xref\" href=\"system.threading.manualresetevent\" data-linktype=\"relative-path\">ManualResetEvent</a>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore. Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_ReleaseMutex_\" data-linktype=\"relative-path\">ReleaseMutex</a> method on a mutex that it does not own.  </p>\n<p>Because the WaitHandle class derives from <a class=\"xref\" href=\"system.marshalbyrefobject\" data-linktype=\"relative-path\">MarshalByRefObject</a>, these classes can be used to synchronize the activities of threads across application domain boundaries.  </p>\n<p>In addition to its derived classes, the WaitHandle class has a number of static methods that block a thread until one or more synchronization objects receive a signal.. These include:  </p>\n</li>\n<li><p><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SignalAndWait_\" data-linktype=\"relative-path\">SignalAndWait</a>, which allows a thread to signal one wait handle and immediately wait on another.  </p>\n</li>\n<li><p><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a>, which allows a thread to wait until all the wait handles in an array receive a signal.  </p>\n</li>\n<li><p><a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a>, which allows a thread to wait until any one of a specified set of wait handles has been signaled .  </p>\n<p>The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.  </p>\n</li>\n</ul>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> This type implements the <a class=\"xref\" href=\"system.idisposable\" data-linktype=\"relative-path\">IDisposable</a> interface. When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Close_\" data-linktype=\"relative-path\">Close</a> method in a <code>try</code>/<code>catch</code> block. To dispose of it indirectly, use a language construct such as <code>using</code> (in C#) or <code>Using</code> (in Visual Basic). For more information, see the “Using an Object that Implements IDisposable” section in the <a class=\"xref\" href=\"system.idisposable\" data-linktype=\"relative-path\">IDisposable</a> interface topic.  </p>\n</div>\n<p> WaitHandle implements the <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose_\" data-linktype=\"relative-path\">Dispose</a> pattern. See <a href=\"../Topic/Dispose%20Pattern.md\" data-linktype=\"relative-path\">Dispose Pattern</a>. When you derive from WaitHandle, use the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SafeWaitHandle_\" data-linktype=\"relative-path\">SafeWaitHandle</a> property to store your native handle operating system handle. You do not need to override the protected <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Dispose_\" data-linktype=\"relative-path\">Dispose</a> method unless you use additional unmanaged resources.</p>\n\r\n    \r\n    \r\n    <h2>Constructors\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle__ctor\" data-linktype=\"self-bookmark\">WaitHandle()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> class.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Fields\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_InvalidHandle\" data-linktype=\"self-bookmark\">InvalidHandle</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Represents an invalid native operating system handle. This field is read-only.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_WaitTimeout\" data-linktype=\"self-bookmark\">WaitTimeout</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Indicates that a <span class=\"xref\">stem.Threading.WaitHandle.WaitAny*</span> operation timed out before any of the wait handles were signaled. This field is constant.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Properties\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_Handle\" data-linktype=\"self-bookmark\">Handle</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets or sets the native operating system handle.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_SafeWaitHandle\" data-linktype=\"self-bookmark\">SafeWaitHandle</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets or sets the native operating system handle.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Methods\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_Close\" data-linktype=\"self-bookmark\">Close()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Releases all resources held by the current <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_Dispose\" data-linktype=\"self-bookmark\">Dispose()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Releases all resources used by the current instance of the <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> class.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_Dispose_System_Boolean_\" data-linktype=\"self-bookmark\">Dispose(Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, releases the unmanaged resources used by the <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>, and optionally releases the managed resources.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_SignalAndWait_System_Threading_WaitHandle_System_Threading_WaitHandle_\" data-linktype=\"self-bookmark\">SignalAndWait(WaitHandle,WaitHandle)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Signals one <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> and waits on another.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_SignalAndWait_System_Threading_WaitHandle_System_Threading_WaitHandle_System_Int32_System_Boolean_\" data-linktype=\"self-bookmark\">SignalAndWait(WaitHandle,WaitHandle,Int32,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Signals one <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_SignalAndWait_System_Threading_WaitHandle_System_Threading_WaitHandle_System_TimeSpan_System_Boolean_\" data-linktype=\"self-bookmark\">SignalAndWait(WaitHandle,WaitHandle,TimeSpan,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Signals one <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> and waits on another, specifying the time-out interval as a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> and specifying whether to exit the synchronization domain for the context before entering the wait.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___\" data-linktype=\"self-bookmark\">WaitAll(WaitHandle[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Waits for all the elements in the specified array to receive a signal.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_Int32_\" data-linktype=\"self-bookmark\">WaitAll(WaitHandle[],Int32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Waits for all the elements in the specified array to receive a signal, using an <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a> value to specify the time interval.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_TimeSpan_\" data-linktype=\"self-bookmark\">WaitAll(WaitHandle[],TimeSpan)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Waits for all the elements in the specified array to receive a signal, using a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> value to specify the time interval.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_Int32_System_Boolean_\" data-linktype=\"self-bookmark\">WaitAll(WaitHandle[],Int32,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Waits for all the elements in the specified array to receive a signal, using an <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_TimeSpan_System_Boolean_\" data-linktype=\"self-bookmark\">WaitAll(WaitHandle[],TimeSpan,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Waits for all the elements in the specified array to receive a signal, using a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___\" data-linktype=\"self-bookmark\">WaitAny(WaitHandle[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Waits for any of the elements in the specified array to receive a signal.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_Int32_\" data-linktype=\"self-bookmark\">WaitAny(WaitHandle[],Int32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_TimeSpan_\" data-linktype=\"self-bookmark\">WaitAny(WaitHandle[],TimeSpan)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Waits for any of the elements in the specified array to receive a signal, using a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> to specify the time interval.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_Int32_System_Boolean_\" data-linktype=\"self-bookmark\">WaitAny(WaitHandle[],Int32,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_TimeSpan_System_Boolean_\" data-linktype=\"self-bookmark\">WaitAny(WaitHandle[],TimeSpan,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Waits for any of the elements in the specified array to receive a signal, using a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_WaitOne\" data-linktype=\"self-bookmark\">WaitOne()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Blocks the current thread until the current <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> receives a signal.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_WaitOne_System_Int32_\" data-linktype=\"self-bookmark\">WaitOne(Int32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Blocks the current thread until the current <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_WaitOne_System_TimeSpan_\" data-linktype=\"self-bookmark\">WaitOne(TimeSpan)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Blocks the current thread until the current instance receives a signal, using a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> to specify the time interval.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_WaitOne_System_Int32_System_Boolean_\" data-linktype=\"self-bookmark\">WaitOne(Int32,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Blocks the current thread until the current <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_WaitHandle_WaitOne_System_TimeSpan_System_Boolean_\" data-linktype=\"self-bookmark\">WaitOne(TimeSpan,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Blocks the current thread until the current instance receives a signal, using a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"constructors\">\r\n        <h2>Constructors\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle__ctor\">\r\n    \r\n            <a id=\"System_Threading_WaitHandle__ctor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">WaitHandle()</div>        \r\n          </div>\r\n    \r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> class.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected WaitHandle ();</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"fields\">\r\n        <h2>Fields\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_InvalidHandle\">\r\n    \r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">InvalidHandle</div>        \r\n          </div>\r\n    \r\n            <p>Represents an invalid native operating system handle. This field is read-only.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected static readonly IntPtr InvalidHandle;</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Used internally to initialize the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Handle_\" data-linktype=\"relative-path\">Handle</a> property.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_WaitTimeout\">\r\n    \r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">WaitTimeout</div>        \r\n          </div>\r\n    \r\n            <p>Indicates that a <span class=\"xref\">stem.Threading.WaitHandle.WaitAny*</span> operation timed out before any of the wait handles were signaled. This field is constant.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public const int WaitTimeout = 258;</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This field is one of the possible return values of <code>WaitAny</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks. For space considerations, only the root directory of each disk is searched.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Threading.WaitHandle.WaitAny2#1\">Imports Microsoft.VisualBasic\nImports System\nImports System.IO\nImports System.Threading\n\nPublic Class Test\n\n    &lt;MTAThread&gt; _\n    Shared Sub Main()\n        Dim search As New Search()\n        search.FindFile(&quot;SomeFile.dat&quot;)\n    End Sub    \nEnd Class\n\nPublic Class Search\n\n    &#39; Maintain state information to pass to FindCallback.\n    Class State\n        Public autoEvent As AutoResetEvent \n        Public fileName As String         \n\n        Sub New(anEvent As AutoResetEvent, fName As String)\n            autoEvent = anEvent\n            fileName = fName\n        End Sub\n    End Class\n\n    Dim autoEvents() As AutoResetEvent\n    Dim diskLetters() As String\n\n    Sub New()\n\n        &#39; Retrieve an array of disk letters.\n        diskLetters = Environment.GetLogicalDrives()\n\n        autoEvents = New AutoResetEvent(diskLetters.Length - 1) {}\n        For i As Integer = 0 To diskLetters.Length - 1\n            autoEvents(i) = New AutoResetEvent(False)\n        Next i\n    End Sub    \n    \n    &#39; Search for fileName in the root directory of all disks.\n    Sub FindFile(fileName As String)\n        For i As Integer = 0 To diskLetters.Length - 1\n            Console.WriteLine(&quot;Searching for {0} on {1}.&quot;, _\n                fileName, diskLetters(i))\n        \n            ThreadPool.QueueUserWorkItem(AddressOf FindCallback, _ \n                New State(autoEvents(i), diskLetters(i) &amp; fileName))\n        Next i\n\n        &#39; Wait for the first instance of the file to be found.\n        Dim index As Integer = _\n            WaitHandle.WaitAny(autoEvents, 3000, False)\n        If index = WaitHandle.WaitTimeout\n            Console.WriteLine(vbCrLf &amp; &quot;{0} not found.&quot;, fileName)\n        Else\n            Console.WriteLine(vbCrLf &amp; &quot;{0} found on {1}.&quot;, _\n                fileName, diskLetters(index))\n        End If\n    End Sub\n\n    &#39; Search for stateInfo.fileName.\n    Sub FindCallback(state As Object)\n        Dim stateInfo As State = DirectCast(state, State)\n\n        &#39; Signal if the file is found.\n        If File.Exists(stateInfo.fileName) Then\n            stateInfo.autoEvent.Set()\n        End If\n    End Sub\n\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.WaitHandle.WaitAny2#1\">using System;\nusing System.IO;\nusing System.Threading;\n\nclass Test\n{\n    static void Main()\n    {\n        Search search = new Search();\n        search.FindFile(&quot;SomeFile.dat&quot;);\n    }\n}\n\nclass Search\n{\n    // Maintain state information to pass to FindCallback.\n    class State\n    {\n        public AutoResetEvent autoEvent;\n        public string         fileName;\n\n        public State(AutoResetEvent autoEvent, string fileName)\n        {\n            this.autoEvent    = autoEvent;\n            this.fileName     = fileName;\n        }\n    }\n\n    AutoResetEvent[] autoEvents;\n    String[] diskLetters;\n\n    public Search()\n    {\n        // Retrieve an array of disk letters.\n        diskLetters = Environment.GetLogicalDrives();\n\n        autoEvents = new AutoResetEvent[diskLetters.Length];\n        for(int i = 0; i &lt; diskLetters.Length; i++)\n        {\n            autoEvents[i] = new AutoResetEvent(false);\n        }\n    }\n\n    // Search for fileName in the root directory of all disks.\n    public void FindFile(string fileName)\n    {\n        for(int i = 0; i &lt; diskLetters.Length; i++)\n        {\n            Console.WriteLine(&quot;Searching for {0} on {1}.&quot;,\n                fileName, diskLetters[i]);\n            ThreadPool.QueueUserWorkItem(\n                new WaitCallback(FindCallback), \n                new State(autoEvents[i], diskLetters[i] + fileName));\n        }\n\n        // Wait for the first instance of the file to be found.\n        int index = WaitHandle.WaitAny(autoEvents, 3000, false);\n        if(index == WaitHandle.WaitTimeout)\n        {\n            Console.WriteLine(&quot;<br>{0} not found.&quot;, fileName);\n        }\n        else\n        {\n            Console.WriteLine(&quot;<br>{0} found on {1}.&quot;, fileName,\n                diskLetters[index]);\n        }\n    }\n\n    // Search for stateInfo.fileName.\n    void FindCallback(object state)\n    {\n        State stateInfo = (State)state;\n\n        // Signal if the file is found.\n        if(File.Exists(stateInfo.fileName))\n        {\n            stateInfo.autoEvent.Set();\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.WaitHandle.WaitAny2#1\">using namespace System;\nusing namespace System::IO;\nusing namespace System::Threading;\nref class Search\n{\nprivate:\n\n   // Maintain state information to pass to FindCallback.\n   ref class State\n   {\n   public:\n      AutoResetEvent^ autoEvent;\n      String^ fileName;\n      State( AutoResetEvent^ autoEvent, String^ fileName )\n         : autoEvent( autoEvent ), fileName( fileName )\n      {}\n\n   };\n\n\npublic:\n   array&lt;AutoResetEvent^&gt;^autoEvents;\n   array&lt;String^&gt;^diskLetters;\n\n   // Search for stateInfo-&gt;fileName.\n   void FindCallback( Object^ state )\n   {\n      State^ stateInfo = dynamic_cast&lt;State^&gt;(state);\n      \n      // Signal if the file is found.\n      if ( File::Exists( stateInfo-&gt;fileName ) )\n      {\n         stateInfo-&gt;autoEvent-&gt;Set();\n      }\n   }\n\n   Search()\n   {\n      \n      // Retrieve an array of disk letters.\n      diskLetters = Environment::GetLogicalDrives();\n      autoEvents = gcnew array&lt;AutoResetEvent^&gt;(diskLetters-&gt;Length);\n      for ( int i = 0; i &lt; diskLetters-&gt;Length; i++ )\n      {\n         autoEvents[ i ] = gcnew AutoResetEvent( false );\n\n      }\n   }\n\n\n   // Search for fileName in the root directory of all disks.\n   void FindFile( String^ fileName )\n   {\n      for ( int i = 0; i &lt; diskLetters-&gt;Length; i++ )\n      {\n         Console::WriteLine(  &quot;Searching for {0} on {1}.&quot;, fileName, diskLetters[ i ] );\n         ThreadPool::QueueUserWorkItem( gcnew WaitCallback( this, &amp;Search::FindCallback ), gcnew State( autoEvents[ i ],String::Concat( diskLetters[ i ], fileName ) ) );\n\n      }\n      \n      // Wait for the first instance of the file to be found.\n      int index = WaitHandle::WaitAny( autoEvents, 3000, false );\n      if ( index == WaitHandle::WaitTimeout )\n      {\n         Console::WriteLine( &quot;<br>{0} not found.&quot;, fileName );\n      }\n      else\n      {\n         Console::WriteLine( &quot;<br>{0} found on {1}.&quot;, fileName, diskLetters[ index ] );\n      }\n   }\n\n};\n\nint main()\n{\n   Search^ search = gcnew Search;\n   search-&gt;FindFile( &quot;SomeFile.dat&quot; );\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"properties\">\r\n        <h2>Properties\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_Handle\">\r\n    \r\n            <a id=\"System_Threading_WaitHandle_Handle_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Handle</div>        \r\n          </div>\r\n    \r\n            <p>Gets or sets the native operating system handle.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual IntPtr Handle { get; set; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </div>\r\n                  <p>An <code>IntPtr</code> representing the native operating system handle. The default is the value of the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_InvalidHandle\" data-linktype=\"relative-path\">InvalidHandle</a> field.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Assigning a new value to the Handle property does not close the previous handle. This can result in a leaked handle.  </p>\n<p> Do not use this property in the .NET Framework version 2.0 or later; use the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SafeWaitHandle_\" data-linktype=\"relative-path\">SafeWaitHandle</a> property instead. Setting this property to a valid handle also sets the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SafeWaitHandle_\" data-linktype=\"relative-path\">SafeWaitHandle</a> property, but setting it to <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_InvalidHandle\" data-linktype=\"relative-path\">InvalidHandle</a> can result in a leaked handle.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_SafeWaitHandle\">\r\n    \r\n            <a id=\"System_Threading_WaitHandle_SafeWaitHandle_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">SafeWaitHandle</div>        \r\n          </div>\r\n    \r\n            <p>Gets or sets the native operating system handle.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"microsoft.win32.safehandles.safewaithandle\" data-linktype=\"relative-path\">SafeWaitHandle</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"microsoft.win32.safehandles.safewaithandle\" data-linktype=\"relative-path\">SafeWaitHandle</a> representing the native operating system handle.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>When you assign a new value to the SafeWaitHandle property, the previous handle will be closed when the previous <a class=\"xref\" href=\"microsoft.win32.safehandles.safewaithandle\" data-linktype=\"relative-path\">SafeWaitHandle</a> object is collected. Do not manually close the handle, because this results in an <a class=\"xref\" href=\"system.objectdisposedexception\" data-linktype=\"relative-path\">ObjectDisposedException</a> when the <a class=\"xref\" href=\"microsoft.win32.safehandles.safewaithandle\" data-linktype=\"relative-path\">SafeWaitHandle</a> attempts to close the handle.  </p>\n<p> <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> implements the <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose_\" data-linktype=\"relative-path\">Dispose</a> pattern. See <a href=\"../Topic/Dispose%20Pattern.md\" data-linktype=\"relative-path\">Dispose Pattern</a>. When you derive from <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>, use the SafeWaitHandle property to store your native handle operating system handle. You do not need to override the protected <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Dispose_\" data-linktype=\"relative-path\">Dispose</a> method unless you use additional unmanaged resources.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"methods\">\r\n        <h2>Methods\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_Close\">\r\n    \r\n            <a id=\"System_Threading_WaitHandle_Close_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Close()</div>        \r\n          </div>\r\n    \r\n            <p>Releases all resources held by the current <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void Close ();</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is the public implementation of the <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose_\" data-linktype=\"relative-path\">Dispose</a> method for the <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> class and its derived classes. It provides a standard implementation that calls the <code>Dispose(Boolean)</code> overload with a <code>true</code> argument and then calls the <a class=\"xref\" href=\"system.gc#System_GC_SuppressFinalize_\" data-linktype=\"relative-path\">SuppressFinalize</a> method. Call this method to release all resources held by an instance of <code>WaitHandle</code> or a derived class.  </p>\n<p> Once this method is called, references to the current instance cause undefined behavior.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Always call Close or <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Dispose\" data-linktype=\"relative-path\">Dispose()</a> before you release your last reference to the <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>. Otherwise, the resources it is using will not be freed.</p>\n</div>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_Dispose\">\r\n    \r\n            <a id=\"System_Threading_WaitHandle_Dispose_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Dispose()</div>        \r\n          </div>\r\n    \r\n            <p>Releases all resources used by the current instance of the <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> class.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void Dispose ();</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is equivalent to the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Close_\" data-linktype=\"relative-path\">Close</a> method.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Always call <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Close_\" data-linktype=\"relative-path\">Close</a> or Dispose before you release your last reference to the <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>. Otherwise, the resources it is using will not be freed.</p>\n</div>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_Dispose_System_Boolean_\">\r\n    \r\n            <a id=\"System_Threading_WaitHandle_Dispose_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Dispose(Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, releases the unmanaged resources used by the <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>, and optionally releases the managed resources.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected virtual void Dispose (bool explicitDisposing);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>explicitDisposing</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to release both managed and unmanaged resources; <code>false</code> to release only unmanaged resources.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is called by the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Close_\" data-linktype=\"relative-path\">Close</a> and the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Dispose\" data-linktype=\"relative-path\">Dispose()</a> methods with the <code>explicitDisposing</code> parameter set to <code>true</code>.  When the <code>explicitDisposing</code> parameter is <code>true</code>, this method releases all resources held by any managed objects that this <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> object references.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_SignalAndWait_System_Threading_WaitHandle_System_Threading_WaitHandle_\">\r\n    \r\n            <a id=\"System_Threading_WaitHandle_SignalAndWait_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">SignalAndWait(WaitHandle,WaitHandle)</div>        \r\n          </div>\r\n    \r\n            <p>Signals one <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> and waits on another.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>toSignal</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> to signal.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>toWaitOn</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> to wait on.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>toSignal</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>toWaitOn</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The method was called on a thread that has <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.platformnotsupportedexception\" data-linktype=\"relative-path\">PlatformNotSupportedException</a></div>\r\n                  </div>\r\n                  <p>This method is not supported on Windows 98 or Windows Millennium Edition.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p><code>toSignal</code> is a semaphore, and it already has a full count.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></div>\r\n                  </div>\r\n                  <p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This operation is not guaranteed to be atomic. After the current thread signals <code>toSignal</code> but before it waits on <code>toWaitOn</code>, a thread that is running on another processor might signal <code>toWaitOn</code> or wait on it.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example uses the SignalAndWait method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.  </p>\n<p> The example starts five threads, allows them to block on an <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> created with the <a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">System.Threading.EventResetMode</a> flag, and then releases one thread each time the user presses the ENTER key. The example then queues another five threads and releases them all using an <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> created with the <a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">System.Threading.EventResetMode</a> flag.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Threading.WaitHandle.SignalAndWait#1\">using namespace System;\nusing namespace System::Threading;\n\npublic ref class Example\n{\nprivate:\n   // The EventWaitHandle used to demonstrate the difference\n   // between AutoReset and ManualReset synchronization events.\n   //\n   static EventWaitHandle^ ewh;\n\n   // A counter to make sure all threads are started and\n   // blocked before any are released. A Long is used to show\n   // the use of the 64-bit Interlocked methods.\n   //\n   static __int64 threadCount = 0;\n\n   // An AutoReset event that allows the main thread to block\n   // until an exiting thread has decremented the count.\n   //\n   static EventWaitHandle^ clearCount =\n      gcnew EventWaitHandle( false,EventResetMode::AutoReset );\n\npublic:\n   [MTAThread]\n   static void main()\n   {\n      // Create an AutoReset EventWaitHandle.\n      //\n      ewh = gcnew EventWaitHandle( false,EventResetMode::AutoReset );\n      \n      // Create and start five numbered threads. Use the\n      // ParameterizedThreadStart delegate, so the thread\n      // number can be passed as an argument to the Start\n      // method.\n      for ( int i = 0; i &lt;= 4; i++ )\n      {\n         Thread^ t = gcnew Thread(\n            gcnew ParameterizedThreadStart( ThreadProc ) );\n         t-&gt;Start( i );\n      }\n      \n      // Wait until all the threads have started and blocked.\n      // When multiple threads use a 64-bit value on a 32-bit\n      // system, you must access the value through the\n      // Interlocked class to guarantee thread safety.\n      //\n      while ( Interlocked::Read( threadCount ) &lt; 5 )\n      {\n         Thread::Sleep( 500 );\n      }\n\n      // Release one thread each time the user presses ENTER,\n      // until all threads have been released.\n      //\n      while ( Interlocked::Read( threadCount ) &gt; 0 )\n      {\n         Console::WriteLine( L&quot;Press ENTER to release a waiting thread.&quot; );\n         Console::ReadLine();\n         \n         // SignalAndWait signals the EventWaitHandle, which\n         // releases exactly one thread before resetting,\n         // because it was created with AutoReset mode.\n         // SignalAndWait then blocks on clearCount, to\n         // allow the signaled thread to decrement the count\n         // before looping again.\n         //\n         WaitHandle::SignalAndWait( ewh, clearCount );\n      }\n      Console::WriteLine();\n      \n      // Create a ManualReset EventWaitHandle.\n      //\n      ewh = gcnew EventWaitHandle( false,EventResetMode::ManualReset );\n      \n      // Create and start five more numbered threads.\n      //\n      for ( int i = 0; i &lt;= 4; i++ )\n      {\n         Thread^ t = gcnew Thread(\n            gcnew ParameterizedThreadStart( ThreadProc ) );\n         t-&gt;Start( i );\n      }\n      \n      // Wait until all the threads have started and blocked.\n      //\n      while ( Interlocked::Read( threadCount ) &lt; 5 )\n      {\n         Thread::Sleep( 500 );\n      }\n\n      // Because the EventWaitHandle was created with\n      // ManualReset mode, signaling it releases all the\n      // waiting threads.\n      //\n      Console::WriteLine( L&quot;Press ENTER to release the waiting threads.&quot; );\n      Console::ReadLine();\n      ewh-&gt;Set();\n\n   }\n\n   static void ThreadProc( Object^ data )\n   {\n      int index = static_cast&lt;Int32&gt;(data);\n\n      Console::WriteLine( L&quot;Thread {0} blocks.&quot;, data );\n      // Increment the count of blocked threads.\n      Interlocked::Increment( threadCount );\n      \n      // Wait on the EventWaitHandle.\n      ewh-&gt;WaitOne();\n\n      Console::WriteLine( L&quot;Thread {0} exits.&quot;, data );\n      // Decrement the count of blocked threads.\n      Interlocked::Decrement( threadCount );\n      \n      // After signaling ewh, the main thread blocks on\n      // clearCount until the signaled thread has\n      // decremented the count. Signal it now.\n      //\n      clearCount-&gt;Set();\n   }\n};\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.WaitHandle.SignalAndWait#1\">Imports System\nImports System.Threading\n\nPublic Class Example\n\n    &#39; The EventWaitHandle used to demonstrate the difference\n    &#39; between AutoReset and ManualReset synchronization events.\n    &#39;\n    Private Shared ewh As EventWaitHandle\n\n    &#39; A counter to make sure all threads are started and\n    &#39; blocked before any are released. A Long is used to show\n    &#39; the use of the 64-bit Interlocked methods.\n    &#39;\n    Private Shared threadCount As Long = 0\n\n    &#39; An AutoReset event that allows the main thread to block\n    &#39; until an exiting thread has decremented the count.\n    &#39;\n    Private Shared clearCount As New EventWaitHandle(False, _\n        EventResetMode.AutoReset)\n\n    &lt;MTAThread&gt; _\n    Public Shared Sub Main()\n\n        &#39; Create an AutoReset EventWaitHandle.\n        &#39;\n        ewh = New EventWaitHandle(False, EventResetMode.AutoReset)\n\n        &#39; Create and start five numbered threads. Use the\n        &#39; ParameterizedThreadStart delegate, so the thread\n        &#39; number can be passed as an argument to the Start \n        &#39; method.\n        For i As Integer = 0 To 4\n            Dim t As New Thread(AddressOf ThreadProc)\n            t.Start(i)\n        Next i\n\n        &#39; Wait until all the threads have started and blocked.\n        &#39; When multiple threads use a 64-bit value on a 32-bit\n        &#39; system, you must access the value through the\n        &#39; Interlocked class to guarantee thread safety.\n        &#39;\n        While Interlocked.Read(threadCount) &lt; 5\n            Thread.Sleep(500)\n        End While\n\n        &#39; Release one thread each time the user presses ENTER,\n        &#39; until all threads have been released.\n        &#39;\n        While Interlocked.Read(threadCount) &gt; 0\n            Console.WriteLine(&quot;Press ENTER to release a waiting thread.&quot;)\n            Console.ReadLine()\n\n            &#39; SignalAndWait signals the EventWaitHandle, which\n            &#39; releases exactly one thread before resetting, \n            &#39; because it was created with AutoReset mode. \n            &#39; SignalAndWait then blocks on clearCount, to \n            &#39; allow the signaled thread to decrement the count\n            &#39; before looping again.\n            &#39;\n            WaitHandle.SignalAndWait(ewh, clearCount)\n        End While\n        Console.WriteLine()\n\n        &#39; Create a ManualReset EventWaitHandle.\n        &#39;\n        ewh = New EventWaitHandle(False, EventResetMode.ManualReset)\n\n        &#39; Create and start five more numbered threads.\n        &#39;\n        For i As Integer = 0 To 4\n            Dim t As New Thread(AddressOf ThreadProc)\n            t.Start(i)\n        Next i\n\n        &#39; Wait until all the threads have started and blocked.\n        &#39;\n        While Interlocked.Read(threadCount) &lt; 5\n            Thread.Sleep(500)\n        End While\n\n        &#39; Because the EventWaitHandle was created with\n        &#39; ManualReset mode, signaling it releases all the\n        &#39; waiting threads.\n        &#39;\n        Console.WriteLine(&quot;Press ENTER to release the waiting threads.&quot;)\n        Console.ReadLine()\n        ewh.Set()\n        \n    End Sub\n\n    Public Shared Sub ThreadProc(ByVal data As Object)\n        Dim index As Integer = CInt(data)\n\n        Console.WriteLine(&quot;Thread {0} blocks.&quot;, data)\n        &#39; Increment the count of blocked threads.\n        Interlocked.Increment(threadCount)\n\n        &#39; Wait on the EventWaitHandle.\n        ewh.WaitOne()\n\n        Console.WriteLine(&quot;Thread {0} exits.&quot;, data)\n        &#39; Decrement the count of blocked threads.\n        Interlocked.Decrement(threadCount)\n\n        &#39; After signaling ewh, the main thread blocks on\n        &#39; clearCount until the signaled thread has \n        &#39; decremented the count. Signal it now.\n        &#39;\n        clearCount.Set()\n    End Sub\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.WaitHandle.SignalAndWait#1\">using System;\nusing System.Threading;\n\npublic class Example\n{\n    // The EventWaitHandle used to demonstrate the difference\n    // between AutoReset and ManualReset synchronization events.\n    //\n    private static EventWaitHandle ewh;\n\n    // A counter to make sure all threads are started and\n    // blocked before any are released. A Long is used to show\n    // the use of the 64-bit Interlocked methods.\n    //\n    private static long threadCount = 0;\n\n    // An AutoReset event that allows the main thread to block\n    // until an exiting thread has decremented the count.\n    //\n    private static EventWaitHandle clearCount = \n        new EventWaitHandle(false, EventResetMode.AutoReset);\n\n    [MTAThread]\n    public static void Main()\n    {\n        // Create an AutoReset EventWaitHandle.\n        //\n        ewh = new EventWaitHandle(false, EventResetMode.AutoReset);\n\n        // Create and start five numbered threads. Use the\n        // ParameterizedThreadStart delegate, so the thread\n        // number can be passed as an argument to the Start \n        // method.\n        for (int i = 0; i &lt;= 4; i++)\n        {\n            Thread t = new Thread(\n                new ParameterizedThreadStart(ThreadProc)\n            );\n            t.Start(i);\n        }\n\n        // Wait until all the threads have started and blocked.\n        // When multiple threads use a 64-bit value on a 32-bit\n        // system, you must access the value through the\n        // Interlocked class to guarantee thread safety.\n        //\n        while (Interlocked.Read(ref threadCount) &lt; 5)\n        {\n            Thread.Sleep(500);\n        }\n\n        // Release one thread each time the user presses ENTER,\n        // until all threads have been released.\n        //\n        while (Interlocked.Read(ref threadCount) &gt; 0)\n        {\n            Console.WriteLine(&quot;Press ENTER to release a waiting thread.&quot;);\n            Console.ReadLine();\n\n            // SignalAndWait signals the EventWaitHandle, which\n            // releases exactly one thread before resetting, \n            // because it was created with AutoReset mode. \n            // SignalAndWait then blocks on clearCount, to \n            // allow the signaled thread to decrement the count\n            // before looping again.\n            //\n            WaitHandle.SignalAndWait(ewh, clearCount);\n        }\n        Console.WriteLine();\n\n        // Create a ManualReset EventWaitHandle.\n        //\n        ewh = new EventWaitHandle(false, EventResetMode.ManualReset);\n\n        // Create and start five more numbered threads.\n        //\n        for(int i=0; i&lt;=4; i++)\n        {\n            Thread t = new Thread(\n                new ParameterizedThreadStart(ThreadProc)\n            );\n            t.Start(i);\n        }\n\n        // Wait until all the threads have started and blocked.\n        //\n        while (Interlocked.Read(ref threadCount) &lt; 5)\n        {\n            Thread.Sleep(500);\n        }\n\n        // Because the EventWaitHandle was created with\n        // ManualReset mode, signaling it releases all the\n        // waiting threads.\n        //\n        Console.WriteLine(&quot;Press ENTER to release the waiting threads.&quot;);\n        Console.ReadLine();\n        ewh.Set();\n        \n    }\n\n    public static void ThreadProc(object data)\n    {\n        int index = (int) data;\n\n        Console.WriteLine(&quot;Thread {0} blocks.&quot;, data);\n        // Increment the count of blocked threads.\n        Interlocked.Increment(ref threadCount);\n\n        // Wait on the EventWaitHandle.\n        ewh.WaitOne();\n\n        Console.WriteLine(&quot;Thread {0} exits.&quot;, data);\n        // Decrement the count of blocked threads.\n        Interlocked.Decrement(ref threadCount);\n\n        // After signaling ewh, the main thread blocks on\n        // clearCount until the signaled thread has \n        // decremented the count. Signal it now.\n        //\n        clearCount.Set();\n    }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_SignalAndWait_System_Threading_WaitHandle_System_Threading_WaitHandle_System_Int32_System_Boolean_\">\r\n    \r\n            <a id=\"System_Threading_WaitHandle_SignalAndWait_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">SignalAndWait(WaitHandle,WaitHandle,Int32,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Signals one <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>toSignal</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> to signal.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>toWaitOn</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> to wait on.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>millisecondsTimeout</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An integer that represents the interval to wait. If the value is <a class=\"xref\" href=\"system.threading.timeout#System_Threading_Timeout_Infinite\" data-linktype=\"relative-path\">Infinite</a>, that is, -1, the wait is infinite.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>exitContext</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if both the signal and the wait completed successfully, or <code>false</code> if the signal completed but the wait timed out.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>toSignal</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>toWaitOn</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The method is called on a thread that has <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.platformnotsupportedexception\" data-linktype=\"relative-path\">PlatformNotSupportedException</a></div>\r\n                  </div>\r\n                  <p>This method is not supported on Windows 98 or Windows Millennium Edition.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> cannot be signaled because it would exceed its maximum count.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p><code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></div>\r\n                  </div>\r\n                  <p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This operation is not guaranteed to be atomic. After the current thread signals <code>toSignal</code> but before it waits on <code>toWaitOn</code>, a thread that is running on another processor might signal <code>toWaitOn</code> or wait on it.  </p>\n<p> If <code>millisecondsTimeout</code> is zero, the method does not block. It tests the state of the <code>toWaitOn</code> and returns immediately.  </p>\n<h2 id=\"notes-on-exiting-the-context\">Notes on Exiting the Context</h2>\n<p> The <code>exitContext</code> parameter has no effect unless the SignalAndWait method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>. Even if you are currently executing a method on a class that does not derive from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>, like <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>, you can be in a nondefault context if a <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a> is on your stack in the current application domain.  </p>\n<p> When your code is executing in a nondefault context, specifying <code>true</code> for <code>exitContext</code> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the SignalAndWait method. The thread returns to the original nondefault context after the call to the SignalAndWait method completes.  </p>\n<p> This can be useful when the context-bound class has <a class=\"xref\" href=\"system.runtime.remoting.contexts.synchronizationattribute\" data-linktype=\"relative-path\">SynchronizationAttribute</a>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the SignalAndWait method and specifies <code>true</code> for <code>exitContext</code>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the SignalAndWait method returns, the thread that made the call must wait to reenter the synchronization domain.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_SignalAndWait_System_Threading_WaitHandle_System_Threading_WaitHandle_System_TimeSpan_System_Boolean_\">\r\n    \r\n            <a id=\"System_Threading_WaitHandle_SignalAndWait_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">SignalAndWait(WaitHandle,WaitHandle,TimeSpan,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Signals one <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> and waits on another, specifying the time-out interval as a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> and specifying whether to exit the synchronization domain for the context before entering the wait.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>toSignal</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> to signal.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>toWaitOn</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> to wait on.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>timeout</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents the interval to wait. If the value is -1, the wait is infinite.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>exitContext</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if both the signal and the wait completed successfully, or <code>false</code> if the signal completed but the wait timed out.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>toSignal</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>toWaitOn</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The method was called on a thread that has <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.platformnotsupportedexception\" data-linktype=\"relative-path\">PlatformNotSupportedException</a></div>\r\n                  </div>\r\n                  <p>This method is not supported on Windows 98 or Windows Millennium Edition.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p><code>toSignal</code> is a semaphore, and it already has a full count.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p><code>timeout</code> evaluates to a negative number of milliseconds other than -1.  </p>\n<p> -or-  </p>\n<p> <code>timeout</code> is greater than <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">MaxValue</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></div>\r\n                  </div>\r\n                  <p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This operation is not guaranteed to be atomic. After the current thread signals <code>toSignal</code> but before it waits on <code>toWaitOn</code>, a thread that is running on another processor might signal <code>toWaitOn</code> or wait on it.  </p>\n<p> The maximum value for <code>timeout</code> is <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">System.Int32.MaxValue</a>.  </p>\n<p> If <code>timeout</code> is zero, the method does not block. It tests the state of the <code>toWaitOn</code> and returns immediately.  </p>\n<h2 id=\"notes-on-exiting-the-context\">Notes on Exiting the Context</h2>\n<p> The <code>exitContext</code> parameter has no effect unless the SignalAndWait method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>. Even if you are currently executing a method on a class that does not derive from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>, like <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>, you can be in a nondefault context if a <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a> is on your stack in the current application domain.  </p>\n<p> When your code is executing in a nondefault context, specifying <code>true</code> for <code>exitContext</code> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the SignalAndWait method. The thread returns to the original nondefault context after the call to the SignalAndWait method completes.  </p>\n<p> This can be useful when the context-bound class has <a class=\"xref\" href=\"system.runtime.remoting.contexts.synchronizationattribute\" data-linktype=\"relative-path\">SynchronizationAttribute</a>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the SignalAndWait method and specifies <code>true</code> for <code>exitContext</code>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the SignalAndWait method returns, the thread that made the call must wait to reenter the synchronization domain.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___\">\r\n    \r\n            <a id=\"System_Threading_WaitHandle_WaitAll_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">WaitAll(WaitHandle[])</div>        \r\n          </div>\r\n    \r\n            <p>Waits for all the elements in the specified array to receive a signal.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>waitHandles</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <code>WaitHandle</code> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> when every element in <code>waitHandles</code> has received a signal; otherwise the method never returns.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p>The <code>waitHandles</code> parameter is <code>null</code>. -or-  </p>\n<p> One or more of the objects in the <code>waitHandles</code> array are <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>waitHandles</code> is an array with no elements and the .NET Framework version is 2.0 or later.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.duplicatewaitobjectexception\" data-linktype=\"relative-path\">DuplicateWaitObjectException</a></div>\r\n                  </div>\r\n                  <div class=\"alert NOTE\"><br> In the <a href=\"http://go.microsoft.com/fwlink/?LinkID=247912\" data-linktype=\"external\">.NET for Windows Store apps</a> or the <a href=\"../Topic/Cross-Platform%20Development%20with%20the%20Portable%20Class%20Library.md\" data-linktype=\"relative-path\">Portable Class Library</a>, catch the base class exception, <a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a>, instead.<br>\n</div>  \n\n<p> The <code>waitHandles</code> array contains elements that are duplicates.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The number of objects in <code>waitHandles</code> is greater than the system permits.  </p>\n<p> -or-  </p>\n<p> The <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a></div>\r\n                  </div>\r\n                  <p><code>waitHandles</code> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></div>\r\n                  </div>\r\n                  <p>The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The <code>waitHandles</code> array contains a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> is new in the .NET Framework version 2.0. In previous versions, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method returns <code>true</code> when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method returns when all the handles are signaled. On some implementations, if more than 64 handles are passed, a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> is thrown. If the array contains duplicates, the call fails with a <a class=\"xref\" href=\"system.duplicatewaitobjectexception\" data-linktype=\"relative-path\">DuplicateWaitObjectException</a>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method is not supported on threads that have <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a>.  </p>\n</div>\n<p> Calling this method overload is equivalent to calling the [WaitAll(WaitHandle&lt;xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29&gt; method overload and specifying -1 (or <a class=\"xref\" href=\"system.threading.timeout#System_Threading_Timeout_Infinite\" data-linktype=\"relative-path\">System.Threading.Timeout.Infinite</a>) for <code>millisecondsTimeout</code>and <code>true</code> for <code>exitContext</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example shows how to use the thread pool to asynchronously create and write to a group of files. Each write operation is queued as a work item and signals when it is finished. The main thread waits for all the items to signal and then exits.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Threading.WaitHandle.WaitAll1#1\">using namespace System;\nusing namespace System::IO;\nusing namespace System::Security::Permissions;\nusing namespace System::Threading;\n\nref class State\n{\npublic:\n   String^ fileName;\n   array&lt;Byte&gt;^byteArray;\n   ManualResetEvent^ manualEvent;\n   State( String^ fileName, array&lt;Byte&gt;^byteArray, ManualResetEvent^ manualEvent )\n      : fileName( fileName ), byteArray( byteArray ), manualEvent( manualEvent )\n   {}\n\n};\n\nref class Writer\n{\nprivate:\n   static int workItemCount = 0;\n   Writer(){}\n\n\npublic:\n   static void WriteToFile( Object^ state )\n   {\n      int workItemNumber = workItemCount;\n      Interlocked::Increment( workItemCount );\n      Console::WriteLine( &quot;Starting work item {0}.&quot;, workItemNumber.ToString() );\n      State^ stateInfo = dynamic_cast&lt;State^&gt;(state);\n      FileStream^ fileWriter;\n      \n      // Create and write to the file.\n      try\n      {\n         fileWriter = gcnew FileStream( stateInfo-&gt;fileName,FileMode::Create );\n         fileWriter-&gt;Write( stateInfo-&gt;byteArray, 0, stateInfo-&gt;byteArray-&gt;Length );\n      }\n      finally\n      {\n         if ( fileWriter != nullptr )\n         {\n            fileWriter-&gt;Close();\n         }\n         \n         // Signal main() that the work item has finished.\n         Console::WriteLine( &quot;Ending work item {0}.&quot;, workItemNumber.ToString() );\n         stateInfo-&gt;manualEvent-&gt;Set();\n      }\n\n   }\n\n};\n\nvoid main()\n{\n   const int numberOfFiles = 5;\n   String^ dirName =  &quot;C:\\&nbsp;&nbsp;&nbsp;&nbsp;estTest&quot;;\n   String^ fileName;\n   array&lt;Byte&gt;^byteArray;\n   Random^ randomGenerator = gcnew Random;\n   array&lt;ManualResetEvent^&gt;^manualEvents = gcnew array&lt;ManualResetEvent^&gt;(numberOfFiles);\n   State^ stateInfo;\n   if (  !Directory::Exists( dirName ) )\n   {\n      Directory::CreateDirectory( dirName );\n   }\n\n   \n   // Queue the work items that create and write to the files.\n   for ( int i = 0; i &lt; numberOfFiles; i++ )\n   {\n      fileName = String::Concat( dirName,  &quot;\\&nbsp;&nbsp;&nbsp;&nbsp;est&quot;, ((i)).ToString(),  &quot;.dat&quot; );\n      \n      // Create random data to write to the file.\n      byteArray = gcnew array&lt;Byte&gt;(1000000);\n      randomGenerator-&gt;NextBytes( byteArray );\n      manualEvents[ i ] = gcnew ManualResetEvent( false );\n      stateInfo = gcnew State( fileName,byteArray,manualEvents[ i ] );\n      ThreadPool::QueueUserWorkItem( gcnew WaitCallback( &amp;Writer::WriteToFile ), stateInfo );\n\n   }\n   \n   // Since ThreadPool threads are background threads, \n   // wait for the work items to signal before exiting.\n   WaitHandle::WaitAll( manualEvents );\n   Console::WriteLine( &quot;Files written - main exiting.&quot; );\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.WaitHandle.WaitAll1#1\">using System;\nusing System.IO;\nusing System.Security.Permissions;\nusing System.Threading;\n\nclass Test\n{\n    static void Main()\n    {\n        const int numberOfFiles = 5;\n        string dirName = @&quot;C:&nbsp;&nbsp;&nbsp;&nbsp;estTest&quot;;\n        string fileName;\n\n        byte[] byteArray;\n        Random randomGenerator = new Random();\n\n        ManualResetEvent[] manualEvents = \n            new ManualResetEvent[numberOfFiles];\n        State stateInfo;\n\n        if(!Directory.Exists(dirName))\n        {\n            Directory.CreateDirectory(dirName);\n        }\n\n        // Queue the work items that create and write to the files.\n        for(int i = 0; i &lt; numberOfFiles; i++)\n        {\n            fileName = string.Concat(\n                dirName, @&quot;&nbsp;&nbsp;&nbsp;&nbsp;est&quot;, i.ToString(), &quot;.dat&quot;);\n\n            // Create random data to write to the file.\n            byteArray = new byte[1000000];\n            randomGenerator.NextBytes(byteArray);\n\n            manualEvents[i] = new ManualResetEvent(false);\n\n            stateInfo = \n                new State(fileName, byteArray, manualEvents[i]);\n\n            ThreadPool.QueueUserWorkItem(new WaitCallback(\n                Writer.WriteToFile), stateInfo);\n        }\n    \n        // Since ThreadPool threads are background threads, \n        // wait for the work items to signal before exiting.\n        WaitHandle.WaitAll(manualEvents);\n        Console.WriteLine(&quot;Files written - main exiting.&quot;);\n    }\n}\n\n// Maintain state to pass to WriteToFile.\nclass State\n{\n    public string fileName;\n    public byte[] byteArray;\n    public ManualResetEvent manualEvent;\n\n    public State(string fileName, byte[] byteArray, \n        ManualResetEvent manualEvent)\n    {\n        this.fileName = fileName;\n        this.byteArray = byteArray;\n        this.manualEvent = manualEvent;\n    }\n}\n\nclass Writer\n{\n    static int workItemCount = 0;\n    Writer() {}\n\n    public static void WriteToFile(object state)\n    {\n        int workItemNumber = workItemCount;\n        Interlocked.Increment(ref workItemCount);\n        Console.WriteLine(&quot;Starting work item {0}.&quot;,\n            workItemNumber.ToString());\n        State stateInfo = (State)state;\n        FileStream fileWriter = null;\n\n        // Create and write to the file.\n        try\n        {\n            fileWriter = new FileStream(\n                stateInfo.fileName, FileMode.Create);\n            fileWriter.Write(stateInfo.byteArray, \n                0, stateInfo.byteArray.Length);\n        }\n        finally\n        {\n            if(fileWriter != null)\n            {\n                fileWriter.Close();\n            }\n\n            // Signal Main that the work item has finished.\n            Console.WriteLine(&quot;Ending work item {0}.&quot;, \n                workItemNumber.ToString());\n            stateInfo.manualEvent.Set();\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.WaitHandle.WaitAll1#1\">Imports System\nImports System.IO\nImports System.Security.Permissions\nImports System.Threading\n\nPublic Class Test\n\n    &#39; WaitHandle.WaitAll requires a multithreaded apartment \n    &#39; when using multiple wait handles.\n    &lt;MTAThreadAttribute&gt; _\n    Shared Sub Main()\n        Const numberOfFiles As Integer = 5\n        Dim dirName As String = &quot;C:&nbsp;&nbsp;&nbsp;&nbsp;estTest&quot;\n        Dim fileName As String \n\n        Dim byteArray() As Byte \n        Dim randomGenerator As New Random()\n\n        Dim manualEvents(numberOfFiles - 1) As ManualResetEvent\n        Dim stateInfo As State \n\n        If Directory.Exists(dirName) &lt;&gt; True Then\n            Directory.CreateDirectory(dirName)\n        End If\n\n        &#39; Queue the work items that create and write to the files.\n        For i As Integer = 0 To numberOfFiles - 1\n            fileName = String.Concat( _\n                dirName, &quot;&nbsp;&nbsp;&nbsp;&nbsp;est&quot;, i.ToString(), &quot;.dat&quot;)\n\n            &#39; Create random data to write to the file.\n            byteArray = New Byte(1000000){}\n            randomGenerator.NextBytes(byteArray)\n\n            manualEvents(i) = New ManualResetEvent(false)\n\n            stateInfo = _ \n                New State(fileName, byteArray, manualEvents(i))\n\n            ThreadPool.QueueUserWorkItem(AddressOf _\n                Writer.WriteToFile, stateInfo)\n        Next i\n    \n        &#39; Since ThreadPool threads are background threads, \n        &#39; wait for the work items to signal before exiting.\n        WaitHandle.WaitAll(manualEvents)\n        Console.WriteLine(&quot;Files written - main exiting.&quot;)\n    End Sub\n\nEnd Class\n \n&#39; Maintain state to pass to WriteToFile.\nPublic Class State\n\n    Public fileName As String\n    Public byteArray As Byte()\n    Public manualEvent As ManualResetEvent\n\n    Sub New(fileName As String, byteArray() As Byte, _\n        manualEvent As ManualResetEvent)\n    \n        Me.fileName = fileName\n        Me.byteArray = byteArray\n        Me.manualEvent = manualEvent\n    End Sub\n\nEnd Class\n\nPublic Class Writer\n\n    Private Sub New()\n    End Sub\n\n    Shared workItemCount As Integer = 0\n\n    Shared Sub WriteToFile(state As Object)\n        Dim workItemNumber As Integer = workItemCount\n        Interlocked.Increment(workItemCount)\n        Console.WriteLine(&quot;Starting work item {0}.&quot;, _\n            workItemNumber.ToString())\n        Dim stateInfo As State = CType(state, State)\n        Dim fileWriter As FileStream = Nothing\n\n        &#39; Create and write to the file.\n        Try\n            fileWriter = New FileStream( _\n                stateInfo.fileName, FileMode.Create)\n            fileWriter.Write(stateInfo.byteArray, _\n                0, stateInfo.byteArray.Length)\n        Finally\n            If Not fileWriter Is Nothing Then\n                fileWriter.Close()\n            End If\n\n            &#39; Signal Main that the work item has finished.\n            Console.WriteLine(&quot;Ending work item {0}.&quot;, _\n                workItemNumber.ToString())\n            stateInfo.manualEvent.Set()\n        End Try\n    End Sub\n\nEnd Class\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_Int32_\">\r\n    \r\n            <a id=\"System_Threading_WaitHandle_WaitAll_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">WaitAll(WaitHandle[],Int32)</div>        \r\n          </div>\r\n    \r\n            <p>Waits for all the elements in the specified array to receive a signal, using an <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a> value to specify the time interval.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>waitHandles</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <code>WaitHandle</code> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object (duplicates).</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>millisecondsTimeout</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The number of milliseconds to wait, or <a class=\"xref\" href=\"system.threading.timeout#System_Threading_Timeout_Infinite\" data-linktype=\"relative-path\">Infinite</a> (-1) to wait indefinitely.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> when every element in <code>waitHandles</code> has received a signal; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p>The <code>waitHandles</code> parameter is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One or more of the objects in the <code>waitHandles</code> array is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>waitHandles</code> is an array with no elements.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.duplicatewaitobjectexception\" data-linktype=\"relative-path\">DuplicateWaitObjectException</a></div>\r\n                  </div>\r\n                  <div class=\"alert NOTE\"><br> In the <a href=\"http://go.microsoft.com/fwlink/?LinkID=247912\" data-linktype=\"external\">.NET for Windows Store apps</a> or the <a href=\"../Topic/Cross-Platform%20Development%20with%20the%20Portable%20Class%20Library.md\" data-linktype=\"relative-path\">Portable Class Library</a>, catch the base class exception, <a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a>, instead.<br>\n</div>  \n\n<p> The <code>waitHandles</code> array contains elements that are duplicates.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The number of objects in <code>waitHandles</code> is greater than the system permits.  </p>\n<p> -or-  </p>\n<p> The <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p><code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></div>\r\n                  </div>\r\n                  <p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The <code>waitHandles</code> array contains a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If <code>millisecondsTimeout</code> is zero, the method does not block. It tests the state of the wait handles and returns immediately.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs. On some implementations, if more than 64 handles are passed, a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> is thrown. If there are duplicates in the array, the call fails with a <a class=\"xref\" href=\"system.duplicatewaitobjectexception\" data-linktype=\"relative-path\">DuplicateWaitObjectException</a>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method is not supported on threads that have <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a>.  </p>\n</div>\n<p> Calling this method overload is the same as calling the [WaitAll(WaitHandle&lt;xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29&gt; overload and specifying <code>false</code> for <code>exitContext</code>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_TimeSpan_\">\r\n    \r\n            <a id=\"System_Threading_WaitHandle_WaitAll_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">WaitAll(WaitHandle[],TimeSpan)</div>        \r\n          </div>\r\n    \r\n            <p>Waits for all the elements in the specified array to receive a signal, using a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> value to specify the time interval.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>waitHandles</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <code>WaitHandle</code> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>timeout</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents the number of milliseconds to wait, or a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents -1 milliseconds, to wait indefinitely.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> when every element in <code>waitHandles</code> has received a signal; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p>The <code>waitHandles</code> parameter is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One or more of the objects in the <code>waitHandles</code> array is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>waitHandles</code> is an array with no elements.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.duplicatewaitobjectexception\" data-linktype=\"relative-path\">DuplicateWaitObjectException</a></div>\r\n                  </div>\r\n                  <div class=\"alert NOTE\"><br> In the <a href=\"http://go.microsoft.com/fwlink/?LinkID=247912\" data-linktype=\"external\">.NET for Windows Store apps</a> or the <a href=\"../Topic/Cross-Platform%20Development%20with%20the%20Portable%20Class%20Library.md\" data-linktype=\"relative-path\">Portable Class Library</a>, catch the base class exception, <a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a>, instead.<br>\n</div>  \n\n<p> The <code>waitHandles</code> array contains elements that are duplicates.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The number of objects in <code>waitHandles</code> is greater than the system permits.  </p>\n<p> -or-  </p>\n<p> The <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p><code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out.  </p>\n<p> -or-  </p>\n<p> <code>timeout</code> is greater than <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">MaxValue</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></div>\r\n                  </div>\r\n                  <p>The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The <code>waitHandles</code> array contains a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If <code>timeout</code> is zero, the method does not block. It tests the state of the wait handles and returns immediately.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs. On some implementations, if more than 64 handles are passed, a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> is thrown. If the array contains duplicates, the call will fail.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method is not supported on threads that have <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a>.  </p>\n</div>\n<p> The maximum value for <code>timeout</code> is <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">System.Int32.MaxValue</a>.  </p>\n<p> Calling this method overload is the same as calling the [WaitAll(WaitHandle&lt;xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29&gt; overload and specifying <code>false</code> for <code>exitContext</code>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_Int32_System_Boolean_\">\r\n    \r\n            <a id=\"System_Threading_WaitHandle_WaitAll_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">WaitAll(WaitHandle[],Int32,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Waits for all the elements in the specified array to receive a signal, using an <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>waitHandles</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <code>WaitHandle</code> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object (duplicates).</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>millisecondsTimeout</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The number of milliseconds to wait, or <a class=\"xref\" href=\"system.threading.timeout#System_Threading_Timeout_Infinite\" data-linktype=\"relative-path\">Infinite</a> (-1) to wait indefinitely.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>exitContext</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> when every element in <code>waitHandles</code> has received a signal; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p>The <code>waitHandles</code> parameter is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One or more of the objects in the <code>waitHandles</code> array is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>waitHandles</code> is an array with no elements and the .NET Framework version is 2.0 or later.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.duplicatewaitobjectexception\" data-linktype=\"relative-path\">DuplicateWaitObjectException</a></div>\r\n                  </div>\r\n                  <p>The <code>waitHandles</code> array contains elements that are duplicates.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The number of objects in <code>waitHandles</code> is greater than the system permits.  </p>\n<p> -or-  </p>\n<p> The <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a></div>\r\n                  </div>\r\n                  <p><code>waitHandles</code> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p><code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></div>\r\n                  </div>\r\n                  <p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The <code>waitHandles</code> array contains a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If <code>millisecondsTimeout</code> is zero, the method does not block. It tests the state of the wait handles and returns immediately.  </p>\n<p> <a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> is new in the .NET Framework version 2.0. In previous versions, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method returns <code>true</code> when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs. On some implementations, if more than 64 handles are passed, a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> is thrown. If there are duplicates in the array, the call fails with a <a class=\"xref\" href=\"system.duplicatewaitobjectexception\" data-linktype=\"relative-path\">DuplicateWaitObjectException</a>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method is not supported on threads that have <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a>.  </p>\n</div>\n<h2 id=\"notes-on-exiting-the-context\">Notes on Exiting the Context</h2>\n<p> The <code>exitContext</code> parameter has no effect unless the WaitAll method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>. Even if you are currently executing a method on a class that is not derived from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>, like <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>, you can be in a nondefault context if a <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a> is on your stack in the current application domain.  </p>\n<p> When your code is executing in a nondefault context, specifying <code>true</code> for <code>exitContext</code> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the WaitAll method. The thread returns to the original nondefault context after the call to the WaitAll method completes.  </p>\n<p> This can be useful when the context-bound class has the <a class=\"xref\" href=\"system.runtime.remoting.contexts.synchronizationattribute\" data-linktype=\"relative-path\">SynchronizationAttribute</a> attribute. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the WaitAll method and specifies <code>true</code> for <code>exitContext</code>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the WaitAll method returns, the thread that made the call must wait to reenter the synchronization domain.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example shows how to use the thread pool to asynchronously create and write to a group of files. Each write operation is queued as a work item and signals when it is finished. The main thread waits for all the items to signal and then exits.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Threading.WaitHandle.WaitAll2#1\">using namespace System;\nusing namespace System::IO;\nusing namespace System::Security::Permissions;\nusing namespace System::Threading;\n\n// Maintain state to pass to WriteToFile.\nref class State\n{\npublic:\n   String^ fileName;\n   array&lt;Byte&gt;^byteArray;\n   ManualResetEvent^ manualEvent;\n   State( String^ fileName, array&lt;Byte&gt;^byteArray, ManualResetEvent^ manualEvent )\n      : fileName( fileName ), byteArray( byteArray ), manualEvent( manualEvent )\n   {}\n\n};\n\nref class Writer\n{\nprivate:\n   static int workItemCount = 0;\n   Writer(){}\n\n\npublic:\n   static void WriteToFile( Object^ state )\n   {\n      int workItemNumber = workItemCount;\n      Interlocked::Increment( workItemCount );\n      Console::WriteLine( &quot;Starting work item {0}.&quot;, workItemNumber.ToString() );\n      State^ stateInfo = dynamic_cast&lt;State^&gt;(state);\n      FileStream^ fileWriter;\n      \n      // Create and write to the file.\n      try\n      {\n         fileWriter = gcnew FileStream( stateInfo-&gt;fileName,FileMode::Create );\n         fileWriter-&gt;Write( stateInfo-&gt;byteArray, 0, stateInfo-&gt;byteArray-&gt;Length );\n      }\n      finally\n      {\n         if ( fileWriter != nullptr )\n         {\n            fileWriter-&gt;Close();\n         }\n         \n         // Signal main() that the work item has finished.\n         Console::WriteLine( &quot;Ending work item {0}.&quot;, workItemNumber.ToString() );\n         stateInfo-&gt;manualEvent-&gt;Set();\n      }\n\n   }\n\n};\n\nint main()\n{\n   const int numberOfFiles = 5;\n   String^ dirName =  &quot;C:\\&nbsp;&nbsp;&nbsp;&nbsp;estTest&quot;;\n   String^ fileName;\n   array&lt;Byte&gt;^byteArray;\n   Random^ randomGenerator = gcnew Random;\n   array&lt;ManualResetEvent^&gt;^manualEvents = gcnew array&lt;ManualResetEvent^&gt;(numberOfFiles);\n   State^ stateInfo;\n   if (  !Directory::Exists( dirName ) )\n   {\n      Directory::CreateDirectory( dirName );\n   }\n\n   \n   // Queue the work items that create and write to the files.\n   for ( int i = 0; i &lt; numberOfFiles; i++ )\n   {\n      fileName = String::Concat( dirName,  &quot;\\&nbsp;&nbsp;&nbsp;&nbsp;est&quot;, ((i)).ToString(),  &quot;.dat&quot; );\n      \n      // Create random data to write to the file.\n      byteArray = gcnew array&lt;Byte&gt;(1000000);\n      randomGenerator-&gt;NextBytes( byteArray );\n      manualEvents[ i ] = gcnew ManualResetEvent( false );\n      stateInfo = gcnew State( fileName,byteArray,manualEvents[ i ] );\n      ThreadPool::QueueUserWorkItem( gcnew WaitCallback( &amp;Writer::WriteToFile ), stateInfo );\n\n   }\n   \n   // Since ThreadPool threads are background threads, \n   // wait for the work items to signal before exiting.\n   if ( WaitHandle::WaitAll( manualEvents, 5000, false ) )\n   {\n      Console::WriteLine( &quot;Files written - main exiting.&quot; );\n   }\n   else\n   {\n      \n      // The wait operation times out.\n      Console::WriteLine( &quot;Error writing files - main exiting.&quot; );\n   }\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.WaitHandle.WaitAll2#1\">using System;\nusing System.IO;\nusing System.Security.Permissions;\nusing System.Threading;\n\nclass Test\n{\n    static void Main()\n    {\n        const int numberOfFiles = 5;\n        string dirName = @&quot;C:&nbsp;&nbsp;&nbsp;&nbsp;estTest&quot;;\n        string fileName;\n\n        byte[] byteArray;\n        Random randomGenerator = new Random();\n\n        ManualResetEvent[] manualEvents = \n            new ManualResetEvent[numberOfFiles];\n        State stateInfo;\n\n        if(!Directory.Exists(dirName))\n        {\n            Directory.CreateDirectory(dirName);\n        }\n\n        // Queue the work items that create and write to the files.\n        for(int i = 0; i &lt; numberOfFiles; i++)\n        {\n            fileName = string.Concat(\n                dirName, @&quot;&nbsp;&nbsp;&nbsp;&nbsp;est&quot;, i.ToString(), &quot;.dat&quot;);\n\n            // Create random data to write to the file.\n            byteArray = new byte[1000000];\n            randomGenerator.NextBytes(byteArray);\n\n            manualEvents[i] = new ManualResetEvent(false);\n\n            stateInfo = \n                new State(fileName, byteArray, manualEvents[i]);\n\n            ThreadPool.QueueUserWorkItem(new WaitCallback(\n                Writer.WriteToFile), stateInfo);\n        }\n    \n        // Since ThreadPool threads are background threads, \n        // wait for the work items to signal before exiting.\n        if(WaitHandle.WaitAll(manualEvents, 5000, false))\n        {\n            Console.WriteLine(&quot;Files written - main exiting.&quot;);\n        }\n        else\n        {\n            // The wait operation times out.\n            Console.WriteLine(&quot;Error writing files - main exiting.&quot;);\n        }\n    }\n}\n\n// Maintain state to pass to WriteToFile.\nclass State\n{\n    public string fileName;\n    public byte[] byteArray;\n    public ManualResetEvent manualEvent;\n\n    public State(string fileName, byte[] byteArray, \n        ManualResetEvent manualEvent)\n    {\n        this.fileName = fileName;\n        this.byteArray = byteArray;\n        this.manualEvent = manualEvent;\n    }\n}\n\nclass Writer\n{\n    static int workItemCount = 0;\n    Writer() {}\n\n    public static void WriteToFile(object state)\n    {\n        int workItemNumber = workItemCount;\n        Interlocked.Increment(ref workItemCount);\n        Console.WriteLine(&quot;Starting work item {0}.&quot;,\n            workItemNumber.ToString());\n        State stateInfo = (State)state;\n        FileStream fileWriter = null;\n\n        // Create and write to the file.\n        try\n        {\n            fileWriter = new FileStream(\n                stateInfo.fileName, FileMode.Create);\n            fileWriter.Write(stateInfo.byteArray, \n                0, stateInfo.byteArray.Length);\n        }\n        finally\n        {\n            if(fileWriter != null)\n            {\n                fileWriter.Close();\n            }\n\n            // Signal Main that the work item has finished.\n            Console.WriteLine(&quot;Ending work item {0}.&quot;, \n                workItemNumber.ToString());\n            stateInfo.manualEvent.Set();\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.WaitHandle.WaitAll2#1\">Imports System\nImports System.IO\nImports System.Security.Permissions\nImports System.Threading\n\nPublic Class Test\n\n    &#39; WaitHandle.WaitAll requires a multithreaded apartment \n    &#39; when using multiple wait handles.\n    &lt;MTAThreadAttribute&gt; _\n    Shared Sub Main()\n        Const numberOfFiles As Integer = 5\n        Dim dirName As String = &quot;C:&nbsp;&nbsp;&nbsp;&nbsp;estTest&quot;\n        Dim fileName As String \n\n        Dim byteArray() As Byte \n        Dim randomGenerator As New Random()\n\n        Dim manualEvents(numberOfFiles - 1) As ManualResetEvent\n        Dim stateInfo As State \n\n        If Directory.Exists(dirName) &lt;&gt; True Then\n            Directory.CreateDirectory(dirName)\n        End If\n\n        &#39; Queue the work items that create and write to the files.\n        For i As Integer = 0 To numberOfFiles - 1\n            fileName = String.Concat( _\n                dirName, &quot;&nbsp;&nbsp;&nbsp;&nbsp;est&quot;, i.ToString(), &quot;.dat&quot;)\n\n            &#39; Create random data to write to the file.\n            byteArray = New Byte(1000000){}\n            randomGenerator.NextBytes(byteArray)\n\n            manualEvents(i) = New ManualResetEvent(false)\n\n            stateInfo = _ \n                New State(fileName, byteArray, manualEvents(i))\n\n            ThreadPool.QueueUserWorkItem(AddressOf _\n                Writer.WriteToFile, stateInfo)\n        Next i\n    \n        &#39; Since ThreadPool threads are background threads, \n        &#39; wait for the work items to signal before exiting.\n        If WaitHandle.WaitAll(manualEvents, 5000, false) = True  Then\n\n            Console.WriteLine(&quot;Files written - main exiting.&quot;)\n        Else\n        \n            &#39; The wait operation times out.\n            Console.WriteLine(&quot;Error writing files - main exiting.&quot;)\n        End If\n    End Sub\n\nEnd Class\n \n&#39; Maintain state to pass to WriteToFile.\nPublic Class State\n\n    Public fileName As String\n    Public byteArray As Byte()\n    Public manualEvent As ManualResetEvent\n\n    Sub New(fileName As String, byteArray() As Byte, _\n        manualEvent As ManualResetEvent)\n    \n        Me.fileName = fileName\n        Me.byteArray = byteArray\n        Me.manualEvent = manualEvent\n    End Sub\n\nEnd Class\n\nPublic Class Writer\n\n    Private Sub New()\n    End Sub\n\n    Shared workItemCount As Integer = 0\n\n    Shared Sub WriteToFile(state As Object)\n        Dim workItemNumber As Integer = workItemCount\n        Interlocked.Increment(workItemCount)\n        Console.WriteLine(&quot;Starting work item {0}.&quot;, _\n            workItemNumber.ToString())\n        Dim stateInfo As State = CType(state, State)\n        Dim fileWriter As FileStream = Nothing\n\n        &#39; Create and write to the file.\n        Try\n            fileWriter = New FileStream( _\n                stateInfo.fileName, FileMode.Create)\n            fileWriter.Write(stateInfo.byteArray, _\n                0, stateInfo.byteArray.Length)\n        Finally\n            If Not fileWriter Is Nothing Then\n                fileWriter.Close()\n            End If\n\n            &#39; Signal Main that the work item has finished.\n            Console.WriteLine(&quot;Ending work item {0}.&quot;, _\n                workItemNumber.ToString())\n            stateInfo.manualEvent.Set()\n        End Try\n    End Sub\n\nEnd Class\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_TimeSpan_System_Boolean_\">\r\n    \r\n            <a id=\"System_Threading_WaitHandle_WaitAll_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">WaitAll(WaitHandle[],TimeSpan,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Waits for all the elements in the specified array to receive a signal, using a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>waitHandles</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <code>WaitHandle</code> array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>timeout</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents the number of milliseconds to wait, or a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents -1 milliseconds, to wait indefinitely.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>exitContext</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> when every element in <code>waitHandles</code> has received a signal; otherwise <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p>The <code>waitHandles</code> parameter is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One or more of the objects in the <code>waitHandles</code> array is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>waitHandles</code> is an array with no elements and the .NET Framework version is 2.0 or later.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.duplicatewaitobjectexception\" data-linktype=\"relative-path\">DuplicateWaitObjectException</a></div>\r\n                  </div>\r\n                  <p>The <code>waitHandles</code> array contains elements that are duplicates.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The number of objects in <code>waitHandles</code> is greater than the system permits.  </p>\n<p> -or-  </p>\n<p> The <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a></div>\r\n                  </div>\r\n                  <p><code>waitHandles</code> is an array with no elements and the .NET Framework version is 1.0 or 1.1.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p><code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out.  </p>\n<p> -or-  </p>\n<p> <code>timeout</code> is greater than <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">MaxValue</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></div>\r\n                  </div>\r\n                  <p>The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The <code>waitHandles</code> array contains a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If <code>timeout</code> is zero, the method does not block. It tests the state of the wait handles and returns immediately.  </p>\n<p> <a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> is new in the .NET Framework version 2.0. In previous versions, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method returns <code>true</code> when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs. On some implementations, if more than 64 handles are passed, a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> is thrown. If the array contains duplicates, the call will fail.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method is not supported on threads that have <a class=\"xref\" href=\"system.stathreadattribute\" data-linktype=\"relative-path\">STAThreadAttribute</a>.  </p>\n</div>\n<p> The maximum value for <code>timeout</code> is <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">System.Int32.MaxValue</a>.  </p>\n<h2 id=\"notes-on-exiting-the-context\">Notes on Exiting the Context</h2>\n<p> The <code>exitContext</code> parameter has no effect unless the WaitAll method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>. Even if you are currently executing a method on a class that is not derived from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>, like <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>, you can be in a nondefault context if a <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a> is on your stack in the current application domain.  </p>\n<p> When your code is executing in a nondefault context, specifying <code>true</code> for <code>exitContext</code> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the WaitAll method. It returns to the original nondefault context after the call to the WaitAll method completes.  </p>\n<p> This can be useful when the context-bound class has <a class=\"xref\" href=\"system.runtime.remoting.contexts.synchronizationattribute\" data-linktype=\"relative-path\">SynchronizationAttribute</a>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the WaitAll method and specifies <code>true</code> for <code>exitContext</code>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the WaitAll method returns, the thread that made the call must wait to reenter the synchronization domain.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example shows how to use the thread pool to asynchronously create and write to a group of files. Each write operation is queued as a work item and signals when it is finished. The main thread waits for all the items to signal and then exits.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Threading.WaitHandle.WaitAll3#1\">using namespace System;\nusing namespace System::IO;\nusing namespace System::Security::Permissions;\nusing namespace System::Threading;\n\n// Maintain state to pass to WriteToFile.\nref class State\n{\npublic:\n   String^ fileName;\n   array&lt;Byte&gt;^byteArray;\n   ManualResetEvent^ manualEvent;\n   State( String^ fileName, array&lt;Byte&gt;^byteArray, ManualResetEvent^ manualEvent )\n      : fileName( fileName ), byteArray( byteArray ), manualEvent( manualEvent )\n   {}\n\n};\n\nref class Writer\n{\nprivate:\n   static int workItemCount = 0;\n   Writer(){}\n\n\npublic:\n   static void WriteToFile( Object^ state )\n   {\n      int workItemNumber = workItemCount;\n      Interlocked::Increment( workItemCount );\n      Console::WriteLine( &quot;Starting work item {0}.&quot;, workItemNumber.ToString() );\n      State^ stateInfo = dynamic_cast&lt;State^&gt;(state);\n      FileStream^ fileWriter;\n      \n      // Create and write to the file.\n      try\n      {\n         fileWriter = gcnew FileStream( stateInfo-&gt;fileName,FileMode::Create );\n         fileWriter-&gt;Write( stateInfo-&gt;byteArray, 0, stateInfo-&gt;byteArray-&gt;Length );\n      }\n      finally\n      {\n         if ( fileWriter != nullptr )\n         {\n            fileWriter-&gt;Close();\n         }\n         \n         // Signal main() that the work item has finished.\n         Console::WriteLine( &quot;Ending work item {0}.&quot;, workItemNumber.ToString() );\n         stateInfo-&gt;manualEvent-&gt;Set();\n      }\n\n   }\n\n};\n\nint main()\n{\n   const int numberOfFiles = 5;\n   String^ dirName =  &quot;C:\\&nbsp;&nbsp;&nbsp;&nbsp;estTest&quot;;\n   String^ fileName;\n   array&lt;Byte&gt;^byteArray;\n   Random^ randomGenerator = gcnew Random;\n   array&lt;ManualResetEvent^&gt;^manualEvents = gcnew array&lt;ManualResetEvent^&gt;(numberOfFiles);\n   State^ stateInfo;\n   if (  !Directory::Exists( dirName ) )\n   {\n      Directory::CreateDirectory( dirName );\n   }\n\n   \n   // Queue the work items that create and write to the files.\n   for ( int i = 0; i &lt; numberOfFiles; i++ )\n   {\n      fileName = String::Concat( dirName,  &quot;\\&nbsp;&nbsp;&nbsp;&nbsp;est&quot;, ((i)).ToString(),  &quot;.dat&quot; );\n      \n      // Create random data to write to the file.\n      byteArray = gcnew array&lt;Byte&gt;(1000000);\n      randomGenerator-&gt;NextBytes( byteArray );\n      manualEvents[ i ] = gcnew ManualResetEvent( false );\n      stateInfo = gcnew State( fileName,byteArray,manualEvents[ i ] );\n      ThreadPool::QueueUserWorkItem( gcnew WaitCallback( &amp;Writer::WriteToFile ), stateInfo );\n\n   }\n   \n   // Since ThreadPool threads are background threads, \n   // wait for the work items to signal before exiting.\n   if ( WaitHandle::WaitAll( manualEvents, TimeSpan(0,0,5), false ) )\n   {\n      Console::WriteLine( &quot;Files written - main exiting.&quot; );\n   }\n   else\n   {\n      \n      // The wait operation times out.\n      Console::WriteLine( &quot;Error writing files - main exiting.&quot; );\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.WaitHandle.WaitAll3#1\">Imports System\nImports System.IO\nImports System.Security.Permissions\nImports System.Threading\n\nPublic Class Test\n\n    &#39; WaitHandle.WaitAll requires a multithreaded apartment \n    &#39; when using multiple wait handles.\n    &lt;MTAThreadAttribute&gt; _\n    Shared Sub Main()\n        Const numberOfFiles As Integer = 5\n        Dim dirName As String = &quot;C:&nbsp;&nbsp;&nbsp;&nbsp;estTest&quot;\n        Dim fileName As String \n\n        Dim byteArray() As Byte \n        Dim randomGenerator As New Random()\n\n        Dim manualEvents(numberOfFiles - 1) As ManualResetEvent\n        Dim stateInfo As State \n\n        If Directory.Exists(dirName) &lt;&gt; True Then\n            Directory.CreateDirectory(dirName)\n        End If\n\n        &#39; Queue the work items that create and write to the files.\n        For i As Integer = 0 To numberOfFiles - 1\n            fileName = String.Concat( _\n                dirName, &quot;&nbsp;&nbsp;&nbsp;&nbsp;est&quot;, i.ToString(), &quot;.dat&quot;)\n\n            &#39; Create random data to write to the file.\n            byteArray = New Byte(1000000){}\n            randomGenerator.NextBytes(byteArray)\n\n            manualEvents(i) = New ManualResetEvent(false)\n\n            stateInfo = _ \n                New State(fileName, byteArray, manualEvents(i))\n\n            ThreadPool.QueueUserWorkItem(AddressOf _\n                Writer.WriteToFile, stateInfo)\n        Next i\n    \n        &#39; Since ThreadPool threads are background threads, \n        &#39; wait for the work items to signal before exiting.\n        If WaitHandle.WaitAll( _\n            manualEvents, New TimeSpan(0, 0, 5), false) = True  Then\n\n            Console.WriteLine(&quot;Files written - main exiting.&quot;)\n        Else\n        \n            &#39; The wait operation times out.\n            Console.WriteLine(&quot;Error writing files - main exiting.&quot;)\n        End If\n    End Sub\n\nEnd Class\n \n&#39; Maintain state to pass to WriteToFile.\nPublic Class State\n\n    Public fileName As String\n    Public byteArray As Byte()\n    Public manualEvent As ManualResetEvent\n\n    Sub New(fileName As String, byteArray() As Byte, _\n        manualEvent As ManualResetEvent)\n    \n        Me.fileName = fileName\n        Me.byteArray = byteArray\n        Me.manualEvent = manualEvent\n    End Sub\n\nEnd Class\n\nPublic Class Writer\n\n    Private Sub New()\n    End Sub\n\n    Shared workItemCount As Integer = 0\n\n    Shared Sub WriteToFile(state As Object)\n        Dim workItemNumber As Integer = workItemCount\n        Interlocked.Increment(workItemCount)\n        Console.WriteLine(&quot;Starting work item {0}.&quot;, _\n            workItemNumber.ToString())\n        Dim stateInfo As State = CType(state, State)\n        Dim fileWriter As FileStream = Nothing\n\n        &#39; Create and write to the file.\n        Try\n            fileWriter = New FileStream( _\n                stateInfo.fileName, FileMode.Create)\n            fileWriter.Write(stateInfo.byteArray, _\n                0, stateInfo.byteArray.Length)\n        Finally\n            If Not fileWriter Is Nothing Then\n                fileWriter.Close()\n            End If\n\n            &#39; Signal Main that the work item has finished.\n            Console.WriteLine(&quot;Ending work item {0}.&quot;, _\n                workItemNumber.ToString())\n            stateInfo.manualEvent.Set()\n        End Try\n    End Sub\n\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.WaitHandle.WaitAll3#1\">using System;\nusing System.IO;\nusing System.Security.Permissions;\nusing System.Threading;\n\nclass Test\n{\n    static void Main()\n    {\n        const int numberOfFiles = 5;\n        string dirName = @&quot;C:&nbsp;&nbsp;&nbsp;&nbsp;estTest&quot;;\n        string fileName;\n\n        byte[] byteArray;\n        Random randomGenerator = new Random();\n\n        ManualResetEvent[] manualEvents = \n            new ManualResetEvent[numberOfFiles];\n        State stateInfo;\n\n        if(!Directory.Exists(dirName))\n        {\n            Directory.CreateDirectory(dirName);\n        }\n\n        // Queue the work items that create and write to the files.\n        for(int i = 0; i &lt; numberOfFiles; i++)\n        {\n            fileName = string.Concat(\n                dirName, @&quot;&nbsp;&nbsp;&nbsp;&nbsp;est&quot;, i.ToString(), &quot;.dat&quot;);\n\n            // Create random data to write to the file.\n            byteArray = new byte[1000000];\n            randomGenerator.NextBytes(byteArray);\n\n            manualEvents[i] = new ManualResetEvent(false);\n\n            stateInfo = \n                new State(fileName, byteArray, manualEvents[i]);\n\n            ThreadPool.QueueUserWorkItem(new WaitCallback(\n                Writer.WriteToFile), stateInfo);\n        }\n    \n        // Since ThreadPool threads are background threads, \n        // wait for the work items to signal before exiting.\n        if(WaitHandle.WaitAll(\n            manualEvents, new TimeSpan(0, 0, 5), false))\n        {\n            Console.WriteLine(&quot;Files written - main exiting.&quot;);\n        }\n        else\n        {\n            // The wait operation times out.\n            Console.WriteLine(&quot;Error writing files - main exiting.&quot;);\n        }\n    }\n}\n\n// Maintain state to pass to WriteToFile.\nclass State\n{\n    public string fileName;\n    public byte[] byteArray;\n    public ManualResetEvent manualEvent;\n\n    public State(string fileName, byte[] byteArray, \n        ManualResetEvent manualEvent)\n    {\n        this.fileName = fileName;\n        this.byteArray = byteArray;\n        this.manualEvent = manualEvent;\n    }\n}\n\nclass Writer\n{\n    static int workItemCount = 0;\n    Writer() {}\n\n    public static void WriteToFile(object state)\n    {\n        int workItemNumber = workItemCount;\n        Interlocked.Increment(ref workItemCount);\n        Console.WriteLine(&quot;Starting work item {0}.&quot;,\n            workItemNumber.ToString());\n        State stateInfo = (State)state;\n        FileStream fileWriter = null;\n\n        // Create and write to the file.\n        try\n        {\n            fileWriter = new FileStream(\n                stateInfo.fileName, FileMode.Create);\n            fileWriter.Write(stateInfo.byteArray, \n                0, stateInfo.byteArray.Length);\n        }\n        finally\n        {\n            if(fileWriter != null)\n            {\n                fileWriter.Close();\n            }\n\n            // Signal Main that the work item has finished.\n            Console.WriteLine(&quot;Ending work item {0}.&quot;, \n                workItemNumber.ToString());\n            stateInfo.manualEvent.Set();\n        }\n    }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___\">\r\n    \r\n            <a id=\"System_Threading_WaitHandle_WaitAny_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">WaitAny(WaitHandle[])</div>        \r\n          </div>\r\n    \r\n            <p>Waits for any of the elements in the specified array to receive a signal.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static int WaitAny (System.Threading.WaitHandle[] waitHandles);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>waitHandles</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <code>WaitHandle</code> array containing the objects for which the current instance will wait.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </div>\r\n                  <p>The array index of the object that satisfied the wait.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p>The <code>waitHandles</code> parameter is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One or more of the objects in the <code>waitHandles</code> array is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The number of objects in <code>waitHandles</code> is greater than the system permits.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a></div>\r\n                  </div>\r\n                  <p><code>waitHandles</code> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></div>\r\n                  </div>\r\n                  <p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>waitHandles</code> is an array with no elements, and the .NET Framework version is 2.0 or later.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The <code>waitHandles</code> array contains a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> is new in the .NET Framework version 2.0. In previous versions, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method returns <code>true</code> if the wait completes because a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method throws an <a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> only when the wait completes because of an abandoned mutex. If <code>waitHandles</code> contains a released mutex with a lower index number than the abandoned mutex, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method completes normally and the exception is not thrown.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a>, and that <code>Mutex</code> is at index 0 (zero) in a <code>WaitAny</code> array on another thread, the index returned by <code>WaitAny</code> is 128 instead of 0.  </p>\n</div>\n<p> This method returns when any handle is signaled. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> is thrown.  </p>\n<p> Calling this method overload is equivalent to calling the [WaitAny(WaitHandle&lt;xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29&gt; method overload and specifying -1 (or <a class=\"xref\" href=\"system.threading.timeout#System_Threading_Timeout_Infinite\" data-linktype=\"relative-path\">System.Threading.Timeout.Infinite</a>) for <code>millisecondsTimeout</code>and <code>true</code> for <code>exitContext</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates calling the WaitAnymethod.  </p>\n<pre><code class=\"lang-cs\" name=\"WaitHandle#1\">using System;\nusing System.Threading;\n\npublic sealed class App \n{\n    // Define an array with two AutoResetEvent WaitHandles.\n    static WaitHandle[] waitHandles = new WaitHandle[] \n    {\n        new AutoResetEvent(false),\n        new AutoResetEvent(false)\n    };\n\n    // Define a random number generator for testing.\n    static Random r = new Random();\n\n    static void Main() \n    {\n        // Queue up two tasks on two different threads; \n        // wait until all tasks are completed.\n        DateTime dt = DateTime.Now;\n        Console.WriteLine(&quot;Main thread is waiting for BOTH tasks to complete.&quot;);\n        ThreadPool.QueueUserWorkItem(new WaitCallback(DoTask), waitHandles[0]);\n        ThreadPool.QueueUserWorkItem(new WaitCallback(DoTask), waitHandles[1]);\n        WaitHandle.WaitAll(waitHandles);\n        // The time shown below should match the longest task.\n        Console.WriteLine(&quot;Both tasks are completed (time waited={0})&quot;, \n            (DateTime.Now - dt).TotalMilliseconds);\n\n        // Queue up two tasks on two different threads; \n        // wait until any tasks are completed.\n        dt = DateTime.Now;\n        Console.WriteLine();\n        Console.WriteLine(&quot;The main thread is waiting for either task to complete.&quot;);\n        ThreadPool.QueueUserWorkItem(new WaitCallback(DoTask), waitHandles[0]);\n        ThreadPool.QueueUserWorkItem(new WaitCallback(DoTask), waitHandles[1]);\n        int index = WaitHandle.WaitAny(waitHandles);\n        // The time shown below should match the shortest task.\n        Console.WriteLine(&quot;Task {0} finished first (time waited={1}).&quot;,\n            index + 1, (DateTime.Now - dt).TotalMilliseconds);\n    }\n\n    static void DoTask(Object state) \n    {\n        AutoResetEvent are = (AutoResetEvent) state;\n        int time = 1000 * r.Next(2, 10);\n        Console.WriteLine(&quot;Performing a task for {0} milliseconds.&quot;, time);\n        Thread.Sleep(time);\n        are.Set();\n    }\n}\n\n// This code produces output similar to the following:\n//\n//  Main thread is waiting for BOTH tasks to complete.\n//  Performing a task for 7000 milliseconds.\n//  Performing a task for 4000 milliseconds.\n//  Both tasks are completed (time waited=7064.8052)\n// \n//  The main thread is waiting for either task to complete.\n//  Performing a task for 2000 milliseconds.\n//  Performing a task for 2000 milliseconds.\n//  Task 1 finished first (time waited=2000.6528).\n</code></pre><pre><code class=\"lang-cpp\" name=\"WaitHandle#1\">using namespace System;\nusing namespace System::Threading;\n\npublic ref class WaitHandleExample\n{\n    // Define a random number generator for testing.\nprivate:\n    static Random^ random = gcnew Random();\npublic:\n    static void DoTask(Object^ state)\n    {\n        AutoResetEvent^ autoReset = (AutoResetEvent^) state;\n        int time = 1000 * random-&gt;Next(2, 10);\n        Console::WriteLine(&quot;Performing a task for {0} milliseconds.&quot;, time);\n        Thread::Sleep(time);\n        autoReset-&gt;Set();\n    }\n};\n\nint main()\n{\n    // Define an array with two AutoResetEvent WaitHandles.\n    array&lt;WaitHandle^&gt;^ handles = gcnew array&lt;WaitHandle^&gt; {\n        gcnew AutoResetEvent(false), gcnew AutoResetEvent(false)};\n\n    // Queue up two tasks on two different threads;\n    // wait until all tasks are completed.\n    DateTime timeInstance = DateTime::Now;\n    Console::WriteLine(&quot;Main thread is waiting for BOTH tasks to &quot; +\n        &quot;complete.&quot;);\n    ThreadPool::QueueUserWorkItem(\n        gcnew WaitCallback(WaitHandleExample::DoTask), handles[0]);\n    ThreadPool::QueueUserWorkItem(\n        gcnew WaitCallback(WaitHandleExample::DoTask), handles[1]);\n    WaitHandle::WaitAll(handles);\n    // The time shown below should match the longest task.\n    Console::WriteLine(&quot;Both tasks are completed (time waited={0})&quot;,\n        (DateTime::Now - timeInstance).TotalMilliseconds);\n\n    // Queue up two tasks on two different threads;\n    // wait until any tasks are completed.\n    timeInstance = DateTime::Now;\n    Console::WriteLine();\n    Console::WriteLine(&quot;The main thread is waiting for either task to &quot; +\n        &quot;complete.&quot;);\n    ThreadPool::QueueUserWorkItem(\n        gcnew WaitCallback(WaitHandleExample::DoTask), handles[0]);\n    ThreadPool::QueueUserWorkItem(\n        gcnew WaitCallback(WaitHandleExample::DoTask), handles[1]);\n    int index = WaitHandle::WaitAny(handles);\n    // The time shown below should match the shortest task.\n    Console::WriteLine(&quot;Task {0} finished first (time waited={1}).&quot;,\n        index + 1, (DateTime::Now - timeInstance).TotalMilliseconds);\n}\n\n// This code produces the following sample output.\n//\n// Main thread is waiting for BOTH tasks to complete.\n// Performing a task for 7000 milliseconds.\n// Performing a task for 4000 milliseconds.\n// Both tasks are completed (time waited=7064.8052)\n\n// The main thread is waiting for either task to complete.\n// Performing a task for 2000 milliseconds.\n// Performing a task for 2000 milliseconds.\n// Task 1 finished first (time waited=2000.6528).\n</code></pre><pre><code class=\"lang-vb\" name=\"WaitHandle#1\">Imports System\nImports System.Threading\n\nNotInheritable Public Class App\n    &#39; Define an array with two AutoResetEvent WaitHandles.\n    Private Shared waitHandles() As WaitHandle = _\n        {New AutoResetEvent(False), New AutoResetEvent(False)}\n    \n    &#39; Define a random number generator for testing.\n    Private Shared r As New Random()\n    \n    &lt;MTAThreadAttribute&gt; _\n    Public Shared Sub Main() \n        &#39; Queue two tasks on two different threads; \n        &#39; wait until all tasks are completed.\n        Dim dt As DateTime = DateTime.Now\n        Console.WriteLine(&quot;Main thread is waiting for BOTH tasks to complete.&quot;)\n        ThreadPool.QueueUserWorkItem(AddressOf DoTask, waitHandles(0))\n        ThreadPool.QueueUserWorkItem(AddressOf DoTask, waitHandles(1))\n        WaitHandle.WaitAll(waitHandles)\n        &#39; The time shown below should match the longest task.\n        Console.WriteLine(&quot;Both tasks are completed (time waited={0})&quot;, _\n            (DateTime.Now - dt).TotalMilliseconds)\n        \n        &#39; Queue up two tasks on two different threads; \n        &#39; wait until any tasks are completed.\n        dt = DateTime.Now\n        Console.WriteLine()\n        Console.WriteLine(&quot;The main thread is waiting for either task to complete.&quot;)\n        ThreadPool.QueueUserWorkItem(AddressOf DoTask, waitHandles(0))\n        ThreadPool.QueueUserWorkItem(AddressOf DoTask, waitHandles(1))\n        Dim index As Integer = WaitHandle.WaitAny(waitHandles)\n        &#39; The time shown below should match the shortest task.\n        Console.WriteLine(&quot;Task {0} finished first (time waited={1}).&quot;, _\n            index + 1,(DateTime.Now - dt).TotalMilliseconds)\n    \n    End Sub &#39;Main\n    \n    Shared Sub DoTask(ByVal state As [Object]) \n        Dim are As AutoResetEvent = CType(state, AutoResetEvent)\n        Dim time As Integer = 1000 * r.Next(2, 10)\n        Console.WriteLine(&quot;Performing a task for {0} milliseconds.&quot;, time)\n        Thread.Sleep(time)\n        are.Set()\n    \n    End Sub &#39;DoTask\nEnd Class &#39;App\n\n&#39; This code produces output similar to the following:\n&#39;\n&#39;  Main thread is waiting for BOTH tasks to complete.\n&#39;  Performing a task for 7000 milliseconds.\n&#39;  Performing a task for 4000 milliseconds.\n&#39;  Both tasks are completed (time waited=7064.8052)\n&#39; \n&#39;  The main thread is waiting for either task to complete.\n&#39;  Performing a task for 2000 milliseconds.\n&#39;  Performing a task for 2000 milliseconds.\n&#39;  Task 1 finished first (time waited=2000.6528).\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_Int32_\">\r\n    \r\n            <a id=\"System_Threading_WaitHandle_WaitAny_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">WaitAny(WaitHandle[],Int32)</div>        \r\n          </div>\r\n    \r\n            <p>Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>waitHandles</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <code>WaitHandle</code> array containing the objects for which the current instance will wait.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>millisecondsTimeout</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The number of milliseconds to wait, or <a class=\"xref\" href=\"system.threading.timeout#System_Threading_Timeout_Infinite\" data-linktype=\"relative-path\">Infinite</a> (-1) to wait indefinitely.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </div>\r\n                  <p>The array index of the object that satisfied the wait, or <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitTimeout\" data-linktype=\"relative-path\">WaitTimeout</a> if no object satisfied the wait and a time interval equivalent to <code>millisecondsTimeout</code> has passed.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p>The <code>waitHandles</code> parameter is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One or more of the objects in the <code>waitHandles</code> array is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The number of objects in <code>waitHandles</code> is greater than the system permits.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p><code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></div>\r\n                  </div>\r\n                  <p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>waitHandles</code> is an array with no elements.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The <code>waitHandles</code> array contains a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If <code>millisecondsTimeout</code> is zero, the method does not block. It tests the state of the wait handles and returns immediately.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method throws an <a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> only when the wait completes because of an abandoned mutex. If <code>waitHandles</code> contains a released mutex with a lower index number than the abandoned mutex, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method completes normally and the exception is not thrown.  </p>\n<p> This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> is thrown.  </p>\n<p> Calling this method overload is the same as calling the [WaitAny(WaitHandle&lt;xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29&gt; overload and specifying <code>false</code> for <code>exitContext</code>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_TimeSpan_\">\r\n    \r\n            <a id=\"System_Threading_WaitHandle_WaitAny_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">WaitAny(WaitHandle[],TimeSpan)</div>        \r\n          </div>\r\n    \r\n            <p>Waits for any of the elements in the specified array to receive a signal, using a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> to specify the time interval.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>waitHandles</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <code>WaitHandle</code> array containing the objects for which the current instance will wait.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>timeout</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents the number of milliseconds to wait, or a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents -1 milliseconds to wait indefinitely.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </div>\r\n                  <p>The array index of the object that satisfied the wait, or <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitTimeout\" data-linktype=\"relative-path\">WaitTimeout</a> if no object satisfied the wait and a time interval equivalent to <code>timeout</code> has passed.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p>The <code>waitHandles</code> parameter is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One or more of the objects in the <code>waitHandles</code> array is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The number of objects in <code>waitHandles</code> is greater than the system permits.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p><code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out.  </p>\n<p> -or-  </p>\n<p> <code>timeout</code> is greater than <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">MaxValue</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></div>\r\n                  </div>\r\n                  <p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>waitHandles</code> is an array with no elements.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The <code>waitHandles</code> array contains a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If <code>timeout</code> is zero, the method does not block. It tests the state of the wait handles and returns immediately.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method throws an <a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> only when the wait completes because of an abandoned mutex. If <code>waitHandles</code> contains a released mutex with a lower index number than the abandoned mutex, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method completes normally and the exception is not thrown.  </p>\n<p> This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> is thrown.  </p>\n<p> The maximum value for <code>timeout</code> is <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">System.Int32.MaxValue</a>.  </p>\n<p> Calling this method overload is the same as calling the [WaitAny(WaitHandle&lt;xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29&gt; overload and specifying <code>false</code> for <code>exitContext</code>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_Int32_System_Boolean_\">\r\n    \r\n            <a id=\"System_Threading_WaitHandle_WaitAny_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">WaitAny(WaitHandle[],Int32,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>waitHandles</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <code>WaitHandle</code> array containing the objects for which the current instance will wait.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>millisecondsTimeout</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The number of milliseconds to wait, or <a class=\"xref\" href=\"system.threading.timeout#System_Threading_Timeout_Infinite\" data-linktype=\"relative-path\">Infinite</a> (-1) to wait indefinitely.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>exitContext</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </div>\r\n                  <p>The array index of the object that satisfied the wait, or <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitTimeout\" data-linktype=\"relative-path\">WaitTimeout</a> if no object satisfied the wait and a time interval equivalent to <code>millisecondsTimeout</code> has passed.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p>The <code>waitHandles</code> parameter is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One or more of the objects in the <code>waitHandles</code> array is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The number of objects in <code>waitHandles</code> is greater than the system permits.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a></div>\r\n                  </div>\r\n                  <p><code>waitHandles</code> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p><code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></div>\r\n                  </div>\r\n                  <p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>waitHandles</code> is an array with no elements, and the .NET Framework version is 2.0 or later.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The <code>waitHandles</code> array contains a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If <code>millisecondsTimeout</code> is zero, the method does not block. It tests the state of the wait handles and returns immediately.  </p>\n<p> <a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> is new in the .NET Framework version 2.0. In previous versions, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method returns <code>true</code> if the wait completes because a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method throws an <a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> only when the wait completes because of an abandoned mutex. If <code>waitHandles</code> contains a released mutex with a lower index number than the abandoned mutex, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method completes normally and the exception is not thrown.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a>, and that <code>Mutex</code> is at index 0 (zero) in a <code>WaitAny</code> array on another thread, the index returned by <code>WaitAny</code> is 128 instead of 0.  </p>\n</div>\n<p> This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> is thrown.  </p>\n<h2 id=\"notes-on-exiting-the-context\">Notes on Exiting the Context</h2>\n<p> The <code>exitContext</code> parameter has no effect unless the WaitAny method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>. Even if you are currently executing a method on a class that does not derive from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>, like <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>, you can be in a nondefault context if a <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a> is on your stack in the current application domain.  </p>\n<p> When your code is executing in a nondefault context, specifying <code>true</code> for <code>exitContext</code> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the WaitAny method. The thread returns to the original nondefault context after the call to the WaitAny method completes.  </p>\n<p> This can be useful when the context-bound class has <a class=\"xref\" href=\"system.runtime.remoting.contexts.synchronizationattribute\" data-linktype=\"relative-path\">SynchronizationAttribute</a>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the WaitAny method and specifies <code>true</code> for <code>exitContext</code>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the WaitAny method returns, the thread that made the call must wait to reenter the synchronization domain.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks. For space considerations, only the root directory of each disk is searched.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Threading.WaitHandle.WaitAny2#1\">Imports Microsoft.VisualBasic\nImports System\nImports System.IO\nImports System.Threading\n\nPublic Class Test\n\n    &lt;MTAThread&gt; _\n    Shared Sub Main()\n        Dim search As New Search()\n        search.FindFile(&quot;SomeFile.dat&quot;)\n    End Sub    \nEnd Class\n\nPublic Class Search\n\n    &#39; Maintain state information to pass to FindCallback.\n    Class State\n        Public autoEvent As AutoResetEvent \n        Public fileName As String         \n\n        Sub New(anEvent As AutoResetEvent, fName As String)\n            autoEvent = anEvent\n            fileName = fName\n        End Sub\n    End Class\n\n    Dim autoEvents() As AutoResetEvent\n    Dim diskLetters() As String\n\n    Sub New()\n\n        &#39; Retrieve an array of disk letters.\n        diskLetters = Environment.GetLogicalDrives()\n\n        autoEvents = New AutoResetEvent(diskLetters.Length - 1) {}\n        For i As Integer = 0 To diskLetters.Length - 1\n            autoEvents(i) = New AutoResetEvent(False)\n        Next i\n    End Sub    \n    \n    &#39; Search for fileName in the root directory of all disks.\n    Sub FindFile(fileName As String)\n        For i As Integer = 0 To diskLetters.Length - 1\n            Console.WriteLine(&quot;Searching for {0} on {1}.&quot;, _\n                fileName, diskLetters(i))\n        \n            ThreadPool.QueueUserWorkItem(AddressOf FindCallback, _ \n                New State(autoEvents(i), diskLetters(i) &amp; fileName))\n        Next i\n\n        &#39; Wait for the first instance of the file to be found.\n        Dim index As Integer = _\n            WaitHandle.WaitAny(autoEvents, 3000, False)\n        If index = WaitHandle.WaitTimeout\n            Console.WriteLine(vbCrLf &amp; &quot;{0} not found.&quot;, fileName)\n        Else\n            Console.WriteLine(vbCrLf &amp; &quot;{0} found on {1}.&quot;, _\n                fileName, diskLetters(index))\n        End If\n    End Sub\n\n    &#39; Search for stateInfo.fileName.\n    Sub FindCallback(state As Object)\n        Dim stateInfo As State = DirectCast(state, State)\n\n        &#39; Signal if the file is found.\n        If File.Exists(stateInfo.fileName) Then\n            stateInfo.autoEvent.Set()\n        End If\n    End Sub\n\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.WaitHandle.WaitAny2#1\">using System;\nusing System.IO;\nusing System.Threading;\n\nclass Test\n{\n    static void Main()\n    {\n        Search search = new Search();\n        search.FindFile(&quot;SomeFile.dat&quot;);\n    }\n}\n\nclass Search\n{\n    // Maintain state information to pass to FindCallback.\n    class State\n    {\n        public AutoResetEvent autoEvent;\n        public string         fileName;\n\n        public State(AutoResetEvent autoEvent, string fileName)\n        {\n            this.autoEvent    = autoEvent;\n            this.fileName     = fileName;\n        }\n    }\n\n    AutoResetEvent[] autoEvents;\n    String[] diskLetters;\n\n    public Search()\n    {\n        // Retrieve an array of disk letters.\n        diskLetters = Environment.GetLogicalDrives();\n\n        autoEvents = new AutoResetEvent[diskLetters.Length];\n        for(int i = 0; i &lt; diskLetters.Length; i++)\n        {\n            autoEvents[i] = new AutoResetEvent(false);\n        }\n    }\n\n    // Search for fileName in the root directory of all disks.\n    public void FindFile(string fileName)\n    {\n        for(int i = 0; i &lt; diskLetters.Length; i++)\n        {\n            Console.WriteLine(&quot;Searching for {0} on {1}.&quot;,\n                fileName, diskLetters[i]);\n            ThreadPool.QueueUserWorkItem(\n                new WaitCallback(FindCallback), \n                new State(autoEvents[i], diskLetters[i] + fileName));\n        }\n\n        // Wait for the first instance of the file to be found.\n        int index = WaitHandle.WaitAny(autoEvents, 3000, false);\n        if(index == WaitHandle.WaitTimeout)\n        {\n            Console.WriteLine(&quot;<br>{0} not found.&quot;, fileName);\n        }\n        else\n        {\n            Console.WriteLine(&quot;<br>{0} found on {1}.&quot;, fileName,\n                diskLetters[index]);\n        }\n    }\n\n    // Search for stateInfo.fileName.\n    void FindCallback(object state)\n    {\n        State stateInfo = (State)state;\n\n        // Signal if the file is found.\n        if(File.Exists(stateInfo.fileName))\n        {\n            stateInfo.autoEvent.Set();\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.WaitHandle.WaitAny2#1\">using namespace System;\nusing namespace System::IO;\nusing namespace System::Threading;\nref class Search\n{\nprivate:\n\n   // Maintain state information to pass to FindCallback.\n   ref class State\n   {\n   public:\n      AutoResetEvent^ autoEvent;\n      String^ fileName;\n      State( AutoResetEvent^ autoEvent, String^ fileName )\n         : autoEvent( autoEvent ), fileName( fileName )\n      {}\n\n   };\n\n\npublic:\n   array&lt;AutoResetEvent^&gt;^autoEvents;\n   array&lt;String^&gt;^diskLetters;\n\n   // Search for stateInfo-&gt;fileName.\n   void FindCallback( Object^ state )\n   {\n      State^ stateInfo = dynamic_cast&lt;State^&gt;(state);\n      \n      // Signal if the file is found.\n      if ( File::Exists( stateInfo-&gt;fileName ) )\n      {\n         stateInfo-&gt;autoEvent-&gt;Set();\n      }\n   }\n\n   Search()\n   {\n      \n      // Retrieve an array of disk letters.\n      diskLetters = Environment::GetLogicalDrives();\n      autoEvents = gcnew array&lt;AutoResetEvent^&gt;(diskLetters-&gt;Length);\n      for ( int i = 0; i &lt; diskLetters-&gt;Length; i++ )\n      {\n         autoEvents[ i ] = gcnew AutoResetEvent( false );\n\n      }\n   }\n\n\n   // Search for fileName in the root directory of all disks.\n   void FindFile( String^ fileName )\n   {\n      for ( int i = 0; i &lt; diskLetters-&gt;Length; i++ )\n      {\n         Console::WriteLine(  &quot;Searching for {0} on {1}.&quot;, fileName, diskLetters[ i ] );\n         ThreadPool::QueueUserWorkItem( gcnew WaitCallback( this, &amp;Search::FindCallback ), gcnew State( autoEvents[ i ],String::Concat( diskLetters[ i ], fileName ) ) );\n\n      }\n      \n      // Wait for the first instance of the file to be found.\n      int index = WaitHandle::WaitAny( autoEvents, 3000, false );\n      if ( index == WaitHandle::WaitTimeout )\n      {\n         Console::WriteLine( &quot;<br>{0} not found.&quot;, fileName );\n      }\n      else\n      {\n         Console::WriteLine( &quot;<br>{0} found on {1}.&quot;, fileName, diskLetters[ index ] );\n      }\n   }\n\n};\n\nint main()\n{\n   Search^ search = gcnew Search;\n   search-&gt;FindFile( &quot;SomeFile.dat&quot; );\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_TimeSpan_System_Boolean_\">\r\n    \r\n            <a id=\"System_Threading_WaitHandle_WaitAny_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">WaitAny(WaitHandle[],TimeSpan,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Waits for any of the elements in the specified array to receive a signal, using a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>waitHandles</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <code>WaitHandle</code> array containing the objects for which the current instance will wait.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>timeout</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents the number of milliseconds to wait, or a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents -1 milliseconds to wait indefinitely.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>exitContext</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </div>\r\n                  <p>The array index of the object that satisfied the wait, or <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitTimeout\" data-linktype=\"relative-path\">WaitTimeout</a> if no object satisfied the wait and a time interval equivalent to <code>timeout</code> has passed.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p>The <code>waitHandles</code> parameter is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One or more of the objects in the <code>waitHandles</code> array is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The number of objects in <code>waitHandles</code> is greater than the system permits.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a></div>\r\n                  </div>\r\n                  <p><code>waitHandles</code> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p><code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out.  </p>\n<p> -or-  </p>\n<p> <code>timeout</code> is greater than <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">MaxValue</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></div>\r\n                  </div>\r\n                  <p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>waitHandles</code> is an array with no elements, and the .NET Framework version is 2.0 or later.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The <code>waitHandles</code> array contains a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If <code>timeout</code> is zero, the method does not block. It tests the state of the wait handles and returns immediately.  </p>\n<p> <a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> is new in the .NET Framework version 2.0. In previous versions, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method returns <code>true</code> if the wait completes because a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method throws an <a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> only when the wait completes because of an abandoned mutex. If <code>waitHandles</code> contains a released mutex with a lower index number than the abandoned mutex, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> method completes normally and the exception is not thrown.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a>, and that <code>Mutex</code> is at index 0 (zero) in a <code>WaitAny</code> array on another thread, the index returned by <code>WaitAny</code> is 128 instead of 0.  </p>\n</div>\n<p> This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> is thrown.  </p>\n<p> The maximum value for <code>timeout</code> is <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">System.Int32.MaxValue</a>.  </p>\n<h2 id=\"notes-on-exiting-the-context\">Notes on Exiting the Context</h2>\n<p> The <code>exitContext</code> parameter has no effect unless the WaitAny method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>. Even if you are currently executing a method on a class that does not derive from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>, like <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>, you can be in a nondefault context if a <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a> is on your stack in the current application domain.  </p>\n<p> When your code is executing in a nondefault context, specifying <code>true</code> for <code>exitContext</code> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the WaitAny method. The thread returns to the original nondefault context after the call to the WaitAny method completes.  </p>\n<p> This can be useful when the context-bound class has <a class=\"xref\" href=\"system.runtime.remoting.contexts.synchronizationattribute\" data-linktype=\"relative-path\">SynchronizationAttribute</a>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the WaitAny method and specifies <code>true</code> for <code>exitContext</code>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the WaitAny method returns, the thread that made the call must wait to reenter the synchronization domain.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks. For space considerations, only the root directory of each disk is searched.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Threading.WaitHandle.WaitAny3#1\">using namespace System;\nusing namespace System::IO;\nusing namespace System::Threading;\nref class Search\n{\nprivate:\n\n   // Maintain state information to pass to FindCallback.\n   ref class State\n   {\n   public:\n      AutoResetEvent^ autoEvent;\n      String^ fileName;\n      State( AutoResetEvent^ autoEvent, String^ fileName )\n         : autoEvent( autoEvent ), fileName( fileName )\n      {}\n\n   };\n\n\npublic:\n   array&lt;AutoResetEvent^&gt;^autoEvents;\n   array&lt;String^&gt;^diskLetters;\n\n   // Search for stateInfo-&gt;fileName.\n   void FindCallback( Object^ state )\n   {\n      State^ stateInfo = dynamic_cast&lt;State^&gt;(state);\n      \n      // Signal if the file is found.\n      if ( File::Exists( stateInfo-&gt;fileName ) )\n      {\n         stateInfo-&gt;autoEvent-&gt;Set();\n      }\n   }\n\n   Search()\n   {\n      \n      // Retrieve an array of disk letters.\n      diskLetters = Environment::GetLogicalDrives();\n      autoEvents = gcnew array&lt;AutoResetEvent^&gt;(diskLetters-&gt;Length);\n      for ( int i = 0; i &lt; diskLetters-&gt;Length; i++ )\n      {\n         autoEvents[ i ] = gcnew AutoResetEvent( false );\n\n      }\n   }\n\n\n   // Search for fileName in the root directory of all disks.\n   void FindFile( String^ fileName )\n   {\n      for ( int i = 0; i &lt; diskLetters-&gt;Length; i++ )\n      {\n         Console::WriteLine(  &quot;Searching for {0} on {1}.&quot;, fileName, diskLetters[ i ] );\n         ThreadPool::QueueUserWorkItem( gcnew WaitCallback( this, &amp;Search::FindCallback ), gcnew State( autoEvents[ i ],String::Concat( diskLetters[ i ], fileName ) ) );\n\n      }\n      \n      // Wait for the first instance of the file to be found.\n      int index = WaitHandle::WaitAny( autoEvents, TimeSpan(0,0,3), false );\n      if ( index == WaitHandle::WaitTimeout )\n      {\n         Console::WriteLine( &quot;<br>{0} not found.&quot;, fileName );\n      }\n      else\n      {\n         Console::WriteLine( &quot;<br>{0} found on {1}.&quot;, fileName, diskLetters[ index ] );\n      }\n   }\n\n};\n\nint main()\n{\n   Search^ search = gcnew Search;\n   search-&gt;FindFile( &quot;SomeFile.dat&quot; );\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.WaitHandle.WaitAny3#1\">using System;\nusing System.IO;\nusing System.Threading;\n\nclass Test\n{\n    static void Main()\n    {\n        Search search = new Search();\n        search.FindFile(&quot;SomeFile.dat&quot;);\n    }\n}\n\nclass Search\n{\n    // Maintain state information to pass to FindCallback.\n    class State\n    {\n        public AutoResetEvent autoEvent;\n        public string         fileName;\n\n        public State(AutoResetEvent autoEvent, string fileName)\n        {\n            this.autoEvent    = autoEvent;\n            this.fileName     = fileName;\n        }\n    }\n\n    AutoResetEvent[] autoEvents;\n    String[] diskLetters;\n\n    public Search()\n    {\n        // Retrieve an array of disk letters.\n        diskLetters = Environment.GetLogicalDrives();\n\n        autoEvents = new AutoResetEvent[diskLetters.Length];\n        for(int i = 0; i &lt; diskLetters.Length; i++)\n        {\n            autoEvents[i] = new AutoResetEvent(false);\n        }\n    }\n\n    // Search for fileName in the root directory of all disks.\n    public void FindFile(string fileName)\n    {\n        for(int i = 0; i &lt; diskLetters.Length; i++)\n        {\n            Console.WriteLine(&quot;Searching for {0} on {1}.&quot;,\n                fileName, diskLetters[i]);\n            ThreadPool.QueueUserWorkItem(\n                new WaitCallback(FindCallback), \n                new State(autoEvents[i], diskLetters[i] + fileName));\n        }\n\n        // Wait for the first instance of the file to be found.\n        int index = WaitHandle.WaitAny(\n            autoEvents, new TimeSpan(0, 0, 3), false);\n        if(index == WaitHandle.WaitTimeout)\n        {\n            Console.WriteLine(&quot;<br>{0} not found.&quot;, fileName);\n        }\n        else\n        {\n            Console.WriteLine(&quot;<br>{0} found on {1}.&quot;, fileName,\n                diskLetters[index]);\n        }\n    }\n\n    // Search for stateInfo.fileName.\n    void FindCallback(object state)\n    {\n        State stateInfo = (State)state;\n\n        // Signal if the file is found.\n        if(File.Exists(stateInfo.fileName))\n        {\n            stateInfo.autoEvent.Set();\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.WaitHandle.WaitAny3#1\">Imports Microsoft.VisualBasic\nImports System\nImports System.IO\nImports System.Threading\n\nPublic Class Test\n\n    &lt;MTAThread&gt; _\n    Shared Sub Main()\n        Dim search As New Search()\n        search.FindFile(&quot;SomeFile.dat&quot;)\n    End Sub    \nEnd Class\n\nPublic Class Search\n\n    &#39; Maintain state information to pass to FindCallback.\n    Class State\n        Public autoEvent As AutoResetEvent \n        Public fileName As String         \n\n        Sub New(anEvent As AutoResetEvent, fName As String)\n            autoEvent = anEvent\n            fileName = fName\n        End Sub\n    End Class\n\n    Dim autoEvents() As AutoResetEvent\n    Dim diskLetters() As String\n\n    Sub New()\n\n        &#39; Retrieve an array of disk letters.\n        diskLetters = Environment.GetLogicalDrives()\n\n        autoEvents = New AutoResetEvent(diskLetters.Length - 1) {}\n        For i As Integer = 0 To diskLetters.Length - 1\n            autoEvents(i) = New AutoResetEvent(False)\n        Next i\n    End Sub    \n    \n    &#39; Search for fileName in the root directory of all disks.\n    Sub FindFile(fileName As String)\n        For i As Integer = 0 To diskLetters.Length - 1\n            Console.WriteLine(&quot;Searching for {0} on {1}.&quot;, _\n                fileName, diskLetters(i))\n        \n            ThreadPool.QueueUserWorkItem(AddressOf FindCallback, _ \n                New State(autoEvents(i), diskLetters(i) &amp; fileName))\n        Next i\n\n        &#39; Wait for the first instance of the file to be found.\n        Dim index As Integer = WaitHandle.WaitAny( _\n            autoEvents, New TimeSpan(0, 0, 3), False)\n        If index = WaitHandle.WaitTimeout\n            Console.WriteLine(vbCrLf &amp; &quot;{0} not found.&quot;, fileName)\n        Else\n            Console.WriteLine(vbCrLf &amp; &quot;{0} found on {1}.&quot;, _\n                fileName, diskLetters(index))\n        End If\n    End Sub\n\n    &#39; Search for stateInfo.fileName.\n    Sub FindCallback(state As Object)\n        Dim stateInfo As State = DirectCast(state, State)\n\n        &#39; Signal if the file is found.\n        If File.Exists(stateInfo.fileName) Then\n            stateInfo.autoEvent.Set()\n        End If\n    End Sub\n\nEnd Class\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_WaitOne\">\r\n    \r\n            <a id=\"System_Threading_WaitHandle_WaitOne_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">WaitOne()</div>        \r\n          </div>\r\n    \r\n            <p>Blocks the current thread until the current <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> receives a signal.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool WaitOne ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the current instance receives a signal. If the current instance is never signaled, <span class=\"xref\">stem.Threading.WaitHandle.WaitOne*</span> never returns.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.objectdisposedexception\" data-linktype=\"relative-path\">ObjectDisposedException</a></div>\r\n                  </div>\r\n                  <p>The current instance has already been disposed.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></div>\r\n                  </div>\r\n                  <p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The current instance is a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> is new in the .NET Framework version 2.0. In previous versions, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> method returns <code>true</code> when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  </p>\n<p> The caller of this method blocks indefinitely until the current instance receives a signal. Use this method to block until a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <a class=\"xref\" href=\"system.iasyncresult\" data-linktype=\"relative-path\">IAsyncResult</a> interface.  </p>\n<p> Calling this method overload is equivalent to calling the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_System_Int32_System_Boolean_\" data-linktype=\"relative-path\">WaitOne(Int32,Boolean)</a> method overload and specifying -1 or <a class=\"xref\" href=\"system.threading.timeout#System_Threading_Timeout_Infinite\" data-linktype=\"relative-path\">System.Threading.Timeout.Infinite</a> for the first parameter and <code>false</code> for the second parameter.  </p>\n<p> Override this method to customize the behavior of derived classes.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.WaitHandle.WaitOne1#1\">using System;\nusing System.Threading;\n\nclass WaitOne\n{\n    static AutoResetEvent autoEvent = new AutoResetEvent(false);\n\n    static void Main()\n    {\n        Console.WriteLine(&quot;Main starting.&quot;);\n\n        ThreadPool.QueueUserWorkItem(\n            new WaitCallback(WorkMethod), autoEvent);\n\n        // Wait for work method to signal.\n        autoEvent.WaitOne();\n        Console.WriteLine(&quot;Work method signaled.<br>Main ending.&quot;);\n    }\n\n    static void WorkMethod(object stateInfo) \n    {\n        Console.WriteLine(&quot;Work starting.&quot;);\n\n        // Simulate time spent working.\n        Thread.Sleep(new Random().Next(100, 2000));\n\n        // Signal that work is finished.\n        Console.WriteLine(&quot;Work ending.&quot;);\n        ((AutoResetEvent)stateInfo).Set();\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.WaitHandle.WaitOne1#1\">using namespace System;\nusing namespace System::Threading;\nref class WaitOne\n{\nprivate:\n   WaitOne(){}\n\n\npublic:\n   static void WorkMethod( Object^ stateInfo )\n   {\n      Console::WriteLine( &quot;Work starting.&quot; );\n      \n      // Simulate time spent working.\n      Thread::Sleep( (gcnew Random)-&gt;Next( 100, 2000 ) );\n      \n      // Signal that work is finished.\n      Console::WriteLine( &quot;Work ending.&quot; );\n      dynamic_cast&lt;AutoResetEvent^&gt;(stateInfo)-&gt;Set();\n   }\n\n};\n\nint main()\n{\n   Console::WriteLine( &quot;Main starting.&quot; );\n   AutoResetEvent^ autoEvent = gcnew AutoResetEvent( false );\n   ThreadPool::QueueUserWorkItem( gcnew WaitCallback( &amp;WaitOne::WorkMethod ), autoEvent );\n   \n   // Wait for work method to signal.\n   autoEvent-&gt;WaitOne(  );\n   Console::WriteLine( &quot;Work method signaled.<br>Main ending.&quot; );\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.WaitHandle.WaitOne1#1\">Imports System\nImports System.Threading\n\nPublic Class WaitOne\n\n    Shared autoEvent As New AutoResetEvent(False)\n\n    &lt;MTAThread&gt; _\n    Shared Sub Main()\n        Console.WriteLine(&quot;Main starting.&quot;)\n\n        ThreadPool.QueueUserWorkItem(AddressOf WorkMethod, autoEvent)\n\n        &#39; Wait for work method to signal.\n        autoEvent.WaitOne()\n        Console.WriteLine(&quot;Work method signaled.&quot;)\n        Console.WriteLine(&quot;Main ending.&quot;)\n    End Sub\n\n    Shared Sub WorkMethod(stateInfo As Object) \n        Console.WriteLine(&quot;Work starting.&quot;)\n\n        &#39; Simulate time spent working.\n        Thread.Sleep(New Random().Next(100, 2000))\n\n        &#39; Signal that work is finished.\n        Console.WriteLine(&quot;Work ending.&quot;)\n        CType(stateInfo, AutoResetEvent).Set()\n    End Sub\n\nEnd Class\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_WaitOne_System_Int32_\">\r\n    \r\n            <a id=\"System_Threading_WaitHandle_WaitOne_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">WaitOne(Int32)</div>        \r\n          </div>\r\n    \r\n            <p>Blocks the current thread until the current <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool WaitOne (int millisecondsTimeout);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>millisecondsTimeout</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The number of milliseconds to wait, or <a class=\"xref\" href=\"system.threading.timeout#System_Threading_Timeout_Infinite\" data-linktype=\"relative-path\">Infinite</a> (-1) to wait indefinitely.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the current instance receives a signal; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.objectdisposedexception\" data-linktype=\"relative-path\">ObjectDisposedException</a></div>\r\n                  </div>\r\n                  <p>The current instance has already been disposed.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p><code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></div>\r\n                  </div>\r\n                  <p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The current instance is a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If <code>millisecondsTimeout</code> is zero, the method does not block. It tests the state of the wait handle and returns immediately.  </p>\n<p> The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <a class=\"xref\" href=\"system.iasyncresult\" data-linktype=\"relative-path\">IAsyncResult</a> interface.  </p>\n<p> Override this method to customize the behavior of derived classes.  </p>\n<p> Calling this method overload is the same as calling the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_System_Int32_System_Boolean_\" data-linktype=\"relative-path\">WaitOne(Int32,Boolean)</a> overload and specifying <code>false</code> for <code>exitContext</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Threading.WaitHandle.WaitOne2#1\">using namespace System;\nusing namespace System::Threading;\nref class WaitOne\n{\nprivate:\n   WaitOne(){}\n\n\npublic:\n   static void WorkMethod( Object^ stateInfo )\n   {\n      Console::WriteLine( &quot;Work starting.&quot; );\n      \n      // Simulate time spent working.\n      Thread::Sleep( (gcnew Random)-&gt;Next( 100, 2000 ) );\n      \n      // Signal that work is finished.\n      Console::WriteLine( &quot;Work ending.&quot; );\n      dynamic_cast&lt;AutoResetEvent^&gt;(stateInfo)-&gt;Set();\n   }\n\n};\n\nint main()\n{\n   Console::WriteLine( &quot;Main starting.&quot; );\n   AutoResetEvent^ autoEvent = gcnew AutoResetEvent( false );\n   ThreadPool::QueueUserWorkItem( gcnew WaitCallback( &amp;WaitOne::WorkMethod ), autoEvent );\n   \n   // Wait for work method to signal.\n   if ( autoEvent-&gt;WaitOne( 1000 ) )\n   {\n      Console::WriteLine( &quot;Work method signaled.&quot; );\n   }\n   else\n   {\n      Console::WriteLine( &quot;Timed out waiting for work &quot;\n      &quot;method to signal.&quot; );\n   }\n\n   Console::WriteLine( &quot;Main ending.&quot; );\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.WaitHandle.WaitOne2#1\">Imports System\nImports System.Threading\n\nPublic Class WaitOne\n\n    Shared autoEvent As New AutoResetEvent(False)\n\n    &lt;MTAThread&gt; _\n    Shared Sub Main()\n        Console.WriteLine(&quot;Main starting.&quot;)\n\n        ThreadPool.QueueUserWorkItem(AddressOf WorkMethod, autoEvent)\n\n        &#39; Wait for work method to signal.\n        If autoEvent.WaitOne(1000) Then\n            Console.WriteLine(&quot;Work method signaled.&quot;)\n        Else\n            Console.WriteLine(&quot;Timed out waiting for work &quot; &amp; _\n                &quot;method to signal.&quot;)\n        End If\n\n        Console.WriteLine(&quot;Main ending.&quot;)\n    End Sub\n\n    Shared Sub WorkMethod(stateInfo As Object) \n        Console.WriteLine(&quot;Work starting.&quot;)\n\n        &#39; Simulate time spent working.\n        Thread.Sleep(New Random().Next(100, 2000))\n\n        &#39; Signal that work is finished.\n        Console.WriteLine(&quot;Work ending.&quot;)\n        CType(stateInfo, AutoResetEvent).Set()\n    End Sub\n\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.WaitHandle.WaitOne2#1\">using System;\nusing System.Threading;\n\nclass WaitOne\n{\n    static AutoResetEvent autoEvent = new AutoResetEvent(false);\n\n    static void Main()\n    {\n        Console.WriteLine(&quot;Main starting.&quot;);\n\n        ThreadPool.QueueUserWorkItem(\n            new WaitCallback(WorkMethod), autoEvent);\n\n        // Wait for work method to signal.\n        if(autoEvent.WaitOne(1000))\n        {\n            Console.WriteLine(&quot;Work method signaled.&quot;);\n        }\n        else\n        {\n            Console.WriteLine(&quot;Timed out waiting for work &quot; +\n                &quot;method to signal.&quot;);\n        }\n        Console.WriteLine(&quot;Main ending.&quot;);\n    }\n\n    static void WorkMethod(object stateInfo) \n    {\n        Console.WriteLine(&quot;Work starting.&quot;);\n\n        // Simulate time spent working.\n        Thread.Sleep(new Random().Next(100, 2000));\n\n        // Signal that work is finished.\n        Console.WriteLine(&quot;Work ending.&quot;);\n        ((AutoResetEvent)stateInfo).Set();\n    }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_WaitOne_System_TimeSpan_\">\r\n    \r\n            <a id=\"System_Threading_WaitHandle_WaitOne_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">WaitOne(TimeSpan)</div>        \r\n          </div>\r\n    \r\n            <p>Blocks the current thread until the current instance receives a signal, using a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> to specify the time interval.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool WaitOne (TimeSpan timeout);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>timeout</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents the number of milliseconds to wait, or a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents -1 milliseconds to wait indefinitely.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the current instance receives a signal; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.objectdisposedexception\" data-linktype=\"relative-path\">ObjectDisposedException</a></div>\r\n                  </div>\r\n                  <p>The current instance has already been disposed.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p><code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out.  </p>\n<p> -or-  </p>\n<p> <code>timeout</code> is greater than <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">MaxValue</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></div>\r\n                  </div>\r\n                  <p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The current instance is a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If <code>timeout</code> is zero, the method does not block. It tests the state of the wait handle and returns immediately.  </p>\n<p> The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <a class=\"xref\" href=\"system.iasyncresult\" data-linktype=\"relative-path\">IAsyncResult</a> interface.  </p>\n<p> Override this method to customize the behavior of derived classes.  </p>\n<p> The maximum value for <code>timeout</code> is <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">System.Int32.MaxValue</a>.  </p>\n<p> Calling this method overload is the same as calling the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_System_TimeSpan_System_Boolean_\" data-linktype=\"relative-path\">WaitOne(TimeSpan,Boolean)</a> overload and specifying <code>false</code> for <code>exitContext</code>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_WaitOne_System_Int32_System_Boolean_\">\r\n    \r\n            <a id=\"System_Threading_WaitHandle_WaitOne_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">WaitOne(Int32,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Blocks the current thread until the current <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>millisecondsTimeout</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The number of milliseconds to wait, or <a class=\"xref\" href=\"system.threading.timeout#System_Threading_Timeout_Infinite\" data-linktype=\"relative-path\">Infinite</a> (-1) to wait indefinitely.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>exitContext</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the current instance receives a signal; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.objectdisposedexception\" data-linktype=\"relative-path\">ObjectDisposedException</a></div>\r\n                  </div>\r\n                  <p>The current instance has already been disposed.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p><code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></div>\r\n                  </div>\r\n                  <p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The current instance is a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If <code>millisecondsTimeout</code> is zero, the method does not block. It tests the state of the wait handle and returns immediately.  </p>\n<p> <a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> is new in the .NET Framework version 2.0. In previous versions, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> method returns <code>true</code> when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  </p>\n<p> The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <a class=\"xref\" href=\"system.iasyncresult\" data-linktype=\"relative-path\">IAsyncResult</a> interface.  </p>\n<p> Override this method to customize the behavior of derived classes.  </p>\n<h2 id=\"notes-on-exiting-the-context\">Notes on Exiting the Context</h2>\n<p> The <code>exitContext</code> parameter has no effect unless the WaitOne method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>. Even if you are currently executing a method on a class that does not derive from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>, like <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>, you can be in a nondefault context if a <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a> is on your stack in the current application domain.  </p>\n<p> When your code is executing in a nondefault context, specifying <code>true</code> for <code>exitContext</code> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the WaitOne method. The thread returns to the original nondefault context after the call to the WaitOne method completes.  </p>\n<p> This can be useful when the context-bound class has <a class=\"xref\" href=\"system.runtime.remoting.contexts.synchronizationattribute\" data-linktype=\"relative-path\">SynchronizationAttribute</a>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the WaitOne method and specifies <code>true</code> for <code>exitContext</code>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the WaitOne method returns, the thread that made the call must wait to reenter the synchronization domain.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example shows how the WaitOne method overload behaves when it is called within a synchronization domain. First, a thread waits with <code>exitContext</code> set to <code>false</code> and blocks until the wait timeout expires. A second thread executes after the first thread terminates and waits with <code>exitContext</code> set to <code>true</code>. The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.WaitHandle.WaitOne4#1\">using System;\nusing System.Threading;\nusing System.Runtime.Remoting.Contexts;\n\n[Synchronization(true)]\npublic class SyncingClass : ContextBoundObject\n{\n    private EventWaitHandle waitHandle;\n\n    public SyncingClass()\n    {\n         waitHandle =\n            new EventWaitHandle(false, EventResetMode.ManualReset);\n    }\n\n    public void Signal()\n    {\n        Console.WriteLine(&quot;Thread[{0:d4}]: Signalling...&quot;, Thread.CurrentThread.GetHashCode());\n        waitHandle.Set();\n    }\n\n    public void DoWait(bool leaveContext)\n    {\n        bool signalled;\n\n        waitHandle.Reset();\n        Console.WriteLine(&quot;Thread[{0:d4}]: Waiting...&quot;, Thread.CurrentThread.GetHashCode());\n        signalled = waitHandle.WaitOne(3000, leaveContext);\n        if (signalled)\n        {\n            Console.WriteLine(&quot;Thread[{0:d4}]: Wait released!!!&quot;, Thread.CurrentThread.GetHashCode());\n        }\n        else\n        {\n            Console.WriteLine(&quot;Thread[{0:d4}]: Wait timeout!!!&quot;, Thread.CurrentThread.GetHashCode());\n        }\n    }\n}\n\npublic class TestSyncDomainWait\n{\n    public static void Main()\n    {\n        SyncingClass syncClass = new SyncingClass();\n\n        Thread runWaiter;\n\n        Console.WriteLine(&quot;<br>Wait and signal INSIDE synchronization domain:<br>&quot;);\n        runWaiter = new Thread(RunWaitKeepContext);\n        runWaiter.Start(syncClass);\n        Thread.Sleep(1000);\n        Console.WriteLine(&quot;Thread[{0:d4}]: Signal...&quot;, Thread.CurrentThread.GetHashCode());\n        // This call to Signal will block until the timeout in DoWait expires.\n        syncClass.Signal();\n        runWaiter.Join();\n\n        Console.WriteLine(&quot;<br>Wait and signal OUTSIDE synchronization domain:<br>&quot;);\n        runWaiter = new Thread(RunWaitLeaveContext);\n        runWaiter.Start(syncClass);\n        Thread.Sleep(1000);\n        Console.WriteLine(&quot;Thread[{0:d4}]: Signal...&quot;, Thread.CurrentThread.GetHashCode());\n        // This call to Signal is unblocked and will set the wait handle to\n        // release the waiting thread.\n        syncClass.Signal();\n        runWaiter.Join();\n    }\n\n    public static void RunWaitKeepContext(object parm)\n    {\n        ((SyncingClass)parm).DoWait(false);\n    }\n\n    public static void RunWaitLeaveContext(object parm)\n    {\n        ((SyncingClass)parm).DoWait(true);\n    }\n}\n\n// The output for the example program will be similar to the following:\n//\n// Wait and signal INSIDE synchronization domain:\n//\n// Thread[0004]: Waiting...\n// Thread[0001]: Signal...\n// Thread[0004]: Wait timeout!!!\n// Thread[0001]: Signalling...\n//\n// Wait and signal OUTSIDE synchronization domain:\n//\n// Thread[0006]: Waiting...\n// Thread[0001]: Signal...\n// Thread[0001]: Signalling...\n// Thread[0006]: Wait released!!!\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.WaitHandle.WaitOne4#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Runtime::Remoting::Contexts;\n\n[Synchronization(true)]\npublic ref class SyncingClass : ContextBoundObject\n{\nprivate:\n    EventWaitHandle^ waitHandle;\n\npublic:\n    SyncingClass()\n    {\n         waitHandle =\n            gcnew EventWaitHandle(false, EventResetMode::ManualReset);\n    }\n\n    void Signal()\n    {\n        Console::WriteLine(&quot;Thread[{0:d4}]: Signalling...&quot;, Thread::CurrentThread-&gt;GetHashCode());\n        waitHandle-&gt;Set();\n    }\n\n    void DoWait(bool leaveContext)\n    {\n        bool signalled;\n\n        waitHandle-&gt;Reset();\n        Console::WriteLine(&quot;Thread[{0:d4}]: Waiting...&quot;, Thread::CurrentThread-&gt;GetHashCode());\n        signalled = waitHandle-&gt;WaitOne(3000, leaveContext);\n        if (signalled)\n        {\n            Console::WriteLine(&quot;Thread[{0:d4}]: Wait released!!!&quot;, Thread::CurrentThread-&gt;GetHashCode());\n        }\n        else\n        {\n            Console::WriteLine(&quot;Thread[{0:d4}]: Wait timeout!!!&quot;, Thread::CurrentThread-&gt;GetHashCode());\n        }\n    }\n};\n\npublic ref class TestSyncDomainWait\n{\npublic:\n    static void Main()\n    {\n        SyncingClass^ syncClass = gcnew SyncingClass();\n\n        Thread^ runWaiter;\n\n        Console::WriteLine(&quot;<br>Wait and signal INSIDE synchronization domain:<br>&quot;);\n        runWaiter = gcnew Thread(gcnew ParameterizedThreadStart(&amp;TestSyncDomainWait::RunWaitKeepContext));\n        runWaiter-&gt;Start(syncClass);\n        Thread::Sleep(1000);\n        Console::WriteLine(&quot;Thread[{0:d4}]: Signal...&quot;, Thread::CurrentThread-&gt;GetHashCode());\n        // This call to Signal will block until the timeout in DoWait expires.\n        syncClass-&gt;Signal();\n        runWaiter-&gt;Join();\n\n        Console::WriteLine(&quot;<br>Wait and signal OUTSIDE synchronization domain:<br>&quot;);\n        runWaiter = gcnew Thread(gcnew ParameterizedThreadStart(&amp;TestSyncDomainWait::RunWaitLeaveContext));\n        runWaiter-&gt;Start(syncClass);\n        Thread::Sleep(1000);\n        Console::WriteLine(&quot;Thread[{0:d4}]: Signal...&quot;, Thread::CurrentThread-&gt;GetHashCode());\n        // This call to Signal is unblocked and will set the wait handle to\n        // release the waiting thread.\n        syncClass-&gt;Signal();\n        runWaiter-&gt;Join();\n    }\n\n    static void RunWaitKeepContext(Object^ parm)\n    {\n        ((SyncingClass^)parm)-&gt;DoWait(false);\n    }\n\n    static void RunWaitLeaveContext(Object^ parm)\n    {\n        ((SyncingClass^)parm)-&gt;DoWait(true);\n    }\n};\n\nint main()\n{\n    TestSyncDomainWait::Main();\n}\n// The output for the example program will be similar to the following:\n//\n// Wait and signal INSIDE synchronization domain:\n//\n// Thread[0004]: Waiting...\n// Thread[0001]: Signal...\n// Thread[0004]: Wait timeout!!!\n// Thread[0001]: Signalling...\n//\n// Wait and signal OUTSIDE synchronization domain:\n//\n// Thread[0006]: Waiting...\n// Thread[0001]: Signal...\n// Thread[0001]: Signalling...\n// Thread[0006]: Wait released!!!\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.WaitHandle.WaitOne4#1\">Imports System\nImports System.Threading\nImports System.Runtime.Remoting.Contexts\n\n&lt;Synchronization(true)&gt;\nPublic Class SyncingClass\n    Inherits ContextBoundObject\n    \n    Private waitHandle As EventWaitHandle\n\n    Public Sub New()\n         waitHandle = New EventWaitHandle(false, EventResetMode.ManualReset)\n    End Sub\n\n    Public Sub Signal()\n        Console.WriteLine(&quot;Thread[{0:d4}]: Signalling...&quot;, Thread.CurrentThread.GetHashCode())\n        waitHandle.Set()\n    End Sub\n\n    Public Sub DoWait(leaveContext As Boolean)\n        Dim signalled As Boolean\n\n        waitHandle.Reset()\n        Console.WriteLine(&quot;Thread[{0:d4}]: Waiting...&quot;, Thread.CurrentThread.GetHashCode())\n        signalled = waitHandle.WaitOne(3000, leaveContext)\n        If signalled Then\n            Console.WriteLine(&quot;Thread[{0:d4}]: Wait released!!!&quot;, Thread.CurrentThread.GetHashCode())\n        Else\n            Console.WriteLine(&quot;Thread[{0:d4}]: Wait timeout!!!&quot;, Thread.CurrentThread.GetHashCode())\n        End If\n    End Sub\nEnd Class\n\nPublic Class TestSyncDomainWait\n    Public Shared Sub Main()\n        Dim syncClass As New SyncingClass()\n\n        Dim runWaiter As Thread\n\n        Console.WriteLine(vbNewLine + &quot;Wait and signal INSIDE synchronization domain:&quot; + vbNewLine)\n        runWaiter = New Thread(AddressOf RunWaitKeepContext)\n        runWaiter.Start(syncClass)\n        Thread.Sleep(1000)\n        Console.WriteLine(&quot;Thread[{0:d4}]: Signal...&quot;, Thread.CurrentThread.GetHashCode())\n        &#39; This call to Signal will block until the timeout in DoWait expires.\n        syncClass.Signal()\n        runWaiter.Join()\n\n        Console.WriteLine(vbNewLine + &quot;Wait and signal OUTSIDE synchronization domain:&quot; + vbNewLine)\n        runWaiter = New Thread(AddressOf RunWaitLeaveContext)\n        runWaiter.Start(syncClass)\n        Thread.Sleep(1000)\n        Console.WriteLine(&quot;Thread[{0:d4}]: Signal...&quot;, Thread.CurrentThread.GetHashCode())\n        &#39; This call to Signal is unblocked and will set the wait handle to\n        &#39; release the waiting thread.\n        syncClass.Signal()\n        runWaiter.Join()\n    End Sub\n\n    Public Shared Sub RunWaitKeepContext(parm As Object)\n        Dim syncClass As SyncingClass = CType(parm, SyncingClass)\n        syncClass.DoWait(False)\n    End Sub\n\n    Public Shared Sub RunWaitLeaveContext(parm As Object)\n        Dim syncClass As SyncingClass = CType(parm, SyncingClass)\n        syncClass.DoWait(True)\n    End Sub\nEnd Class\n\n&#39; The output for the example program will be similar to the following:\n&#39;\n&#39; Wait and signal INSIDE synchronization domain:\n&#39;\n&#39; Thread[0004]: Waiting...\n&#39; Thread[0001]: Signal...\n&#39; Thread[0004]: Wait timeout!!!\n&#39; Thread[0001]: Signalling...\n&#39;\n&#39; Wait and signal OUTSIDE synchronization domain:\n&#39;\n&#39; Thread[0006]: Waiting...\n&#39; Thread[0001]: Signal...\n&#39; Thread[0001]: Signalling...\n&#39; Thread[0006]: Wait released!!!\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_WaitHandle_WaitOne_System_TimeSpan_System_Boolean_\">\r\n    \r\n            <a id=\"System_Threading_WaitHandle_WaitOne_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">WaitOne(TimeSpan,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Blocks the current thread until the current instance receives a signal, using a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> to specify the time interval and specifying whether to exit the synchronization domain before the wait.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool WaitOne (TimeSpan timeout, bool exitContext);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>timeout</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents the number of milliseconds to wait, or a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> that represents -1 milliseconds to wait indefinitely.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>exitContext</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the current instance receives a signal; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.objectdisposedexception\" data-linktype=\"relative-path\">ObjectDisposedException</a></div>\r\n                  </div>\r\n                  <p>The current instance has already been disposed.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p><code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out.  </p>\n<p> -or-  </p>\n<p> <code>timeout</code> is greater than <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">MaxValue</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a></div>\r\n                  </div>\r\n                  <p>The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The current instance is a transparent proxy for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> in another application domain.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If <code>timeout</code> is zero, the method does not block. It tests the state of the wait handle and returns immediately.  </p>\n<p> <a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> is new in the .NET Framework version 2.0. In previous versions, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> method returns <code>true</code> when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  </p>\n<p> The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <a class=\"xref\" href=\"system.iasyncresult\" data-linktype=\"relative-path\">IAsyncResult</a> interface.  </p>\n<p> Override this method to customize the behavior of derived classes.  </p>\n<p> The maximum value for <code>timeout</code> is <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">System.Int32.MaxValue</a>.  </p>\n<h2 id=\"notes-on-exiting-the-context\">Notes on Exiting the Context</h2>\n<p> The <code>exitContext</code> parameter has no effect unless the WaitOne method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>. Even if you are currently executing a method on a class that does not derive from <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a>, like <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>, you can be in a nondefault context if a <a class=\"xref\" href=\"system.contextboundobject\" data-linktype=\"relative-path\">ContextBoundObject</a> is on your stack in the current application domain.  </p>\n<p> When your code is executing in a nondefault context, specifying <code>true</code> for <code>exitContext</code> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the WaitOne method. The thread returns to the original nondefault context after the call to the WaitOne method completes.  </p>\n<p> This can be useful when the context-bound class has <a class=\"xref\" href=\"system.runtime.remoting.contexts.synchronizationattribute\" data-linktype=\"relative-path\">SynchronizationAttribute</a>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the WaitOne method and specifies <code>true</code> for <code>exitContext</code>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the WaitOne method returns, the thread that made the call must wait to reenter the synchronization domain.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.WaitHandle.WaitOne3#1\">using System;\nusing System.Threading;\n\nclass WaitOne\n{\n    static AutoResetEvent autoEvent = new AutoResetEvent(false);\n\n    static void Main()\n    {\n        Console.WriteLine(&quot;Main starting.&quot;);\n\n        ThreadPool.QueueUserWorkItem(\n            new WaitCallback(WorkMethod), autoEvent);\n\n        // Wait for work method to signal.\n        if(autoEvent.WaitOne(new TimeSpan(0, 0, 1), false))\n        {\n            Console.WriteLine(&quot;Work method signaled.&quot;);\n        }\n        else\n        {\n            Console.WriteLine(&quot;Timed out waiting for work &quot; +\n                &quot;method to signal.&quot;);\n        }\n        Console.WriteLine(&quot;Main ending.&quot;);\n    }\n\n    static void WorkMethod(object stateInfo) \n    {\n        Console.WriteLine(&quot;Work starting.&quot;);\n\n        // Simulate time spent working.\n        Thread.Sleep(new Random().Next(100, 2000));\n\n        // Signal that work is finished.\n        Console.WriteLine(&quot;Work ending.&quot;);\n        ((AutoResetEvent)stateInfo).Set();\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.WaitHandle.WaitOne3#1\">using namespace System;\nusing namespace System::Threading;\nref class WaitOne\n{\nprivate:\n   WaitOne(){}\n\n\npublic:\n   static void WorkMethod( Object^ stateInfo )\n   {\n      Console::WriteLine( &quot;Work starting.&quot; );\n      \n      // Simulate time spent working.\n      Thread::Sleep( (gcnew Random)-&gt;Next( 100, 2000 ) );\n      \n      // Signal that work is finished.\n      Console::WriteLine( &quot;Work ending.&quot; );\n      dynamic_cast&lt;AutoResetEvent^&gt;(stateInfo)-&gt;Set();\n   }\n\n};\n\nint main()\n{\n   Console::WriteLine( &quot;Main starting.&quot; );\n   AutoResetEvent^ autoEvent = gcnew AutoResetEvent( false );\n   ThreadPool::QueueUserWorkItem( gcnew WaitCallback( &amp;WaitOne::WorkMethod ), autoEvent );\n   \n   // Wait for work method to signal.\n   if ( autoEvent-&gt;WaitOne( TimeSpan(0,0,1), false ) )\n   {\n      Console::WriteLine( &quot;Work method signaled.&quot; );\n   }\n   else\n   {\n      Console::WriteLine( &quot;Timed out waiting for work &quot;\n      &quot;method to signal.&quot; );\n   }\n\n   Console::WriteLine( &quot;Main ending.&quot; );\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.WaitHandle.WaitOne3#1\">Imports System\nImports System.Threading\n\nPublic Class WaitOne\n\n    Shared autoEvent As New AutoResetEvent(False)\n\n    &lt;MTAThread&gt; _\n    Shared Sub Main()\n        Console.WriteLine(&quot;Main starting.&quot;)\n\n        ThreadPool.QueueUserWorkItem(AddressOf WorkMethod, autoEvent)\n\n        &#39; Wait for work method to signal.\n        If autoEvent.WaitOne(New TimeSpan(0, 0, 1), False) Then\n            Console.WriteLine(&quot;Work method signaled.&quot;)\n        Else\n            Console.WriteLine(&quot;Timed out waiting for work &quot; &amp; _\n                &quot;method to signal.&quot;)\n        End If\n\n        Console.WriteLine(&quot;Main ending.&quot;)\n    End Sub\n\n    Shared Sub WorkMethod(stateInfo As Object) \n        Console.WriteLine(&quot;Work starting.&quot;)\n\n        &#39; Simulate time spent working.\n        Thread.Sleep(New Random().Next(100, 2000))\n\n        &#39; Signal that work is finished.\n        Console.WriteLine(&quot;Work ending.&quot;)\n        CType(stateInfo, AutoResetEvent).Set()\n    End Sub\n\nEnd Class\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n","outputRootRelativePath":"./","pageMetadata":"<meta name=\"breadcrumb_path\" content=\"breadcrumb/toc.json\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"fulldocset\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.fulldocset\">\r\n<meta name=\"ref_skeleton_gitcommit\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Threading.WaitHandle.yml\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Threading.WaitHandle.yml\">\r\n<meta name=\"APIName\" content=\"System.Threading.WaitHandle\">\r\n<meta name=\"APIName\" content=\"System.Threading.WaitHandle..ctor\">\r\n<meta name=\"APIName\" content=\"System.Threading.WaitHandle.Close\">\r\n<meta name=\"APIName\" content=\"System.Threading.WaitHandle.Dispose\">\r\n<meta name=\"APIName\" content=\"System.Threading.WaitHandle.Handle\">\r\n<meta name=\"APIName\" content=\"System.Threading.WaitHandle.InvalidHandle\">\r\n<meta name=\"APIName\" content=\"System.Threading.WaitHandle.SafeWaitHandle\">\r\n<meta name=\"APIName\" content=\"System.Threading.WaitHandle.SignalAndWait\">\r\n<meta name=\"APIName\" content=\"System.Threading.WaitHandle.WaitAll\">\r\n<meta name=\"APIName\" content=\"System.Threading.WaitHandle.WaitAny\">\r\n<meta name=\"APIName\" content=\"System.Threading.WaitHandle.WaitOne\">\r\n<meta name=\"APIName\" content=\"System.Threading.WaitHandle.WaitTimeout\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-01 01:37 AM\">\r\n<meta name=\"document_id\" content=\"81064bf3-f23d-02d2-f193-7031ccd2f1cf\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Encapsulates operating system–specific objects that wait for exclusive access to shared resources.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/System.Threading/toc.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Threading.WaitHandle\">\r\n","rawMetadata":{"breadcrumb_path":"breadcrumb/toc.json","search.ms_sitename":"Docs","search.ms_docsetname":"fulldocset","version":null,"_op_canonicalUrlPrefix":"https://ppe.docs.microsoft.com/en-us/fulldotnet/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":true,"depot_name":"MSDN.fulldocset","_op_gitRefSkeletonCommitHistory":[{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"use plugin in master","commit_sha":"501959ac03e19ac52a27aa4c6bbeb980f8b11c8c","commit_date":"2017-03-01 09:31:20 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"fix pointer ref","commit_sha":"76befb0e7f7b41839ec719047e5b39a5981298f3","commit_date":"2017-02-28 15:47:23 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"switch from platform to version","commit_sha":"78cdacb5ca782478af490a6b30c3a2cb2b6b873e","commit_date":"2017-02-28 15:09:51 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"update platforms","commit_sha":"39ad5a8919a59afc93a79ac4bd8e07c3b471b37a","commit_date":"2017-02-28 10:38:59 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"checkin yml","commit_sha":"da161b792852497df7140d7768cee2eccd9cb43f","commit_date":"2017-02-28 09:36:15 +0800"}],"ref_skeleton_gitcommit":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Threading.WaitHandle.yml","original_ref_skeleton_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Threading.WaitHandle.yml","open_to_public_contributors":true,"api_name":["System.Threading.WaitHandle","System.Threading.WaitHandle..ctor","System.Threading.WaitHandle.Close","System.Threading.WaitHandle.Dispose","System.Threading.WaitHandle.Handle","System.Threading.WaitHandle.InvalidHandle","System.Threading.WaitHandle.SafeWaitHandle","System.Threading.WaitHandle.SignalAndWait","System.Threading.WaitHandle.WaitAll","System.Threading.WaitHandle.WaitAny","System.Threading.WaitHandle.WaitOne","System.Threading.WaitHandle.WaitTimeout"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Threading.WaitHandle","System::Threading::WaitHandle","System.Threading.WaitHandle.#ctor","System::Threading::WaitHandle::#ctor","System.Threading.WaitHandle.Close","System::Threading::WaitHandle::Close","System.Threading.WaitHandle.Dispose","System::Threading::WaitHandle::Dispose","System.Threading.WaitHandle.Handle","System::Threading::WaitHandle::Handle","System.Threading.WaitHandle.InvalidHandle","System::Threading::WaitHandle::InvalidHandle","System.Threading.WaitHandle.SafeWaitHandle","System::Threading::WaitHandle::SafeWaitHandle","System.Threading.WaitHandle.SignalAndWait","System::Threading::WaitHandle::SignalAndWait","System.Threading.WaitHandle.WaitAll","System::Threading::WaitHandle::WaitAll","System.Threading.WaitHandle.WaitAny","System::Threading::WaitHandle::WaitAny","System.Threading.WaitHandle.WaitOne","System::Threading::WaitHandle::WaitOne","System.Threading.WaitHandle.WaitTimeout","System::Threading::WaitHandle::WaitTimeout"],"dev_langs":["csharp"],"updated_at":"2017-03-01 01:37 AM","document_id":"81064bf3-f23d-02d2-f193-7031ccd2f1cf","content_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/xml/System.Threading/WaitHandle.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"WaitHandle class | Microsoft Docs","_op_ogTitle":"WaitHandle class","description":"Encapsulates operating system–specific objects that wait for exclusive access to shared resources.\n","toc_asset_id":"_splitted/System.Threading/toc.json","toc_rel":"_splitted/System.Threading/toc.json","source_url":"","ms.assetid":"System.Threading.WaitHandle","canonical_url":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.threading.waithandle","_op_canonicalUrl":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.threading.waithandle","fileRelativePath":"System.Threading.WaitHandle.html"},"themesRelativePathToOutputRoot":"_themes/"}