{"content":"    \r\n    <h1 id=\"System_Threading_EventWaitHandle\">\r\n      <span class=\"lang-csharp\">EventWaitHandle</span>\r\n        Class\r\n    </h1>\r\n    \r\n    \r\n    <nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n      <h3>In this Article</h3>\r\n    </nav><div class=\"summary\">\r\n    \t<p>Represents a thread synchronization event.</p>\n\r\n    </div><h2>Syntax</h2>\r\n    \r\n    \t<h3>Declaration</h3>\r\n    \t<pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ComVisible(true)]\npublic class EventWaitHandle : System.Threading.WaitHandle</code></pre>\r\n    \r\n    \r\n    \r\n    <h3>Inheritance Hierarchy</h3>\r\n    <ul class=\"inheritance\">\r\n        <li class=\"l0\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>\r\n          </div>\r\n        </li>\r\n        <li class=\"l1\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.marshalbyrefobject\" data-linktype=\"relative-path\">MarshalByRefObject</a>\r\n          </div>\r\n        </li>\r\n        <li class=\"l2\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">System.Threading.WaitHandle</a>\r\n          </div>\r\n        </li>\r\n      <li class=\"l3\">\r\n        <div class=\"xref\">\r\n          <div class=\"lang-csharp\">EventWaitHandle</div>\r\n        </div>\r\n      </li>\r\n    </ul>\r\n    \r\n      <div class=\"referencebox inheritedMembers\">\r\n        <h3>Inherited Members</h3>\r\n        <h4></h4>\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.marshalbyrefobject#System_MarshalByRefObject_CreateObjRef_System_Type_\" data-linktype=\"relative-path\">CreateObjRef(Type)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.marshalbyrefobject#System_MarshalByRefObject_GetLifetimeService\" data-linktype=\"relative-path\">GetLifetimeService()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.marshalbyrefobject#System_MarshalByRefObject_InitializeLifetimeService\" data-linktype=\"relative-path\">InitializeLifetimeService()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.marshalbyrefobject#System_MarshalByRefObject_MemberwiseClone_System_Boolean_\" data-linktype=\"relative-path\">MemberwiseClone(Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Close\" data-linktype=\"relative-path\">Close()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Dispose\" data-linktype=\"relative-path\">Dispose()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Dispose_System_Boolean_\" data-linktype=\"relative-path\">Dispose(Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Handle\" data-linktype=\"relative-path\">Handle</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_InvalidHandle\" data-linktype=\"relative-path\">InvalidHandle</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SafeWaitHandle\" data-linktype=\"relative-path\">SafeWaitHandle</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SignalAndWait_System_Threading_WaitHandle_System_Threading_WaitHandle_\" data-linktype=\"relative-path\">SignalAndWait(WaitHandle,WaitHandle)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SignalAndWait_System_Threading_WaitHandle_System_Threading_WaitHandle_System_Int32_System_Boolean_\" data-linktype=\"relative-path\">SignalAndWait(WaitHandle,WaitHandle,Int32,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SignalAndWait_System_Threading_WaitHandle_System_Threading_WaitHandle_System_TimeSpan_System_Boolean_\" data-linktype=\"relative-path\">SignalAndWait(WaitHandle,WaitHandle,TimeSpan,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___\" data-linktype=\"relative-path\">WaitAll(WaitHandle[])</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_Int32_\" data-linktype=\"relative-path\">WaitAll(WaitHandle[],Int32)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_Int32_System_Boolean_\" data-linktype=\"relative-path\">WaitAll(WaitHandle[],Int32,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_TimeSpan_\" data-linktype=\"relative-path\">WaitAll(WaitHandle[],TimeSpan)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_TimeSpan_System_Boolean_\" data-linktype=\"relative-path\">WaitAll(WaitHandle[],TimeSpan,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___\" data-linktype=\"relative-path\">WaitAny(WaitHandle[])</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_Int32_\" data-linktype=\"relative-path\">WaitAny(WaitHandle[],Int32)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_Int32_System_Boolean_\" data-linktype=\"relative-path\">WaitAny(WaitHandle[],Int32,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_TimeSpan_\" data-linktype=\"relative-path\">WaitAny(WaitHandle[],TimeSpan)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_TimeSpan_System_Boolean_\" data-linktype=\"relative-path\">WaitAny(WaitHandle[],TimeSpan,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne\" data-linktype=\"relative-path\">WaitOne()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_System_Int32_\" data-linktype=\"relative-path\">WaitOne(Int32)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_System_Int32_System_Boolean_\" data-linktype=\"relative-path\">WaitOne(Int32,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_System_TimeSpan_\" data-linktype=\"relative-path\">WaitOne(TimeSpan)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_System_TimeSpan_System_Boolean_\" data-linktype=\"relative-path\">WaitOne(TimeSpan,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitTimeout\" data-linktype=\"relative-path\">WaitTimeout</a>\r\n          </div>\r\n          \r\n      </div>\r\n    \r\n    \r\n      <h2>Remarks</h2>\r\n      <p>The EventWaitHandle class allows threads to communicate with each other by signaling. Typically, one or more threads block on an EventWaitHandle until an unblocked thread calls the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_Set_\" data-linktype=\"relative-path\">Set</a> method, releasing one or more of the blocked threads. A thread can signal an EventWaitHandle and then block on it, by calling the <code>static</code> (<code>Shared</code> in Visual Basic) <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SignalAndWait_\" data-linktype=\"relative-path\">SignalAndWait</a> method.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The EventWaitHandle class provides access to named system synchronization events.  </p>\n</div>\n<p> The behavior of an EventWaitHandle that has been signaled depends on its reset mode. An EventWaitHandle created with the <a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">System.Threading.EventResetMode</a> flag resets automatically when signaled, after releasing a single waiting thread. An EventWaitHandle created with the <a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">System.Threading.EventResetMode</a> flag remains signaled until its <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_Reset_\" data-linktype=\"relative-path\">Reset</a> method is called.  </p>\n<p> Automatic reset events provide exclusive access to a resource. If an automatic reset event is signaled when no threads are waiting, it remains signaled until a thread attempts to wait on it. The event releases the thread and immediately resets, blocking subsequent threads.  </p>\n<p> Manual reset events are like gates. When the event is not signaled, threads that wait on it will block. When the event is signaled, all waiting threads are released, and the event remains signaled (that is, subsequent waits do not block) until its <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_Reset_\" data-linktype=\"relative-path\">Reset</a> method is called. Manual reset events are useful when one thread must complete an activity before other threads can proceed.  </p>\n<p> EventWaitHandle objects can be used with the <code>static</code>(<code>Shared</code> in Visual Basic) <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> and <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> methods.  </p>\n<p> For more information about thread synchronization mechanisms, see <a href=\"../Topic/EventWaitHandle,%20AutoResetEvent,%20CountdownEvent,%20ManualResetEvent.md\" data-linktype=\"relative-path\">EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent</a>.</p>\n\r\n    \r\n    \r\n    <h2>Constructors\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_EventWaitHandle__ctor_System_Boolean_System_Threading_EventResetMode_\" data-linktype=\"self-bookmark\">EventWaitHandle(Boolean,EventResetMode)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_EventWaitHandle__ctor_System_Boolean_System_Threading_EventResetMode_System_String_\" data-linktype=\"self-bookmark\">EventWaitHandle(Boolean,EventResetMode,String)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_EventWaitHandle__ctor_System_Boolean_System_Threading_EventResetMode_System_String_System_Boolean__\" data-linktype=\"self-bookmark\">EventWaitHandle(Boolean,EventResetMode,String,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_EventWaitHandle__ctor_System_Boolean_System_Threading_EventResetMode_System_String_System_Boolean__System_Security_AccessControl_EventWaitHandleSecurity_\" data-linktype=\"self-bookmark\">EventWaitHandle(Boolean,EventResetMode,String,Boolean,EventWaitHandleSecurity)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Methods\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_EventWaitHandle_GetAccessControl\" data-linktype=\"self-bookmark\">GetAccessControl()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets an <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlesecurity\" data-linktype=\"relative-path\">EventWaitHandleSecurity</a> object that represents the access control security for the named system event represented by the current <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> object.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_EventWaitHandle_OpenExisting_System_String_\" data-linktype=\"self-bookmark\">OpenExisting(String)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Opens the specified named synchronization event, if it already exists.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_EventWaitHandle_OpenExisting_System_String_System_Security_AccessControl_EventWaitHandleRights_\" data-linktype=\"self-bookmark\">OpenExisting(String,EventWaitHandleRights)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Opens the specified named synchronization event, if it already exists, with the desired security access.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_EventWaitHandle_Reset\" data-linktype=\"self-bookmark\">Reset()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets the state of the event to nonsignaled, causing threads to block.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_EventWaitHandle_Set\" data-linktype=\"self-bookmark\">Set()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets the state of the event to signaled, allowing one or more waiting threads to proceed.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_EventWaitHandle_SetAccessControl_System_Security_AccessControl_EventWaitHandleSecurity_\" data-linktype=\"self-bookmark\">SetAccessControl(EventWaitHandleSecurity)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets the access control security for a named system event.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_EventWaitHandle_TryOpenExisting_System_String_System_Threading_EventWaitHandle__\" data-linktype=\"self-bookmark\">TryOpenExisting(String,EventWaitHandle)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_EventWaitHandle_TryOpenExisting_System_String_System_Security_AccessControl_EventWaitHandleRights_System_Threading_EventWaitHandle__\" data-linktype=\"self-bookmark\">TryOpenExisting(String,EventWaitHandleRights,EventWaitHandle)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"constructors\">\r\n        <h2>Constructors\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_EventWaitHandle__ctor_System_Boolean_System_Threading_EventResetMode_\">\r\n    \r\n            <a id=\"System_Threading_EventWaitHandle__ctor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">EventWaitHandle(Boolean,EventResetMode)</div>        \r\n          </div>\r\n    \r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> class, specifying whether the wait handle is initially signaled, and whether it resets automatically or manually.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>initialState</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to set the initial state to signaled; <code>false</code> to set it to nonsignaled.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>mode</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">EventResetMode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>One of the <a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">EventResetMode</a> values that determines whether the event resets automatically or manually.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the initial state of the event is nonsignaled, threads that wait on the event will block. If the initial state is signaled, and the <a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">EventResetMode</a> flag is specified for <code>mode</code>, threads that wait on the event will not block. If the initial state is signaled, and <code>mode</code> is <a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">EventResetMode</a>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example uses the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SignalAndWait_System_Threading_WaitHandle_System_Threading_WaitHandle_\" data-linktype=\"relative-path\">SignalAndWait(WaitHandle,WaitHandle)</a> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.  </p>\n<p> The example starts five threads and allows them to block on an <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> created with the <a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">System.Threading.EventResetMode</a> flag, then releases one thread each time the user presses ENTER key. The example then queues another five threads and releases them all using an <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> created with the <a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">System.Threading.EventResetMode</a> flag.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Threading.WaitHandle.SignalAndWait#1\">using namespace System;\nusing namespace System::Threading;\n\npublic ref class Example\n{\nprivate:\n   // The EventWaitHandle used to demonstrate the difference\n   // between AutoReset and ManualReset synchronization events.\n   //\n   static EventWaitHandle^ ewh;\n\n   // A counter to make sure all threads are started and\n   // blocked before any are released. A Long is used to show\n   // the use of the 64-bit Interlocked methods.\n   //\n   static __int64 threadCount = 0;\n\n   // An AutoReset event that allows the main thread to block\n   // until an exiting thread has decremented the count.\n   //\n   static EventWaitHandle^ clearCount =\n      gcnew EventWaitHandle( false,EventResetMode::AutoReset );\n\npublic:\n   [MTAThread]\n   static void main()\n   {\n      // Create an AutoReset EventWaitHandle.\n      //\n      ewh = gcnew EventWaitHandle( false,EventResetMode::AutoReset );\n      \n      // Create and start five numbered threads. Use the\n      // ParameterizedThreadStart delegate, so the thread\n      // number can be passed as an argument to the Start\n      // method.\n      for ( int i = 0; i &lt;= 4; i++ )\n      {\n         Thread^ t = gcnew Thread(\n            gcnew ParameterizedThreadStart( ThreadProc ) );\n         t-&gt;Start( i );\n      }\n      \n      // Wait until all the threads have started and blocked.\n      // When multiple threads use a 64-bit value on a 32-bit\n      // system, you must access the value through the\n      // Interlocked class to guarantee thread safety.\n      //\n      while ( Interlocked::Read( threadCount ) &lt; 5 )\n      {\n         Thread::Sleep( 500 );\n      }\n\n      // Release one thread each time the user presses ENTER,\n      // until all threads have been released.\n      //\n      while ( Interlocked::Read( threadCount ) &gt; 0 )\n      {\n         Console::WriteLine( L&quot;Press ENTER to release a waiting thread.&quot; );\n         Console::ReadLine();\n         \n         // SignalAndWait signals the EventWaitHandle, which\n         // releases exactly one thread before resetting,\n         // because it was created with AutoReset mode.\n         // SignalAndWait then blocks on clearCount, to\n         // allow the signaled thread to decrement the count\n         // before looping again.\n         //\n         WaitHandle::SignalAndWait( ewh, clearCount );\n      }\n      Console::WriteLine();\n      \n      // Create a ManualReset EventWaitHandle.\n      //\n      ewh = gcnew EventWaitHandle( false,EventResetMode::ManualReset );\n      \n      // Create and start five more numbered threads.\n      //\n      for ( int i = 0; i &lt;= 4; i++ )\n      {\n         Thread^ t = gcnew Thread(\n            gcnew ParameterizedThreadStart( ThreadProc ) );\n         t-&gt;Start( i );\n      }\n      \n      // Wait until all the threads have started and blocked.\n      //\n      while ( Interlocked::Read( threadCount ) &lt; 5 )\n      {\n         Thread::Sleep( 500 );\n      }\n\n      // Because the EventWaitHandle was created with\n      // ManualReset mode, signaling it releases all the\n      // waiting threads.\n      //\n      Console::WriteLine( L&quot;Press ENTER to release the waiting threads.&quot; );\n      Console::ReadLine();\n      ewh-&gt;Set();\n\n   }\n\n   static void ThreadProc( Object^ data )\n   {\n      int index = static_cast&lt;Int32&gt;(data);\n\n      Console::WriteLine( L&quot;Thread {0} blocks.&quot;, data );\n      // Increment the count of blocked threads.\n      Interlocked::Increment( threadCount );\n      \n      // Wait on the EventWaitHandle.\n      ewh-&gt;WaitOne();\n\n      Console::WriteLine( L&quot;Thread {0} exits.&quot;, data );\n      // Decrement the count of blocked threads.\n      Interlocked::Decrement( threadCount );\n      \n      // After signaling ewh, the main thread blocks on\n      // clearCount until the signaled thread has\n      // decremented the count. Signal it now.\n      //\n      clearCount-&gt;Set();\n   }\n};\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.WaitHandle.SignalAndWait#1\">Imports System\nImports System.Threading\n\nPublic Class Example\n\n    &#39; The EventWaitHandle used to demonstrate the difference\n    &#39; between AutoReset and ManualReset synchronization events.\n    &#39;\n    Private Shared ewh As EventWaitHandle\n\n    &#39; A counter to make sure all threads are started and\n    &#39; blocked before any are released. A Long is used to show\n    &#39; the use of the 64-bit Interlocked methods.\n    &#39;\n    Private Shared threadCount As Long = 0\n\n    &#39; An AutoReset event that allows the main thread to block\n    &#39; until an exiting thread has decremented the count.\n    &#39;\n    Private Shared clearCount As New EventWaitHandle(False, _\n        EventResetMode.AutoReset)\n\n    &lt;MTAThread&gt; _\n    Public Shared Sub Main()\n\n        &#39; Create an AutoReset EventWaitHandle.\n        &#39;\n        ewh = New EventWaitHandle(False, EventResetMode.AutoReset)\n\n        &#39; Create and start five numbered threads. Use the\n        &#39; ParameterizedThreadStart delegate, so the thread\n        &#39; number can be passed as an argument to the Start \n        &#39; method.\n        For i As Integer = 0 To 4\n            Dim t As New Thread(AddressOf ThreadProc)\n            t.Start(i)\n        Next i\n\n        &#39; Wait until all the threads have started and blocked.\n        &#39; When multiple threads use a 64-bit value on a 32-bit\n        &#39; system, you must access the value through the\n        &#39; Interlocked class to guarantee thread safety.\n        &#39;\n        While Interlocked.Read(threadCount) &lt; 5\n            Thread.Sleep(500)\n        End While\n\n        &#39; Release one thread each time the user presses ENTER,\n        &#39; until all threads have been released.\n        &#39;\n        While Interlocked.Read(threadCount) &gt; 0\n            Console.WriteLine(&quot;Press ENTER to release a waiting thread.&quot;)\n            Console.ReadLine()\n\n            &#39; SignalAndWait signals the EventWaitHandle, which\n            &#39; releases exactly one thread before resetting, \n            &#39; because it was created with AutoReset mode. \n            &#39; SignalAndWait then blocks on clearCount, to \n            &#39; allow the signaled thread to decrement the count\n            &#39; before looping again.\n            &#39;\n            WaitHandle.SignalAndWait(ewh, clearCount)\n        End While\n        Console.WriteLine()\n\n        &#39; Create a ManualReset EventWaitHandle.\n        &#39;\n        ewh = New EventWaitHandle(False, EventResetMode.ManualReset)\n\n        &#39; Create and start five more numbered threads.\n        &#39;\n        For i As Integer = 0 To 4\n            Dim t As New Thread(AddressOf ThreadProc)\n            t.Start(i)\n        Next i\n\n        &#39; Wait until all the threads have started and blocked.\n        &#39;\n        While Interlocked.Read(threadCount) &lt; 5\n            Thread.Sleep(500)\n        End While\n\n        &#39; Because the EventWaitHandle was created with\n        &#39; ManualReset mode, signaling it releases all the\n        &#39; waiting threads.\n        &#39;\n        Console.WriteLine(&quot;Press ENTER to release the waiting threads.&quot;)\n        Console.ReadLine()\n        ewh.Set()\n        \n    End Sub\n\n    Public Shared Sub ThreadProc(ByVal data As Object)\n        Dim index As Integer = CInt(data)\n\n        Console.WriteLine(&quot;Thread {0} blocks.&quot;, data)\n        &#39; Increment the count of blocked threads.\n        Interlocked.Increment(threadCount)\n\n        &#39; Wait on the EventWaitHandle.\n        ewh.WaitOne()\n\n        Console.WriteLine(&quot;Thread {0} exits.&quot;, data)\n        &#39; Decrement the count of blocked threads.\n        Interlocked.Decrement(threadCount)\n\n        &#39; After signaling ewh, the main thread blocks on\n        &#39; clearCount until the signaled thread has \n        &#39; decremented the count. Signal it now.\n        &#39;\n        clearCount.Set()\n    End Sub\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.WaitHandle.SignalAndWait#1\">using System;\nusing System.Threading;\n\npublic class Example\n{\n    // The EventWaitHandle used to demonstrate the difference\n    // between AutoReset and ManualReset synchronization events.\n    //\n    private static EventWaitHandle ewh;\n\n    // A counter to make sure all threads are started and\n    // blocked before any are released. A Long is used to show\n    // the use of the 64-bit Interlocked methods.\n    //\n    private static long threadCount = 0;\n\n    // An AutoReset event that allows the main thread to block\n    // until an exiting thread has decremented the count.\n    //\n    private static EventWaitHandle clearCount = \n        new EventWaitHandle(false, EventResetMode.AutoReset);\n\n    [MTAThread]\n    public static void Main()\n    {\n        // Create an AutoReset EventWaitHandle.\n        //\n        ewh = new EventWaitHandle(false, EventResetMode.AutoReset);\n\n        // Create and start five numbered threads. Use the\n        // ParameterizedThreadStart delegate, so the thread\n        // number can be passed as an argument to the Start \n        // method.\n        for (int i = 0; i &lt;= 4; i++)\n        {\n            Thread t = new Thread(\n                new ParameterizedThreadStart(ThreadProc)\n            );\n            t.Start(i);\n        }\n\n        // Wait until all the threads have started and blocked.\n        // When multiple threads use a 64-bit value on a 32-bit\n        // system, you must access the value through the\n        // Interlocked class to guarantee thread safety.\n        //\n        while (Interlocked.Read(ref threadCount) &lt; 5)\n        {\n            Thread.Sleep(500);\n        }\n\n        // Release one thread each time the user presses ENTER,\n        // until all threads have been released.\n        //\n        while (Interlocked.Read(ref threadCount) &gt; 0)\n        {\n            Console.WriteLine(&quot;Press ENTER to release a waiting thread.&quot;);\n            Console.ReadLine();\n\n            // SignalAndWait signals the EventWaitHandle, which\n            // releases exactly one thread before resetting, \n            // because it was created with AutoReset mode. \n            // SignalAndWait then blocks on clearCount, to \n            // allow the signaled thread to decrement the count\n            // before looping again.\n            //\n            WaitHandle.SignalAndWait(ewh, clearCount);\n        }\n        Console.WriteLine();\n\n        // Create a ManualReset EventWaitHandle.\n        //\n        ewh = new EventWaitHandle(false, EventResetMode.ManualReset);\n\n        // Create and start five more numbered threads.\n        //\n        for(int i=0; i&lt;=4; i++)\n        {\n            Thread t = new Thread(\n                new ParameterizedThreadStart(ThreadProc)\n            );\n            t.Start(i);\n        }\n\n        // Wait until all the threads have started and blocked.\n        //\n        while (Interlocked.Read(ref threadCount) &lt; 5)\n        {\n            Thread.Sleep(500);\n        }\n\n        // Because the EventWaitHandle was created with\n        // ManualReset mode, signaling it releases all the\n        // waiting threads.\n        //\n        Console.WriteLine(&quot;Press ENTER to release the waiting threads.&quot;);\n        Console.ReadLine();\n        ewh.Set();\n        \n    }\n\n    public static void ThreadProc(object data)\n    {\n        int index = (int) data;\n\n        Console.WriteLine(&quot;Thread {0} blocks.&quot;, data);\n        // Increment the count of blocked threads.\n        Interlocked.Increment(ref threadCount);\n\n        // Wait on the EventWaitHandle.\n        ewh.WaitOne();\n\n        Console.WriteLine(&quot;Thread {0} exits.&quot;, data);\n        // Decrement the count of blocked threads.\n        Interlocked.Decrement(ref threadCount);\n\n        // After signaling ewh, the main thread blocks on\n        // clearCount until the signaled thread has \n        // decremented the count. Signal it now.\n        //\n        clearCount.Set();\n    }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_EventWaitHandle__ctor_System_Boolean_System_Threading_EventResetMode_System_String_\">\r\n    \r\n            <a id=\"System_Threading_EventWaitHandle__ctor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">EventWaitHandle(Boolean,EventResetMode,String)</div>        \r\n          </div>\r\n    \r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, and the name of a system synchronization event.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>initialState</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to set the initial state to signaled if the named event is created as a result of this call; <code>false</code> to set it to nonsignaled.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>mode</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">EventResetMode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>One of the <a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">EventResetMode</a> values that determines whether the event resets automatically or manually.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of a system-wide synchronization event.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a></div>\r\n                  </div>\r\n                  <p>A Win32 error occurred.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The named event exists and has access control security, but the user does not have <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">EventWaitHandleRights</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandlecannotbeopenedexception\" data-linktype=\"relative-path\">WaitHandleCannotBeOpenedException</a></div>\r\n                  </div>\r\n                  <p>The named event cannot be created, perhaps because a wait handle of a different type has the same name.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is longer than 260 characters.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If <code>name</code> is <code>null</code> or an empty string, a local <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> is created.  </p>\n<p> If a system event with the name specified for the <code>name</code> parameter already exists, the <code>initialState</code> parameter is ignored.  </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> When using this constructor for named system events, specify <code>false</code> for <code>initialState</code>. This constructor provides no way to determine whether a named system event was created, so you cannot make any assumptions about the state of the named event. To determine whether a named event was created, use the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle__ctor_System_Boolean_System_Threading_EventResetMode_System_String_System_Boolean__\" data-linktype=\"relative-path\">EventWaitHandle(Boolean,EventResetMode,String,Boolean)</a> constructor or the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle__ctor_System_Boolean_System_Threading_EventResetMode_System_String_System_Boolean__System_Security_AccessControl_EventWaitHandleSecurity_\" data-linktype=\"relative-path\">EventWaitHandle(Boolean,EventResetMode,String,Boolean,EventWaitHandleSecurity)</a> constructor.  </p>\n</div>\n<p> If the initial state of the event is nonsignaled, threads that wait on the event will block. If the initial state is signaled, and the <a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">EventResetMode</a> flag is specified for <code>mode</code>, threads that wait on the event will not block. If the initial state is signaled, and <code>mode</code> is <a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">EventResetMode</a>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_EventWaitHandle__ctor_System_Boolean_System_Threading_EventResetMode_System_String_System_Boolean__\">\r\n    \r\n            <a id=\"System_Threading_EventWaitHandle__ctor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">EventWaitHandle(Boolean,EventResetMode,String,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, and a Boolean variable whose value after the call indicates whether the named system event was created.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>initialState</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to set the initial state to signaled if the named event is created as a result of this call; <code>false</code> to set it to nonsignaled.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>mode</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">EventResetMode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>One of the <a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">EventResetMode</a> values that determines whether the event resets automatically or manually.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of a system-wide synchronization event.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>createdNew</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>When this method returns, contains <code>true</code> if a local event was created (that is, if <code>name</code> is <code>null</code> or an empty string) or if the specified named system event was created; <code>false</code> if the specified named system event already existed. This parameter is passed uninitialized.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a></div>\r\n                  </div>\r\n                  <p>A Win32 error occurred.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The named event exists and has access control security, but the user does not have <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">EventWaitHandleRights</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandlecannotbeopenedexception\" data-linktype=\"relative-path\">WaitHandleCannotBeOpenedException</a></div>\r\n                  </div>\r\n                  <p>The named event cannot be created, perhaps because a wait handle of a different type has the same name.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is longer than 260 characters.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If a system event with the name specified for the <code>name</code> parameter already exists, the <code>initialState</code> parameter is ignored. After calling this constructor, use the value in the variable specified for the <code>ref</code> parameter (<code>ByRef</code> parameter in Visual Basic)<code>createdNew</code> to determine whether the named system event already existed or was created.  </p>\n<p> If the initial state of the event is nonsignaled, threads that wait on the event will block. If the initial state is signaled, and the <a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">EventResetMode</a> flag is specified for <code>mode</code>, threads that wait on the event will not block. If the initial state is signaled, and <code>mode</code> is <a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">EventResetMode</a>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_EventWaitHandle__ctor_System_Boolean_System_Threading_EventResetMode_System_String_System_Boolean__System_Security_AccessControl_EventWaitHandleSecurity_\">\r\n    \r\n            <a id=\"System_Threading_EventWaitHandle__ctor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">EventWaitHandle(Boolean,EventResetMode,String,Boolean,EventWaitHandleSecurity)</div>        \r\n          </div>\r\n    \r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> class, specifying whether the wait handle is initially signaled if created as a result of this call, whether it resets automatically or manually, the name of a system synchronization event, a Boolean variable whose value after the call indicates whether the named system event was created, and the access control security to be applied to the named event if it is created.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public EventWaitHandle (bool initialState, System.Threading.EventResetMode mode, string name, out bool createdNew, System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>initialState</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to set the initial state to signaled if the named event is created as a result of this call; <code>false</code> to set it to nonsignaled.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>mode</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">EventResetMode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>One of the <a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">EventResetMode</a> values that determines whether the event resets automatically or manually.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of a system-wide synchronization event.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>createdNew</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>When this method returns, contains <code>true</code> if a local event was created (that is, if <code>name</code> is <code>null</code> or an empty string) or if the specified named system event was created; <code>false</code> if the specified named system event already existed. This parameter is passed uninitialized.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>eventSecurity</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlesecurity\" data-linktype=\"relative-path\">EventWaitHandleSecurity</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlesecurity\" data-linktype=\"relative-path\">EventWaitHandleSecurity</a> object that represents the access control security to be applied to the named system event.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a></div>\r\n                  </div>\r\n                  <p>A Win32 error occurred.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The named event exists and has access control security, but the user does not have <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">EventWaitHandleRights</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandlecannotbeopenedexception\" data-linktype=\"relative-path\">WaitHandleCannotBeOpenedException</a></div>\r\n                  </div>\r\n                  <p>The named event cannot be created, perhaps because a wait handle of a different type has the same name.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is longer than 260 characters.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Use this constructor to apply access control security to a named system event when it is created, preventing other code from taking control of the event.  </p>\n<p> This constructor initializes an <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> object that represents a system event. You can create multiple <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> objects that represent the same system event.  </p>\n<p> If the system event does not exist, it is created with the specified access control security. If the event exists, the specified access control security is ignored.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The caller has full control over the newly created <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> object even if <code>eventSecurity</code> denies or fails to grant some access rights to the current user. However, if the current user attempts to get another <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> object to represent the same named event, using either a constructor or the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_OpenExisting_\" data-linktype=\"relative-path\">OpenExisting</a> method, Windows access control security is applied.  </p>\n</div>\n<p> If a system event with the name specified for the <code>name</code> parameter already exists, the <code>initialState</code> parameter is ignored. After calling this constructor, use the value in the variable specified for the <code>ref</code> parameter (<code>ByRef</code> parameter in Visual Basic) <code>createdNew</code> to determine whether the named system event already existed or was created.  </p>\n<p> If the initial state of the event is nonsignaled, threads that wait on the event will block. If the initial state is signaled, and the <a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">EventResetMode</a> flag is specified for <code>mode</code>, threads that wait on the event will not block. If the initial state is signaled, and <code>mode</code> is <a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">EventResetMode</a>, the first thread that waits on the event will be released immediately, after which the event will reset, and subsequent threads will block.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates the cross-process behavior of a named system event with access control security. The example uses the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a> method overload to test for the existence of a named event.  </p>\n<p> If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.  </p>\n<p> If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a>. The exception is caught, and the example uses the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_OpenExisting_System_String_System_Security_AccessControl_EventWaitHandleRights_\" data-linktype=\"relative-path\">OpenExisting(String,EventWaitHandleRights)</a> method overload to wait on the event with the rights needed to read and change the permissions.  </p>\n<p> After the permissions are changed, the event is opened with the rights required to wait on it and signal it. If you run the compiled example from a third command window, the example runs using the new permissions.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.EventWaitHandle.ctor named 5#1\">using System;\nusing System.Threading;\nusing System.Security.AccessControl;\n\ninternal class Example\n{\n    internal static void Main()\n    {\n        const string ewhName = &quot;EventWaitHandleExample5&quot;;\n\n        EventWaitHandle ewh = null;\n        bool doesNotExist = false;\n        bool unauthorized = false;\n\n        // The value of this variable is set by the event\n        // constructor. It is true if the named system event was\n        // created, and false if the named event already existed.\n        //\n        bool wasCreated;\n\n        // Attempt to open the named event.\n        try\n        {\n            // Open the event with (EventWaitHandleRights.Synchronize\n            // | EventWaitHandleRights.Modify), to wait on and \n            // signal the named event.\n            //\n            ewh = EventWaitHandle.OpenExisting(ewhName);\n        }\n        catch (WaitHandleCannotBeOpenedException)\n        {\n            Console.WriteLine(&quot;Named event does not exist.&quot;);\n            doesNotExist = true;\n        }\n        catch (UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n            unauthorized = true;\n        }\n\n        // There are three cases: (1) The event does not exist.\n        // (2) The event exists, but the current user doesn&#39;t \n        // have access. (3) The event exists and the user has\n        // access.\n        //\n        if (doesNotExist)\n        {\n            // The event does not exist, so create it.\n\n            // Create an access control list (ACL) that denies the\n            // current user the right to wait on or signal the \n            // event, but allows the right to read and change\n            // security information for the event.\n            //\n            string user = Environment.UserDomainName + &quot;\\\\&quot;\n                + Environment.UserName;\n            EventWaitHandleSecurity ewhSec = \n                new EventWaitHandleSecurity();\n\n            EventWaitHandleAccessRule rule = \n                new EventWaitHandleAccessRule(user, \n                    EventWaitHandleRights.Synchronize | \n                    EventWaitHandleRights.Modify, \n                    AccessControlType.Deny);\n            ewhSec.AddAccessRule(rule);\n\n            rule = new EventWaitHandleAccessRule(user, \n                EventWaitHandleRights.ReadPermissions | \n                EventWaitHandleRights.ChangePermissions, \n                AccessControlType.Allow);\n            ewhSec.AddAccessRule(rule);\n\n            // Create an EventWaitHandle object that represents\n            // the system event named by the constant &#39;ewhName&#39;, \n            // initially signaled, with automatic reset, and with\n            // the specified security access. The Boolean value that \n            // indicates creation of the underlying system object\n            // is placed in wasCreated.\n            //\n            ewh = new EventWaitHandle(true, \n                EventResetMode.AutoReset, \n                ewhName, \n                out wasCreated, \n                ewhSec);\n\n            // If the named system event was created, it can be\n            // used by the current instance of this program, even \n            // though the current user is denied access. The current\n            // program owns the event. Otherwise, exit the program.\n            // \n            if (wasCreated)\n            {\n                Console.WriteLine(&quot;Created the named event.&quot;);\n            }\n            else\n            {\n                Console.WriteLine(&quot;Unable to create the event.&quot;);\n                return;\n            }\n        }\n        else if (unauthorized)\n        {\n            // Open the event to read and change the access control\n            // security. The access control security defined above\n            // allows the current user to do this.\n            //\n            try\n            {\n                ewh = EventWaitHandle.OpenExisting(ewhName, \n                    EventWaitHandleRights.ReadPermissions | \n                    EventWaitHandleRights.ChangePermissions);\n\n                // Get the current ACL. This requires \n                // EventWaitHandleRights.ReadPermissions.\n                EventWaitHandleSecurity ewhSec = ewh.GetAccessControl();\n                \n                string user = Environment.UserDomainName + &quot;\\\\&quot;\n                    + Environment.UserName;\n\n                // First, the rule that denied the current user \n                // the right to enter and release the event must\n                // be removed.\n                EventWaitHandleAccessRule rule = \n                    new EventWaitHandleAccessRule(user, \n                        EventWaitHandleRights.Synchronize | \n                        EventWaitHandleRights.Modify, \n                        AccessControlType.Deny);\n                ewhSec.RemoveAccessRule(rule);\n\n                // Now grant the user the correct rights.\n                // \n                rule = new EventWaitHandleAccessRule(user, \n                    EventWaitHandleRights.Synchronize | \n                    EventWaitHandleRights.Modify, \n                    AccessControlType.Allow);\n                ewhSec.AddAccessRule(rule);\n\n                // Update the ACL. This requires\n                // EventWaitHandleRights.ChangePermissions.\n                ewh.SetAccessControl(ewhSec);\n\n                Console.WriteLine(&quot;Updated event security.&quot;);\n\n                // Open the event with (EventWaitHandleRights.Synchronize \n                // | EventWaitHandleRights.Modify), the rights required\n                // to wait on and signal the event.\n                //\n                ewh = EventWaitHandle.OpenExisting(ewhName);\n\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;,\n                    ex.Message);\n                return;\n            }\n\n        }\n\n        // Wait on the event, and hold it until the program\n        // exits.\n        //\n        try\n        {\n            Console.WriteLine(&quot;Wait on the event.&quot;);\n            ewh.WaitOne();\n            Console.WriteLine(&quot;Event was signaled.&quot;);\n            Console.WriteLine(&quot;Press the Enter key to signal the event and exit.&quot;);\n            Console.ReadLine();\n        }\n        catch (UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n        }\n        finally\n        {\n            ewh.Set();\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.EventWaitHandle.ctor named 5#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Security::AccessControl;\nusing namespace System::Security::Permissions;\n\npublic ref class Example\n{\npublic:\n   [SecurityPermissionAttribute(SecurityAction::Demand,Flags=SecurityPermissionFlag::UnmanagedCode)]\n   static void Main()\n   {\n      String^ ewhName = L&quot;EventWaitHandleExample5&quot;;\n\n      EventWaitHandle^ ewh = nullptr;\n      bool doesNotExist = false;\n      bool unauthorized = false;\n      \n      // The value of this variable is set by the event\n      // constructor. It is true if the named system event was\n      // created, and false if the named event already existed.\n      //\n      bool wasCreated;\n      \n      // Attempt to open the named event.\n      try\n      {\n         // Open the event with (EventWaitHandleRights.Synchronize\n         // | EventWaitHandleRights.Modify), to wait on and\n         // signal the named event.\n         //\n         ewh = EventWaitHandle::OpenExisting( ewhName );\n      }\n      catch ( WaitHandleCannotBeOpenedException^ ) \n      {\n         Console::WriteLine( L&quot;Named event does not exist.&quot; );\n         doesNotExist = true;\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n         unauthorized = true;\n      }\n\n      // There are three cases: (1) The event does not exist.\n      // (2) The event exists, but the current user doesn&#39;t\n      // have access. (3) The event exists and the user has\n      // access.\n      //\n      if ( doesNotExist )\n      {\n         // The event does not exist, so create it.\n\n         // Create an access control list (ACL) that denies the\n         // current user the right to wait on or signal the\n         // event, but allows the right to read and change\n         // security information for the event.\n         //\n         String^ user = String::Concat( Environment::UserDomainName, L&quot;\\\\&quot;,\n            Environment::UserName );\n         EventWaitHandleSecurity^ ewhSec = gcnew EventWaitHandleSecurity;\n         //following constructor fails\n         EventWaitHandleAccessRule^ rule = gcnew EventWaitHandleAccessRule(\n            user,\n            static_cast&lt;EventWaitHandleRights&gt;(\n               EventWaitHandleRights::Synchronize | \n               EventWaitHandleRights::Modify),\n            AccessControlType::Deny );\n         ewhSec-&gt;AddAccessRule( rule );\n\n         rule = gcnew EventWaitHandleAccessRule( user,\n            static_cast&lt;EventWaitHandleRights&gt;(\n               EventWaitHandleRights::ReadPermissions | \n               EventWaitHandleRights::ChangePermissions),\n            AccessControlType::Allow );\n         ewhSec-&gt;AddAccessRule( rule );\n         \n         // Create an EventWaitHandle object that represents\n         // the system event named by the constant &#39;ewhName&#39;,\n         // initially signaled, with automatic reset, and with\n         // the specified security access. The Boolean value that\n         // indicates creation of the underlying system object\n         // is placed in wasCreated.\n         //\n         ewh = gcnew EventWaitHandle( true,\n            EventResetMode::AutoReset,\n            ewhName,\n            wasCreated,\n            ewhSec );\n         \n         // If the named system event was created, it can be\n         // used by the current instance of this program, even\n         // though the current user is denied access. The current\n         // program owns the event. Otherwise, exit the program.\n         //\n         if ( wasCreated )\n         {\n            Console::WriteLine( L&quot;Created the named event.&quot; );\n         }\n         else\n         {\n            Console::WriteLine( L&quot;Unable to create the event.&quot; );\n            return;\n         }\n      }\n      else if ( unauthorized )\n      {\n         // Open the event to read and change the access control\n         // security. The access control security defined above\n         // allows the current user to do this.\n         //\n         try\n         {\n            ewh = EventWaitHandle::OpenExisting( ewhName, \n               static_cast&lt;EventWaitHandleRights&gt;(\n                  EventWaitHandleRights::ReadPermissions |\n                  EventWaitHandleRights::ChangePermissions) );\n            \n            // Get the current ACL. This requires\n            // EventWaitHandleRights.ReadPermissions.\n            EventWaitHandleSecurity^ ewhSec = ewh-&gt;GetAccessControl();\n            String^ user = String::Concat( Environment::UserDomainName, L&quot;\\\\&quot;,\n               Environment::UserName );\n            \n            // First, the rule that denied the current user\n            // the right to enter and release the event must\n            // be removed.\n            EventWaitHandleAccessRule^ rule = gcnew EventWaitHandleAccessRule(\n               user,\n               static_cast&lt;EventWaitHandleRights&gt;(\n                  EventWaitHandleRights::Synchronize |\n                  EventWaitHandleRights::Modify),\n               AccessControlType::Deny );\n            ewhSec-&gt;RemoveAccessRule( rule );\n            \n            // Now grant the user the correct rights.\n            //\n            rule = gcnew EventWaitHandleAccessRule( user,\n               static_cast&lt;EventWaitHandleRights&gt;(\n                  EventWaitHandleRights::Synchronize |\n                  EventWaitHandleRights::Modify),\n               AccessControlType::Allow );\n            ewhSec-&gt;AddAccessRule( rule );\n            \n            // Update the ACL. This requires\n            // EventWaitHandleRights.ChangePermissions.\n            ewh-&gt;SetAccessControl( ewhSec );\n            Console::WriteLine( L&quot;Updated event security.&quot; );\n            \n            // Open the event with (EventWaitHandleRights.Synchronize\n            // | EventWaitHandleRights.Modify), the rights required\n            // to wait on and signal the event.\n            //\n            ewh = EventWaitHandle::OpenExisting( ewhName );\n         }\n         catch ( UnauthorizedAccessException^ ex ) \n         {\n            Console::WriteLine( L&quot;Unable to change permissions: {0}&quot;,\n               ex-&gt;Message );\n            return;\n         }\n\n      }\n      \n      // Wait on the event, and hold it until the program\n      // exits.\n      //\n      try\n      {\n         Console::WriteLine( L&quot;Wait on the event.&quot; );\n         ewh-&gt;WaitOne();\n         Console::WriteLine( L&quot;Event was signaled.&quot; );\n         Console::WriteLine( L&quot;Press the Enter key to signal the event and exit.&quot; );\n         Console::ReadLine();\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n      }\n      finally\n      {\n         ewh-&gt;Set();\n      }\n   }\n};\n\nint main()\n{\n   Example::Main();\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.EventWaitHandle.ctor named 5#1\">Imports System\nImports System.Threading\nImports System.Security.AccessControl\n\nFriend Class Example\n\n    &lt;MTAThread&gt; _\n    Friend Shared Sub Main()\n        Const ewhName As String = &quot;EventWaitHandleExample5&quot;\n\n        Dim ewh As EventWaitHandle = Nothing\n        Dim doesNotExist as Boolean = False\n        Dim unauthorized As Boolean = False\n\n        &#39; The value of this variable is set by the event\n        &#39; constructor. It is True if the named system event was\n        &#39; created, and False if the named event already existed.\n        &#39;\n        Dim wasCreated As Boolean\n\n        &#39; Attempt to open the named event.\n        Try\n            &#39; Open the event with (EventWaitHandleRights.Synchronize\n            &#39; Or EventWaitHandleRights.Modify), to wait on and \n            &#39; signal the named event.\n            &#39;\n            ewh = EventWaitHandle.OpenExisting(ewhName)\n        Catch ex As WaitHandleCannotBeOpenedException\n            Console.WriteLine(&quot;Named event does not exist.&quot;)\n            doesNotExist = True\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message)\n            unauthorized = True\n        End Try\n\n        &#39; There are three cases: (1) The event does not exist.\n        &#39; (2) The event exists, but the current user doesn&#39;t \n        &#39; have access. (3) The event exists and the user has\n        &#39; access.\n        &#39;\n        If doesNotExist Then\n            &#39; The event does not exist, so create it.\n\n            &#39; Create an access control list (ACL) that denies the\n            &#39; current user the right to wait on or signal the \n            &#39; event, but allows the right to read and change\n            &#39; security information for the event.\n            &#39;\n            Dim user As String = Environment.UserDomainName _ \n                &amp; &quot;\\&quot; &amp; Environment.UserName\n            Dim ewhSec As New EventWaitHandleSecurity()\n\n            Dim rule As New EventWaitHandleAccessRule(user, _\n                EventWaitHandleRights.Synchronize Or _\n                EventWaitHandleRights.Modify, _\n                AccessControlType.Deny)\n            ewhSec.AddAccessRule(rule)\n\n            rule = New EventWaitHandleAccessRule(user, _\n                EventWaitHandleRights.ReadPermissions Or _\n                EventWaitHandleRights.ChangePermissions, _\n                AccessControlType.Allow)\n            ewhSec.AddAccessRule(rule)\n\n            &#39; Create an EventWaitHandle object that represents\n            &#39; the system event named by the constant &#39;ewhName&#39;, \n            &#39; initially signaled, with automatic reset, and with\n            &#39; the specified security access. The Boolean value that \n            &#39; indicates creation of the underlying system object\n            &#39; is placed in wasCreated.\n            &#39;\n            ewh = New EventWaitHandle(True, _\n                EventResetMode.AutoReset, ewhName, _\n                wasCreated, ewhSec)\n\n            &#39; If the named system event was created, it can be\n            &#39; used by the current instance of this program, even \n            &#39; though the current user is denied access. The current\n            &#39; program owns the event. Otherwise, exit the program.\n            &#39; \n            If wasCreated Then\n                Console.WriteLine(&quot;Created the named event.&quot;)\n            Else\n                Console.WriteLine(&quot;Unable to create the event.&quot;)\n                Return\n            End If\n\n        ElseIf unauthorized Then\n\n            &#39; Open the event to read and change the access control\n            &#39; security. The access control security defined above\n            &#39; allows the current user to do this.\n            &#39;\n            Try\n                ewh = EventWaitHandle.OpenExisting(ewhName, _\n                    EventWaitHandleRights.ReadPermissions Or _\n                    EventWaitHandleRights.ChangePermissions)\n\n                &#39; Get the current ACL. This requires \n                &#39; EventWaitHandleRights.ReadPermissions.\n                Dim ewhSec As EventWaitHandleSecurity = _\n                    ewh.GetAccessControl()\n                \n                Dim user As String = Environment.UserDomainName _ \n                    &amp; &quot;\\&quot; &amp; Environment.UserName\n\n                &#39; First, the rule that denied the current user \n                &#39; the right to enter and release the event must\n                &#39; be removed.\n                Dim rule As New EventWaitHandleAccessRule(user, _\n                    EventWaitHandleRights.Synchronize Or _\n                    EventWaitHandleRights.Modify, _\n                    AccessControlType.Deny)\n                ewhSec.RemoveAccessRule(rule)\n\n                &#39; Now grant the user the correct rights.\n                &#39; \n                rule = New EventWaitHandleAccessRule(user, _\n                    EventWaitHandleRights.Synchronize Or _\n                    EventWaitHandleRights.Modify, _\n                    AccessControlType.Allow)\n                ewhSec.AddAccessRule(rule)\n\n                &#39; Update the ACL. This requires\n                &#39; EventWaitHandleRights.ChangePermissions.\n                ewh.SetAccessControl(ewhSec)\n\n                Console.WriteLine(&quot;Updated event security.&quot;)\n\n                &#39; Open the event with (EventWaitHandleRights.Synchronize \n                &#39; Or EventWaitHandleRights.Modify), the rights required\n                &#39; to wait on and signal the event.\n                &#39;\n                ewh = EventWaitHandle.OpenExisting(ewhName)\n\n            Catch ex As UnauthorizedAccessException\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;, _\n                    ex.Message)\n                Return\n            End Try\n\n        End If\n\n        &#39; Wait on the event, and hold it until the program\n        &#39; exits.\n        &#39;\n        Try\n            Console.WriteLine(&quot;Wait on the event.&quot;)\n            ewh.WaitOne()\n            Console.WriteLine(&quot;Event was signaled.&quot;)\n            Console.WriteLine(&quot;Press the Enter key to signal the event and exit.&quot;)\n            Console.ReadLine()\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, _\n                ex.Message)\n        Finally\n            ewh.Set()\n        End Try\n    End Sub \nEnd Class \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"methods\">\r\n        <h2>Methods\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_EventWaitHandle_GetAccessControl\">\r\n    \r\n            <a id=\"System_Threading_EventWaitHandle_GetAccessControl_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetAccessControl()</div>        \r\n          </div>\r\n    \r\n            <p>Gets an <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlesecurity\" data-linktype=\"relative-path\">EventWaitHandleSecurity</a> object that represents the access control security for the named system event represented by the current <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> object.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Security.AccessControl.EventWaitHandleSecurity GetAccessControl ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlesecurity\" data-linktype=\"relative-path\">EventWaitHandleSecurity</a></div>\r\n                  </div>\r\n                  <p>An <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlesecurity\" data-linktype=\"relative-path\">EventWaitHandleSecurity</a> object that represents the access control security for the named system event.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The current <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> object represents a named system event, and the user does not have <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">EventWaitHandleRights</a>.  </p>\n<p> -or-  </p>\n<p> The current <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> object represents a named system event, and was not opened with <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">EventWaitHandleRights</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>Not supported for Windows 98 or Windows Millennium Edition.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.objectdisposedexception\" data-linktype=\"relative-path\">ObjectDisposedException</a></div>\r\n                  </div>\r\n                  <p>The <span class=\"xref\">stem.Threading.WaitHandle.Close*</span> method was previously called on this <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The GetAccessControl method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <a class=\"xref\" href=\"system.security.accesscontrol.accesscontrolsections\" data-linktype=\"relative-path\">System.Security.AccessControl.AccessControlSections</a>, <a class=\"xref\" href=\"system.security.accesscontrol.accesscontrolsections\" data-linktype=\"relative-path\">System.Security.AccessControl.AccessControlSections</a>, and <a class=\"xref\" href=\"system.security.accesscontrol.accesscontrolsections\" data-linktype=\"relative-path\">System.Security.AccessControl.AccessControlSections</a>.  </p>\n<p> The user must have <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">System.Security.AccessControl.EventWaitHandleRights</a> rights to call this method, and the event must have been opened with the <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">System.Security.AccessControl.EventWaitHandleRights</a> flag.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates the cross-process behavior of a named system event with access control security. The example uses the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a> method overload to test for the existence of a named event.  </p>\n<p> If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.  </p>\n<p> If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a>. The exception is caught, and the example uses the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_OpenExisting_System_String_System_Security_AccessControl_EventWaitHandleRights_\" data-linktype=\"relative-path\">OpenExisting(String,EventWaitHandleRights)</a> method overload to wait on the event with the rights needed to read and change the permissions.  </p>\n<p> After the permissions have been read, using the GetAccessControl method, and changed, the event is opened with the rights required to wait on it and signal it. If you run the compiled example from a third command window, the example runs using the new permissions.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.EventWaitHandle.ctor named 5#1\">using System;\nusing System.Threading;\nusing System.Security.AccessControl;\n\ninternal class Example\n{\n    internal static void Main()\n    {\n        const string ewhName = &quot;EventWaitHandleExample5&quot;;\n\n        EventWaitHandle ewh = null;\n        bool doesNotExist = false;\n        bool unauthorized = false;\n\n        // The value of this variable is set by the event\n        // constructor. It is true if the named system event was\n        // created, and false if the named event already existed.\n        //\n        bool wasCreated;\n\n        // Attempt to open the named event.\n        try\n        {\n            // Open the event with (EventWaitHandleRights.Synchronize\n            // | EventWaitHandleRights.Modify), to wait on and \n            // signal the named event.\n            //\n            ewh = EventWaitHandle.OpenExisting(ewhName);\n        }\n        catch (WaitHandleCannotBeOpenedException)\n        {\n            Console.WriteLine(&quot;Named event does not exist.&quot;);\n            doesNotExist = true;\n        }\n        catch (UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n            unauthorized = true;\n        }\n\n        // There are three cases: (1) The event does not exist.\n        // (2) The event exists, but the current user doesn&#39;t \n        // have access. (3) The event exists and the user has\n        // access.\n        //\n        if (doesNotExist)\n        {\n            // The event does not exist, so create it.\n\n            // Create an access control list (ACL) that denies the\n            // current user the right to wait on or signal the \n            // event, but allows the right to read and change\n            // security information for the event.\n            //\n            string user = Environment.UserDomainName + &quot;\\\\&quot;\n                + Environment.UserName;\n            EventWaitHandleSecurity ewhSec = \n                new EventWaitHandleSecurity();\n\n            EventWaitHandleAccessRule rule = \n                new EventWaitHandleAccessRule(user, \n                    EventWaitHandleRights.Synchronize | \n                    EventWaitHandleRights.Modify, \n                    AccessControlType.Deny);\n            ewhSec.AddAccessRule(rule);\n\n            rule = new EventWaitHandleAccessRule(user, \n                EventWaitHandleRights.ReadPermissions | \n                EventWaitHandleRights.ChangePermissions, \n                AccessControlType.Allow);\n            ewhSec.AddAccessRule(rule);\n\n            // Create an EventWaitHandle object that represents\n            // the system event named by the constant &#39;ewhName&#39;, \n            // initially signaled, with automatic reset, and with\n            // the specified security access. The Boolean value that \n            // indicates creation of the underlying system object\n            // is placed in wasCreated.\n            //\n            ewh = new EventWaitHandle(true, \n                EventResetMode.AutoReset, \n                ewhName, \n                out wasCreated, \n                ewhSec);\n\n            // If the named system event was created, it can be\n            // used by the current instance of this program, even \n            // though the current user is denied access. The current\n            // program owns the event. Otherwise, exit the program.\n            // \n            if (wasCreated)\n            {\n                Console.WriteLine(&quot;Created the named event.&quot;);\n            }\n            else\n            {\n                Console.WriteLine(&quot;Unable to create the event.&quot;);\n                return;\n            }\n        }\n        else if (unauthorized)\n        {\n            // Open the event to read and change the access control\n            // security. The access control security defined above\n            // allows the current user to do this.\n            //\n            try\n            {\n                ewh = EventWaitHandle.OpenExisting(ewhName, \n                    EventWaitHandleRights.ReadPermissions | \n                    EventWaitHandleRights.ChangePermissions);\n\n                // Get the current ACL. This requires \n                // EventWaitHandleRights.ReadPermissions.\n                EventWaitHandleSecurity ewhSec = ewh.GetAccessControl();\n                \n                string user = Environment.UserDomainName + &quot;\\\\&quot;\n                    + Environment.UserName;\n\n                // First, the rule that denied the current user \n                // the right to enter and release the event must\n                // be removed.\n                EventWaitHandleAccessRule rule = \n                    new EventWaitHandleAccessRule(user, \n                        EventWaitHandleRights.Synchronize | \n                        EventWaitHandleRights.Modify, \n                        AccessControlType.Deny);\n                ewhSec.RemoveAccessRule(rule);\n\n                // Now grant the user the correct rights.\n                // \n                rule = new EventWaitHandleAccessRule(user, \n                    EventWaitHandleRights.Synchronize | \n                    EventWaitHandleRights.Modify, \n                    AccessControlType.Allow);\n                ewhSec.AddAccessRule(rule);\n\n                // Update the ACL. This requires\n                // EventWaitHandleRights.ChangePermissions.\n                ewh.SetAccessControl(ewhSec);\n\n                Console.WriteLine(&quot;Updated event security.&quot;);\n\n                // Open the event with (EventWaitHandleRights.Synchronize \n                // | EventWaitHandleRights.Modify), the rights required\n                // to wait on and signal the event.\n                //\n                ewh = EventWaitHandle.OpenExisting(ewhName);\n\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;,\n                    ex.Message);\n                return;\n            }\n\n        }\n\n        // Wait on the event, and hold it until the program\n        // exits.\n        //\n        try\n        {\n            Console.WriteLine(&quot;Wait on the event.&quot;);\n            ewh.WaitOne();\n            Console.WriteLine(&quot;Event was signaled.&quot;);\n            Console.WriteLine(&quot;Press the Enter key to signal the event and exit.&quot;);\n            Console.ReadLine();\n        }\n        catch (UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n        }\n        finally\n        {\n            ewh.Set();\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.EventWaitHandle.ctor named 5#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Security::AccessControl;\nusing namespace System::Security::Permissions;\n\npublic ref class Example\n{\npublic:\n   [SecurityPermissionAttribute(SecurityAction::Demand,Flags=SecurityPermissionFlag::UnmanagedCode)]\n   static void Main()\n   {\n      String^ ewhName = L&quot;EventWaitHandleExample5&quot;;\n\n      EventWaitHandle^ ewh = nullptr;\n      bool doesNotExist = false;\n      bool unauthorized = false;\n      \n      // The value of this variable is set by the event\n      // constructor. It is true if the named system event was\n      // created, and false if the named event already existed.\n      //\n      bool wasCreated;\n      \n      // Attempt to open the named event.\n      try\n      {\n         // Open the event with (EventWaitHandleRights.Synchronize\n         // | EventWaitHandleRights.Modify), to wait on and\n         // signal the named event.\n         //\n         ewh = EventWaitHandle::OpenExisting( ewhName );\n      }\n      catch ( WaitHandleCannotBeOpenedException^ ) \n      {\n         Console::WriteLine( L&quot;Named event does not exist.&quot; );\n         doesNotExist = true;\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n         unauthorized = true;\n      }\n\n      // There are three cases: (1) The event does not exist.\n      // (2) The event exists, but the current user doesn&#39;t\n      // have access. (3) The event exists and the user has\n      // access.\n      //\n      if ( doesNotExist )\n      {\n         // The event does not exist, so create it.\n\n         // Create an access control list (ACL) that denies the\n         // current user the right to wait on or signal the\n         // event, but allows the right to read and change\n         // security information for the event.\n         //\n         String^ user = String::Concat( Environment::UserDomainName, L&quot;\\\\&quot;,\n            Environment::UserName );\n         EventWaitHandleSecurity^ ewhSec = gcnew EventWaitHandleSecurity;\n         //following constructor fails\n         EventWaitHandleAccessRule^ rule = gcnew EventWaitHandleAccessRule(\n            user,\n            static_cast&lt;EventWaitHandleRights&gt;(\n               EventWaitHandleRights::Synchronize | \n               EventWaitHandleRights::Modify),\n            AccessControlType::Deny );\n         ewhSec-&gt;AddAccessRule( rule );\n\n         rule = gcnew EventWaitHandleAccessRule( user,\n            static_cast&lt;EventWaitHandleRights&gt;(\n               EventWaitHandleRights::ReadPermissions | \n               EventWaitHandleRights::ChangePermissions),\n            AccessControlType::Allow );\n         ewhSec-&gt;AddAccessRule( rule );\n         \n         // Create an EventWaitHandle object that represents\n         // the system event named by the constant &#39;ewhName&#39;,\n         // initially signaled, with automatic reset, and with\n         // the specified security access. The Boolean value that\n         // indicates creation of the underlying system object\n         // is placed in wasCreated.\n         //\n         ewh = gcnew EventWaitHandle( true,\n            EventResetMode::AutoReset,\n            ewhName,\n            wasCreated,\n            ewhSec );\n         \n         // If the named system event was created, it can be\n         // used by the current instance of this program, even\n         // though the current user is denied access. The current\n         // program owns the event. Otherwise, exit the program.\n         //\n         if ( wasCreated )\n         {\n            Console::WriteLine( L&quot;Created the named event.&quot; );\n         }\n         else\n         {\n            Console::WriteLine( L&quot;Unable to create the event.&quot; );\n            return;\n         }\n      }\n      else if ( unauthorized )\n      {\n         // Open the event to read and change the access control\n         // security. The access control security defined above\n         // allows the current user to do this.\n         //\n         try\n         {\n            ewh = EventWaitHandle::OpenExisting( ewhName, \n               static_cast&lt;EventWaitHandleRights&gt;(\n                  EventWaitHandleRights::ReadPermissions |\n                  EventWaitHandleRights::ChangePermissions) );\n            \n            // Get the current ACL. This requires\n            // EventWaitHandleRights.ReadPermissions.\n            EventWaitHandleSecurity^ ewhSec = ewh-&gt;GetAccessControl();\n            String^ user = String::Concat( Environment::UserDomainName, L&quot;\\\\&quot;,\n               Environment::UserName );\n            \n            // First, the rule that denied the current user\n            // the right to enter and release the event must\n            // be removed.\n            EventWaitHandleAccessRule^ rule = gcnew EventWaitHandleAccessRule(\n               user,\n               static_cast&lt;EventWaitHandleRights&gt;(\n                  EventWaitHandleRights::Synchronize |\n                  EventWaitHandleRights::Modify),\n               AccessControlType::Deny );\n            ewhSec-&gt;RemoveAccessRule( rule );\n            \n            // Now grant the user the correct rights.\n            //\n            rule = gcnew EventWaitHandleAccessRule( user,\n               static_cast&lt;EventWaitHandleRights&gt;(\n                  EventWaitHandleRights::Synchronize |\n                  EventWaitHandleRights::Modify),\n               AccessControlType::Allow );\n            ewhSec-&gt;AddAccessRule( rule );\n            \n            // Update the ACL. This requires\n            // EventWaitHandleRights.ChangePermissions.\n            ewh-&gt;SetAccessControl( ewhSec );\n            Console::WriteLine( L&quot;Updated event security.&quot; );\n            \n            // Open the event with (EventWaitHandleRights.Synchronize\n            // | EventWaitHandleRights.Modify), the rights required\n            // to wait on and signal the event.\n            //\n            ewh = EventWaitHandle::OpenExisting( ewhName );\n         }\n         catch ( UnauthorizedAccessException^ ex ) \n         {\n            Console::WriteLine( L&quot;Unable to change permissions: {0}&quot;,\n               ex-&gt;Message );\n            return;\n         }\n\n      }\n      \n      // Wait on the event, and hold it until the program\n      // exits.\n      //\n      try\n      {\n         Console::WriteLine( L&quot;Wait on the event.&quot; );\n         ewh-&gt;WaitOne();\n         Console::WriteLine( L&quot;Event was signaled.&quot; );\n         Console::WriteLine( L&quot;Press the Enter key to signal the event and exit.&quot; );\n         Console::ReadLine();\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n      }\n      finally\n      {\n         ewh-&gt;Set();\n      }\n   }\n};\n\nint main()\n{\n   Example::Main();\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.EventWaitHandle.ctor named 5#1\">Imports System\nImports System.Threading\nImports System.Security.AccessControl\n\nFriend Class Example\n\n    &lt;MTAThread&gt; _\n    Friend Shared Sub Main()\n        Const ewhName As String = &quot;EventWaitHandleExample5&quot;\n\n        Dim ewh As EventWaitHandle = Nothing\n        Dim doesNotExist as Boolean = False\n        Dim unauthorized As Boolean = False\n\n        &#39; The value of this variable is set by the event\n        &#39; constructor. It is True if the named system event was\n        &#39; created, and False if the named event already existed.\n        &#39;\n        Dim wasCreated As Boolean\n\n        &#39; Attempt to open the named event.\n        Try\n            &#39; Open the event with (EventWaitHandleRights.Synchronize\n            &#39; Or EventWaitHandleRights.Modify), to wait on and \n            &#39; signal the named event.\n            &#39;\n            ewh = EventWaitHandle.OpenExisting(ewhName)\n        Catch ex As WaitHandleCannotBeOpenedException\n            Console.WriteLine(&quot;Named event does not exist.&quot;)\n            doesNotExist = True\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message)\n            unauthorized = True\n        End Try\n\n        &#39; There are three cases: (1) The event does not exist.\n        &#39; (2) The event exists, but the current user doesn&#39;t \n        &#39; have access. (3) The event exists and the user has\n        &#39; access.\n        &#39;\n        If doesNotExist Then\n            &#39; The event does not exist, so create it.\n\n            &#39; Create an access control list (ACL) that denies the\n            &#39; current user the right to wait on or signal the \n            &#39; event, but allows the right to read and change\n            &#39; security information for the event.\n            &#39;\n            Dim user As String = Environment.UserDomainName _ \n                &amp; &quot;\\&quot; &amp; Environment.UserName\n            Dim ewhSec As New EventWaitHandleSecurity()\n\n            Dim rule As New EventWaitHandleAccessRule(user, _\n                EventWaitHandleRights.Synchronize Or _\n                EventWaitHandleRights.Modify, _\n                AccessControlType.Deny)\n            ewhSec.AddAccessRule(rule)\n\n            rule = New EventWaitHandleAccessRule(user, _\n                EventWaitHandleRights.ReadPermissions Or _\n                EventWaitHandleRights.ChangePermissions, _\n                AccessControlType.Allow)\n            ewhSec.AddAccessRule(rule)\n\n            &#39; Create an EventWaitHandle object that represents\n            &#39; the system event named by the constant &#39;ewhName&#39;, \n            &#39; initially signaled, with automatic reset, and with\n            &#39; the specified security access. The Boolean value that \n            &#39; indicates creation of the underlying system object\n            &#39; is placed in wasCreated.\n            &#39;\n            ewh = New EventWaitHandle(True, _\n                EventResetMode.AutoReset, ewhName, _\n                wasCreated, ewhSec)\n\n            &#39; If the named system event was created, it can be\n            &#39; used by the current instance of this program, even \n            &#39; though the current user is denied access. The current\n            &#39; program owns the event. Otherwise, exit the program.\n            &#39; \n            If wasCreated Then\n                Console.WriteLine(&quot;Created the named event.&quot;)\n            Else\n                Console.WriteLine(&quot;Unable to create the event.&quot;)\n                Return\n            End If\n\n        ElseIf unauthorized Then\n\n            &#39; Open the event to read and change the access control\n            &#39; security. The access control security defined above\n            &#39; allows the current user to do this.\n            &#39;\n            Try\n                ewh = EventWaitHandle.OpenExisting(ewhName, _\n                    EventWaitHandleRights.ReadPermissions Or _\n                    EventWaitHandleRights.ChangePermissions)\n\n                &#39; Get the current ACL. This requires \n                &#39; EventWaitHandleRights.ReadPermissions.\n                Dim ewhSec As EventWaitHandleSecurity = _\n                    ewh.GetAccessControl()\n                \n                Dim user As String = Environment.UserDomainName _ \n                    &amp; &quot;\\&quot; &amp; Environment.UserName\n\n                &#39; First, the rule that denied the current user \n                &#39; the right to enter and release the event must\n                &#39; be removed.\n                Dim rule As New EventWaitHandleAccessRule(user, _\n                    EventWaitHandleRights.Synchronize Or _\n                    EventWaitHandleRights.Modify, _\n                    AccessControlType.Deny)\n                ewhSec.RemoveAccessRule(rule)\n\n                &#39; Now grant the user the correct rights.\n                &#39; \n                rule = New EventWaitHandleAccessRule(user, _\n                    EventWaitHandleRights.Synchronize Or _\n                    EventWaitHandleRights.Modify, _\n                    AccessControlType.Allow)\n                ewhSec.AddAccessRule(rule)\n\n                &#39; Update the ACL. This requires\n                &#39; EventWaitHandleRights.ChangePermissions.\n                ewh.SetAccessControl(ewhSec)\n\n                Console.WriteLine(&quot;Updated event security.&quot;)\n\n                &#39; Open the event with (EventWaitHandleRights.Synchronize \n                &#39; Or EventWaitHandleRights.Modify), the rights required\n                &#39; to wait on and signal the event.\n                &#39;\n                ewh = EventWaitHandle.OpenExisting(ewhName)\n\n            Catch ex As UnauthorizedAccessException\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;, _\n                    ex.Message)\n                Return\n            End Try\n\n        End If\n\n        &#39; Wait on the event, and hold it until the program\n        &#39; exits.\n        &#39;\n        Try\n            Console.WriteLine(&quot;Wait on the event.&quot;)\n            ewh.WaitOne()\n            Console.WriteLine(&quot;Event was signaled.&quot;)\n            Console.WriteLine(&quot;Press the Enter key to signal the event and exit.&quot;)\n            Console.ReadLine()\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, _\n                ex.Message)\n        Finally\n            ewh.Set()\n        End Try\n    End Sub \nEnd Class \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_EventWaitHandle_OpenExisting_System_String_\">\r\n    \r\n            <a id=\"System_Threading_EventWaitHandle_OpenExisting_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">OpenExisting(String)</div>        \r\n          </div>\r\n    \r\n            <p>Opens the specified named synchronization event, if it already exists.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Threading.EventWaitHandle OpenExisting (string name);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of the system synchronization event to open.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a></div>\r\n                  </div>\r\n                  <p>An  object that represents the named system event.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is an empty string.  </p>\n<p> -or-  </p>\n<p> <code>name</code> is longer than 260 characters.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandlecannotbeopenedexception\" data-linktype=\"relative-path\">WaitHandleCannotBeOpenedException</a></div>\r\n                  </div>\r\n                  <p>The named system event does not exist.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a></div>\r\n                  </div>\r\n                  <p>A Win32 error occurred.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The named event exists, but the user does not have the security access required to use it.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_OpenExisting_\" data-linktype=\"relative-path\">OpenExisting</a> method tries to open the specified named system event. If the system event does not exist, this method throws an exception instead of creating the system event. To create the system event when it does not already exist, use one of the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle__ctor_\" data-linktype=\"relative-path\">EventWaitHandle</a> constructors that has a <code>name</code> parameter.  </p>\n<p> Multiple calls to this method that use the same value for <code>name</code> do not necessarily return the same <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> object, even though the objects that are returned represent the same named system event.  </p>\n<p> This method overload is equivalent to calling the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_OpenExisting_System_String_System_Security_AccessControl_EventWaitHandleRights_\" data-linktype=\"relative-path\">OpenExisting(String,EventWaitHandleRights)</a> method overload and specifying <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">System.Security.AccessControl.EventWaitHandleRights</a> and <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">System.Security.AccessControl.EventWaitHandleRights</a> rights, combined by using the bitwise OR operation.  </p>\n<p> Specifying the <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">System.Security.AccessControl.EventWaitHandleRights</a> flag allows a thread to wait on the named system event, and specifying the <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">System.Security.AccessControl.EventWaitHandleRights</a> flag allows a thread to call the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_Set_\" data-linktype=\"relative-path\">Set</a> and <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_Reset_\" data-linktype=\"relative-path\">Reset</a> methods.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates the cross-process behavior of a named system event with access control security. The example uses the OpenExisting method overload to test for the existence of a named event.  </p>\n<p> If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.  </p>\n<p> If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to OpenExisting. The exception is caught, and the example uses the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_OpenExisting_System_String_System_Security_AccessControl_EventWaitHandleRights_\" data-linktype=\"relative-path\">OpenExisting(String,EventWaitHandleRights)</a> method overload to wait on the event with the rights needed to read and change the permissions.  </p>\n<p> After the permissions are changed, the event is opened with the rights required to wait on it and signal it. If you run the compiled example from a third command window, the example runs using the new permissions.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.EventWaitHandle.ctor named 5#1\">using System;\nusing System.Threading;\nusing System.Security.AccessControl;\n\ninternal class Example\n{\n    internal static void Main()\n    {\n        const string ewhName = &quot;EventWaitHandleExample5&quot;;\n\n        EventWaitHandle ewh = null;\n        bool doesNotExist = false;\n        bool unauthorized = false;\n\n        // The value of this variable is set by the event\n        // constructor. It is true if the named system event was\n        // created, and false if the named event already existed.\n        //\n        bool wasCreated;\n\n        // Attempt to open the named event.\n        try\n        {\n            // Open the event with (EventWaitHandleRights.Synchronize\n            // | EventWaitHandleRights.Modify), to wait on and \n            // signal the named event.\n            //\n            ewh = EventWaitHandle.OpenExisting(ewhName);\n        }\n        catch (WaitHandleCannotBeOpenedException)\n        {\n            Console.WriteLine(&quot;Named event does not exist.&quot;);\n            doesNotExist = true;\n        }\n        catch (UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n            unauthorized = true;\n        }\n\n        // There are three cases: (1) The event does not exist.\n        // (2) The event exists, but the current user doesn&#39;t \n        // have access. (3) The event exists and the user has\n        // access.\n        //\n        if (doesNotExist)\n        {\n            // The event does not exist, so create it.\n\n            // Create an access control list (ACL) that denies the\n            // current user the right to wait on or signal the \n            // event, but allows the right to read and change\n            // security information for the event.\n            //\n            string user = Environment.UserDomainName + &quot;\\\\&quot;\n                + Environment.UserName;\n            EventWaitHandleSecurity ewhSec = \n                new EventWaitHandleSecurity();\n\n            EventWaitHandleAccessRule rule = \n                new EventWaitHandleAccessRule(user, \n                    EventWaitHandleRights.Synchronize | \n                    EventWaitHandleRights.Modify, \n                    AccessControlType.Deny);\n            ewhSec.AddAccessRule(rule);\n\n            rule = new EventWaitHandleAccessRule(user, \n                EventWaitHandleRights.ReadPermissions | \n                EventWaitHandleRights.ChangePermissions, \n                AccessControlType.Allow);\n            ewhSec.AddAccessRule(rule);\n\n            // Create an EventWaitHandle object that represents\n            // the system event named by the constant &#39;ewhName&#39;, \n            // initially signaled, with automatic reset, and with\n            // the specified security access. The Boolean value that \n            // indicates creation of the underlying system object\n            // is placed in wasCreated.\n            //\n            ewh = new EventWaitHandle(true, \n                EventResetMode.AutoReset, \n                ewhName, \n                out wasCreated, \n                ewhSec);\n\n            // If the named system event was created, it can be\n            // used by the current instance of this program, even \n            // though the current user is denied access. The current\n            // program owns the event. Otherwise, exit the program.\n            // \n            if (wasCreated)\n            {\n                Console.WriteLine(&quot;Created the named event.&quot;);\n            }\n            else\n            {\n                Console.WriteLine(&quot;Unable to create the event.&quot;);\n                return;\n            }\n        }\n        else if (unauthorized)\n        {\n            // Open the event to read and change the access control\n            // security. The access control security defined above\n            // allows the current user to do this.\n            //\n            try\n            {\n                ewh = EventWaitHandle.OpenExisting(ewhName, \n                    EventWaitHandleRights.ReadPermissions | \n                    EventWaitHandleRights.ChangePermissions);\n\n                // Get the current ACL. This requires \n                // EventWaitHandleRights.ReadPermissions.\n                EventWaitHandleSecurity ewhSec = ewh.GetAccessControl();\n                \n                string user = Environment.UserDomainName + &quot;\\\\&quot;\n                    + Environment.UserName;\n\n                // First, the rule that denied the current user \n                // the right to enter and release the event must\n                // be removed.\n                EventWaitHandleAccessRule rule = \n                    new EventWaitHandleAccessRule(user, \n                        EventWaitHandleRights.Synchronize | \n                        EventWaitHandleRights.Modify, \n                        AccessControlType.Deny);\n                ewhSec.RemoveAccessRule(rule);\n\n                // Now grant the user the correct rights.\n                // \n                rule = new EventWaitHandleAccessRule(user, \n                    EventWaitHandleRights.Synchronize | \n                    EventWaitHandleRights.Modify, \n                    AccessControlType.Allow);\n                ewhSec.AddAccessRule(rule);\n\n                // Update the ACL. This requires\n                // EventWaitHandleRights.ChangePermissions.\n                ewh.SetAccessControl(ewhSec);\n\n                Console.WriteLine(&quot;Updated event security.&quot;);\n\n                // Open the event with (EventWaitHandleRights.Synchronize \n                // | EventWaitHandleRights.Modify), the rights required\n                // to wait on and signal the event.\n                //\n                ewh = EventWaitHandle.OpenExisting(ewhName);\n\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;,\n                    ex.Message);\n                return;\n            }\n\n        }\n\n        // Wait on the event, and hold it until the program\n        // exits.\n        //\n        try\n        {\n            Console.WriteLine(&quot;Wait on the event.&quot;);\n            ewh.WaitOne();\n            Console.WriteLine(&quot;Event was signaled.&quot;);\n            Console.WriteLine(&quot;Press the Enter key to signal the event and exit.&quot;);\n            Console.ReadLine();\n        }\n        catch (UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n        }\n        finally\n        {\n            ewh.Set();\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.EventWaitHandle.ctor named 5#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Security::AccessControl;\nusing namespace System::Security::Permissions;\n\npublic ref class Example\n{\npublic:\n   [SecurityPermissionAttribute(SecurityAction::Demand,Flags=SecurityPermissionFlag::UnmanagedCode)]\n   static void Main()\n   {\n      String^ ewhName = L&quot;EventWaitHandleExample5&quot;;\n\n      EventWaitHandle^ ewh = nullptr;\n      bool doesNotExist = false;\n      bool unauthorized = false;\n      \n      // The value of this variable is set by the event\n      // constructor. It is true if the named system event was\n      // created, and false if the named event already existed.\n      //\n      bool wasCreated;\n      \n      // Attempt to open the named event.\n      try\n      {\n         // Open the event with (EventWaitHandleRights.Synchronize\n         // | EventWaitHandleRights.Modify), to wait on and\n         // signal the named event.\n         //\n         ewh = EventWaitHandle::OpenExisting( ewhName );\n      }\n      catch ( WaitHandleCannotBeOpenedException^ ) \n      {\n         Console::WriteLine( L&quot;Named event does not exist.&quot; );\n         doesNotExist = true;\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n         unauthorized = true;\n      }\n\n      // There are three cases: (1) The event does not exist.\n      // (2) The event exists, but the current user doesn&#39;t\n      // have access. (3) The event exists and the user has\n      // access.\n      //\n      if ( doesNotExist )\n      {\n         // The event does not exist, so create it.\n\n         // Create an access control list (ACL) that denies the\n         // current user the right to wait on or signal the\n         // event, but allows the right to read and change\n         // security information for the event.\n         //\n         String^ user = String::Concat( Environment::UserDomainName, L&quot;\\\\&quot;,\n            Environment::UserName );\n         EventWaitHandleSecurity^ ewhSec = gcnew EventWaitHandleSecurity;\n         //following constructor fails\n         EventWaitHandleAccessRule^ rule = gcnew EventWaitHandleAccessRule(\n            user,\n            static_cast&lt;EventWaitHandleRights&gt;(\n               EventWaitHandleRights::Synchronize | \n               EventWaitHandleRights::Modify),\n            AccessControlType::Deny );\n         ewhSec-&gt;AddAccessRule( rule );\n\n         rule = gcnew EventWaitHandleAccessRule( user,\n            static_cast&lt;EventWaitHandleRights&gt;(\n               EventWaitHandleRights::ReadPermissions | \n               EventWaitHandleRights::ChangePermissions),\n            AccessControlType::Allow );\n         ewhSec-&gt;AddAccessRule( rule );\n         \n         // Create an EventWaitHandle object that represents\n         // the system event named by the constant &#39;ewhName&#39;,\n         // initially signaled, with automatic reset, and with\n         // the specified security access. The Boolean value that\n         // indicates creation of the underlying system object\n         // is placed in wasCreated.\n         //\n         ewh = gcnew EventWaitHandle( true,\n            EventResetMode::AutoReset,\n            ewhName,\n            wasCreated,\n            ewhSec );\n         \n         // If the named system event was created, it can be\n         // used by the current instance of this program, even\n         // though the current user is denied access. The current\n         // program owns the event. Otherwise, exit the program.\n         //\n         if ( wasCreated )\n         {\n            Console::WriteLine( L&quot;Created the named event.&quot; );\n         }\n         else\n         {\n            Console::WriteLine( L&quot;Unable to create the event.&quot; );\n            return;\n         }\n      }\n      else if ( unauthorized )\n      {\n         // Open the event to read and change the access control\n         // security. The access control security defined above\n         // allows the current user to do this.\n         //\n         try\n         {\n            ewh = EventWaitHandle::OpenExisting( ewhName, \n               static_cast&lt;EventWaitHandleRights&gt;(\n                  EventWaitHandleRights::ReadPermissions |\n                  EventWaitHandleRights::ChangePermissions) );\n            \n            // Get the current ACL. This requires\n            // EventWaitHandleRights.ReadPermissions.\n            EventWaitHandleSecurity^ ewhSec = ewh-&gt;GetAccessControl();\n            String^ user = String::Concat( Environment::UserDomainName, L&quot;\\\\&quot;,\n               Environment::UserName );\n            \n            // First, the rule that denied the current user\n            // the right to enter and release the event must\n            // be removed.\n            EventWaitHandleAccessRule^ rule = gcnew EventWaitHandleAccessRule(\n               user,\n               static_cast&lt;EventWaitHandleRights&gt;(\n                  EventWaitHandleRights::Synchronize |\n                  EventWaitHandleRights::Modify),\n               AccessControlType::Deny );\n            ewhSec-&gt;RemoveAccessRule( rule );\n            \n            // Now grant the user the correct rights.\n            //\n            rule = gcnew EventWaitHandleAccessRule( user,\n               static_cast&lt;EventWaitHandleRights&gt;(\n                  EventWaitHandleRights::Synchronize |\n                  EventWaitHandleRights::Modify),\n               AccessControlType::Allow );\n            ewhSec-&gt;AddAccessRule( rule );\n            \n            // Update the ACL. This requires\n            // EventWaitHandleRights.ChangePermissions.\n            ewh-&gt;SetAccessControl( ewhSec );\n            Console::WriteLine( L&quot;Updated event security.&quot; );\n            \n            // Open the event with (EventWaitHandleRights.Synchronize\n            // | EventWaitHandleRights.Modify), the rights required\n            // to wait on and signal the event.\n            //\n            ewh = EventWaitHandle::OpenExisting( ewhName );\n         }\n         catch ( UnauthorizedAccessException^ ex ) \n         {\n            Console::WriteLine( L&quot;Unable to change permissions: {0}&quot;,\n               ex-&gt;Message );\n            return;\n         }\n\n      }\n      \n      // Wait on the event, and hold it until the program\n      // exits.\n      //\n      try\n      {\n         Console::WriteLine( L&quot;Wait on the event.&quot; );\n         ewh-&gt;WaitOne();\n         Console::WriteLine( L&quot;Event was signaled.&quot; );\n         Console::WriteLine( L&quot;Press the Enter key to signal the event and exit.&quot; );\n         Console::ReadLine();\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n      }\n      finally\n      {\n         ewh-&gt;Set();\n      }\n   }\n};\n\nint main()\n{\n   Example::Main();\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.EventWaitHandle.ctor named 5#1\">Imports System\nImports System.Threading\nImports System.Security.AccessControl\n\nFriend Class Example\n\n    &lt;MTAThread&gt; _\n    Friend Shared Sub Main()\n        Const ewhName As String = &quot;EventWaitHandleExample5&quot;\n\n        Dim ewh As EventWaitHandle = Nothing\n        Dim doesNotExist as Boolean = False\n        Dim unauthorized As Boolean = False\n\n        &#39; The value of this variable is set by the event\n        &#39; constructor. It is True if the named system event was\n        &#39; created, and False if the named event already existed.\n        &#39;\n        Dim wasCreated As Boolean\n\n        &#39; Attempt to open the named event.\n        Try\n            &#39; Open the event with (EventWaitHandleRights.Synchronize\n            &#39; Or EventWaitHandleRights.Modify), to wait on and \n            &#39; signal the named event.\n            &#39;\n            ewh = EventWaitHandle.OpenExisting(ewhName)\n        Catch ex As WaitHandleCannotBeOpenedException\n            Console.WriteLine(&quot;Named event does not exist.&quot;)\n            doesNotExist = True\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message)\n            unauthorized = True\n        End Try\n\n        &#39; There are three cases: (1) The event does not exist.\n        &#39; (2) The event exists, but the current user doesn&#39;t \n        &#39; have access. (3) The event exists and the user has\n        &#39; access.\n        &#39;\n        If doesNotExist Then\n            &#39; The event does not exist, so create it.\n\n            &#39; Create an access control list (ACL) that denies the\n            &#39; current user the right to wait on or signal the \n            &#39; event, but allows the right to read and change\n            &#39; security information for the event.\n            &#39;\n            Dim user As String = Environment.UserDomainName _ \n                &amp; &quot;\\&quot; &amp; Environment.UserName\n            Dim ewhSec As New EventWaitHandleSecurity()\n\n            Dim rule As New EventWaitHandleAccessRule(user, _\n                EventWaitHandleRights.Synchronize Or _\n                EventWaitHandleRights.Modify, _\n                AccessControlType.Deny)\n            ewhSec.AddAccessRule(rule)\n\n            rule = New EventWaitHandleAccessRule(user, _\n                EventWaitHandleRights.ReadPermissions Or _\n                EventWaitHandleRights.ChangePermissions, _\n                AccessControlType.Allow)\n            ewhSec.AddAccessRule(rule)\n\n            &#39; Create an EventWaitHandle object that represents\n            &#39; the system event named by the constant &#39;ewhName&#39;, \n            &#39; initially signaled, with automatic reset, and with\n            &#39; the specified security access. The Boolean value that \n            &#39; indicates creation of the underlying system object\n            &#39; is placed in wasCreated.\n            &#39;\n            ewh = New EventWaitHandle(True, _\n                EventResetMode.AutoReset, ewhName, _\n                wasCreated, ewhSec)\n\n            &#39; If the named system event was created, it can be\n            &#39; used by the current instance of this program, even \n            &#39; though the current user is denied access. The current\n            &#39; program owns the event. Otherwise, exit the program.\n            &#39; \n            If wasCreated Then\n                Console.WriteLine(&quot;Created the named event.&quot;)\n            Else\n                Console.WriteLine(&quot;Unable to create the event.&quot;)\n                Return\n            End If\n\n        ElseIf unauthorized Then\n\n            &#39; Open the event to read and change the access control\n            &#39; security. The access control security defined above\n            &#39; allows the current user to do this.\n            &#39;\n            Try\n                ewh = EventWaitHandle.OpenExisting(ewhName, _\n                    EventWaitHandleRights.ReadPermissions Or _\n                    EventWaitHandleRights.ChangePermissions)\n\n                &#39; Get the current ACL. This requires \n                &#39; EventWaitHandleRights.ReadPermissions.\n                Dim ewhSec As EventWaitHandleSecurity = _\n                    ewh.GetAccessControl()\n                \n                Dim user As String = Environment.UserDomainName _ \n                    &amp; &quot;\\&quot; &amp; Environment.UserName\n\n                &#39; First, the rule that denied the current user \n                &#39; the right to enter and release the event must\n                &#39; be removed.\n                Dim rule As New EventWaitHandleAccessRule(user, _\n                    EventWaitHandleRights.Synchronize Or _\n                    EventWaitHandleRights.Modify, _\n                    AccessControlType.Deny)\n                ewhSec.RemoveAccessRule(rule)\n\n                &#39; Now grant the user the correct rights.\n                &#39; \n                rule = New EventWaitHandleAccessRule(user, _\n                    EventWaitHandleRights.Synchronize Or _\n                    EventWaitHandleRights.Modify, _\n                    AccessControlType.Allow)\n                ewhSec.AddAccessRule(rule)\n\n                &#39; Update the ACL. This requires\n                &#39; EventWaitHandleRights.ChangePermissions.\n                ewh.SetAccessControl(ewhSec)\n\n                Console.WriteLine(&quot;Updated event security.&quot;)\n\n                &#39; Open the event with (EventWaitHandleRights.Synchronize \n                &#39; Or EventWaitHandleRights.Modify), the rights required\n                &#39; to wait on and signal the event.\n                &#39;\n                ewh = EventWaitHandle.OpenExisting(ewhName)\n\n            Catch ex As UnauthorizedAccessException\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;, _\n                    ex.Message)\n                Return\n            End Try\n\n        End If\n\n        &#39; Wait on the event, and hold it until the program\n        &#39; exits.\n        &#39;\n        Try\n            Console.WriteLine(&quot;Wait on the event.&quot;)\n            ewh.WaitOne()\n            Console.WriteLine(&quot;Event was signaled.&quot;)\n            Console.WriteLine(&quot;Press the Enter key to signal the event and exit.&quot;)\n            Console.ReadLine()\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, _\n                ex.Message)\n        Finally\n            ewh.Set()\n        End Try\n    End Sub \nEnd Class \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_EventWaitHandle_OpenExisting_System_String_System_Security_AccessControl_EventWaitHandleRights_\">\r\n    \r\n            <a id=\"System_Threading_EventWaitHandle_OpenExisting_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">OpenExisting(String,EventWaitHandleRights)</div>        \r\n          </div>\r\n    \r\n            <p>Opens the specified named synchronization event, if it already exists, with the desired security access.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Threading.EventWaitHandle OpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of the system synchronization event to open.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>rights</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">EventWaitHandleRights</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitwise combination of the enumeration values that represent the desired security access.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a></div>\r\n                  </div>\r\n                  <p>An object that represents the named system event.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is an empty string.  </p>\n<p> -or-  </p>\n<p> <code>name</code> is longer than 260 characters.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandlecannotbeopenedexception\" data-linktype=\"relative-path\">WaitHandleCannotBeOpenedException</a></div>\r\n                  </div>\r\n                  <p>The named system event does not exist.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a></div>\r\n                  </div>\r\n                  <p>A Win32 error occurred.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The named event exists, but the user does not have the desired security access.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <code>rights</code> parameter must include the <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">System.Security.AccessControl.EventWaitHandleRights</a> flag to allow threads to wait on the event, and the <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">System.Security.AccessControl.EventWaitHandleRights</a> flag to allow threads to call the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_Set_\" data-linktype=\"relative-path\">Set</a> and <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_Reset_\" data-linktype=\"relative-path\">Reset</a> methods.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_OpenExisting_\" data-linktype=\"relative-path\">OpenExisting</a> method tries to open an existing named system event. If the system event does not exist, this method throws an exception instead of creating the system event. To create the system event when it does not already exist, use one of the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle__ctor_\" data-linktype=\"relative-path\">EventWaitHandle</a> constructors that has a <code>name</code> parameter.  </p>\n<p> Multiple calls to this method that use the same value for <code>name</code> do not necessarily return the same <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> object, even though the objects that are returned represent the same named system event.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates the cross-process behavior of a named system event with access control security. The example uses the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a> method overload to test for the existence of a named event.  </p>\n<p> If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.  </p>\n<p> If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a>. The exception is caught, and the example uses the OpenExisting method overload to wait on the event with the rights needed to read and change the permissions.  </p>\n<p> After the permissions are changed, the event is opened with the rights required to wait on it and signal it. If you run the compiled example from a third command window, the example runs using the new permissions.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.EventWaitHandle.ctor named 5#1\">using System;\nusing System.Threading;\nusing System.Security.AccessControl;\n\ninternal class Example\n{\n    internal static void Main()\n    {\n        const string ewhName = &quot;EventWaitHandleExample5&quot;;\n\n        EventWaitHandle ewh = null;\n        bool doesNotExist = false;\n        bool unauthorized = false;\n\n        // The value of this variable is set by the event\n        // constructor. It is true if the named system event was\n        // created, and false if the named event already existed.\n        //\n        bool wasCreated;\n\n        // Attempt to open the named event.\n        try\n        {\n            // Open the event with (EventWaitHandleRights.Synchronize\n            // | EventWaitHandleRights.Modify), to wait on and \n            // signal the named event.\n            //\n            ewh = EventWaitHandle.OpenExisting(ewhName);\n        }\n        catch (WaitHandleCannotBeOpenedException)\n        {\n            Console.WriteLine(&quot;Named event does not exist.&quot;);\n            doesNotExist = true;\n        }\n        catch (UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n            unauthorized = true;\n        }\n\n        // There are three cases: (1) The event does not exist.\n        // (2) The event exists, but the current user doesn&#39;t \n        // have access. (3) The event exists and the user has\n        // access.\n        //\n        if (doesNotExist)\n        {\n            // The event does not exist, so create it.\n\n            // Create an access control list (ACL) that denies the\n            // current user the right to wait on or signal the \n            // event, but allows the right to read and change\n            // security information for the event.\n            //\n            string user = Environment.UserDomainName + &quot;\\\\&quot;\n                + Environment.UserName;\n            EventWaitHandleSecurity ewhSec = \n                new EventWaitHandleSecurity();\n\n            EventWaitHandleAccessRule rule = \n                new EventWaitHandleAccessRule(user, \n                    EventWaitHandleRights.Synchronize | \n                    EventWaitHandleRights.Modify, \n                    AccessControlType.Deny);\n            ewhSec.AddAccessRule(rule);\n\n            rule = new EventWaitHandleAccessRule(user, \n                EventWaitHandleRights.ReadPermissions | \n                EventWaitHandleRights.ChangePermissions, \n                AccessControlType.Allow);\n            ewhSec.AddAccessRule(rule);\n\n            // Create an EventWaitHandle object that represents\n            // the system event named by the constant &#39;ewhName&#39;, \n            // initially signaled, with automatic reset, and with\n            // the specified security access. The Boolean value that \n            // indicates creation of the underlying system object\n            // is placed in wasCreated.\n            //\n            ewh = new EventWaitHandle(true, \n                EventResetMode.AutoReset, \n                ewhName, \n                out wasCreated, \n                ewhSec);\n\n            // If the named system event was created, it can be\n            // used by the current instance of this program, even \n            // though the current user is denied access. The current\n            // program owns the event. Otherwise, exit the program.\n            // \n            if (wasCreated)\n            {\n                Console.WriteLine(&quot;Created the named event.&quot;);\n            }\n            else\n            {\n                Console.WriteLine(&quot;Unable to create the event.&quot;);\n                return;\n            }\n        }\n        else if (unauthorized)\n        {\n            // Open the event to read and change the access control\n            // security. The access control security defined above\n            // allows the current user to do this.\n            //\n            try\n            {\n                ewh = EventWaitHandle.OpenExisting(ewhName, \n                    EventWaitHandleRights.ReadPermissions | \n                    EventWaitHandleRights.ChangePermissions);\n\n                // Get the current ACL. This requires \n                // EventWaitHandleRights.ReadPermissions.\n                EventWaitHandleSecurity ewhSec = ewh.GetAccessControl();\n                \n                string user = Environment.UserDomainName + &quot;\\\\&quot;\n                    + Environment.UserName;\n\n                // First, the rule that denied the current user \n                // the right to enter and release the event must\n                // be removed.\n                EventWaitHandleAccessRule rule = \n                    new EventWaitHandleAccessRule(user, \n                        EventWaitHandleRights.Synchronize | \n                        EventWaitHandleRights.Modify, \n                        AccessControlType.Deny);\n                ewhSec.RemoveAccessRule(rule);\n\n                // Now grant the user the correct rights.\n                // \n                rule = new EventWaitHandleAccessRule(user, \n                    EventWaitHandleRights.Synchronize | \n                    EventWaitHandleRights.Modify, \n                    AccessControlType.Allow);\n                ewhSec.AddAccessRule(rule);\n\n                // Update the ACL. This requires\n                // EventWaitHandleRights.ChangePermissions.\n                ewh.SetAccessControl(ewhSec);\n\n                Console.WriteLine(&quot;Updated event security.&quot;);\n\n                // Open the event with (EventWaitHandleRights.Synchronize \n                // | EventWaitHandleRights.Modify), the rights required\n                // to wait on and signal the event.\n                //\n                ewh = EventWaitHandle.OpenExisting(ewhName);\n\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;,\n                    ex.Message);\n                return;\n            }\n\n        }\n\n        // Wait on the event, and hold it until the program\n        // exits.\n        //\n        try\n        {\n            Console.WriteLine(&quot;Wait on the event.&quot;);\n            ewh.WaitOne();\n            Console.WriteLine(&quot;Event was signaled.&quot;);\n            Console.WriteLine(&quot;Press the Enter key to signal the event and exit.&quot;);\n            Console.ReadLine();\n        }\n        catch (UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n        }\n        finally\n        {\n            ewh.Set();\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.EventWaitHandle.ctor named 5#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Security::AccessControl;\nusing namespace System::Security::Permissions;\n\npublic ref class Example\n{\npublic:\n   [SecurityPermissionAttribute(SecurityAction::Demand,Flags=SecurityPermissionFlag::UnmanagedCode)]\n   static void Main()\n   {\n      String^ ewhName = L&quot;EventWaitHandleExample5&quot;;\n\n      EventWaitHandle^ ewh = nullptr;\n      bool doesNotExist = false;\n      bool unauthorized = false;\n      \n      // The value of this variable is set by the event\n      // constructor. It is true if the named system event was\n      // created, and false if the named event already existed.\n      //\n      bool wasCreated;\n      \n      // Attempt to open the named event.\n      try\n      {\n         // Open the event with (EventWaitHandleRights.Synchronize\n         // | EventWaitHandleRights.Modify), to wait on and\n         // signal the named event.\n         //\n         ewh = EventWaitHandle::OpenExisting( ewhName );\n      }\n      catch ( WaitHandleCannotBeOpenedException^ ) \n      {\n         Console::WriteLine( L&quot;Named event does not exist.&quot; );\n         doesNotExist = true;\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n         unauthorized = true;\n      }\n\n      // There are three cases: (1) The event does not exist.\n      // (2) The event exists, but the current user doesn&#39;t\n      // have access. (3) The event exists and the user has\n      // access.\n      //\n      if ( doesNotExist )\n      {\n         // The event does not exist, so create it.\n\n         // Create an access control list (ACL) that denies the\n         // current user the right to wait on or signal the\n         // event, but allows the right to read and change\n         // security information for the event.\n         //\n         String^ user = String::Concat( Environment::UserDomainName, L&quot;\\\\&quot;,\n            Environment::UserName );\n         EventWaitHandleSecurity^ ewhSec = gcnew EventWaitHandleSecurity;\n         //following constructor fails\n         EventWaitHandleAccessRule^ rule = gcnew EventWaitHandleAccessRule(\n            user,\n            static_cast&lt;EventWaitHandleRights&gt;(\n               EventWaitHandleRights::Synchronize | \n               EventWaitHandleRights::Modify),\n            AccessControlType::Deny );\n         ewhSec-&gt;AddAccessRule( rule );\n\n         rule = gcnew EventWaitHandleAccessRule( user,\n            static_cast&lt;EventWaitHandleRights&gt;(\n               EventWaitHandleRights::ReadPermissions | \n               EventWaitHandleRights::ChangePermissions),\n            AccessControlType::Allow );\n         ewhSec-&gt;AddAccessRule( rule );\n         \n         // Create an EventWaitHandle object that represents\n         // the system event named by the constant &#39;ewhName&#39;,\n         // initially signaled, with automatic reset, and with\n         // the specified security access. The Boolean value that\n         // indicates creation of the underlying system object\n         // is placed in wasCreated.\n         //\n         ewh = gcnew EventWaitHandle( true,\n            EventResetMode::AutoReset,\n            ewhName,\n            wasCreated,\n            ewhSec );\n         \n         // If the named system event was created, it can be\n         // used by the current instance of this program, even\n         // though the current user is denied access. The current\n         // program owns the event. Otherwise, exit the program.\n         //\n         if ( wasCreated )\n         {\n            Console::WriteLine( L&quot;Created the named event.&quot; );\n         }\n         else\n         {\n            Console::WriteLine( L&quot;Unable to create the event.&quot; );\n            return;\n         }\n      }\n      else if ( unauthorized )\n      {\n         // Open the event to read and change the access control\n         // security. The access control security defined above\n         // allows the current user to do this.\n         //\n         try\n         {\n            ewh = EventWaitHandle::OpenExisting( ewhName, \n               static_cast&lt;EventWaitHandleRights&gt;(\n                  EventWaitHandleRights::ReadPermissions |\n                  EventWaitHandleRights::ChangePermissions) );\n            \n            // Get the current ACL. This requires\n            // EventWaitHandleRights.ReadPermissions.\n            EventWaitHandleSecurity^ ewhSec = ewh-&gt;GetAccessControl();\n            String^ user = String::Concat( Environment::UserDomainName, L&quot;\\\\&quot;,\n               Environment::UserName );\n            \n            // First, the rule that denied the current user\n            // the right to enter and release the event must\n            // be removed.\n            EventWaitHandleAccessRule^ rule = gcnew EventWaitHandleAccessRule(\n               user,\n               static_cast&lt;EventWaitHandleRights&gt;(\n                  EventWaitHandleRights::Synchronize |\n                  EventWaitHandleRights::Modify),\n               AccessControlType::Deny );\n            ewhSec-&gt;RemoveAccessRule( rule );\n            \n            // Now grant the user the correct rights.\n            //\n            rule = gcnew EventWaitHandleAccessRule( user,\n               static_cast&lt;EventWaitHandleRights&gt;(\n                  EventWaitHandleRights::Synchronize |\n                  EventWaitHandleRights::Modify),\n               AccessControlType::Allow );\n            ewhSec-&gt;AddAccessRule( rule );\n            \n            // Update the ACL. This requires\n            // EventWaitHandleRights.ChangePermissions.\n            ewh-&gt;SetAccessControl( ewhSec );\n            Console::WriteLine( L&quot;Updated event security.&quot; );\n            \n            // Open the event with (EventWaitHandleRights.Synchronize\n            // | EventWaitHandleRights.Modify), the rights required\n            // to wait on and signal the event.\n            //\n            ewh = EventWaitHandle::OpenExisting( ewhName );\n         }\n         catch ( UnauthorizedAccessException^ ex ) \n         {\n            Console::WriteLine( L&quot;Unable to change permissions: {0}&quot;,\n               ex-&gt;Message );\n            return;\n         }\n\n      }\n      \n      // Wait on the event, and hold it until the program\n      // exits.\n      //\n      try\n      {\n         Console::WriteLine( L&quot;Wait on the event.&quot; );\n         ewh-&gt;WaitOne();\n         Console::WriteLine( L&quot;Event was signaled.&quot; );\n         Console::WriteLine( L&quot;Press the Enter key to signal the event and exit.&quot; );\n         Console::ReadLine();\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n      }\n      finally\n      {\n         ewh-&gt;Set();\n      }\n   }\n};\n\nint main()\n{\n   Example::Main();\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.EventWaitHandle.ctor named 5#1\">Imports System\nImports System.Threading\nImports System.Security.AccessControl\n\nFriend Class Example\n\n    &lt;MTAThread&gt; _\n    Friend Shared Sub Main()\n        Const ewhName As String = &quot;EventWaitHandleExample5&quot;\n\n        Dim ewh As EventWaitHandle = Nothing\n        Dim doesNotExist as Boolean = False\n        Dim unauthorized As Boolean = False\n\n        &#39; The value of this variable is set by the event\n        &#39; constructor. It is True if the named system event was\n        &#39; created, and False if the named event already existed.\n        &#39;\n        Dim wasCreated As Boolean\n\n        &#39; Attempt to open the named event.\n        Try\n            &#39; Open the event with (EventWaitHandleRights.Synchronize\n            &#39; Or EventWaitHandleRights.Modify), to wait on and \n            &#39; signal the named event.\n            &#39;\n            ewh = EventWaitHandle.OpenExisting(ewhName)\n        Catch ex As WaitHandleCannotBeOpenedException\n            Console.WriteLine(&quot;Named event does not exist.&quot;)\n            doesNotExist = True\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message)\n            unauthorized = True\n        End Try\n\n        &#39; There are three cases: (1) The event does not exist.\n        &#39; (2) The event exists, but the current user doesn&#39;t \n        &#39; have access. (3) The event exists and the user has\n        &#39; access.\n        &#39;\n        If doesNotExist Then\n            &#39; The event does not exist, so create it.\n\n            &#39; Create an access control list (ACL) that denies the\n            &#39; current user the right to wait on or signal the \n            &#39; event, but allows the right to read and change\n            &#39; security information for the event.\n            &#39;\n            Dim user As String = Environment.UserDomainName _ \n                &amp; &quot;\\&quot; &amp; Environment.UserName\n            Dim ewhSec As New EventWaitHandleSecurity()\n\n            Dim rule As New EventWaitHandleAccessRule(user, _\n                EventWaitHandleRights.Synchronize Or _\n                EventWaitHandleRights.Modify, _\n                AccessControlType.Deny)\n            ewhSec.AddAccessRule(rule)\n\n            rule = New EventWaitHandleAccessRule(user, _\n                EventWaitHandleRights.ReadPermissions Or _\n                EventWaitHandleRights.ChangePermissions, _\n                AccessControlType.Allow)\n            ewhSec.AddAccessRule(rule)\n\n            &#39; Create an EventWaitHandle object that represents\n            &#39; the system event named by the constant &#39;ewhName&#39;, \n            &#39; initially signaled, with automatic reset, and with\n            &#39; the specified security access. The Boolean value that \n            &#39; indicates creation of the underlying system object\n            &#39; is placed in wasCreated.\n            &#39;\n            ewh = New EventWaitHandle(True, _\n                EventResetMode.AutoReset, ewhName, _\n                wasCreated, ewhSec)\n\n            &#39; If the named system event was created, it can be\n            &#39; used by the current instance of this program, even \n            &#39; though the current user is denied access. The current\n            &#39; program owns the event. Otherwise, exit the program.\n            &#39; \n            If wasCreated Then\n                Console.WriteLine(&quot;Created the named event.&quot;)\n            Else\n                Console.WriteLine(&quot;Unable to create the event.&quot;)\n                Return\n            End If\n\n        ElseIf unauthorized Then\n\n            &#39; Open the event to read and change the access control\n            &#39; security. The access control security defined above\n            &#39; allows the current user to do this.\n            &#39;\n            Try\n                ewh = EventWaitHandle.OpenExisting(ewhName, _\n                    EventWaitHandleRights.ReadPermissions Or _\n                    EventWaitHandleRights.ChangePermissions)\n\n                &#39; Get the current ACL. This requires \n                &#39; EventWaitHandleRights.ReadPermissions.\n                Dim ewhSec As EventWaitHandleSecurity = _\n                    ewh.GetAccessControl()\n                \n                Dim user As String = Environment.UserDomainName _ \n                    &amp; &quot;\\&quot; &amp; Environment.UserName\n\n                &#39; First, the rule that denied the current user \n                &#39; the right to enter and release the event must\n                &#39; be removed.\n                Dim rule As New EventWaitHandleAccessRule(user, _\n                    EventWaitHandleRights.Synchronize Or _\n                    EventWaitHandleRights.Modify, _\n                    AccessControlType.Deny)\n                ewhSec.RemoveAccessRule(rule)\n\n                &#39; Now grant the user the correct rights.\n                &#39; \n                rule = New EventWaitHandleAccessRule(user, _\n                    EventWaitHandleRights.Synchronize Or _\n                    EventWaitHandleRights.Modify, _\n                    AccessControlType.Allow)\n                ewhSec.AddAccessRule(rule)\n\n                &#39; Update the ACL. This requires\n                &#39; EventWaitHandleRights.ChangePermissions.\n                ewh.SetAccessControl(ewhSec)\n\n                Console.WriteLine(&quot;Updated event security.&quot;)\n\n                &#39; Open the event with (EventWaitHandleRights.Synchronize \n                &#39; Or EventWaitHandleRights.Modify), the rights required\n                &#39; to wait on and signal the event.\n                &#39;\n                ewh = EventWaitHandle.OpenExisting(ewhName)\n\n            Catch ex As UnauthorizedAccessException\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;, _\n                    ex.Message)\n                Return\n            End Try\n\n        End If\n\n        &#39; Wait on the event, and hold it until the program\n        &#39; exits.\n        &#39;\n        Try\n            Console.WriteLine(&quot;Wait on the event.&quot;)\n            ewh.WaitOne()\n            Console.WriteLine(&quot;Event was signaled.&quot;)\n            Console.WriteLine(&quot;Press the Enter key to signal the event and exit.&quot;)\n            Console.ReadLine()\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, _\n                ex.Message)\n        Finally\n            ewh.Set()\n        End Try\n    End Sub \nEnd Class \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_EventWaitHandle_Reset\">\r\n    \r\n            <a id=\"System_Threading_EventWaitHandle_Reset_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Reset()</div>        \r\n          </div>\r\n    \r\n            <p>Sets the state of the event to nonsignaled, causing threads to block.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool Reset ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the operation succeeds; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.objectdisposedexception\" data-linktype=\"relative-path\">ObjectDisposedException</a></div>\r\n                  </div>\r\n                  <p>The <span class=\"xref\">stem.Threading.WaitHandle.Close*</span> method was previously called on this <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_EventWaitHandle_Set\">\r\n    \r\n            <a id=\"System_Threading_EventWaitHandle_Set_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Set()</div>        \r\n          </div>\r\n    \r\n            <p>Sets the state of the event to signaled, allowing one or more waiting threads to proceed.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool Set ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the operation succeeds; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.objectdisposedexception\" data-linktype=\"relative-path\">ObjectDisposedException</a></div>\r\n                  </div>\r\n                  <p>The <span class=\"xref\">stem.Threading.WaitHandle.Close*</span> method was previously called on this <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>For an <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> with <a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">System.Threading.EventResetMode</a> (including <a class=\"xref\" href=\"system.threading.autoresetevent\" data-linktype=\"relative-path\">AutoResetEvent</a>), the Set method releases a single thread. If there are no waiting threads, the wait handle remains signaled until a thread attempts to wait on it, or until its <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_Reset_\" data-linktype=\"relative-path\">Reset</a> method is called.  </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> There is no guarantee that every call to the Set method will release a thread from an <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> whose reset mode is <a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">System.Threading.EventResetMode</a>. If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released. It is as if the second call did not happen. Also, if Set is called when there are no threads waiting and the <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> is already signaled, the call has no effect.  </p>\n</div>\n<p> For an <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> with <a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">System.Threading.EventResetMode</a> (including <a class=\"xref\" href=\"system.threading.manualresetevent\" data-linktype=\"relative-path\">ManualResetEvent</a>), calling the Set method leaves the wait handle in a signaled state until its <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_Reset_\" data-linktype=\"relative-path\">Reset</a> method is called.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example uses the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SignalAndWait_System_Threading_WaitHandle_System_Threading_WaitHandle_\" data-linktype=\"relative-path\">SignalAndWait(WaitHandle,WaitHandle)</a> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.  </p>\n<p> The example starts five threads and allows them to block on an <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> created with the <a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">System.Threading.EventResetMode</a> flag, then releases one thread each time the user presses the ENTER key. The example then queues another five threads and releases them all using an <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> created with the <a class=\"xref\" href=\"system.threading.eventresetmode\" data-linktype=\"relative-path\">System.Threading.EventResetMode</a> flag.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Threading.WaitHandle.SignalAndWait#1\">using namespace System;\nusing namespace System::Threading;\n\npublic ref class Example\n{\nprivate:\n   // The EventWaitHandle used to demonstrate the difference\n   // between AutoReset and ManualReset synchronization events.\n   //\n   static EventWaitHandle^ ewh;\n\n   // A counter to make sure all threads are started and\n   // blocked before any are released. A Long is used to show\n   // the use of the 64-bit Interlocked methods.\n   //\n   static __int64 threadCount = 0;\n\n   // An AutoReset event that allows the main thread to block\n   // until an exiting thread has decremented the count.\n   //\n   static EventWaitHandle^ clearCount =\n      gcnew EventWaitHandle( false,EventResetMode::AutoReset );\n\npublic:\n   [MTAThread]\n   static void main()\n   {\n      // Create an AutoReset EventWaitHandle.\n      //\n      ewh = gcnew EventWaitHandle( false,EventResetMode::AutoReset );\n      \n      // Create and start five numbered threads. Use the\n      // ParameterizedThreadStart delegate, so the thread\n      // number can be passed as an argument to the Start\n      // method.\n      for ( int i = 0; i &lt;= 4; i++ )\n      {\n         Thread^ t = gcnew Thread(\n            gcnew ParameterizedThreadStart( ThreadProc ) );\n         t-&gt;Start( i );\n      }\n      \n      // Wait until all the threads have started and blocked.\n      // When multiple threads use a 64-bit value on a 32-bit\n      // system, you must access the value through the\n      // Interlocked class to guarantee thread safety.\n      //\n      while ( Interlocked::Read( threadCount ) &lt; 5 )\n      {\n         Thread::Sleep( 500 );\n      }\n\n      // Release one thread each time the user presses ENTER,\n      // until all threads have been released.\n      //\n      while ( Interlocked::Read( threadCount ) &gt; 0 )\n      {\n         Console::WriteLine( L&quot;Press ENTER to release a waiting thread.&quot; );\n         Console::ReadLine();\n         \n         // SignalAndWait signals the EventWaitHandle, which\n         // releases exactly one thread before resetting,\n         // because it was created with AutoReset mode.\n         // SignalAndWait then blocks on clearCount, to\n         // allow the signaled thread to decrement the count\n         // before looping again.\n         //\n         WaitHandle::SignalAndWait( ewh, clearCount );\n      }\n      Console::WriteLine();\n      \n      // Create a ManualReset EventWaitHandle.\n      //\n      ewh = gcnew EventWaitHandle( false,EventResetMode::ManualReset );\n      \n      // Create and start five more numbered threads.\n      //\n      for ( int i = 0; i &lt;= 4; i++ )\n      {\n         Thread^ t = gcnew Thread(\n            gcnew ParameterizedThreadStart( ThreadProc ) );\n         t-&gt;Start( i );\n      }\n      \n      // Wait until all the threads have started and blocked.\n      //\n      while ( Interlocked::Read( threadCount ) &lt; 5 )\n      {\n         Thread::Sleep( 500 );\n      }\n\n      // Because the EventWaitHandle was created with\n      // ManualReset mode, signaling it releases all the\n      // waiting threads.\n      //\n      Console::WriteLine( L&quot;Press ENTER to release the waiting threads.&quot; );\n      Console::ReadLine();\n      ewh-&gt;Set();\n\n   }\n\n   static void ThreadProc( Object^ data )\n   {\n      int index = static_cast&lt;Int32&gt;(data);\n\n      Console::WriteLine( L&quot;Thread {0} blocks.&quot;, data );\n      // Increment the count of blocked threads.\n      Interlocked::Increment( threadCount );\n      \n      // Wait on the EventWaitHandle.\n      ewh-&gt;WaitOne();\n\n      Console::WriteLine( L&quot;Thread {0} exits.&quot;, data );\n      // Decrement the count of blocked threads.\n      Interlocked::Decrement( threadCount );\n      \n      // After signaling ewh, the main thread blocks on\n      // clearCount until the signaled thread has\n      // decremented the count. Signal it now.\n      //\n      clearCount-&gt;Set();\n   }\n};\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.WaitHandle.SignalAndWait#1\">Imports System\nImports System.Threading\n\nPublic Class Example\n\n    &#39; The EventWaitHandle used to demonstrate the difference\n    &#39; between AutoReset and ManualReset synchronization events.\n    &#39;\n    Private Shared ewh As EventWaitHandle\n\n    &#39; A counter to make sure all threads are started and\n    &#39; blocked before any are released. A Long is used to show\n    &#39; the use of the 64-bit Interlocked methods.\n    &#39;\n    Private Shared threadCount As Long = 0\n\n    &#39; An AutoReset event that allows the main thread to block\n    &#39; until an exiting thread has decremented the count.\n    &#39;\n    Private Shared clearCount As New EventWaitHandle(False, _\n        EventResetMode.AutoReset)\n\n    &lt;MTAThread&gt; _\n    Public Shared Sub Main()\n\n        &#39; Create an AutoReset EventWaitHandle.\n        &#39;\n        ewh = New EventWaitHandle(False, EventResetMode.AutoReset)\n\n        &#39; Create and start five numbered threads. Use the\n        &#39; ParameterizedThreadStart delegate, so the thread\n        &#39; number can be passed as an argument to the Start \n        &#39; method.\n        For i As Integer = 0 To 4\n            Dim t As New Thread(AddressOf ThreadProc)\n            t.Start(i)\n        Next i\n\n        &#39; Wait until all the threads have started and blocked.\n        &#39; When multiple threads use a 64-bit value on a 32-bit\n        &#39; system, you must access the value through the\n        &#39; Interlocked class to guarantee thread safety.\n        &#39;\n        While Interlocked.Read(threadCount) &lt; 5\n            Thread.Sleep(500)\n        End While\n\n        &#39; Release one thread each time the user presses ENTER,\n        &#39; until all threads have been released.\n        &#39;\n        While Interlocked.Read(threadCount) &gt; 0\n            Console.WriteLine(&quot;Press ENTER to release a waiting thread.&quot;)\n            Console.ReadLine()\n\n            &#39; SignalAndWait signals the EventWaitHandle, which\n            &#39; releases exactly one thread before resetting, \n            &#39; because it was created with AutoReset mode. \n            &#39; SignalAndWait then blocks on clearCount, to \n            &#39; allow the signaled thread to decrement the count\n            &#39; before looping again.\n            &#39;\n            WaitHandle.SignalAndWait(ewh, clearCount)\n        End While\n        Console.WriteLine()\n\n        &#39; Create a ManualReset EventWaitHandle.\n        &#39;\n        ewh = New EventWaitHandle(False, EventResetMode.ManualReset)\n\n        &#39; Create and start five more numbered threads.\n        &#39;\n        For i As Integer = 0 To 4\n            Dim t As New Thread(AddressOf ThreadProc)\n            t.Start(i)\n        Next i\n\n        &#39; Wait until all the threads have started and blocked.\n        &#39;\n        While Interlocked.Read(threadCount) &lt; 5\n            Thread.Sleep(500)\n        End While\n\n        &#39; Because the EventWaitHandle was created with\n        &#39; ManualReset mode, signaling it releases all the\n        &#39; waiting threads.\n        &#39;\n        Console.WriteLine(&quot;Press ENTER to release the waiting threads.&quot;)\n        Console.ReadLine()\n        ewh.Set()\n        \n    End Sub\n\n    Public Shared Sub ThreadProc(ByVal data As Object)\n        Dim index As Integer = CInt(data)\n\n        Console.WriteLine(&quot;Thread {0} blocks.&quot;, data)\n        &#39; Increment the count of blocked threads.\n        Interlocked.Increment(threadCount)\n\n        &#39; Wait on the EventWaitHandle.\n        ewh.WaitOne()\n\n        Console.WriteLine(&quot;Thread {0} exits.&quot;, data)\n        &#39; Decrement the count of blocked threads.\n        Interlocked.Decrement(threadCount)\n\n        &#39; After signaling ewh, the main thread blocks on\n        &#39; clearCount until the signaled thread has \n        &#39; decremented the count. Signal it now.\n        &#39;\n        clearCount.Set()\n    End Sub\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.WaitHandle.SignalAndWait#1\">using System;\nusing System.Threading;\n\npublic class Example\n{\n    // The EventWaitHandle used to demonstrate the difference\n    // between AutoReset and ManualReset synchronization events.\n    //\n    private static EventWaitHandle ewh;\n\n    // A counter to make sure all threads are started and\n    // blocked before any are released. A Long is used to show\n    // the use of the 64-bit Interlocked methods.\n    //\n    private static long threadCount = 0;\n\n    // An AutoReset event that allows the main thread to block\n    // until an exiting thread has decremented the count.\n    //\n    private static EventWaitHandle clearCount = \n        new EventWaitHandle(false, EventResetMode.AutoReset);\n\n    [MTAThread]\n    public static void Main()\n    {\n        // Create an AutoReset EventWaitHandle.\n        //\n        ewh = new EventWaitHandle(false, EventResetMode.AutoReset);\n\n        // Create and start five numbered threads. Use the\n        // ParameterizedThreadStart delegate, so the thread\n        // number can be passed as an argument to the Start \n        // method.\n        for (int i = 0; i &lt;= 4; i++)\n        {\n            Thread t = new Thread(\n                new ParameterizedThreadStart(ThreadProc)\n            );\n            t.Start(i);\n        }\n\n        // Wait until all the threads have started and blocked.\n        // When multiple threads use a 64-bit value on a 32-bit\n        // system, you must access the value through the\n        // Interlocked class to guarantee thread safety.\n        //\n        while (Interlocked.Read(ref threadCount) &lt; 5)\n        {\n            Thread.Sleep(500);\n        }\n\n        // Release one thread each time the user presses ENTER,\n        // until all threads have been released.\n        //\n        while (Interlocked.Read(ref threadCount) &gt; 0)\n        {\n            Console.WriteLine(&quot;Press ENTER to release a waiting thread.&quot;);\n            Console.ReadLine();\n\n            // SignalAndWait signals the EventWaitHandle, which\n            // releases exactly one thread before resetting, \n            // because it was created with AutoReset mode. \n            // SignalAndWait then blocks on clearCount, to \n            // allow the signaled thread to decrement the count\n            // before looping again.\n            //\n            WaitHandle.SignalAndWait(ewh, clearCount);\n        }\n        Console.WriteLine();\n\n        // Create a ManualReset EventWaitHandle.\n        //\n        ewh = new EventWaitHandle(false, EventResetMode.ManualReset);\n\n        // Create and start five more numbered threads.\n        //\n        for(int i=0; i&lt;=4; i++)\n        {\n            Thread t = new Thread(\n                new ParameterizedThreadStart(ThreadProc)\n            );\n            t.Start(i);\n        }\n\n        // Wait until all the threads have started and blocked.\n        //\n        while (Interlocked.Read(ref threadCount) &lt; 5)\n        {\n            Thread.Sleep(500);\n        }\n\n        // Because the EventWaitHandle was created with\n        // ManualReset mode, signaling it releases all the\n        // waiting threads.\n        //\n        Console.WriteLine(&quot;Press ENTER to release the waiting threads.&quot;);\n        Console.ReadLine();\n        ewh.Set();\n        \n    }\n\n    public static void ThreadProc(object data)\n    {\n        int index = (int) data;\n\n        Console.WriteLine(&quot;Thread {0} blocks.&quot;, data);\n        // Increment the count of blocked threads.\n        Interlocked.Increment(ref threadCount);\n\n        // Wait on the EventWaitHandle.\n        ewh.WaitOne();\n\n        Console.WriteLine(&quot;Thread {0} exits.&quot;, data);\n        // Decrement the count of blocked threads.\n        Interlocked.Decrement(ref threadCount);\n\n        // After signaling ewh, the main thread blocks on\n        // clearCount until the signaled thread has \n        // decremented the count. Signal it now.\n        //\n        clearCount.Set();\n    }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_EventWaitHandle_SetAccessControl_System_Security_AccessControl_EventWaitHandleSecurity_\">\r\n    \r\n            <a id=\"System_Threading_EventWaitHandle_SetAccessControl_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">SetAccessControl(EventWaitHandleSecurity)</div>        \r\n          </div>\r\n    \r\n            <p>Sets the access control security for a named system event.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void SetAccessControl (System.Security.AccessControl.EventWaitHandleSecurity eventSecurity);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>eventSecurity</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlesecurity\" data-linktype=\"relative-path\">EventWaitHandleSecurity</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlesecurity\" data-linktype=\"relative-path\">EventWaitHandleSecurity</a> object that represents the access control security to be applied to the named system event.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>eventSecurity</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The user does not have <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">EventWaitHandleRights</a>.  </p>\n<p> -or-  </p>\n<p> The event was not opened with <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">EventWaitHandleRights</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.systemexception\" data-linktype=\"relative-path\">SystemException</a></div>\r\n                  </div>\r\n                  <p>The current <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> object does not represent a named system event.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.objectdisposedexception\" data-linktype=\"relative-path\">ObjectDisposedException</a></div>\r\n                  </div>\r\n                  <p>The <span class=\"xref\">stem.Threading.WaitHandle.Close*</span> method was previously called on this <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The user must have <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">System.Security.AccessControl.EventWaitHandleRights</a> rights to call this method, and the event must have been opened with the <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">System.Security.AccessControl.EventWaitHandleRights</a> flag.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates the cross-process behavior of a named system event with access control security. The example uses the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a> method overload to test for the existence of a named event.  </p>\n<p> If the event does not exist, it is created with initial ownership and access control security that denies the current user the right to use the event, but grants the right to read and change permissions on the event.  </p>\n<p> If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a>. The exception is caught, and the example uses the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_OpenExisting_System_String_System_Security_AccessControl_EventWaitHandleRights_\" data-linktype=\"relative-path\">OpenExisting(String,EventWaitHandleRights)</a> method overload to wait on the event with the rights needed to read and change the permissions.  </p>\n<p> After the permissions are changed, using the SetAccessControl method, the event is opened with the rights required to wait on it and signal it. If you run the compiled example from a third command window, the example runs using the new permissions.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.EventWaitHandle.ctor named 5#1\">using System;\nusing System.Threading;\nusing System.Security.AccessControl;\n\ninternal class Example\n{\n    internal static void Main()\n    {\n        const string ewhName = &quot;EventWaitHandleExample5&quot;;\n\n        EventWaitHandle ewh = null;\n        bool doesNotExist = false;\n        bool unauthorized = false;\n\n        // The value of this variable is set by the event\n        // constructor. It is true if the named system event was\n        // created, and false if the named event already existed.\n        //\n        bool wasCreated;\n\n        // Attempt to open the named event.\n        try\n        {\n            // Open the event with (EventWaitHandleRights.Synchronize\n            // | EventWaitHandleRights.Modify), to wait on and \n            // signal the named event.\n            //\n            ewh = EventWaitHandle.OpenExisting(ewhName);\n        }\n        catch (WaitHandleCannotBeOpenedException)\n        {\n            Console.WriteLine(&quot;Named event does not exist.&quot;);\n            doesNotExist = true;\n        }\n        catch (UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n            unauthorized = true;\n        }\n\n        // There are three cases: (1) The event does not exist.\n        // (2) The event exists, but the current user doesn&#39;t \n        // have access. (3) The event exists and the user has\n        // access.\n        //\n        if (doesNotExist)\n        {\n            // The event does not exist, so create it.\n\n            // Create an access control list (ACL) that denies the\n            // current user the right to wait on or signal the \n            // event, but allows the right to read and change\n            // security information for the event.\n            //\n            string user = Environment.UserDomainName + &quot;\\\\&quot;\n                + Environment.UserName;\n            EventWaitHandleSecurity ewhSec = \n                new EventWaitHandleSecurity();\n\n            EventWaitHandleAccessRule rule = \n                new EventWaitHandleAccessRule(user, \n                    EventWaitHandleRights.Synchronize | \n                    EventWaitHandleRights.Modify, \n                    AccessControlType.Deny);\n            ewhSec.AddAccessRule(rule);\n\n            rule = new EventWaitHandleAccessRule(user, \n                EventWaitHandleRights.ReadPermissions | \n                EventWaitHandleRights.ChangePermissions, \n                AccessControlType.Allow);\n            ewhSec.AddAccessRule(rule);\n\n            // Create an EventWaitHandle object that represents\n            // the system event named by the constant &#39;ewhName&#39;, \n            // initially signaled, with automatic reset, and with\n            // the specified security access. The Boolean value that \n            // indicates creation of the underlying system object\n            // is placed in wasCreated.\n            //\n            ewh = new EventWaitHandle(true, \n                EventResetMode.AutoReset, \n                ewhName, \n                out wasCreated, \n                ewhSec);\n\n            // If the named system event was created, it can be\n            // used by the current instance of this program, even \n            // though the current user is denied access. The current\n            // program owns the event. Otherwise, exit the program.\n            // \n            if (wasCreated)\n            {\n                Console.WriteLine(&quot;Created the named event.&quot;);\n            }\n            else\n            {\n                Console.WriteLine(&quot;Unable to create the event.&quot;);\n                return;\n            }\n        }\n        else if (unauthorized)\n        {\n            // Open the event to read and change the access control\n            // security. The access control security defined above\n            // allows the current user to do this.\n            //\n            try\n            {\n                ewh = EventWaitHandle.OpenExisting(ewhName, \n                    EventWaitHandleRights.ReadPermissions | \n                    EventWaitHandleRights.ChangePermissions);\n\n                // Get the current ACL. This requires \n                // EventWaitHandleRights.ReadPermissions.\n                EventWaitHandleSecurity ewhSec = ewh.GetAccessControl();\n                \n                string user = Environment.UserDomainName + &quot;\\\\&quot;\n                    + Environment.UserName;\n\n                // First, the rule that denied the current user \n                // the right to enter and release the event must\n                // be removed.\n                EventWaitHandleAccessRule rule = \n                    new EventWaitHandleAccessRule(user, \n                        EventWaitHandleRights.Synchronize | \n                        EventWaitHandleRights.Modify, \n                        AccessControlType.Deny);\n                ewhSec.RemoveAccessRule(rule);\n\n                // Now grant the user the correct rights.\n                // \n                rule = new EventWaitHandleAccessRule(user, \n                    EventWaitHandleRights.Synchronize | \n                    EventWaitHandleRights.Modify, \n                    AccessControlType.Allow);\n                ewhSec.AddAccessRule(rule);\n\n                // Update the ACL. This requires\n                // EventWaitHandleRights.ChangePermissions.\n                ewh.SetAccessControl(ewhSec);\n\n                Console.WriteLine(&quot;Updated event security.&quot;);\n\n                // Open the event with (EventWaitHandleRights.Synchronize \n                // | EventWaitHandleRights.Modify), the rights required\n                // to wait on and signal the event.\n                //\n                ewh = EventWaitHandle.OpenExisting(ewhName);\n\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;,\n                    ex.Message);\n                return;\n            }\n\n        }\n\n        // Wait on the event, and hold it until the program\n        // exits.\n        //\n        try\n        {\n            Console.WriteLine(&quot;Wait on the event.&quot;);\n            ewh.WaitOne();\n            Console.WriteLine(&quot;Event was signaled.&quot;);\n            Console.WriteLine(&quot;Press the Enter key to signal the event and exit.&quot;);\n            Console.ReadLine();\n        }\n        catch (UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n        }\n        finally\n        {\n            ewh.Set();\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.EventWaitHandle.ctor named 5#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Security::AccessControl;\nusing namespace System::Security::Permissions;\n\npublic ref class Example\n{\npublic:\n   [SecurityPermissionAttribute(SecurityAction::Demand,Flags=SecurityPermissionFlag::UnmanagedCode)]\n   static void Main()\n   {\n      String^ ewhName = L&quot;EventWaitHandleExample5&quot;;\n\n      EventWaitHandle^ ewh = nullptr;\n      bool doesNotExist = false;\n      bool unauthorized = false;\n      \n      // The value of this variable is set by the event\n      // constructor. It is true if the named system event was\n      // created, and false if the named event already existed.\n      //\n      bool wasCreated;\n      \n      // Attempt to open the named event.\n      try\n      {\n         // Open the event with (EventWaitHandleRights.Synchronize\n         // | EventWaitHandleRights.Modify), to wait on and\n         // signal the named event.\n         //\n         ewh = EventWaitHandle::OpenExisting( ewhName );\n      }\n      catch ( WaitHandleCannotBeOpenedException^ ) \n      {\n         Console::WriteLine( L&quot;Named event does not exist.&quot; );\n         doesNotExist = true;\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n         unauthorized = true;\n      }\n\n      // There are three cases: (1) The event does not exist.\n      // (2) The event exists, but the current user doesn&#39;t\n      // have access. (3) The event exists and the user has\n      // access.\n      //\n      if ( doesNotExist )\n      {\n         // The event does not exist, so create it.\n\n         // Create an access control list (ACL) that denies the\n         // current user the right to wait on or signal the\n         // event, but allows the right to read and change\n         // security information for the event.\n         //\n         String^ user = String::Concat( Environment::UserDomainName, L&quot;\\\\&quot;,\n            Environment::UserName );\n         EventWaitHandleSecurity^ ewhSec = gcnew EventWaitHandleSecurity;\n         //following constructor fails\n         EventWaitHandleAccessRule^ rule = gcnew EventWaitHandleAccessRule(\n            user,\n            static_cast&lt;EventWaitHandleRights&gt;(\n               EventWaitHandleRights::Synchronize | \n               EventWaitHandleRights::Modify),\n            AccessControlType::Deny );\n         ewhSec-&gt;AddAccessRule( rule );\n\n         rule = gcnew EventWaitHandleAccessRule( user,\n            static_cast&lt;EventWaitHandleRights&gt;(\n               EventWaitHandleRights::ReadPermissions | \n               EventWaitHandleRights::ChangePermissions),\n            AccessControlType::Allow );\n         ewhSec-&gt;AddAccessRule( rule );\n         \n         // Create an EventWaitHandle object that represents\n         // the system event named by the constant &#39;ewhName&#39;,\n         // initially signaled, with automatic reset, and with\n         // the specified security access. The Boolean value that\n         // indicates creation of the underlying system object\n         // is placed in wasCreated.\n         //\n         ewh = gcnew EventWaitHandle( true,\n            EventResetMode::AutoReset,\n            ewhName,\n            wasCreated,\n            ewhSec );\n         \n         // If the named system event was created, it can be\n         // used by the current instance of this program, even\n         // though the current user is denied access. The current\n         // program owns the event. Otherwise, exit the program.\n         //\n         if ( wasCreated )\n         {\n            Console::WriteLine( L&quot;Created the named event.&quot; );\n         }\n         else\n         {\n            Console::WriteLine( L&quot;Unable to create the event.&quot; );\n            return;\n         }\n      }\n      else if ( unauthorized )\n      {\n         // Open the event to read and change the access control\n         // security. The access control security defined above\n         // allows the current user to do this.\n         //\n         try\n         {\n            ewh = EventWaitHandle::OpenExisting( ewhName, \n               static_cast&lt;EventWaitHandleRights&gt;(\n                  EventWaitHandleRights::ReadPermissions |\n                  EventWaitHandleRights::ChangePermissions) );\n            \n            // Get the current ACL. This requires\n            // EventWaitHandleRights.ReadPermissions.\n            EventWaitHandleSecurity^ ewhSec = ewh-&gt;GetAccessControl();\n            String^ user = String::Concat( Environment::UserDomainName, L&quot;\\\\&quot;,\n               Environment::UserName );\n            \n            // First, the rule that denied the current user\n            // the right to enter and release the event must\n            // be removed.\n            EventWaitHandleAccessRule^ rule = gcnew EventWaitHandleAccessRule(\n               user,\n               static_cast&lt;EventWaitHandleRights&gt;(\n                  EventWaitHandleRights::Synchronize |\n                  EventWaitHandleRights::Modify),\n               AccessControlType::Deny );\n            ewhSec-&gt;RemoveAccessRule( rule );\n            \n            // Now grant the user the correct rights.\n            //\n            rule = gcnew EventWaitHandleAccessRule( user,\n               static_cast&lt;EventWaitHandleRights&gt;(\n                  EventWaitHandleRights::Synchronize |\n                  EventWaitHandleRights::Modify),\n               AccessControlType::Allow );\n            ewhSec-&gt;AddAccessRule( rule );\n            \n            // Update the ACL. This requires\n            // EventWaitHandleRights.ChangePermissions.\n            ewh-&gt;SetAccessControl( ewhSec );\n            Console::WriteLine( L&quot;Updated event security.&quot; );\n            \n            // Open the event with (EventWaitHandleRights.Synchronize\n            // | EventWaitHandleRights.Modify), the rights required\n            // to wait on and signal the event.\n            //\n            ewh = EventWaitHandle::OpenExisting( ewhName );\n         }\n         catch ( UnauthorizedAccessException^ ex ) \n         {\n            Console::WriteLine( L&quot;Unable to change permissions: {0}&quot;,\n               ex-&gt;Message );\n            return;\n         }\n\n      }\n      \n      // Wait on the event, and hold it until the program\n      // exits.\n      //\n      try\n      {\n         Console::WriteLine( L&quot;Wait on the event.&quot; );\n         ewh-&gt;WaitOne();\n         Console::WriteLine( L&quot;Event was signaled.&quot; );\n         Console::WriteLine( L&quot;Press the Enter key to signal the event and exit.&quot; );\n         Console::ReadLine();\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n      }\n      finally\n      {\n         ewh-&gt;Set();\n      }\n   }\n};\n\nint main()\n{\n   Example::Main();\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.EventWaitHandle.ctor named 5#1\">Imports System\nImports System.Threading\nImports System.Security.AccessControl\n\nFriend Class Example\n\n    &lt;MTAThread&gt; _\n    Friend Shared Sub Main()\n        Const ewhName As String = &quot;EventWaitHandleExample5&quot;\n\n        Dim ewh As EventWaitHandle = Nothing\n        Dim doesNotExist as Boolean = False\n        Dim unauthorized As Boolean = False\n\n        &#39; The value of this variable is set by the event\n        &#39; constructor. It is True if the named system event was\n        &#39; created, and False if the named event already existed.\n        &#39;\n        Dim wasCreated As Boolean\n\n        &#39; Attempt to open the named event.\n        Try\n            &#39; Open the event with (EventWaitHandleRights.Synchronize\n            &#39; Or EventWaitHandleRights.Modify), to wait on and \n            &#39; signal the named event.\n            &#39;\n            ewh = EventWaitHandle.OpenExisting(ewhName)\n        Catch ex As WaitHandleCannotBeOpenedException\n            Console.WriteLine(&quot;Named event does not exist.&quot;)\n            doesNotExist = True\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message)\n            unauthorized = True\n        End Try\n\n        &#39; There are three cases: (1) The event does not exist.\n        &#39; (2) The event exists, but the current user doesn&#39;t \n        &#39; have access. (3) The event exists and the user has\n        &#39; access.\n        &#39;\n        If doesNotExist Then\n            &#39; The event does not exist, so create it.\n\n            &#39; Create an access control list (ACL) that denies the\n            &#39; current user the right to wait on or signal the \n            &#39; event, but allows the right to read and change\n            &#39; security information for the event.\n            &#39;\n            Dim user As String = Environment.UserDomainName _ \n                &amp; &quot;\\&quot; &amp; Environment.UserName\n            Dim ewhSec As New EventWaitHandleSecurity()\n\n            Dim rule As New EventWaitHandleAccessRule(user, _\n                EventWaitHandleRights.Synchronize Or _\n                EventWaitHandleRights.Modify, _\n                AccessControlType.Deny)\n            ewhSec.AddAccessRule(rule)\n\n            rule = New EventWaitHandleAccessRule(user, _\n                EventWaitHandleRights.ReadPermissions Or _\n                EventWaitHandleRights.ChangePermissions, _\n                AccessControlType.Allow)\n            ewhSec.AddAccessRule(rule)\n\n            &#39; Create an EventWaitHandle object that represents\n            &#39; the system event named by the constant &#39;ewhName&#39;, \n            &#39; initially signaled, with automatic reset, and with\n            &#39; the specified security access. The Boolean value that \n            &#39; indicates creation of the underlying system object\n            &#39; is placed in wasCreated.\n            &#39;\n            ewh = New EventWaitHandle(True, _\n                EventResetMode.AutoReset, ewhName, _\n                wasCreated, ewhSec)\n\n            &#39; If the named system event was created, it can be\n            &#39; used by the current instance of this program, even \n            &#39; though the current user is denied access. The current\n            &#39; program owns the event. Otherwise, exit the program.\n            &#39; \n            If wasCreated Then\n                Console.WriteLine(&quot;Created the named event.&quot;)\n            Else\n                Console.WriteLine(&quot;Unable to create the event.&quot;)\n                Return\n            End If\n\n        ElseIf unauthorized Then\n\n            &#39; Open the event to read and change the access control\n            &#39; security. The access control security defined above\n            &#39; allows the current user to do this.\n            &#39;\n            Try\n                ewh = EventWaitHandle.OpenExisting(ewhName, _\n                    EventWaitHandleRights.ReadPermissions Or _\n                    EventWaitHandleRights.ChangePermissions)\n\n                &#39; Get the current ACL. This requires \n                &#39; EventWaitHandleRights.ReadPermissions.\n                Dim ewhSec As EventWaitHandleSecurity = _\n                    ewh.GetAccessControl()\n                \n                Dim user As String = Environment.UserDomainName _ \n                    &amp; &quot;\\&quot; &amp; Environment.UserName\n\n                &#39; First, the rule that denied the current user \n                &#39; the right to enter and release the event must\n                &#39; be removed.\n                Dim rule As New EventWaitHandleAccessRule(user, _\n                    EventWaitHandleRights.Synchronize Or _\n                    EventWaitHandleRights.Modify, _\n                    AccessControlType.Deny)\n                ewhSec.RemoveAccessRule(rule)\n\n                &#39; Now grant the user the correct rights.\n                &#39; \n                rule = New EventWaitHandleAccessRule(user, _\n                    EventWaitHandleRights.Synchronize Or _\n                    EventWaitHandleRights.Modify, _\n                    AccessControlType.Allow)\n                ewhSec.AddAccessRule(rule)\n\n                &#39; Update the ACL. This requires\n                &#39; EventWaitHandleRights.ChangePermissions.\n                ewh.SetAccessControl(ewhSec)\n\n                Console.WriteLine(&quot;Updated event security.&quot;)\n\n                &#39; Open the event with (EventWaitHandleRights.Synchronize \n                &#39; Or EventWaitHandleRights.Modify), the rights required\n                &#39; to wait on and signal the event.\n                &#39;\n                ewh = EventWaitHandle.OpenExisting(ewhName)\n\n            Catch ex As UnauthorizedAccessException\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;, _\n                    ex.Message)\n                Return\n            End Try\n\n        End If\n\n        &#39; Wait on the event, and hold it until the program\n        &#39; exits.\n        &#39;\n        Try\n            Console.WriteLine(&quot;Wait on the event.&quot;)\n            ewh.WaitOne()\n            Console.WriteLine(&quot;Event was signaled.&quot;)\n            Console.WriteLine(&quot;Press the Enter key to signal the event and exit.&quot;)\n            Console.ReadLine()\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, _\n                ex.Message)\n        Finally\n            ewh.Set()\n        End Try\n    End Sub \nEnd Class \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_EventWaitHandle_TryOpenExisting_System_String_System_Threading_EventWaitHandle__\">\r\n    \r\n            <a id=\"System_Threading_EventWaitHandle_TryOpenExisting_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">TryOpenExisting(String,EventWaitHandle)</div>        \r\n          </div>\r\n    \r\n            <p>Opens the specified named synchronization event, if it already exists, and returns a value that indicates whether the operation succeeded.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool TryOpenExisting (string name, out System.Threading.EventWaitHandle result);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of the system synchronization event to open.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>result</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>When this method returns, contains a <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> object that represents the named synchronization event if the call succeeded, or <code>null</code> if the call failed. This parameter is treated as uninitialized.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the named synchronization event was opened successfully; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is an empty string.  </p>\n<p> -or-  </p>\n<p> <code>name</code> is longer than 260 characters.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a></div>\r\n                  </div>\r\n                  <p>A Win32 error occurred.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The named event exists, but the user does not have the desired security access.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the named synchronization event does not exist, this method does not create it. To create the system event when it does not already exist, use one of the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle__ctor_\" data-linktype=\"relative-path\">EventWaitHandle</a> constructors that has a <code>name</code> parameter.  </p>\n<p> If you are uncertain whether a named synchronization event exists, use this method overload instead of the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a> method overload, which throws an exception if the synchronization event does not exist.  </p>\n<p> This method overload is equivalent to calling the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_TryOpenExisting_System_String_System_Security_AccessControl_EventWaitHandleRights_System_Threading_EventWaitHandle__\" data-linktype=\"relative-path\">TryOpenExisting(String,EventWaitHandleRights,EventWaitHandle)</a> method overload and specifying <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">System.Security.AccessControl.EventWaitHandleRights</a> and <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">System.Security.AccessControl.EventWaitHandleRights</a> rights, combined by using the bitwise OR operation. Specifying the <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">System.Security.AccessControl.EventWaitHandleRights</a> flag allows a thread to wait on the named system event, and specifying the <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">System.Security.AccessControl.EventWaitHandleRights</a> flag allows a thread to call the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_Set_\" data-linktype=\"relative-path\">Set</a> and <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_Reset_\" data-linktype=\"relative-path\">Reset</a> methods.  </p>\n<p> Multiple calls to this method that use the same value for <code>name</code> do not necessarily return the same <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> object, even though the objects that are returned represent the same named system event.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_EventWaitHandle_TryOpenExisting_System_String_System_Security_AccessControl_EventWaitHandleRights_System_Threading_EventWaitHandle__\">\r\n    \r\n            <a id=\"System_Threading_EventWaitHandle_TryOpenExisting_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">TryOpenExisting(String,EventWaitHandleRights,EventWaitHandle)</div>        \r\n          </div>\r\n    \r\n            <p>Opens the specified named synchronization event, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool TryOpenExisting (string name, System.Security.AccessControl.EventWaitHandleRights rights, out System.Threading.EventWaitHandle result);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of the system synchronization event to open.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>rights</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">EventWaitHandleRights</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitwise combination of the enumeration values that represent the desired security access.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>result</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>When this method returns, contains a <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> object that represents the named synchronization event if the call succeeded, or <code>null</code> if the call failed. This parameter is treated as uninitialized.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the named synchronization event was opened successfully; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is an empty string.  </p>\n<p> -or-  </p>\n<p> <code>name</code> is longer than 260 characters.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a></div>\r\n                  </div>\r\n                  <p>A Win32 error occurred.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The named event exists, but the user does not have the desired security access.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the named synchronization event does not exist, this method does not create it. To create the system event when it does not already exist, use one of the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle__ctor_\" data-linktype=\"relative-path\">EventWaitHandle</a> constructors that has a <code>name</code> parameter.  </p>\n<p> If you are uncertain whether a named synchronization event exists, use this method overload instead of the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_OpenExisting_System_String_System_Security_AccessControl_EventWaitHandleRights_\" data-linktype=\"relative-path\">OpenExisting(String,EventWaitHandleRights)</a> method overload, which throws an exception if the synchronization event does not exist.  </p>\n<p> The <code>rights</code> parameter must include the <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">System.Security.AccessControl.EventWaitHandleRights</a> flag to allow threads to wait on the event, and the <a class=\"xref\" href=\"system.security.accesscontrol.eventwaithandlerights\" data-linktype=\"relative-path\">System.Security.AccessControl.EventWaitHandleRights</a> flag to allow threads to call the <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_Set_\" data-linktype=\"relative-path\">Set</a> and <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_Reset_\" data-linktype=\"relative-path\">Reset</a> methods.  </p>\n<p> Multiple calls to this method that use the same value for <code>name</code> do not necessarily return the same <a class=\"xref\" href=\"system.threading.eventwaithandle\" data-linktype=\"relative-path\">EventWaitHandle</a> object, even though the objects that are returned represent the same named system event.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n","outputRootRelativePath":"./","pageMetadata":"<meta name=\"breadcrumb_path\" content=\"breadcrumb/toc1.json\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"fulldocset\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.fulldocset\">\r\n<meta name=\"ref_skeleton_gitcommit\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Threading.EventWaitHandle.yml\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Threading.EventWaitHandle.yml\">\r\n<meta name=\"APIName\" content=\"System.Threading.EventWaitHandle\">\r\n<meta name=\"APIName\" content=\"System.Threading.EventWaitHandle..ctor\">\r\n<meta name=\"APIName\" content=\"System.Threading.EventWaitHandle.GetAccessControl\">\r\n<meta name=\"APIName\" content=\"System.Threading.EventWaitHandle.OpenExisting\">\r\n<meta name=\"APIName\" content=\"System.Threading.EventWaitHandle.Reset\">\r\n<meta name=\"APIName\" content=\"System.Threading.EventWaitHandle.Set\">\r\n<meta name=\"APIName\" content=\"System.Threading.EventWaitHandle.SetAccessControl\">\r\n<meta name=\"APIName\" content=\"System.Threading.EventWaitHandle.TryOpenExisting\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-01 01:37 AM\">\r\n<meta name=\"document_id\" content=\"afc01ae9-d61a-7bfe-ad3a-02a7cdaf8a96\">\r\n<meta name=\"original_ecmaxml_local_path\" content=\"W:\\vejk\\s\\fulldocset\\xml\\System.Threading\\EventWaitHandle.xml\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Represents a thread synchronization event.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/System.Threading/toc1.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Threading.EventWaitHandle\">\r\n","rawMetadata":{"breadcrumb_path":"breadcrumb/toc.json","search.ms_sitename":"Docs","search.ms_docsetname":"fulldocset","version":null,"_op_canonicalUrlPrefix":"https://ppe.docs.microsoft.com/en-us/fulldotnet/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":true,"depot_name":"MSDN.fulldocset","_op_gitRefSkeletonCommitHistory":[{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"use plugin in master","commit_sha":"501959ac03e19ac52a27aa4c6bbeb980f8b11c8c","commit_date":"2017-03-01 09:31:20 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"switch from platform to version","commit_sha":"78cdacb5ca782478af490a6b30c3a2cb2b6b873e","commit_date":"2017-02-28 15:09:51 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"update platforms","commit_sha":"39ad5a8919a59afc93a79ac4bd8e07c3b471b37a","commit_date":"2017-02-28 10:38:59 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"checkin yml","commit_sha":"da161b792852497df7140d7768cee2eccd9cb43f","commit_date":"2017-02-28 09:36:15 +0800"}],"ref_skeleton_gitcommit":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Threading.EventWaitHandle.yml","original_ref_skeleton_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Threading.EventWaitHandle.yml","open_to_public_contributors":true,"api_name":["System.Threading.EventWaitHandle","System.Threading.EventWaitHandle..ctor","System.Threading.EventWaitHandle.GetAccessControl","System.Threading.EventWaitHandle.OpenExisting","System.Threading.EventWaitHandle.Reset","System.Threading.EventWaitHandle.Set","System.Threading.EventWaitHandle.SetAccessControl","System.Threading.EventWaitHandle.TryOpenExisting"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Threading.EventWaitHandle","System::Threading::EventWaitHandle","System.Threading.EventWaitHandle.#ctor","System::Threading::EventWaitHandle::#ctor","System.Threading.EventWaitHandle.GetAccessControl","System::Threading::EventWaitHandle::GetAccessControl","System.Threading.EventWaitHandle.OpenExisting","System::Threading::EventWaitHandle::OpenExisting","System.Threading.EventWaitHandle.Reset","System::Threading::EventWaitHandle::Reset","System.Threading.EventWaitHandle.Set","System::Threading::EventWaitHandle::Set","System.Threading.EventWaitHandle.SetAccessControl","System::Threading::EventWaitHandle::SetAccessControl","System.Threading.EventWaitHandle.TryOpenExisting","System::Threading::EventWaitHandle::TryOpenExisting"],"dev_langs":["csharp"],"updated_at":"2017-03-01 01:37 AM","document_id":"afc01ae9-d61a-7bfe-ad3a-02a7cdaf8a96","original_ecmaxml_local_path":"W:\\vejk\\s\\fulldocset\\xml\\System.Threading\\EventWaitHandle.xml","content_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/xml/System.Threading/EventWaitHandle.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"EventWaitHandle class | Microsoft Docs","_op_ogTitle":"EventWaitHandle class","description":"Represents a thread synchronization event.\n","toc_asset_id":"_splitted/System.Threading/toc.json","toc_rel":"_splitted/System.Threading/toc.json","source_url":"","ms.assetid":"System.Threading.EventWaitHandle","canonical_url":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.threading.eventwaithandle","_op_canonicalUrl":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.threading.eventwaithandle","fileRelativePath":"System.Threading.EventWaitHandle.html"},"themesRelativePathToOutputRoot":"_themes/"}