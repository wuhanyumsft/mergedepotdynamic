{"content":"    \r\n    <h1 id=\"System_Xml_Linq_XNode\">\r\n      <span class=\"lang-csharp\">XNode</span>\r\n        Class\r\n    </h1>\r\n    \r\n    \r\n    <nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n      <h3>In this Article</h3>\r\n    </nav><div class=\"summary\">\r\n    \t<p>Represents the abstract concept of a node (element, comment, document type, processing instruction, or text node) in the XML tree.</p>\n\r\n    </div><h2>Syntax</h2>\r\n    \r\n    \t<h3>Declaration</h3>\r\n    \t<pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract class XNode : System.Xml.Linq.XObject</code></pre>\r\n    \r\n    \r\n    \r\n    <h3>Inheritance Hierarchy</h3>\r\n    <ul class=\"inheritance\">\r\n        <li class=\"l0\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>\r\n          </div>\r\n        </li>\r\n        <li class=\"l1\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.xml.linq.xobject\" data-linktype=\"relative-path\">System.Xml.Linq.XObject</a>\r\n          </div>\r\n        </li>\r\n      <li class=\"l2\">\r\n        <div class=\"xref\">\r\n          <div class=\"lang-csharp\">XNode</div>\r\n        </div>\r\n      </li>\r\n    </ul>\r\n    \r\n      <div class=\"referencebox inheritedMembers\">\r\n        <h3>Inherited Members</h3>\r\n        <h4></h4>\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_AddAnnotation_System_Object_\" data-linktype=\"relative-path\">AddAnnotation(Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_Annotation_System_Type_\" data-linktype=\"relative-path\">Annotation(Type)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_Annotation__1\" data-linktype=\"relative-path\">Annotation&lt;T&gt;()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_Annotations_System_Type_\" data-linktype=\"relative-path\">Annotations(Type)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_Annotations__1\" data-linktype=\"relative-path\">Annotations&lt;T&gt;()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_BaseUri\" data-linktype=\"relative-path\">BaseUri</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_Changed\" data-linktype=\"relative-path\">Changed</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_Changing\" data-linktype=\"relative-path\">Changing</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_Document\" data-linktype=\"relative-path\">Document</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_NodeType\" data-linktype=\"relative-path\">NodeType</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_Parent\" data-linktype=\"relative-path\">Parent</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_RemoveAnnotations_System_Type_\" data-linktype=\"relative-path\">RemoveAnnotations(Type)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_RemoveAnnotations__1\" data-linktype=\"relative-path\">RemoveAnnotations&lt;T&gt;()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_System_Xml_IXmlLineInfo_HasLineInfo\" data-linktype=\"relative-path\">IXmlLineInfo.HasLineInfo()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_System_Xml_IXmlLineInfo_LineNumber\" data-linktype=\"relative-path\">IXmlLineInfo.LineNumber</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_System_Xml_IXmlLineInfo_LinePosition\" data-linktype=\"relative-path\">IXmlLineInfo.LinePosition</a>\r\n          </div>\r\n          \r\n      </div>\r\n    \r\n    \r\n      <h2>Remarks</h2>\r\n      <p>XNode is an abstract common base class for the following types:  </p>\n<ul>\n<li><a class=\"xref\" href=\"system.xml.linq.xcomment\" data-linktype=\"relative-path\">XComment</a>  \n</li>\n<li><a class=\"xref\" href=\"system.xml.linq.xcontainer\" data-linktype=\"relative-path\">XContainer</a>  \n</li>\n<li><a class=\"xref\" href=\"system.xml.linq.xdocumenttype\" data-linktype=\"relative-path\">XDocumentType</a>  \n</li>\n<li><a class=\"xref\" href=\"system.xml.linq.xprocessinginstruction\" data-linktype=\"relative-path\">XProcessingInstruction</a>  \n</li>\n<li><a class=\"xref\" href=\"system.xml.linq.xtext\" data-linktype=\"relative-path\">XText</a>  \n\n<p><a class=\"xref\" href=\"system.xml.linq.xcontainer\" data-linktype=\"relative-path\">XContainer</a> is an abstract common base class for the following types:  </p>\n</li>\n<li><a class=\"xref\" href=\"system.xml.linq.xdocument\" data-linktype=\"relative-path\">XDocument</a>  \n</li>\n<li><a class=\"xref\" href=\"system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a>  \n\n<p>Objects of classes that derive from <a class=\"xref\" href=\"system.xml.linq.xcontainer\" data-linktype=\"relative-path\">XContainer</a> can contain child nodes.  </p>\n</li>\n</ul>\n<div class=\"NOTE\"><h5>Note</h5><p> An <a class=\"xref\" href=\"system.xml.linq.xattribute\" data-linktype=\"relative-path\">XAttribute</a> is not an XNode. Attributes are maintained as a list of name/value pairs on an element.  </p>\n</div>\n<p> If you are writing a complex XML application, such as an XML editor or a word processor that stores content as XML, you will often work at the node level. Typical activities when working at the node level include adding nodes, deleting nodes, transforming nodes, and iterating through axes that return collections of nodes.</p>\n\r\n    \r\n    \r\n    <h2>Properties\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_DocumentOrderComparer\" data-linktype=\"self-bookmark\">DocumentOrderComparer</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a comparer that can compare the relative position of two nodes.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_EqualityComparer\" data-linktype=\"self-bookmark\">EqualityComparer</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a comparer that can compare two nodes for value equality.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_NextNode\" data-linktype=\"self-bookmark\">NextNode</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the next sibling node of this node.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_PreviousNode\" data-linktype=\"self-bookmark\">PreviousNode</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the previous sibling node of this node.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Methods\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_AddAfterSelf_System_Object_\" data-linktype=\"self-bookmark\">AddAfterSelf(Object)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Adds the specified content immediately after this node.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_AddAfterSelf_System_Object___\" data-linktype=\"self-bookmark\">AddAfterSelf(Object[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Adds the specified content immediately after this node.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_AddBeforeSelf_System_Object_\" data-linktype=\"self-bookmark\">AddBeforeSelf(Object)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Adds the specified content immediately before this node.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_AddBeforeSelf_System_Object___\" data-linktype=\"self-bookmark\">AddBeforeSelf(Object[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Adds the specified content immediately before this node.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_Ancestors\" data-linktype=\"self-bookmark\">Ancestors()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns a collection of the ancestor elements of this node.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_Ancestors_System_Xml_Linq_XName_\" data-linktype=\"self-bookmark\">Ancestors(XName)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns a filtered collection of the ancestor elements of this node. Only elements that have a matching <a class=\"xref\" href=\"system.xml.linq.xname\" data-linktype=\"relative-path\">XName</a> are included in the collection.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_CompareDocumentOrder_System_Xml_Linq_XNode_System_Xml_Linq_XNode_\" data-linktype=\"self-bookmark\">CompareDocumentOrder(XNode,XNode)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Compares two nodes to determine their relative XML document order.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_CreateReader\" data-linktype=\"self-bookmark\">CreateReader()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Creates an <a class=\"xref\" href=\"system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a> for this node.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_CreateReader_System_Xml_Linq_ReaderOptions_\" data-linktype=\"self-bookmark\">CreateReader(ReaderOptions)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Creates an <a class=\"xref\" href=\"system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a> with the options specified by the <code>readerOptions</code> parameter.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_DeepEquals_System_Xml_Linq_XNode_System_Xml_Linq_XNode_\" data-linktype=\"self-bookmark\">DeepEquals(XNode,XNode)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Compares the values of two nodes, including the values of all descendant nodes.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_ElementsAfterSelf\" data-linktype=\"self-bookmark\">ElementsAfterSelf()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns a collection of the sibling elements after this node, in document order.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_ElementsAfterSelf_System_Xml_Linq_XName_\" data-linktype=\"self-bookmark\">ElementsAfterSelf(XName)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns a filtered collection of the sibling elements after this node, in document order. Only elements that have a matching <a class=\"xref\" href=\"system.xml.linq.xname\" data-linktype=\"relative-path\">XName</a> are included in the collection.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_ElementsBeforeSelf\" data-linktype=\"self-bookmark\">ElementsBeforeSelf()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns a collection of the sibling elements before this node, in document order.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_ElementsBeforeSelf_System_Xml_Linq_XName_\" data-linktype=\"self-bookmark\">ElementsBeforeSelf(XName)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns a filtered collection of the sibling elements before this node, in document order. Only elements that have a matching <a class=\"xref\" href=\"system.xml.linq.xname\" data-linktype=\"relative-path\">XName</a> are included in the collection.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_IsAfter_System_Xml_Linq_XNode_\" data-linktype=\"self-bookmark\">IsAfter(XNode)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Determines if the current node appears after a specified node in terms of document order.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_IsBefore_System_Xml_Linq_XNode_\" data-linktype=\"self-bookmark\">IsBefore(XNode)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Determines if the current node appears before a specified node in terms of document order.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_NodesAfterSelf\" data-linktype=\"self-bookmark\">NodesAfterSelf()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns a collection of the sibling nodes after this node, in document order.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_NodesBeforeSelf\" data-linktype=\"self-bookmark\">NodesBeforeSelf()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns a collection of the sibling nodes before this node, in document order.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_ReadFrom_System_Xml_XmlReader_\" data-linktype=\"self-bookmark\">ReadFrom(XmlReader)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Creates an <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> from an <a class=\"xref\" href=\"system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_Remove\" data-linktype=\"self-bookmark\">Remove()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Removes this node from its parent.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_ReplaceWith_System_Object_\" data-linktype=\"self-bookmark\">ReplaceWith(Object)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Replaces this node with the specified content.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_ReplaceWith_System_Object___\" data-linktype=\"self-bookmark\">ReplaceWith(Object[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Replaces this node with the specified content.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_ToString\" data-linktype=\"self-bookmark\">ToString()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns the indented XML for this node.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_ToString_System_Xml_Linq_SaveOptions_\" data-linktype=\"self-bookmark\">ToString(SaveOptions)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns the XML for this node, optionally disabling formatting.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Xml_Linq_XNode_WriteTo_System_Xml_XmlWriter_\" data-linktype=\"self-bookmark\">WriteTo(XmlWriter)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Writes this node to an <a class=\"xref\" href=\"system.xml.xmlwriter\" data-linktype=\"relative-path\">XmlWriter</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"properties\">\r\n        <h2>Properties\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_DocumentOrderComparer\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_DocumentOrderComparer_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">DocumentOrderComparer</div>        \r\n          </div>\r\n    \r\n            <p>Gets a comparer that can compare the relative position of two nodes.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Xml.Linq.XNodeDocumentOrderComparer DocumentOrderComparer { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.xml.linq.xnodedocumentordercomparer\" data-linktype=\"relative-path\">XNodeDocumentOrderComparer</a></div>\r\n                  </div>\r\n                  <p>An <a class=\"xref\" href=\"system.xml.linq.xnodedocumentordercomparer\" data-linktype=\"relative-path\">XNodeDocumentOrderComparer</a> that can compare the relative position of two nodes.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This property is primarily used internally for implementing the &lt;xref:System.Xml.Linq.Extensions.InDocumentOrder%2A&gt; extension method. The recommended approach is to use that extension method instead of using this property directly.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an XML tree with some elements. It then creates a <a class=\"xref\" href=\"system.collections.generic.list-1\" data-linktype=\"relative-path\">List&lt;T&gt;</a> of <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> that contains some elements from the XML tree at random. It sorts the list, using this property to retrieve a <a class=\"xref\" href=\"system.xml.linq.xnodedocumentordercomparer\" data-linktype=\"relative-path\">XNodeDocumentOrderComparer</a>, which implements the <a class=\"xref\" href=\"system.collections.icomparer\" data-linktype=\"relative-path\">System.Collections.IComparer</a> and <a class=\"xref\" href=\"system.collections.generic.icomparer-1\" data-linktype=\"relative-path\">System.Collections.Generic.IComparer&lt;T&gt;</a> interfaces.  </p>\n<pre><code class=\"lang-c#\">\n                XElement xmlTree = new XElement(&quot;Root&quot;,  \n    new XElement(&quot;Child1&quot;, 1),  \n    new XElement(&quot;Child2&quot;, 2),  \n    new XElement(&quot;Child3&quot;, 3),  \n    new XElement(&quot;Child4&quot;, 4),  \n    new XElement(&quot;Child5&quot;, 5)  \n);  \n\nList&lt;XNode&gt; nodeList = new List&lt;XNode&gt;();  \nnodeList.Add(xmlTree.Element(&quot;Child5&quot;));  \nnodeList.Add(xmlTree.Element(&quot;Child3&quot;));  \nnodeList.Add(xmlTree.Element(&quot;Child1&quot;));  \n\n// Sort nodes in document order.  \nnodeList.Sort(XNode.DocumentOrderComparer);  \n\nforeach (XElement el in nodeList)  \n    Console.WriteLine(el);  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim xmlTree As XElement = _   \n        &lt;Root&gt;  \n            &lt;Child1&gt;1&lt;/Child1&gt;  \n            &lt;Child2&gt;2&lt;/Child2&gt;  \n            &lt;Child3&gt;3&lt;/Child3&gt;  \n            &lt;Child4&gt;4&lt;/Child4&gt;  \n            &lt;Child5&gt;5&lt;/Child5&gt;  \n        &lt;/Root&gt;  \n\nDim nodeList As List(Of XNode) = New List(Of XNode)()  \nnodeList.Add(xmlTree.Element(&quot;Child5&quot;))  \nnodeList.Add(xmlTree.Element(&quot;Child3&quot;))  \nnodeList.Add(xmlTree.Element(&quot;Child1&quot;))  \n\n&#39; Sort nodes in document order.  \nnodeList.Sort(XNode.DocumentOrderComparer)  \n\nFor Each el In nodeList  \n    Console.WriteLine(el)  \nNext  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code>\n                &lt;Child1&gt;1&lt;/Child1&gt;  \n&lt;Child3&gt;3&lt;/Child3&gt;  \n&lt;Child5&gt;5&lt;/Child5&gt;  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_EqualityComparer\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_EqualityComparer_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">EqualityComparer</div>        \r\n          </div>\r\n    \r\n            <p>Gets a comparer that can compare two nodes for value equality.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Xml.Linq.XNodeEqualityComparer EqualityComparer { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.xml.linq.xnodeequalitycomparer\" data-linktype=\"relative-path\">XNodeEqualityComparer</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"system.xml.linq.xnodeequalitycomparer\" data-linktype=\"relative-path\">XNodeEqualityComparer</a> that can compare two nodes for value equality.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses this property to retrieve an <a class=\"xref\" href=\"system.xml.linq.xnodeequalitycomparer\" data-linktype=\"relative-path\">XNodeEqualityComparer</a>, which implements the <a class=\"xref\" href=\"system.collections.iequalitycomparer\" data-linktype=\"relative-path\">System.Collections.IEqualityComparer</a> and <a class=\"xref\" href=\"system.collections.generic.iequalitycomparer-1\" data-linktype=\"relative-path\">System.Collections.Generic.IEqualityComparer&lt;T&gt;</a> interfaces. It creates a dictionary that uses this property.  </p>\n<pre><code class=\"lang-c#\">\n                XElement xmlTree = new XElement(&quot;Root&quot;,  \n    new XElement(&quot;Child1&quot;, 1),  \n    new XElement(&quot;Child2&quot;, 2),  \n    new XElement(&quot;Child3&quot;, 3),  \n    new XElement(&quot;Child4&quot;, 4),  \n    new XElement(&quot;Child5&quot;, 5)  \n);  \n\nDictionary&lt;XNode, string&gt; nodeDictionary = new Dictionary&lt;XNode, string&gt;(XNode.EqualityComparer);  \nnodeDictionary.Add(xmlTree.Element(&quot;Child5&quot;), &quot;Child 5 Information&quot;);  \nnodeDictionary.Add(xmlTree.Element(&quot;Child3&quot;), &quot;Child 3 Information&quot;);  \nnodeDictionary.Add(xmlTree.Element(&quot;Child1&quot;), &quot;Child 1 Information&quot;);  \n\nstring str = nodeDictionary[xmlTree.Element(&quot;Child3&quot;)];  \nConsole.WriteLine(str);  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim xmlTree As XElement = _   \n        &lt;Root&gt;  \n            &lt;Child1&gt;1&lt;/Child1&gt;  \n            &lt;Child2&gt;2&lt;/Child2&gt;  \n            &lt;Child3&gt;3&lt;/Child3&gt;  \n            &lt;Child4&gt;4&lt;/Child4&gt;  \n            &lt;Child5&gt;5&lt;/Child5&gt;  \n        &lt;/Root&gt;  \n\nDim nodeDictionary As Dictionary(Of XNode, String) = New Dictionary(Of XNode, String)(XNode.EqualityComparer)  \nnodeDictionary.Add(xmlTree.Element(&quot;Child5&quot;), &quot;Child 5 Information&quot;)  \nnodeDictionary.Add(xmlTree.Element(&quot;Child3&quot;), &quot;Child 3 Information&quot;)  \nnodeDictionary.Add(xmlTree.Element(&quot;Child1&quot;), &quot;Child 1 Information&quot;)  \n\nDim str As String = nodeDictionary(xmlTree.Element(&quot;Child3&quot;))  \nConsole.WriteLine(str)  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code>\nChild 3 Information  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_NextNode\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_NextNode_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">NextNode</div>        \r\n          </div>\r\n    \r\n            <p>Gets the next sibling node of this node.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Xml.Linq.XNode NextNode { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a></div>\r\n                  </div>\r\n                  <p>The <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> that contains the next sibling node.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If this <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> does not have a parent, or if there is no next node, this property returns <code>null</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses this property to loop through nodes.  </p>\n<pre><code class=\"lang-c#\">\n                XElement xmlTree = new XElement(&quot;Root&quot;,  \n    new XElement(&quot;Child1&quot;, 1),  \n    new XText(&quot;Some Text&quot;),  \n    new XElement(&quot;Child2&quot;,  \n        2,  \n        new XElement(&quot;GrandChild&quot;, &quot;GrandChild Content&quot;)  \n    ),  \n    new XComment(&quot;a comment&quot;),  \n    new XElement(&quot;Child3&quot;)  \n);  \nXNode node = xmlTree.Element(&quot;Child2&quot;);  \ndo {  \n    StringBuilder sb = new StringBuilder();  \n    sb.Append(String.Format(&quot;NodeType: {0}&quot;, node.NodeType.ToString().PadRight(10)));  \n    switch (node.NodeType)  \n    {  \n        case XmlNodeType.Text:  \n            sb.Append((node as XText).Value);  \n            break;  \n        case XmlNodeType.Element:  \n            sb.Append((node as XElement).Name);  \n            break;  \n        case XmlNodeType.Comment:  \n            sb.Append((node as XComment).Value);  \n            break;  \n    }  \n    Console.WriteLine(sb.ToString());  \n}  \nwhile ((node = node.NextNode) != null);  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim xmlTree As XElement = _   \n        &lt;Root&gt;  \n            &lt;Child1&gt;1&lt;/Child1&gt;Some Text  \n            &lt;Child2&gt;2  \n                &lt;GrandChild&gt;GrandChild Content&lt;/GrandChild&gt;  \n            &lt;/Child2&gt;  \n            &lt;!--a comment--&gt;  \n            &lt;Child3&gt;3&lt;/Child3&gt;  \n        &lt;/Root&gt;  \n\nDim node As XNode = xmlTree.Element(&quot;Child2&quot;)  \nDo  \n    Dim sb As StringBuilder = New StringBuilder()  \n    sb.Append(String.Format(&quot;NodeType: {0}&quot;, node.NodeType.ToString().PadRight(10)))  \n    Select Case node.NodeType  \n        Case XmlNodeType.Text  \n            sb.Append(DirectCast(node, XText).Value)  \n        Case XmlNodeType.Element  \n            sb.Append(DirectCast(node, XElement).Name)  \n        Case XmlNodeType.Comment  \n            sb.Append(DirectCast(node, XComment).Value)  \n    End Select  \n    Console.WriteLine(sb.ToString())  \n\n    node = node.NextNode  \nLoop While (Not (node Is Nothing))  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code>\n                NodeType: Element   Child2  \nNodeType: Comment   a comment  \nNodeType: Element   Child3  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_PreviousNode\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_PreviousNode_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">PreviousNode</div>        \r\n          </div>\r\n    \r\n            <p>Gets the previous sibling node of this node.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Xml.Linq.XNode PreviousNode { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a></div>\r\n                  </div>\r\n                  <p>The <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> that contains the previous sibling node.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If this <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> does not have a parent, or if there is no previous node, this property returns <code>null</code>.  </p>\n<p> The <a class=\"xref\" href=\"system.xml.linq.xcontainer\" data-linktype=\"relative-path\">XContainer</a> stores its child nodes as a singly-linked list of <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> objects. This means that the PreviousNode property must traverse the list of direct child nodes under the parent container. Therefore, using this property might affect your performance.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses this property to loop through nodes.  </p>\n<pre><code class=\"lang-c#\">\n                XElement xmlTree = new XElement(&quot;Root&quot;,  \n    new XElement(&quot;Child1&quot;, 1),  \n    new XText(&quot;Some Text&quot;),  \n    new XElement(&quot;Child2&quot;,  \n        2,  \n        new XElement(&quot;GrandChild&quot;, &quot;GrandChild Content&quot;)  \n    ),  \n    new XComment(&quot;a comment&quot;),  \n    new XElement(&quot;Child3&quot;)  \n);  \nXNode node = xmlTree.Element(&quot;Child2&quot;);  \ndo {  \n    StringBuilder sb = new StringBuilder();  \n    sb.Append(String.Format(&quot;NodeType: {0}&quot;, node.NodeType.ToString().PadRight(10)));  \n    switch (node.NodeType)  \n    {  \n        case XmlNodeType.Text:  \n            sb.Append((node as XText).Value);  \n            break;  \n        case XmlNodeType.Element:  \n            sb.Append((node as XElement).Name);  \n            break;  \n        case XmlNodeType.Comment:  \n            sb.Append((node as XComment).Value);  \n            break;  \n    }  \n    Console.WriteLine(sb.ToString());  \n}  \nwhile ((node = node.PreviousNode) != null);  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim xmlTree As XElement = _  \n    &lt;Root&gt;  \n        &lt;Child1&gt;1&lt;/Child1&gt;Some Text&lt;Child2&gt;2  \n            &lt;GrandChild&gt;GrandChild Content&lt;/GrandChild&gt;  \n        &lt;/Child2&gt;  \n        &lt;!--a comment--&gt;  \n        &lt;Child3&gt;3&lt;/Child3&gt;  \n    &lt;/Root&gt;  \n\nDim node As XNode = xmlTree.Element(&quot;Child2&quot;)  \nDo  \n    Dim sb As StringBuilder = New StringBuilder()  \n    sb.Append(String.Format(&quot;NodeType: {0}&quot;, node.NodeType.ToString().PadRight(10)))  \n    Select Case node.NodeType  \n        Case XmlNodeType.Text  \n            sb.Append(DirectCast(node, XText).Value)  \n        Case XmlNodeType.Element  \n            sb.Append(DirectCast(node, XElement).Name)  \n        Case XmlNodeType.Comment  \n            sb.Append(DirectCast(node, XComment).Value)  \n    End Select  \n    Console.WriteLine(sb.ToString())  \n\n    node = node.PreviousNode  \nLoop While (Not (node Is Nothing))  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code>\n                NodeType: Element   Child2  \nNodeType: Text      Some Text  \nNodeType: Element   Child1  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"methods\">\r\n        <h2>Methods\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_AddAfterSelf_System_Object_\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_AddAfterSelf_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">AddAfterSelf(Object)</div>        \r\n          </div>\r\n    \r\n            <p>Adds the specified content immediately after this node.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void AddAfterSelf (object content);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>content</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A content object that contains simple content or a collection of content objects to be added after this node.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The parent is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>For details about the valid content that can be passed to this method, see <a href=\"../Topic/Valid%20Content%20of%20XElement%20and%20XDocument%20Objects1.md\" data-linktype=\"relative-path\">Valid Content of XElement and XDocument Objects</a>.  </p>\n<p> <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_Changing\" data-linktype=\"relative-path\">Changing</a> events.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses this method to add an element into the tree.  </p>\n<pre><code class=\"lang-c#\">\n                XElement xmlTree = new XElement(&quot;Root&quot;,  \n    new XElement(&quot;Child1&quot;, 1),  \n    new XElement(&quot;Child2&quot;, 2),  \n    new XElement(&quot;Child3&quot;, 3),  \n    new XElement(&quot;Child4&quot;, 4),  \n    new XElement(&quot;Child5&quot;, 5)  \n);  \nXElement child1 = xmlTree.Element(&quot;Child1&quot;);  \nchild1.AddAfterSelf(  \n    new XElement(&quot;NewChild&quot;, 10)  \n);  \nConsole.WriteLine(xmlTree);  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim xmlTree As XElement = _   \n        &lt;Root&gt;  \n            &lt;Child1&gt;1&lt;/Child1&gt;  \n            &lt;Child2&gt;2&lt;/Child2&gt;  \n            &lt;Child3&gt;3&lt;/Child3&gt;  \n            &lt;Child4&gt;4&lt;/Child4&gt;  \n            &lt;Child5&gt;5&lt;/Child5&gt;  \n        &lt;/Root&gt;  \n\nDim child1 As XElement = xmlTree.&lt;Child1&gt;(0)  \nchild1.AddAfterSelf(New XElement(&quot;NewChild&quot;, 10))  \nConsole.WriteLine(xmlTree)  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code class=\"lang-xml\">\n                &lt;Root&gt;  \n  &lt;Child1&gt;1&lt;/Child1&gt;  \n  &lt;NewChild&gt;10&lt;/NewChild&gt;  \n  &lt;Child2&gt;2&lt;/Child2&gt;  \n  &lt;Child3&gt;3&lt;/Child3&gt;  \n  &lt;Child4&gt;4&lt;/Child4&gt;  \n  &lt;Child5&gt;5&lt;/Child5&gt;  \n&lt;/Root&gt;  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_AddAfterSelf_System_Object___\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_AddAfterSelf_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">AddAfterSelf(Object[])</div>        \r\n          </div>\r\n    \r\n            <p>Adds the specified content immediately after this node.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void AddAfterSelf (object[] content);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>content</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A parameter list of content objects.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The parent is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>For details about the valid content that can be passed to this method, see <a href=\"../Topic/Valid%20Content%20of%20XElement%20and%20XDocument%20Objects1.md\" data-linktype=\"relative-path\">Valid Content of XElement and XDocument Objects</a>.  </p>\n<p> This method will raise the <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_Changed\" data-linktype=\"relative-path\">Changed</a> and the <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_Changing\" data-linktype=\"relative-path\">Changing</a> events.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses a LINQ query to create an <a class=\"xref\" href=\"system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable&lt;T&gt;</a> of <a class=\"xref\" href=\"system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a>, which it then passes to this method. This adds the results of a query to the tree in the desired location.  </p>\n<pre><code class=\"lang-c#\">\n                XElement srcTree = new XElement(&quot;Root&quot;,  \n    new XElement(&quot;Element1&quot;, 1),  \n    new XElement(&quot;Element2&quot;, 2),  \n    new XElement(&quot;Element3&quot;, 3),  \n    new XElement(&quot;Element4&quot;, 4),  \n    new XElement(&quot;Element5&quot;, 5)  \n);  \nXElement xmlTree = new XElement(&quot;Root&quot;,  \n    new XElement(&quot;Child1&quot;, 1),  \n    new XElement(&quot;Child2&quot;, 2),  \n    new XElement(&quot;Child3&quot;, 3),  \n    new XElement(&quot;Child4&quot;, 4),  \n    new XElement(&quot;Child5&quot;, 5)  \n);  \nXElement child1 = xmlTree.Element(&quot;Child1&quot;);  \nchild1.AddAfterSelf(  \n    from el in srcTree.Elements()  \n    where (int)el &gt; 3  \n    select el  \n);  \nConsole.WriteLine(xmlTree);  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim srcTree As XElement = _   \n        &lt;Root&gt;  \n            &lt;Element1&gt;1&lt;/Element1&gt;  \n            &lt;Element2&gt;2&lt;/Element2&gt;  \n            &lt;Element3&gt;3&lt;/Element3&gt;  \n            &lt;Element4&gt;4&lt;/Element4&gt;  \n            &lt;Element5&gt;5&lt;/Element5&gt;  \n        &lt;/Root&gt;  \n\nDim xmlTree As XElement = _   \n        &lt;Root&gt;  \n            &lt;Child1&gt;1&lt;/Child1&gt;  \n            &lt;Child2&gt;2&lt;/Child2&gt;  \n            &lt;Child3&gt;3&lt;/Child3&gt;  \n            &lt;Child4&gt;4&lt;/Child4&gt;  \n            &lt;Child5&gt;5&lt;/Child5&gt;  \n        &lt;/Root&gt;  \n\nDim child1 As XElement = xmlTree.&lt;Child1&gt;(0)  \nchild1.AddAfterSelf( _  \n    From el In srcTree.Elements() _  \n    Where CInt(el) &gt; 3 _  \n    Select el)  \nConsole.WriteLine(xmlTree)  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code class=\"lang-xml\">\n                &lt;Root&gt;  \n  &lt;Child1&gt;1&lt;/Child1&gt;  \n  &lt;Element4&gt;4&lt;/Element4&gt;  \n  &lt;Element5&gt;5&lt;/Element5&gt;  \n  &lt;Child2&gt;2&lt;/Child2&gt;  \n  &lt;Child3&gt;3&lt;/Child3&gt;  \n  &lt;Child4&gt;4&lt;/Child4&gt;  \n  &lt;Child5&gt;5&lt;/Child5&gt;  \n&lt;/Root&gt;  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_AddBeforeSelf_System_Object_\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_AddBeforeSelf_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">AddBeforeSelf(Object)</div>        \r\n          </div>\r\n    \r\n            <p>Adds the specified content immediately before this node.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void AddBeforeSelf (object content);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>content</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A content object that contains simple content or a collection of content objects to be added before this node.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The parent is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>For details about the valid content that can be passed to this method, see <a href=\"../Topic/Valid%20Content%20of%20XElement%20and%20XDocument%20Objects1.md\" data-linktype=\"relative-path\">Valid Content of XElement and XDocument Objects</a>.  </p>\n<p> This method will raise the <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_Changed\" data-linktype=\"relative-path\">Changed</a> and the <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_Changing\" data-linktype=\"relative-path\">Changing</a> events.  </p>\n<p> The <a class=\"xref\" href=\"system.xml.linq.xcontainer\" data-linktype=\"relative-path\">XContainer</a> stores its child nodes as a singly-linked list of <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> objects. This means that the <a class=\"xref\" href=\"system.xml.linq.xnode#System_Xml_Linq_XNode_AddBeforeSelf_\" data-linktype=\"relative-path\">AddBeforeSelf</a> method must traverse the list of direct child nodes under the parent container. Therefore, using this method might  affect your performance.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses this method to add an element into the tree.  </p>\n<pre><code class=\"lang-c#\">\n                XElement xmlTree = new XElement(&quot;Root&quot;,  \n    new XElement(&quot;Child1&quot;, 1),  \n    new XElement(&quot;Child2&quot;, 2),  \n    new XElement(&quot;Child3&quot;, 3),  \n    new XElement(&quot;Child4&quot;, 4),  \n    new XElement(&quot;Child5&quot;, 5)  \n);  \nXElement child1 = xmlTree.Element(&quot;Child1&quot;);  \nchild1.AddBeforeSelf(  \n    new XElement(&quot;NewChild&quot;, 10)  \n);  \nConsole.WriteLine(xmlTree);  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim xmlTree As XElement = _   \n        &lt;Root&gt;  \n            &lt;Child1&gt;1&lt;/Child1&gt;  \n            &lt;Child2&gt;2&lt;/Child2&gt;  \n            &lt;Child3&gt;3&lt;/Child3&gt;  \n            &lt;Child4&gt;4&lt;/Child4&gt;  \n            &lt;Child5&gt;5&lt;/Child5&gt;  \n        &lt;/Root&gt;  \n\nDim child1 As XElement = xmlTree.&lt;Child1&gt;(0)  \nchild1.AddBeforeSelf(New XElement(&quot;NewChild&quot;, 10))  \nConsole.WriteLine(xmlTree)  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code class=\"lang-xml\">\n                &lt;Root&gt;  \n  &lt;NewChild&gt;10&lt;/NewChild&gt;  \n  &lt;Child1&gt;1&lt;/Child1&gt;  \n  &lt;Child2&gt;2&lt;/Child2&gt;  \n  &lt;Child3&gt;3&lt;/Child3&gt;  \n  &lt;Child4&gt;4&lt;/Child4&gt;  \n  &lt;Child5&gt;5&lt;/Child5&gt;  \n&lt;/Root&gt;  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_AddBeforeSelf_System_Object___\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_AddBeforeSelf_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">AddBeforeSelf(Object[])</div>        \r\n          </div>\r\n    \r\n            <p>Adds the specified content immediately before this node.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void AddBeforeSelf (object[] content);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>content</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A parameter list of content objects.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The parent is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>For details about the valid content that can be passed to this method, see <a href=\"../Topic/Valid%20Content%20of%20XElement%20and%20XDocument%20Objects1.md\" data-linktype=\"relative-path\">Valid Content of XElement and XDocument Objects</a>.  </p>\n<p> This method will raise the <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_Changed\" data-linktype=\"relative-path\">Changed</a> and the <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_Changing\" data-linktype=\"relative-path\">Changing</a> events.  </p>\n<p> The <a class=\"xref\" href=\"system.xml.linq.xcontainer\" data-linktype=\"relative-path\">XContainer</a> stores its child nodes as a singly-linked list of <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> objects. This means that the <a class=\"xref\" href=\"system.xml.linq.xnode#System_Xml_Linq_XNode_AddBeforeSelf_\" data-linktype=\"relative-path\">AddBeforeSelf</a> method must traverse the list of direct child nodes under the parent container. Therefore, using this function might affect your performance.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses a LINQ query to create an <a class=\"xref\" href=\"system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable&lt;T&gt;</a> of <a class=\"xref\" href=\"system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a>, which it then passes to this method. This adds the results of a query to the tree in the desired location.  </p>\n<pre><code class=\"lang-c#\">\n                XElement srcTree = new XElement(&quot;Root&quot;,  \n    new XElement(&quot;Element1&quot;, 1),  \n    new XElement(&quot;Element2&quot;, 2),  \n    new XElement(&quot;Element3&quot;, 3),  \n    new XElement(&quot;Element4&quot;, 4),  \n    new XElement(&quot;Element5&quot;, 5)  \n);  \nXElement xmlTree = new XElement(&quot;Root&quot;,  \n    new XElement(&quot;Child1&quot;, 1),  \n    new XElement(&quot;Child2&quot;, 2),  \n    new XElement(&quot;Child3&quot;, 3),  \n    new XElement(&quot;Child4&quot;, 4),  \n    new XElement(&quot;Child5&quot;, 5)  \n);  \nXElement child1 = xmlTree.Element(&quot;Child1&quot;);  \nchild1.AddBeforeSelf(  \n    from el in srcTree.Elements()  \n    where (int)el &gt; 3  \n    select el  \n);  \nConsole.WriteLine(xmlTree);  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim srcTree As XElement = _   \n        &lt;Root&gt;  \n            &lt;Element1&gt;1&lt;/Element1&gt;  \n            &lt;Element2&gt;2&lt;/Element2&gt;  \n            &lt;Element3&gt;3&lt;/Element3&gt;  \n            &lt;Element4&gt;4&lt;/Element4&gt;  \n            &lt;Element5&gt;5&lt;/Element5&gt;  \n        &lt;/Root&gt;  \n\nDim xmlTree As XElement = _   \n        &lt;Root&gt;  \n            &lt;Child1&gt;1&lt;/Child1&gt;  \n            &lt;Child2&gt;2&lt;/Child2&gt;  \n            &lt;Child3&gt;3&lt;/Child3&gt;  \n            &lt;Child4&gt;4&lt;/Child4&gt;  \n            &lt;Child5&gt;5&lt;/Child5&gt;  \n        &lt;/Root&gt;  \n\nDim child1 As XElement = xmlTree.&lt;Child1&gt;(0)  \nchild1.AddBeforeSelf( _  \n    From el In srcTree.Elements() _  \n    Where CInt(el) &gt; 3 _  \n    Select el)  \n\nConsole.WriteLine(xmlTree)  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code class=\"lang-xml\">\n                &lt;Root&gt;  \n  &lt;Element4&gt;4&lt;/Element4&gt;  \n  &lt;Element5&gt;5&lt;/Element5&gt;  \n  &lt;Child1&gt;1&lt;/Child1&gt;  \n  &lt;Child2&gt;2&lt;/Child2&gt;  \n  &lt;Child3&gt;3&lt;/Child3&gt;  \n  &lt;Child4&gt;4&lt;/Child4&gt;  \n  &lt;Child5&gt;5&lt;/Child5&gt;  \n&lt;/Root&gt;  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_Ancestors\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_Ancestors_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Ancestors()</div>        \r\n          </div>\r\n    \r\n            <p>Returns a collection of the ancestor elements of this node.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Ancestors ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable</a>&lt;<a class=\"xref\" href=\"system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a>&gt;</div>\r\n                  </div>\r\n                  <p>An <span class=\"xref\">stem.Collections.Generic.IEnumerable`1</span> of <a class=\"xref\" href=\"system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a> of the ancestor elements of this node.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method does not return itself in the results.  </p>\n<p> The nodes in the returned collection are in reverse document order.  </p>\n<p> This method uses deferred execution.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses this method to enumerate the ancestors of a node.  </p>\n<pre><code class=\"lang-c#\">\n                XElement xmlTree = new XElement(&quot;Root&quot;,  \n    new XElement(&quot;Child&quot;,   \n        new XElement(&quot;GrandChild&quot;, &quot;content&quot;)  \n    )  \n);  \nIEnumerable&lt;XElement&gt; grandChild = xmlTree.Descendants(&quot;GrandChild&quot;);  \nforeach (XElement el in grandChild.Ancestors())  \n    Console.WriteLine(el.Name);  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim xmlTree As XElement = _   \n        &lt;Root&gt;  \n            &lt;Child&gt;  \n                &lt;GrandChild&gt;content&lt;/GrandChild&gt;  \n            &lt;/Child&gt;  \n        &lt;/Root&gt;  \n\nDim grandChild As IEnumerable(Of XElement) = xmlTree...&lt;GrandChild&gt;  \nFor Each el In grandChild.Ancestors()  \n    Console.WriteLine(el.Name)  \nNext  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code>\n                Child  \nRoot  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_Ancestors_System_Xml_Linq_XName_\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_Ancestors_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Ancestors(XName)</div>        \r\n          </div>\r\n    \r\n            <p>Returns a filtered collection of the ancestor elements of this node. Only elements that have a matching <a class=\"xref\" href=\"system.xml.linq.xname\" data-linktype=\"relative-path\">XName</a> are included in the collection.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Ancestors (System.Xml.Linq.XName name);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.xml.linq.xname\" data-linktype=\"relative-path\">XName</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.xml.linq.xname\" data-linktype=\"relative-path\">XName</a> to match.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable</a>&lt;<a class=\"xref\" href=\"system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a>&gt;</div>\r\n                  </div>\r\n                  <p>An <span class=\"xref\">stem.Collections.Generic.IEnumerable`1</span> of <a class=\"xref\" href=\"system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a> of the ancestor elements of this node. Only elements that have a matching <a class=\"xref\" href=\"system.xml.linq.xname\" data-linktype=\"relative-path\">XName</a> are included in the collection.  </p>\n<p> The nodes in the returned collection are in reverse document order.  </p>\n<p> This method uses deferred execution.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method will not return itself in the results.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses this method.  </p>\n<pre><code class=\"lang-c#\">\n                XElement xmlTree = new XElement(&quot;Root&quot;,  \n    new XElement(&quot;Child&quot;,   \n        new XElement(&quot;GrandChild&quot;, &quot;content&quot;)  \n    )  \n);  \nIEnumerable&lt;XElement&gt; grandChild = xmlTree.Descendants(&quot;GrandChild&quot;);  \nforeach (XElement el in grandChild.Ancestors(&quot;Child&quot;))  \n    Console.WriteLine(el.Name);  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim xmlTree As XElement = _   \n        &lt;Root&gt;  \n            &lt;Child&gt;  \n                &lt;GrandChild&gt;content&lt;/GrandChild&gt;  \n            &lt;/Child&gt;  \n        &lt;/Root&gt;  \n\nDim grandChild As IEnumerable(Of XElement) = xmlTree...&lt;GrandChild&gt;  \nFor Each el In grandChild.Ancestors(&quot;Child&quot;)  \n    Console.WriteLine(el.Name)  \nNext  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code>\nChild  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_CompareDocumentOrder_System_Xml_Linq_XNode_System_Xml_Linq_XNode_\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_CompareDocumentOrder_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">CompareDocumentOrder(XNode,XNode)</div>        \r\n          </div>\r\n    \r\n            <p>Compares two nodes to determine their relative XML document order.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static int CompareDocumentOrder (System.Xml.Linq.XNode n1, System.Xml.Linq.XNode n2);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>n1</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>First <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> to compare.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>n2</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Second <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> to compare.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </div>\r\n                  <p>An <code>int</code> containing 0 if the nodes are equal; -1 if <code>n1</code> is before <code>n2</code>; 1 if <code>n1</code> is after <code>n2</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The two nodes do not share a common ancestor.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <a class=\"xref\" href=\"system.xml.linq.xcontainer\" data-linktype=\"relative-path\">XContainer</a> stores its child nodes as a singly-linked list of <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> objects. This means that the CompareDocumentOrder method must traverse the ancestors of the two nodes being compared until it finds the common parent. Then it must traverse the list of the common parent’s child nodes to determine the order of the two nodes being compared. Therefore, using this method might affect your performance.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses this method.  </p>\n<pre><code class=\"lang-c#\">\n                XElement xmlTree = new XElement(&quot;Root&quot;,  \n    new XElement(&quot;Child1&quot;,  \n        new XElement(&quot;GrandChild1&quot;, 1),  \n        new XElement(&quot;GrandChild2&quot;, 2),  \n        new XElement(&quot;GrandChild3&quot;, 3)  \n    ),  \n    new XElement(&quot;Child2&quot;,  \n        new XElement(&quot;GrandChild4&quot;, 4),  \n        new XElement(&quot;GrandChild5&quot;, 5),  \n        new XElement(&quot;GrandChild6&quot;, 6)  \n    )  \n);  \nXElement el1 = xmlTree.Descendants(&quot;GrandChild2&quot;).First();  \nXElement el2 = xmlTree.Descendants(&quot;GrandChild6&quot;).First();  \nif (XElement.CompareDocumentOrder(el1, el2) == 0)  \n    Console.WriteLine(&quot;Compared elements are the same element&quot;);  \nelse if (XElement.CompareDocumentOrder(el1, el2) &gt; 0)  \n    Console.WriteLine(&quot;el1 is after el2&quot;);  \nelse  \n    Console.WriteLine(&quot;el1 is before el2&quot;);  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim xmlTree As XElement = _   \n        &lt;Root&gt;  \n            &lt;Child1&gt;  \n                &lt;GrandChild1&gt;1&lt;/GrandChild1&gt;  \n                &lt;GrandChild2&gt;2&lt;/GrandChild2&gt;  \n                &lt;GrandChild3&gt;3&lt;/GrandChild3&gt;  \n            &lt;/Child1&gt;  \n            &lt;Child2&gt;  \n                &lt;GrandChild4&gt;4&lt;/GrandChild4&gt;  \n                &lt;GrandChild5&gt;5&lt;/GrandChild5&gt;  \n                &lt;GrandChild6&gt;6&lt;/GrandChild6&gt;  \n            &lt;/Child2&gt;  \n        &lt;/Root&gt;  \n\nDim el1 As XElement = xmlTree...&lt;GrandChild2&gt;(0)  \nDim el2 As XElement = xmlTree...&lt;GrandChild6&gt;(0)  \n\nIf (XElement.CompareDocumentOrder(el1, el2) = 0) Then  \n    Console.WriteLine(&quot;Compared elements are the same element&quot;)  \nElseIf (XElement.CompareDocumentOrder(el1, el2) &gt; 0) Then  \n    Console.WriteLine(&quot;el1 is after el2&quot;)  \nElse  \n    Console.WriteLine(&quot;el1 is before el2&quot;)  \nEnd If  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code>\nel1 is before el2  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_CreateReader\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_CreateReader_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">CreateReader()</div>        \r\n          </div>\r\n    \r\n            <p>Creates an <a class=\"xref\" href=\"system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a> for this node.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Xml.XmlReader CreateReader ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a></div>\r\n                  </div>\r\n                  <p>An <a class=\"xref\" href=\"system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a> that can be used to read this node and its descendants.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>You typically use this method when you have to supply another component with an <a class=\"xref\" href=\"system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a>. For example, you can create an <a class=\"xref\" href=\"system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a> from a LINQ to XML tree, and then pass that reader to <a class=\"xref\" href=\"system.xml.xmldocument#System_Xml_XmlDocument_Load_\" data-linktype=\"relative-path\">Load</a>.  </p>\n<p> All of the readers returned by <a class=\"xref\" href=\"system.xml.xmlreader#System_Xml_XmlReader_Create_\" data-linktype=\"relative-path\">Create</a> are normalizing readers. They always perform line break normalization and full normalization of attributes. In contrast, the <a class=\"xref\" href=\"system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a> returned by CreateReader is not a normalizing reader. It does not transform any white space. It also returns attributes in the order that they were added, not in attribute name order.  </p>\n<p> LINQ to XML does not keep information about whether attributes are default attributes. <a class=\"xref\" href=\"system.xml.xmlreader#System_Xml_XmlReader_IsDefault_\" data-linktype=\"relative-path\">IsDefault</a> will always return false regardless of whether the attribute was populated from a default value or not.  </p>\n<p> The the <code>PUBLIC</code> and <code>SYSTEM</code> pseudo attributes on <a class=\"xref\" href=\"system.xml.linq.xdocumenttype\" data-linktype=\"relative-path\">XDocumentType</a> are not available through the <a class=\"xref\" href=\"system.xml.xmlreader#System_Xml_XmlReader_MoveToAttribute_\" data-linktype=\"relative-path\">MoveToAttribute</a> method. They are only available through the <a class=\"xref\" href=\"system.xml.xmlreader#System_Xml_XmlReader_GetAttribute_\" data-linktype=\"relative-path\">GetAttribute</a> method that takes the qualified name of the attribute as a parameter. If you have to retrieve the <code>PUBLIC</code> or <code>SYSTEM</code> attributes, you should use the <a class=\"xref\" href=\"system.xml.xmlreader#System_Xml_XmlReader_GetAttribute_\" data-linktype=\"relative-path\">GetAttribute</a> method.  </p>\n<p> Base64 and BinHex data are not supported. If you attempt to retrieve these types of data (for example, by calling <a class=\"xref\" href=\"system.xml.xmlreader#System_Xml_XmlReader_ReadElementContentAsBase64_\" data-linktype=\"relative-path\">ReadElementContentAsBase64</a>), the reader will throw <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a>.  </p>\n<p> The <code>xml</code> declaration is not surfaced by the reader. While reading, you will not encounter a node of type <a class=\"xref\" href=\"system.xml.xmlnodetype\" data-linktype=\"relative-path\">XmlNodeType</a>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an XML tree, creates an <a class=\"xref\" href=\"system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a> by using the CreateReader method, and creates an <a class=\"xref\" href=\"system.xml.xmldocument\" data-linktype=\"relative-path\">XmlDocument</a> by using the reader.  </p>\n<pre><code class=\"lang-c#\">\n                XDocument xmlTree = new XDocument(  \n    new XElement(&quot;Root&quot;,  \n        new XAttribute(&quot;Att1&quot;, &quot;Attribute Content&quot;),  \n        new XElement(&quot;Child1&quot;, 1),  \n        new XElement(&quot;Child2&quot;, 2)  \n    )  \n);  \nXmlReader reader = xmlTree.CreateReader();  \nreader.MoveToContent();  \nXmlDocument doc = new XmlDocument();  \nXmlNode cd = doc.ReadNode(reader);  \ndoc.AppendChild(cd);  \nConsole.WriteLine(doc.OuterXml);  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim xmlTree As XDocument =  _   \n    &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; standalone=&quot;yes&quot;?&gt;  \n        &lt;Root Att1=&quot;Attribute Content&quot;&gt;  \n            &lt;Child1&gt;1&lt;/Child1&gt;  \n            &lt;Child2&gt;2&lt;/Child2&gt;  \n        &lt;/Root&gt;  \nDim reader As XmlReader = xmlTree.CreateReader()  \nreader.MoveToContent()  \nDim doc As XmlDocument = New XmlDocument()  \nDim cd As XmlNode = doc.ReadNode(reader)  \ndoc.AppendChild(cd)  \nConsole.WriteLine(doc.OuterXml)  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code class=\"lang-xml\">\n&lt;Root Att1=&quot;Attribute Content&quot;&gt;&lt;Child1&gt;1&lt;/Child1&gt;&lt;Child2&gt;2&lt;/Child2&gt;&lt;/Root&gt;  \n</code></pre><p> Another use for this method is to do an XSLT transformation. You can create an XML tree, create an <a class=\"xref\" href=\"system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a> from the XML tree, create a new document, and create an <a class=\"xref\" href=\"system.xml.xmlwriter\" data-linktype=\"relative-path\">XmlWriter</a> that will write into the new document. Then, you can invoke the XSLT transformation, passing the <a class=\"xref\" href=\"system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a> and <a class=\"xref\" href=\"system.xml.xmlwriter\" data-linktype=\"relative-path\">XmlWriter</a> to the transformation. After the transformation successfully completes, the new XML tree is populated with the results of the transform.  </p>\n<pre><code class=\"lang-c#\">\n                string xslMarkup = @&quot;&lt;?xml version=&#39;1.0&#39;?&gt;  \n&lt;xsl:stylesheet xmlns:xsl=&#39;http://www.w3.org/1999/XSL/Transform&#39; version=&#39;1.0&#39;&gt;  \n    &lt;xsl:template match=&#39;/Parent&#39;&gt;  \n        &lt;Root&gt;  \n            &lt;C1&gt;  \n            &lt;xsl:value-of select=&#39;Child1&#39;/&gt;  \n            &lt;/C1&gt;  \n            &lt;C2&gt;  \n            &lt;xsl:value-of select=&#39;Child2&#39;/&gt;  \n            &lt;/C2&gt;  \n        &lt;/Root&gt;  \n    &lt;/xsl:template&gt;  \n&lt;/xsl:stylesheet&gt;&quot;;  \n\nXDocument xmlTree = new XDocument(  \n    new XElement(&quot;Parent&quot;,  \n        new XElement(&quot;Child1&quot;, &quot;Child1 data&quot;),  \n        new XElement(&quot;Child2&quot;, &quot;Child2 data&quot;)  \n    )  \n);  \n\nXDocument newTree = new XDocument();  \nusing (XmlWriter writer = newTree.CreateWriter()) {  \n    // Load the style sheet.  \n    XslCompiledTransform xslt = new XslCompiledTransform();  \n    xslt.Load(XmlReader.Create(new StringReader(xslMarkup)));  \n\n    // Execute the transform and output the results to a writer.  \n    xslt.Transform(xmlTree.CreateReader(), writer);  \n}  \n\nConsole.WriteLine(newTree);  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim xslMarkup As XDocument = _   \n    &lt;?xml version=&#39;1.0&#39;?&gt;  \n    &lt;xsl:stylesheet xmlns:xsl=&#39;http://www.w3.org/1999/XSL/Transform&#39; version=&#39;1.0&#39;&gt;  \n        &lt;xsl:template match=&#39;/Parent&#39;&gt;  \n            &lt;Root&gt;  \n                &lt;C1&gt;  \n                    &lt;xsl:value-of select=&#39;Child1&#39;/&gt;  \n                &lt;/C1&gt;  \n                &lt;C2&gt;  \n                    &lt;xsl:value-of select=&#39;Child2&#39;/&gt;  \n                &lt;/C2&gt;  \n            &lt;/Root&gt;  \n        &lt;/xsl:template&gt;  \n    &lt;/xsl:stylesheet&gt;  \n\nDim xmlTree As XElement = _   \n        &lt;Parent&gt;  \n            &lt;Child1&gt;Child1 data&lt;/Child1&gt;  \n            &lt;Child2&gt;Child2 data&lt;/Child2&gt;  \n        &lt;/Parent&gt;  \n\nDim newTree As XDocument = New XDocument()  \n\nUsing writer As XmlWriter = newTree.CreateWriter()  \n    &#39; Load the style sheet.  \n    Dim xslt As XslCompiledTransform = _  \n        New XslCompiledTransform()  \n    xslt.Load(xslMarkup.CreateReader())  \n\n    &#39; Execute the transform and output the results to a writer.  \n    xslt.Transform(xmlTree.CreateReader(), writer)  \nEnd Using  \n\nConsole.WriteLine(newTree)  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code class=\"lang-xml\">\n                &lt;Root&gt;  \n  &lt;C1&gt;Child1 data&lt;/C1&gt;  \n  &lt;C2&gt;Child2 data&lt;/C2&gt;  \n&lt;/Root&gt;  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_CreateReader_System_Xml_Linq_ReaderOptions_\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_CreateReader_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">CreateReader(ReaderOptions)</div>        \r\n          </div>\r\n    \r\n            <p>Creates an <a class=\"xref\" href=\"system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a> with the options specified by the <code>readerOptions</code> parameter.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Xml.XmlReader CreateReader (System.Xml.Linq.ReaderOptions readerOptions);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>readerOptions</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.xml.linq.readeroptions\" data-linktype=\"relative-path\">ReaderOptions</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <a class=\"xref\" href=\"system.xml.linq.readeroptions\" data-linktype=\"relative-path\">ReaderOptions</a> object that specifies whether to omit duplicate namespaces.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a></div>\r\n                  </div>\r\n                  <p>An <a class=\"xref\" href=\"system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a> object.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_DeepEquals_System_Xml_Linq_XNode_System_Xml_Linq_XNode_\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_DeepEquals_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">DeepEquals(XNode,XNode)</div>        \r\n          </div>\r\n    \r\n            <p>Compares the values of two nodes, including the values of all descendant nodes.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool DeepEquals (System.Xml.Linq.XNode n1, System.Xml.Linq.XNode n2);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>n1</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The first <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> to compare.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>n2</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The second <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> to compare.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the nodes are equal; otherwise <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The following criteria determine whether two nodes are equal:  </p>\n<ul>\n<li><p>A <code>null</code> node is equal to another <code>null</code> node but unequal to a non-<code>null</code> node.  </p>\n</li>\n<li><p>Two <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> objects of different types are never equal.  </p>\n</li>\n<li><p>Two <a class=\"xref\" href=\"system.xml.linq.xtext\" data-linktype=\"relative-path\">XText</a> nodes are equal if they contain the same text.  </p>\n</li>\n<li><p>Two <a class=\"xref\" href=\"system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a> nodes are equal if they have the same tag name, the same set of attributes with the same values, and (ignoring comments and processing instructions) contain two equal length sequences of equal content nodes.  </p>\n</li>\n<li><p>Two <a class=\"xref\" href=\"system.xml.linq.xdocument\" data-linktype=\"relative-path\">XDocument</a> nodes are equal if their root nodes are equal.  </p>\n</li>\n<li><p>Two <a class=\"xref\" href=\"system.xml.linq.xcomment\" data-linktype=\"relative-path\">XComment</a> nodes are equal if they contain the same comment text.  </p>\n</li>\n<li><p>Two <a class=\"xref\" href=\"system.xml.linq.xprocessinginstruction\" data-linktype=\"relative-path\">XProcessingInstruction</a> nodes are equal if they have the same target and data.  </p>\n</li>\n<li><p>Two <a class=\"xref\" href=\"system.xml.linq.xdocumenttype\" data-linktype=\"relative-path\">XDocumentType</a> nodes are equal if the have the same name, public ID, system ID, and internal subset.</p>\n</li>\n</ul>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses this method to compare two XML trees.  </p>\n<pre><code class=\"lang-c#\">\n                XElement xmlTree1 = new XElement(&quot;Root&quot;,  \n    new XAttribute(&quot;Att1&quot;, 1),  \n    new XAttribute(&quot;Att2&quot;, 2),  \n    new XElement(&quot;Child1&quot;, 1),  \n    new XElement(&quot;Child2&quot;, &quot;some content&quot;)  \n);  \nXElement xmlTree2 = new XElement(&quot;Root&quot;,  \n    new XAttribute(&quot;Att1&quot;, 1),  \n    new XAttribute(&quot;Att2&quot;, 2),  \n    new XElement(&quot;Child1&quot;, 1),  \n    new XElement(&quot;Child2&quot;, &quot;some content&quot;)  \n);  \nConsole.WriteLine(XNode.DeepEquals(xmlTree1, xmlTree2));  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim xmlTree1 As XElement = _   \n        &lt;Root Att1=&quot;1&quot; Att2=&quot;2&quot;&gt;  \n            &lt;Child1&gt;1&lt;/Child1&gt;  \n            &lt;Child2&gt;some content&lt;/Child2&gt;  \n        &lt;/Root&gt;  \n\nDim xmlTree2 As XElement = _   \n        &lt;Root Att1=&quot;1&quot; Att2=&quot;2&quot;&gt;  \n            &lt;Child1&gt;1&lt;/Child1&gt;  \n            &lt;Child2&gt;some content&lt;/Child2&gt;  \n        &lt;/Root&gt;  \n\nConsole.WriteLine(XNode.DeepEquals(xmlTree1, xmlTree2))  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code>\nTrue  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_ElementsAfterSelf\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_ElementsAfterSelf_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ElementsAfterSelf()</div>        \r\n          </div>\r\n    \r\n            <p>Returns a collection of the sibling elements after this node, in document order.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsAfterSelf ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable</a>&lt;<a class=\"xref\" href=\"system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a>&gt;</div>\r\n                  </div>\r\n                  <p>An <span class=\"xref\">stem.Collections.Generic.IEnumerable`1</span> of <a class=\"xref\" href=\"system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a> of the sibling elements after this node, in document order.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method only includes siblings in the returned collection. It does not include descendants.  </p>\n<p> This method uses deferred execution.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an element with some complex content. It then uses this method to retrieve the nodes in document order.  </p>\n<pre><code class=\"lang-c#\">\n                XElement xmlTree = new XElement(&quot;Root&quot;,  \n    new XText(&quot;Text content.&quot;),  \n    new XElement(&quot;Child1&quot;, &quot;child1 content&quot;),  \n    new XElement(&quot;Child2&quot;, &quot;child2 content&quot;),  \n    new XElement(&quot;Child3&quot;, &quot;child3 content&quot;),  \n    new XText(&quot;More text content.&quot;),  \n    new XElement(&quot;Child4&quot;, &quot;child4 content&quot;),  \n    new XElement(&quot;Child5&quot;, &quot;child5 content&quot;)  \n);  \nXElement child = xmlTree.Element(&quot;Child3&quot;);  \nIEnumerable&lt;XElement&gt; elements = child.ElementsAfterSelf();  \nforeach (XElement el in elements)  \n    Console.WriteLine(el.Name);  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim xmlTree As XElement = _  \n        &lt;Root&gt;Text content.  \n            &lt;Child1&gt;child1 content&lt;/Child1&gt;  \n            &lt;Child2&gt;child2 content&lt;/Child2&gt;  \n            &lt;Child3&gt;child3 content&lt;/Child3&gt;More text content.  \n            &lt;Child4&gt;child4 content&lt;/Child4&gt;  \n            &lt;Child5&gt;child5 content&lt;/Child5&gt;  \n        &lt;/Root&gt;  \n\nDim child As XElement = xmlTree.&lt;Child3&gt;(0)  \nDim elements As IEnumerable(Of XElement) = child.ElementsAfterSelf()  \nFor Each el In elements  \n    Console.WriteLine(el.Name)  \nNext  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code>\n                Child4  \nChild5  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_ElementsAfterSelf_System_Xml_Linq_XName_\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_ElementsAfterSelf_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ElementsAfterSelf(XName)</div>        \r\n          </div>\r\n    \r\n            <p>Returns a filtered collection of the sibling elements after this node, in document order. Only elements that have a matching <a class=\"xref\" href=\"system.xml.linq.xname\" data-linktype=\"relative-path\">XName</a> are included in the collection.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsAfterSelf (System.Xml.Linq.XName name);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.xml.linq.xname\" data-linktype=\"relative-path\">XName</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.xml.linq.xname\" data-linktype=\"relative-path\">XName</a> to match.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable</a>&lt;<a class=\"xref\" href=\"system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a>&gt;</div>\r\n                  </div>\r\n                  <p>An <span class=\"xref\">stem.Collections.Generic.IEnumerable`1</span> of <a class=\"xref\" href=\"system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a> of the sibling elements after this node, in document order. Only elements that have a matching <a class=\"xref\" href=\"system.xml.linq.xname\" data-linktype=\"relative-path\">XName</a> are included in the collection.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method only includes siblings in the returned collection. It does not include descendants.  </p>\n<p> This method uses deferred execution.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an element with some complex content. It then uses this method to retrieve the sibling elements, in document order.  </p>\n<pre><code class=\"lang-c#\">\n                XElement xmlTree = new XElement(&quot;Root&quot;,  \n    new XText(&quot;Text content.&quot;),  \n    new XElement(&quot;Child1&quot;, &quot;child1 content&quot;),  \n    new XElement(&quot;Child2&quot;, &quot;child2 content&quot;),  \n    new XElement(&quot;Child3&quot;, &quot;child3 content&quot;),  \n    new XText(&quot;More text content.&quot;),  \n    new XElement(&quot;Child4&quot;, &quot;child4 content&quot;),  \n    new XElement(&quot;Child5&quot;, &quot;child5 content&quot;)  \n);  \nXElement child = xmlTree.Element(&quot;Child3&quot;);  \nIEnumerable&lt;XElement&gt; elements = child.ElementsAfterSelf(&quot;Child4&quot;);  \nforeach (XElement el in elements)  \n    Console.WriteLine(el.Name);  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim xmlTree As XElement = _   \n        &lt;Root&gt;Text content.  \n            &lt;Child1&gt;child1 content&lt;/Child1&gt;  \n            &lt;Child2&gt;child2 content&lt;/Child2&gt;  \n            &lt;Child3&gt;child3 content&lt;/Child3&gt;More text content.  \n            &lt;Child4&gt;child4 content&lt;/Child4&gt;  \n            &lt;Child5&gt;child5 content&lt;/Child5&gt;  \n        &lt;/Root&gt;  \n\nDim child As XElement = xmlTree.&lt;Child3&gt;(0)  \nDim elements As IEnumerable(Of XElement) = child.ElementsAfterSelf(&quot;Child4&quot;)  \n\nFor Each el In elements  \n    Console.WriteLine(el.Name)  \nNext  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code>\nChild4  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_ElementsBeforeSelf\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_ElementsBeforeSelf_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ElementsBeforeSelf()</div>        \r\n          </div>\r\n    \r\n            <p>Returns a collection of the sibling elements before this node, in document order.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsBeforeSelf ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable</a>&lt;<a class=\"xref\" href=\"system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a>&gt;</div>\r\n                  </div>\r\n                  <p>An <span class=\"xref\">stem.Collections.Generic.IEnumerable`1</span> of <a class=\"xref\" href=\"system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a> of the sibling elements before this node, in document order.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method only includes siblings in the returned collection. It does not include descendants.  </p>\n<p> This method uses deferred execution.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses this axis method.  </p>\n<pre><code class=\"lang-c#\">\n                XElement xmlTree = new XElement(&quot;Root&quot;,  \n    new XText(&quot;Text content.&quot;),  \n    new XElement(&quot;Child1&quot;, &quot;child1 content&quot;),  \n    new XElement(&quot;Child2&quot;, &quot;child2 content&quot;),  \n    new XElement(&quot;Child3&quot;, &quot;child3 content&quot;),  \n    new XText(&quot;More text content.&quot;),  \n    new XElement(&quot;Child4&quot;, &quot;child4 content&quot;),  \n    new XElement(&quot;Child5&quot;, &quot;child5 content&quot;)  \n);  \nXElement child = xmlTree.Element(&quot;Child3&quot;);  \nIEnumerable&lt;XElement&gt; elements = child.ElementsBeforeSelf();  \nforeach (XElement el in elements)  \n    Console.WriteLine(el.Name);  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim xmlTree As XElement = _   \n        &lt;Root&gt;Text content.  \n            &lt;Child1&gt;child1 content&lt;/Child1&gt;  \n            &lt;Child2&gt;child2 content&lt;/Child2&gt;  \n            &lt;Child3&gt;child3 content&lt;/Child3&gt;More text content.  \n            &lt;Child4&gt;child4 content&lt;/Child4&gt;  \n            &lt;Child5&gt;child5 content&lt;/Child5&gt;  \n        &lt;/Root&gt;  \n\nDim child As XElement = xmlTree.&lt;Child3&gt;(0)  \nDim elements As IEnumerable(Of XElement) = child.ElementsBeforeSelf()  \n\nFor Each el In elements  \n    Console.WriteLine(el.Name)  \nNext  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code>\n                Child1  \nChild2  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_ElementsBeforeSelf_System_Xml_Linq_XName_\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_ElementsBeforeSelf_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ElementsBeforeSelf(XName)</div>        \r\n          </div>\r\n    \r\n            <p>Returns a filtered collection of the sibling elements before this node, in document order. Only elements that have a matching <a class=\"xref\" href=\"system.xml.linq.xname\" data-linktype=\"relative-path\">XName</a> are included in the collection.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; ElementsBeforeSelf (System.Xml.Linq.XName name);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.xml.linq.xname\" data-linktype=\"relative-path\">XName</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.xml.linq.xname\" data-linktype=\"relative-path\">XName</a> to match.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable</a>&lt;<a class=\"xref\" href=\"system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a>&gt;</div>\r\n                  </div>\r\n                  <p>An <span class=\"xref\">stem.Collections.Generic.IEnumerable`1</span> of <a class=\"xref\" href=\"system.xml.linq.xelement\" data-linktype=\"relative-path\">XElement</a> of the sibling elements before this node, in document order. Only elements that have a matching <a class=\"xref\" href=\"system.xml.linq.xname\" data-linktype=\"relative-path\">XName</a> are included in the collection.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method only includes siblings in the returned collection. It does not include descendants.  </p>\n<p> This method uses deferred execution.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses this method.  </p>\n<pre><code class=\"lang-c#\">\n                XElement xmlTree = new XElement(&quot;Root&quot;,  \n    new XText(&quot;Text content.&quot;),  \n    new XElement(&quot;Child1&quot;, &quot;child1 content&quot;),  \n    new XElement(&quot;Child2&quot;, &quot;child2 content&quot;),  \n    new XElement(&quot;Child3&quot;, &quot;child3 content&quot;),  \n    new XText(&quot;More text content.&quot;),  \n    new XElement(&quot;Child4&quot;, &quot;child4 content&quot;),  \n    new XElement(&quot;Child5&quot;, &quot;child5 content&quot;)  \n);  \nXElement child = xmlTree.Element(&quot;Child3&quot;);  \nIEnumerable&lt;XElement&gt; elements = child.ElementsBeforeSelf(&quot;Child2&quot;);  \nforeach (XElement el in elements)  \n    Console.WriteLine(el.Name);  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim xmlTree As XElement = _   \n        &lt;Root&gt;Text content.  \n            &lt;Child1&gt;child1 content&lt;/Child1&gt;  \n            &lt;Child2&gt;child2 content&lt;/Child2&gt;  \n            &lt;Child3&gt;child3 content&lt;/Child3&gt;More text content.  \n            &lt;Child4&gt;child4 content&lt;/Child4&gt;  \n            &lt;Child5&gt;child5 content&lt;/Child5&gt;  \n        &lt;/Root&gt;  \n\nDim child As XElement = xmlTree.&lt;Child3&gt;(0)  \nDim elements As IEnumerable(Of XElement) = child.ElementsBeforeSelf(&quot;Child2&quot;)  \n\nFor Each el In elements  \n    Console.WriteLine(el.Name)  \nNext  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code>\nChild2  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_IsAfter_System_Xml_Linq_XNode_\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_IsAfter_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsAfter(XNode)</div>        \r\n          </div>\r\n    \r\n            <p>Determines if the current node appears after a specified node in terms of document order.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsAfter (System.Xml.Linq.XNode node);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>node</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> to compare for document order.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if this node appears after the specified node; otherwise <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <a class=\"xref\" href=\"system.xml.linq.xcontainer\" data-linktype=\"relative-path\">XContainer</a> stores its child nodes as a singly-linked list of <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> objects. This means that the <a class=\"xref\" href=\"system.xml.linq.xnode#System_Xml_Linq_XNode_CompareDocumentOrder_\" data-linktype=\"relative-path\">CompareDocumentOrder</a> method must traverse the ancestors of the two nodes being compared until it finds the common parent. Then it must traverse the list of the common parent’s child nodes to determine the order of the two nodes being compared. Therefore, using this method might affect your performance.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses this method.  </p>\n<pre><code class=\"lang-c#\">\n                XElement xmlTree = new XElement(&quot;Root&quot;,  \n    new XText(&quot;Text content.&quot;),  \n    new XElement(&quot;Child1&quot;, &quot;child1 content&quot;),  \n    new XElement(&quot;Child2&quot;, &quot;child2 content&quot;),  \n    new XElement(&quot;Child3&quot;, &quot;child3 content&quot;),  \n    new XText(&quot;More text content.&quot;),  \n    new XElement(&quot;Child4&quot;, &quot;child4 content&quot;),  \n    new XElement(&quot;Child5&quot;, &quot;child5 content&quot;)  \n);  \nXElement child3 = xmlTree.Element(&quot;Child3&quot;);  \nXElement child5 = xmlTree.Element(&quot;Child5&quot;);  \nif (child5.IsAfter(child3))  \n    Console.WriteLine(&quot;Child5 is after Child3&quot;);  \nelse  \n    Console.WriteLine(&quot;Child5 is not after Child3&quot;);  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim xmlTree As XElement = _   \n        &lt;Root&gt;Text content.  \n            &lt;Child1&gt;child1 content&lt;/Child1&gt;  \n            &lt;Child2&gt;child2 content&lt;/Child2&gt;  \n            &lt;Child3&gt;child3 content&lt;/Child3&gt;More text content.  \n            &lt;Child4&gt;child4 content&lt;/Child4&gt;  \n            &lt;Child5&gt;child5 content&lt;/Child5&gt;  \n        &lt;/Root&gt;  \n\nDim child3 As XElement = xmlTree.&lt;Child3&gt;(0)  \nDim child5 As XElement = xmlTree.&lt;Child5&gt;(0)  \nIf (child5.IsAfter(child3)) Then  \n    Console.WriteLine(&quot;Child5 is after Child3&quot;)  \nElse  \n    Console.WriteLine(&quot;Child5 is not after Child3&quot;)  \nEnd If  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code>\nChild5 is after Child3  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_IsBefore_System_Xml_Linq_XNode_\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_IsBefore_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsBefore(XNode)</div>        \r\n          </div>\r\n    \r\n            <p>Determines if the current node appears before a specified node in terms of document order.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsBefore (System.Xml.Linq.XNode node);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>node</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> to compare for document order.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if this node appears before the specified node; otherwise <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <a class=\"xref\" href=\"system.xml.linq.xcontainer\" data-linktype=\"relative-path\">XContainer</a> stores its child nodes as a singly-linked list of <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> objects. This means that the IsBefore method must traverse the ancestors of the two nodes being compared until it finds the common parent. Then it must traverse the list of the common parent’s child nodes to determine the order of the two nodes being compared. Therefore, using this method might affect your performance.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses this method.  </p>\n<pre><code class=\"lang-c#\">\n                XElement xmlTree = new XElement(&quot;Root&quot;,  \n    new XText(&quot;Text content.&quot;),  \n    new XElement(&quot;Child1&quot;, &quot;child1 content&quot;),  \n    new XElement(&quot;Child2&quot;, &quot;child2 content&quot;),  \n    new XElement(&quot;Child3&quot;, &quot;child3 content&quot;),  \n    new XText(&quot;More text content.&quot;),  \n    new XElement(&quot;Child4&quot;, &quot;child4 content&quot;),  \n    new XElement(&quot;Child5&quot;, &quot;child5 content&quot;)  \n);  \nXElement child3 = xmlTree.Element(&quot;Child3&quot;);  \nXElement child5 = xmlTree.Element(&quot;Child5&quot;);  \nif (child5.IsBefore(child3))  \n    Console.WriteLine(&quot;Child5 is before Child3&quot;);  \nelse  \n    Console.WriteLine(&quot;Child5 is not before Child3&quot;);  \n</code></pre><p> [vb]  </p>\n<pre><code>\n                Dim xmlTree As XElement = _   \n        &lt;Root&gt;Text content.  \n            &lt;Child1&gt;child1 content&lt;/Child1&gt;  \n            &lt;Child2&gt;child2 content&lt;/Child2&gt;  \n            &lt;Child3&gt;child3 content&lt;/Child3&gt;More text content.  \n            &lt;Child4&gt;child4 content&lt;/Child4&gt;  \n            &lt;Child5&gt;child5 content&lt;/Child5&gt;  \n        &lt;/Root&gt;  \n\nDim child3 As XElement = xmlTree.&lt;Child3&gt;(0)  \nDim child5 As XElement = xmlTree.&lt;Child5&gt;(0)  \nIf (child5.IsBefore(child3)) Then  \n    Console.WriteLine(&quot;Child5 is before Child3&quot;)  \nElse  \n    Console.WriteLine(&quot;Child5 is not before Child3&quot;)  \nEnd If  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code>\nChild5 is not before Child3  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_NodesAfterSelf\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_NodesAfterSelf_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">NodesAfterSelf()</div>        \r\n          </div>\r\n    \r\n            <p>Returns a collection of the sibling nodes after this node, in document order.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt; NodesAfterSelf ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable</a>&lt;<a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a>&gt;</div>\r\n                  </div>\r\n                  <p>An <span class=\"xref\">stem.Collections.Generic.IEnumerable`1</span> of <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> of the sibling nodes after this node, in document order.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method only includes siblings in the returned collection. It does not include descendants.  </p>\n<p> This method uses deferred execution.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an XML tree, and then queries the tree using this axis method.  </p>\n<pre><code class=\"lang-c#\">\n                XElement xmlTree = new XElement(&quot;Root&quot;,  \n    new XText(&quot;Text content.&quot;),  \n    new XElement(&quot;Child1&quot;, &quot;child1 content&quot;),  \n    new XElement(&quot;Child2&quot;, &quot;child2 content&quot;),  \n    new XText(&quot;More text content.&quot;),  \n    new XElement(&quot;child3&quot;, &quot;child3 content&quot;)  \n);  \nXElement child = xmlTree.Element(&quot;Child2&quot;);  \nIEnumerable&lt;XNode&gt; nodes =  \n    from node in child.NodesAfterSelf()  \n    select node;  \nforeach (XNode node in nodes)  \n{  \n    Console.WriteLine(&quot;Node type: {0}  {1}&quot;,  \n        node.NodeType,  \n        node.NodeType == XmlNodeType.Text ? (node as XText).Value : &quot;&quot;);  \n}  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim xmlTree As XElement = New XElement(&quot;Root&quot;, _New XText(&quot;Text content.&quot;), _  \n    New XElement(&quot;Child1&quot;, &quot;child1 content&quot;), _  \n    New XElement(&quot;Child2&quot;, &quot;child2 content&quot;), _  \n    New XText(&quot;More text content.&quot;), _  \n    New XElement(&quot;child3&quot;, &quot;child3 content&quot;) _  \n)  \n\nDim child As XElement = xmlTree.Element(&quot;Child2&quot;)  \nDim nodes As IEnumerable(Of XNode) = _  \n    From node In child.NodesAfterSelf() _  \n    Select node  \nFor Each node As XNode In nodes  \n    Dim s As String = &quot;&quot;  \n    If node.NodeType = XmlNodeType.Text Then  \n        s = DirectCast(node, XText).Value  \n    End If  \n    Console.WriteLine(&quot;Node type: {0}  {1}&quot;, node.NodeType, s)  \nNext  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code>\n                Node type: Text  More text content.  \nNode type: Element  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_NodesBeforeSelf\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_NodesBeforeSelf_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">NodesBeforeSelf()</div>        \r\n          </div>\r\n    \r\n            <p>Returns a collection of the sibling nodes before this node, in document order.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt; NodesBeforeSelf ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable</a>&lt;<a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a>&gt;</div>\r\n                  </div>\r\n                  <p>An <span class=\"xref\">stem.Collections.Generic.IEnumerable`1</span> of <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> of the sibling nodes before this node, in document order.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method only includes siblings in the returned collection. It does not include descendants.  </p>\n<p> This method uses deferred execution.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an XML tree, and then queries the tree using this axis method.  </p>\n<pre><code class=\"lang-c#\">\n                XElement xmlTree = new XElement(&quot;Root&quot;,  \n    new XText(&quot;Text content.&quot;),  \n    new XElement(&quot;Child1&quot;, &quot;child1 content&quot;),  \n    new XElement(&quot;Child2&quot;, &quot;child2 content&quot;),  \n    new XText(&quot;More text content.&quot;),  \n    new XElement(&quot;child3&quot;, &quot;child3 content&quot;)  \n);  \nXElement child = xmlTree.Element(&quot;Child2&quot;);  \nIEnumerable&lt;XNode&gt; nodes =  \n    from node in child.NodesBeforeSelf()  \n    select node;  \nforeach (XNode node in nodes)  \n    Console.WriteLine(&quot;Node type: {0}  {1}&quot;,  \n        node.NodeType,  \n        node.NodeType == XmlNodeType.Text ? (node as XText).Value : &quot;&quot;);  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim xmlTree As XElement = New XElement(&quot;Root&quot;, _  \n    New XText(&quot;Text content.&quot;), _  \n    New XElement(&quot;Child1&quot;, &quot;child1 content&quot;), _  \n    New XElement(&quot;Child2&quot;, &quot;child2 content&quot;), _  \n    New XText(&quot;More text content.&quot;), _  \n    New XElement(&quot;child3&quot;, &quot;child3 content&quot;) _  \n)  \n\nDim child As XElement = xmlTree.Element(&quot;Child2&quot;)  \nDim nodes As IEnumerable(Of XNode) = _  \n    From node In child.NodesBeforeSelf() _  \n    Select node  \nFor Each node As XNode In nodes  \n    Dim s As String = &quot;&quot;  \n    If node.NodeType = XmlNodeType.Text Then  \n        s = DirectCast(node, XText).Value  \n    End If  \n    Console.WriteLine(&quot;Node type: {0}  {1}&quot;, node.NodeType, s)  \nNext  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code>\n                Node type: Text  Text content.  \nNode type: Element  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_ReadFrom_System_Xml_XmlReader_\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_ReadFrom_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ReadFrom(XmlReader)</div>        \r\n          </div>\r\n    \r\n            <p>Creates an <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> from an <a class=\"xref\" href=\"system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Xml.Linq.XNode ReadFrom (System.Xml.XmlReader reader);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>reader</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An <a class=\"xref\" href=\"system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a> positioned at the node to read into this <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a></div>\r\n                  </div>\r\n                  <p>An <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> that contains the node and its descendant nodes that were read from the reader. The runtime type of the node is determined by the node type (<span class=\"xref\">stem.Xml.Linq.XObject.NodeType*</span>) of the first node encountered in the reader.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The <a class=\"xref\" href=\"system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a> is not positioned on a recognized node type.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.xml.xmlexception\" data-linktype=\"relative-path\">XmlException</a></div>\r\n                  </div>\r\n                  <p>The underlying <a class=\"xref\" href=\"system.xml.xmlreader\" data-linktype=\"relative-path\">XmlReader</a> throws an exception.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>You can use this method to write a method that returns a collection of nodes, yielding each node as the node is read from the reader. This method enables you to process arbitrarily large XML files with a very small memory footprint.  </p>\n<p> The reader that you pass to this method might throw exceptions. ReadFrom does not catch all exceptions thrown by the reader; the unhandled exceptions bubble up to the code that called ReadFrom. In particular, your code should be prepared to handle <a class=\"xref\" href=\"system.xml.xmlexception\" data-linktype=\"relative-path\">XmlException</a>.  </p>\n<p> For an example of how to stream a more complex document, see <a href=\"../Topic/How%20to:%20Stream%20XML%20Fragments%20with%20Access%20to%20Header%20Information.md\" data-linktype=\"relative-path\">How to: Stream XML Fragments with Access to Header Information</a>.  </p>\n<p> Certain standard query operators, such as &lt;xref:System.Linq.Enumerable.OrderBy%2A&gt;, iterate their source, collect all of the data, sort it, and then finally yield the first item in the sequence. If you use a query operator that materializes its source before yielding the first item, you will not retain a small memory footprint.  </p>\n<p> For an example of using LINQ to XML to transform extremely large XML documents while maintaining a small memory footprint, see <a href=\"../Topic/How%20to:%20Perform%20Streaming%20Transform%20of%20Large%20XML%20Documents.md\" data-linktype=\"relative-path\">How to: Perform Streaming Transform of Large XML Documents</a>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>This example uses the following XML file, named Source.xml:  </p>\n<pre><code class=\"lang-xml\">\n                &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;   \n&lt;Root&gt;  \n  &lt;Child Key=&quot;01&quot;&gt;  \n    &lt;GrandChild&gt;aaa&lt;/GrandChild&gt;  \n  &lt;/Child&gt;  \n  &lt;Child Key=&quot;02&quot;&gt;  \n    &lt;GrandChild&gt;bbb&lt;/GrandChild&gt;  \n  &lt;/Child&gt;  \n  &lt;Child Key=&quot;03&quot;&gt;  \n    &lt;GrandChild&gt;ccc&lt;/GrandChild&gt;  \n  &lt;/Child&gt;  \n&lt;/Root&gt;  \n</code></pre><p> This example creates a custom axis method that uses ReadFrom. You can query the custom axis by using a LINQ query.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The following example uses the yield return construct of C#. Because there is no equivalent feature in Visual Basic 2008, this example is provided only in C#.  </p>\n</div>\n<pre><code class=\"lang-c#\">\n                class Program  \n{  \n    static IEnumerable&lt;XElement&gt; StreamRootChildDoc(string uri)  \n    {  \n        using (XmlReader reader = XmlReader.Create(uri))  \n        {  \n            reader.MoveToContent();  \n            // Parse the file and display each of the nodes.  \n            while (reader.Read())  \n            {  \n                switch (reader.NodeType)  \n                {  \n                    case XmlNodeType.Element:  \n                        if (reader.Name == &quot;Child&quot;)  \n                        {  \n                            XElement el = XElement.ReadFrom(reader) as XElement;  \n                            if (el != null)  \n                                yield return el;  \n                        }  \n                        break;  \n                }  \n            }  \n        }  \n    }  \n\n    static void Main(string[] args)  \n    {  \n        IEnumerable&lt;string&gt; grandChildData =  \n            from el in StreamRootChildDoc(&quot;Source.xml&quot;)  \n            where (int)el.Attribute(&quot;Key&quot;) &gt; 1  \n            select (string)el.Element(&quot;GrandChild&quot;);  \n\n        foreach (string str in grandChildData)  \n            Console.WriteLine(str);  \n    }  \n}  \n</code></pre><p> This example produces the following output.  </p>\n<pre><code>\n                bbb  \nccc  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_Remove\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_Remove_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Remove()</div>        \r\n          </div>\r\n    \r\n            <p>Removes this node from its parent.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void Remove ();</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The parent is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>In LINQ to XML programming, you should not manipulate or modify a set of nodes while you are querying for nodes in that set. In practical terms, this means that you should not iterate over a set of nodes and remove them. Instead, you should materialize them into a <a class=\"xref\" href=\"system.collections.generic.list-1\" data-linktype=\"relative-path\">List&lt;T&gt;</a> by using the &lt;xref:System.Linq.Enumerable.ToList%2A&gt; extension method. Then, you can iterate over the list to remove the nodes. For more information, see <a href=\"../Topic/Mixed%20Declarative%20Code-Imperative%20Code%20Bugs%20(LINQ%20to%20XML).md\" data-linktype=\"relative-path\">Mixed Declarative Code/Imperative Code Bugs (LINQ to XML)</a>.  </p>\n<p> Alternatively, if you want to remove a set of nodes, it is recommended that you use the <a class=\"xref\" href=\"system.xml.linq.extensions#System_Xml_Linq_Extensions_Remove_\" data-linktype=\"relative-path\">Remove</a> method. This method copies the nodes to a list, and then iterates over the list to remove the nodes.  </p>\n<p> This method will raise the <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_Changed\" data-linktype=\"relative-path\">Changed</a> and the <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_Changing\" data-linktype=\"relative-path\">Changing</a> events.  </p>\n<p> The <a class=\"xref\" href=\"system.xml.linq.xcontainer\" data-linktype=\"relative-path\">XContainer</a> stores its child nodes as a singly-linked list of <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> objects. This means that the Remove method must traverse the list of direct child nodes under the parent container. Therefore, using this method might affect your performance.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example removes a node from its parent.  </p>\n<pre><code class=\"lang-c#\">\n                XElement xmlTree = new XElement(&quot;Root&quot;,  \n    new XElement(&quot;Child1&quot;, &quot;child1 content&quot;),  \n    new XElement(&quot;Child2&quot;, &quot;child2 content&quot;),  \n    new XElement(&quot;Child3&quot;, &quot;child3 content&quot;),  \n    new XElement(&quot;Child4&quot;, &quot;child4 content&quot;),  \n    new XElement(&quot;Child5&quot;, &quot;child5 content&quot;)  \n);  \nXElement child3 = xmlTree.Element(&quot;Child3&quot;);  \nchild3.Remove();  \nConsole.WriteLine(xmlTree);  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim xmlTree As XElement = _   \n        &lt;Root&gt;  \n            &lt;Child1&gt;child1 content&lt;/Child1&gt;  \n            &lt;Child2&gt;child2 content&lt;/Child2&gt;  \n            &lt;Child3&gt;child3 content&lt;/Child3&gt;  \n            &lt;Child4&gt;child4 content&lt;/Child4&gt;  \n            &lt;Child5&gt;child5 content&lt;/Child5&gt;  \n        &lt;/Root&gt;  \n\nDim child3 As XElement = xmlTree.&lt;Child3&gt;(0)  \nchild3.Remove()  \nConsole.WriteLine(xmlTree)  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code class=\"lang-xml\">\n                &lt;Root&gt;  \n  &lt;Child1&gt;child1 content&lt;/Child1&gt;  \n  &lt;Child2&gt;child2 content&lt;/Child2&gt;  \n  &lt;Child4&gt;child4 content&lt;/Child4&gt;  \n  &lt;Child5&gt;child5 content&lt;/Child5&gt;  \n&lt;/Root&gt;  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_ReplaceWith_System_Object_\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_ReplaceWith_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ReplaceWith(Object)</div>        \r\n          </div>\r\n    \r\n            <p>Replaces this node with the specified content.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void ReplaceWith (object content);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>content</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Content that replaces this node.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method first removes this node from its parent, and then adds the specified content to this node&#39;s parent, in the place of this node.  </p>\n<p> The <a class=\"xref\" href=\"system.xml.linq.xcontainer\" data-linktype=\"relative-path\">XContainer</a> stores its child nodes as a singly-linked list of <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> objects. This means that the <a class=\"xref\" href=\"system.xml.linq.xnode#System_Xml_Linq_XNode_ReplaceWith_\" data-linktype=\"relative-path\">ReplaceWith</a> method must traverse the list of direct child nodes under the parent container. Therefore, using this method might affect your performance.  </p>\n<p> For details about the valid content that can be passed to this method, see <a href=\"../Topic/Valid%20Content%20of%20XElement%20and%20XDocument%20Objects1.md\" data-linktype=\"relative-path\">Valid Content of XElement and XDocument Objects</a>.  </p>\n<p> This method will raise the <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_Changed\" data-linktype=\"relative-path\">Changed</a> and the <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_Changing\" data-linktype=\"relative-path\">Changing</a> events.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses this method to replace the contents of a node with different content.  </p>\n<pre><code class=\"lang-c#\">\n                XElement xmlTree = new XElement(&quot;Root&quot;,  \n    new XElement(&quot;Child1&quot;, &quot;child1 content&quot;),  \n    new XElement(&quot;Child2&quot;, &quot;child2 content&quot;),  \n    new XElement(&quot;Child3&quot;, &quot;child3 content&quot;),  \n    new XElement(&quot;Child4&quot;, &quot;child4 content&quot;),  \n    new XElement(&quot;Child5&quot;, &quot;child5 content&quot;)  \n);  \nXElement child3 = xmlTree.Element(&quot;Child3&quot;);  \nchild3.ReplaceWith(  \n    new XElement(&quot;NewChild&quot;, &quot;new content&quot;)  \n);  \nConsole.WriteLine(xmlTree);  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim xmlTree As XElement = _   \n        &lt;Root&gt;  \n            &lt;Child1&gt;child1 content&lt;/Child1&gt;  \n            &lt;Child2&gt;child2 content&lt;/Child2&gt;  \n            &lt;Child3&gt;child3 content&lt;/Child3&gt;  \n            &lt;Child4&gt;child4 content&lt;/Child4&gt;  \n            &lt;Child5&gt;child5 content&lt;/Child5&gt;  \n        &lt;/Root&gt;  \n\nDim child3 As XElement = xmlTree.&lt;Child3&gt;(0)  \nchild3.ReplaceWith(&lt;NewChild&gt;new content&lt;/NewChild&gt;)  \nConsole.WriteLine(xmlTree)  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code class=\"lang-xml\">\n                &lt;Root&gt;  \n  &lt;Child1&gt;child1 content&lt;/Child1&gt;  \n  &lt;Child2&gt;child2 content&lt;/Child2&gt;  \n  &lt;NewChild&gt;new content&lt;/NewChild&gt;  \n  &lt;Child4&gt;child4 content&lt;/Child4&gt;  \n  &lt;Child5&gt;child5 content&lt;/Child5&gt;  \n&lt;/Root&gt;  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_ReplaceWith_System_Object___\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_ReplaceWith_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ReplaceWith(Object[])</div>        \r\n          </div>\r\n    \r\n            <p>Replaces this node with the specified content.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void ReplaceWith (object[] content);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>content</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A parameter list of the new content.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method first removes this node from its parent, and then adds the specified content to this node&#39;s parent, in the place of this node.  </p>\n<p> The <a class=\"xref\" href=\"system.xml.linq.xcontainer\" data-linktype=\"relative-path\">XContainer</a> stores its child nodes as a singly-linked list of <a class=\"xref\" href=\"system.xml.linq.xnode\" data-linktype=\"relative-path\">XNode</a> objects. This means that the <a class=\"xref\" href=\"system.xml.linq.xnode#System_Xml_Linq_XNode_ReplaceWith_\" data-linktype=\"relative-path\">ReplaceWith</a> method must traverse the list of direct child nodes under the parent container. Therefore, using this method might affect your performance.  </p>\n<p> For details about the valid content that can be passed to this method, see <a href=\"../Topic/Valid%20Content%20of%20XElement%20and%20XDocument%20Objects1.md\" data-linktype=\"relative-path\">Valid Content of XElement and XDocument Objects</a>.  </p>\n<p> This method will raise the <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_Changed\" data-linktype=\"relative-path\">Changed</a> and the <a class=\"xref\" href=\"system.xml.linq.xobject#System_Xml_Linq_XObject_Changing\" data-linktype=\"relative-path\">Changing</a> events.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example shows using the results of a LINQ to XML query as the input to this method.  </p>\n<pre><code class=\"lang-c#\">\n                XElement srcTree = new XElement(&quot;Root&quot;,  \n    new XElement(&quot;Element1&quot;, 1),  \n    new XElement(&quot;Element2&quot;, 2),  \n    new XElement(&quot;Element3&quot;, 3),  \n    new XElement(&quot;Element4&quot;, 4),  \n    new XElement(&quot;Element5&quot;, 5)  \n);  \nXElement xmlTree = new XElement(&quot;Root&quot;,  \n    new XElement(&quot;Child1&quot;, 1),  \n    new XElement(&quot;Child2&quot;, 2),  \n    new XElement(&quot;Child3&quot;, 3),  \n    new XElement(&quot;Child4&quot;, 4),  \n    new XElement(&quot;Child5&quot;, 5)  \n);  \nXElement child3 = xmlTree.Element(&quot;Child3&quot;);  \nchild3.ReplaceWith(  \n    from el in srcTree.Elements()  \n    where (int)el &gt; 3  \n    select el  \n);  \nConsole.WriteLine(xmlTree);  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim srcTree As XElement = _   \n        &lt;Root&gt;  \n            &lt;Element1&gt;1&lt;/Element1&gt;  \n            &lt;Element2&gt;2&lt;/Element2&gt;  \n            &lt;Element3&gt;3&lt;/Element3&gt;  \n            &lt;Element4&gt;4&lt;/Element4&gt;  \n            &lt;Element5&gt;5&lt;/Element5&gt;  \n        &lt;/Root&gt;  \n\nDim xmlTree As XElement = _   \n        &lt;Root&gt;  \n            &lt;Child1&gt;1&lt;/Child1&gt;  \n            &lt;Child2&gt;2&lt;/Child2&gt;  \n            &lt;Child3&gt;3&lt;/Child3&gt;  \n            &lt;Child4&gt;4&lt;/Child4&gt;  \n            &lt;Child5&gt;5&lt;/Child5&gt;  \n        &lt;/Root&gt;  \n\nDim child3 As XElement = xmlTree.&lt;Child3&gt;(0)  \nchild3.ReplaceWith( _  \n    From el In srcTree.Elements() _  \n    Where (CInt(el) &gt; 3) _  \n    Select el)  \n\nConsole.WriteLine(xmlTree)  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code class=\"lang-xml\">\n                &lt;Root&gt;  \n  &lt;Child1&gt;1&lt;/Child1&gt;  \n  &lt;Child2&gt;2&lt;/Child2&gt;  \n  &lt;Element4&gt;4&lt;/Element4&gt;  \n  &lt;Element5&gt;5&lt;/Element5&gt;  \n  &lt;Child4&gt;4&lt;/Child4&gt;  \n  &lt;Child5&gt;5&lt;/Child5&gt;  \n&lt;/Root&gt;  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_ToString\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_ToString_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ToString()</div>        \r\n          </div>\r\n    \r\n            <p>Returns the indented XML for this node.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override string ToString ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a> containing the indented XML.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses this method to retrieve indented XML.  </p>\n<pre><code class=\"lang-c#\">\n                XElement xmlTree = new XElement(&quot;Root&quot;,  \n    new XElement(&quot;Child1&quot;, 1)  \n);  \nConsole.WriteLine(xmlTree);  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim xmlTree As XElement = _   \n        &lt;Root&gt;  \n            &lt;Child1&gt;1&lt;/Child1&gt;  \n        &lt;/Root&gt;  \n\nConsole.WriteLine(xmlTree)  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code class=\"lang-xml\">\n                &lt;Root&gt;  \n  &lt;Child1&gt;1&lt;/Child1&gt;  \n&lt;/Root&gt;  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_ToString_System_Xml_Linq_SaveOptions_\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_ToString_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ToString(SaveOptions)</div>        \r\n          </div>\r\n    \r\n            <p>Returns the XML for this node, optionally disabling formatting.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public string ToString (System.Xml.Linq.SaveOptions options);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>options</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.xml.linq.saveoptions\" data-linktype=\"relative-path\">SaveOptions</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <a class=\"xref\" href=\"system.xml.linq.saveoptions\" data-linktype=\"relative-path\">SaveOptions</a> that specifies formatting behavior.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a> containing the XML.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses this method to retrieve unformatted and formatted XML.  </p>\n<pre><code class=\"lang-c#\">\n                XElement root = XElement.Parse(&quot;&lt;Root&gt;&lt;Child/&gt;&lt;/Root&gt;&quot;);  \nConsole.WriteLine(root.ToString(SaveOptions.DisableFormatting));  \nConsole.WriteLine(&quot;---&quot;);  \nConsole.WriteLine(root.ToString(SaveOptions.None));  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim root As XElement = &lt;Root&gt;  \n                           &lt;Child/&gt;  \n                       &lt;/Root&gt;  \nConsole.WriteLine(root.ToString(SaveOptions.DisableFormatting))  \nConsole.WriteLine(&quot;---&quot;)  \nConsole.WriteLine(root.ToString(SaveOptions.None))  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code>\n                &lt;Root&gt;&lt;Child /&gt;&lt;/Root&gt;  \n---  \n&lt;Root&gt;  \n  &lt;Child /&gt;  \n&lt;/Root&gt;  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Xml_Linq_XNode_WriteTo_System_Xml_XmlWriter_\">\r\n    \r\n            <a id=\"System_Xml_Linq_XNode_WriteTo_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">WriteTo(XmlWriter)</div>        \r\n          </div>\r\n    \r\n            <p>Writes this node to an <a class=\"xref\" href=\"system.xml.xmlwriter\" data-linktype=\"relative-path\">XmlWriter</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract void WriteTo (System.Xml.XmlWriter writer);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>writer</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.xml.xmlwriter\" data-linktype=\"relative-path\">XmlWriter</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An <a class=\"xref\" href=\"system.xml.xmlwriter\" data-linktype=\"relative-path\">XmlWriter</a> into which this method will write.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>You can use this method to write code that does a streaming transform of a very large document. For more information, see <a href=\"../Topic/How%20to:%20Perform%20Streaming%20Transform%20of%20Large%20XML%20Documents.md\" data-linktype=\"relative-path\">How to: Perform Streaming Transform of Large XML Documents</a>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an <a class=\"xref\" href=\"system.xml.xmlwriter\" data-linktype=\"relative-path\">XmlWriter</a> that writes to a <a class=\"xref\" href=\"system.text.stringbuilder\" data-linktype=\"relative-path\">StringBuilder</a>. It then uses this method to write two XML trees to the writer.  </p>\n<pre><code class=\"lang-c#\">\n                StringBuilder sb = new StringBuilder();  \nXmlWriterSettings xws = new XmlWriterSettings();  \nxws.OmitXmlDeclaration = true;  \nxws.Indent = true;  \n\nusing (XmlWriter xw = XmlWriter.Create(sb, xws)) {  \n    xw.WriteStartElement(&quot;Root&quot;);  \n    XElement child1 = new XElement(&quot;Child&quot;,  \n        new XElement(&quot;GrandChild&quot;, &quot;some content&quot;)  \n    );  \n    child1.WriteTo(xw);  \n    XElement child2 = new XElement(&quot;AnotherChild&quot;,  \n        new XElement(&quot;GrandChild&quot;, &quot;different content&quot;)  \n    );  \n    child2.WriteTo(xw);  \n    xw.WriteEndElement();  \n}  \nConsole.WriteLine(sb.ToString());  \n</code></pre><pre><code class=\"lang-vb\">\n                Dim sb As StringBuilder = New StringBuilder()  \nDim xws As XmlWriterSettings = New XmlWriterSettings()  \nxws.OmitXmlDeclaration = True  \nxws.Indent = True  \n\nUsing xw = XmlWriter.Create(sb, xws)  \n    xw.WriteStartElement(&quot;Root&quot;)  \n    Dim child1 As XElement = &lt;Child&gt;  \n                                 &lt;GrandChild&gt;some content&lt;/GrandChild&gt;  \n                             &lt;/Child&gt;  \n    child1.WriteTo(xw)  \n    Dim child2 As XElement = &lt;AnotherChild&gt;  \n                                 &lt;GrandChild&gt;different content&lt;/GrandChild&gt;  \n                             &lt;/AnotherChild&gt;  \n    child2.WriteTo(xw)  \n    xw.WriteEndElement()  \nEnd Using  \n\nConsole.WriteLine(sb.ToString())  \n</code></pre><p> This example produces the following output:  </p>\n<pre><code class=\"lang-xml\">\n                &lt;Root&gt;  \n  &lt;Child&gt;  \n    &lt;GrandChild&gt;some content&lt;/GrandChild&gt;  \n  &lt;/Child&gt;  \n  &lt;AnotherChild&gt;  \n    &lt;GrandChild&gt;different content&lt;/GrandChild&gt;  \n  &lt;/AnotherChild&gt;  \n&lt;/Root&gt;  \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n","outputRootRelativePath":"./","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"breadcrumb_path\" content=\"breadcrumb/toc.json\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"fulldocset\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.fulldocset\">\r\n<meta name=\"ref_skeleton_gitcommit\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Xml.Linq.XNode.yml\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Xml.Linq.XNode.yml\">\r\n<meta name=\"APIName\" content=\"System.Xml.Linq.XNode\">\r\n<meta name=\"APIName\" content=\"System.Xml.Linq.XNode.AddAfterSelf\">\r\n<meta name=\"APIName\" content=\"System.Xml.Linq.XNode.AddBeforeSelf\">\r\n<meta name=\"APIName\" content=\"System.Xml.Linq.XNode.Ancestors\">\r\n<meta name=\"APIName\" content=\"System.Xml.Linq.XNode.CompareDocumentOrder\">\r\n<meta name=\"APIName\" content=\"System.Xml.Linq.XNode.CreateReader\">\r\n<meta name=\"APIName\" content=\"System.Xml.Linq.XNode.DeepEquals\">\r\n<meta name=\"APIName\" content=\"System.Xml.Linq.XNode.DocumentOrderComparer\">\r\n<meta name=\"APIName\" content=\"System.Xml.Linq.XNode.ElementsAfterSelf\">\r\n<meta name=\"APIName\" content=\"System.Xml.Linq.XNode.ElementsBeforeSelf\">\r\n<meta name=\"APIName\" content=\"System.Xml.Linq.XNode.EqualityComparer\">\r\n<meta name=\"APIName\" content=\"System.Xml.Linq.XNode.IsAfter\">\r\n<meta name=\"APIName\" content=\"System.Xml.Linq.XNode.IsBefore\">\r\n<meta name=\"APIName\" content=\"System.Xml.Linq.XNode.NextNode\">\r\n<meta name=\"APIName\" content=\"System.Xml.Linq.XNode.NodesAfterSelf\">\r\n<meta name=\"APIName\" content=\"System.Xml.Linq.XNode.NodesBeforeSelf\">\r\n<meta name=\"APIName\" content=\"System.Xml.Linq.XNode.PreviousNode\">\r\n<meta name=\"APIName\" content=\"System.Xml.Linq.XNode.ReadFrom\">\r\n<meta name=\"APIName\" content=\"System.Xml.Linq.XNode.Remove\">\r\n<meta name=\"APIName\" content=\"System.Xml.Linq.XNode.ReplaceWith\">\r\n<meta name=\"APIName\" content=\"System.Xml.Linq.XNode.ToString\">\r\n<meta name=\"APIName\" content=\"System.Xml.Linq.XNode.WriteTo\">\r\n<meta name=\"APILocation\" content=\"System.Xml.Linq.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-01 01:37 AM\">\r\n<meta name=\"document_id\" content=\"2a813fc8-8033-8880-a53d-4736c1354995\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Represents the abstract concept of a node (element, comment, document type, processing instruction, or text node) in the XML tree.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/System.Xml.Linq/toc.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Xml.Linq.XNode\">\r\n","rawMetadata":{"author":"dotnet-bot","breadcrumb_path":"breadcrumb/toc.json","search.ms_sitename":"Docs","search.ms_docsetname":"fulldocset","version":null,"_op_canonicalUrlPrefix":"https://ppe.docs.microsoft.com/en-us/fulldotnet/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":true,"depot_name":"MSDN.fulldocset","_op_gitRefSkeletonCommitHistory":[{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"use plugin in master","commit_sha":"501959ac03e19ac52a27aa4c6bbeb980f8b11c8c","commit_date":"2017-03-01 09:31:20 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"fix pointer ref","commit_sha":"76befb0e7f7b41839ec719047e5b39a5981298f3","commit_date":"2017-02-28 15:47:23 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"switch from platform to version","commit_sha":"78cdacb5ca782478af490a6b30c3a2cb2b6b873e","commit_date":"2017-02-28 15:09:51 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"update platforms","commit_sha":"39ad5a8919a59afc93a79ac4bd8e07c3b471b37a","commit_date":"2017-02-28 10:38:59 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"checkin yml","commit_sha":"da161b792852497df7140d7768cee2eccd9cb43f","commit_date":"2017-02-28 09:36:15 +0800"}],"ref_skeleton_gitcommit":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Xml.Linq.XNode.yml","original_ref_skeleton_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Xml.Linq.XNode.yml","open_to_public_contributors":true,"api_name":["System.Xml.Linq.XNode","System.Xml.Linq.XNode.AddAfterSelf","System.Xml.Linq.XNode.AddBeforeSelf","System.Xml.Linq.XNode.Ancestors","System.Xml.Linq.XNode.CompareDocumentOrder","System.Xml.Linq.XNode.CreateReader","System.Xml.Linq.XNode.DeepEquals","System.Xml.Linq.XNode.DocumentOrderComparer","System.Xml.Linq.XNode.ElementsAfterSelf","System.Xml.Linq.XNode.ElementsBeforeSelf","System.Xml.Linq.XNode.EqualityComparer","System.Xml.Linq.XNode.IsAfter","System.Xml.Linq.XNode.IsBefore","System.Xml.Linq.XNode.NextNode","System.Xml.Linq.XNode.NodesAfterSelf","System.Xml.Linq.XNode.NodesBeforeSelf","System.Xml.Linq.XNode.PreviousNode","System.Xml.Linq.XNode.ReadFrom","System.Xml.Linq.XNode.Remove","System.Xml.Linq.XNode.ReplaceWith","System.Xml.Linq.XNode.ToString","System.Xml.Linq.XNode.WriteTo"],"api_location":["System.Xml.Linq.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Xml.Linq.XNode","System::Xml::Linq::XNode","System.Xml.Linq.XNode.AddAfterSelf","System::Xml::Linq::XNode::AddAfterSelf","System.Xml.Linq.XNode.AddBeforeSelf","System::Xml::Linq::XNode::AddBeforeSelf","System.Xml.Linq.XNode.Ancestors","System::Xml::Linq::XNode::Ancestors","System.Xml.Linq.XNode.CompareDocumentOrder","System::Xml::Linq::XNode::CompareDocumentOrder","System.Xml.Linq.XNode.CreateReader","System::Xml::Linq::XNode::CreateReader","System.Xml.Linq.XNode.DeepEquals","System::Xml::Linq::XNode::DeepEquals","System.Xml.Linq.XNode.DocumentOrderComparer","System::Xml::Linq::XNode::DocumentOrderComparer","System.Xml.Linq.XNode.ElementsAfterSelf","System::Xml::Linq::XNode::ElementsAfterSelf","System.Xml.Linq.XNode.ElementsBeforeSelf","System::Xml::Linq::XNode::ElementsBeforeSelf","System.Xml.Linq.XNode.EqualityComparer","System::Xml::Linq::XNode::EqualityComparer","System.Xml.Linq.XNode.IsAfter","System::Xml::Linq::XNode::IsAfter","System.Xml.Linq.XNode.IsBefore","System::Xml::Linq::XNode::IsBefore","System.Xml.Linq.XNode.NextNode","System::Xml::Linq::XNode::NextNode","System.Xml.Linq.XNode.NodesAfterSelf","System::Xml::Linq::XNode::NodesAfterSelf","System.Xml.Linq.XNode.NodesBeforeSelf","System::Xml::Linq::XNode::NodesBeforeSelf","System.Xml.Linq.XNode.PreviousNode","System::Xml::Linq::XNode::PreviousNode","System.Xml.Linq.XNode.ReadFrom","System::Xml::Linq::XNode::ReadFrom","System.Xml.Linq.XNode.Remove","System::Xml::Linq::XNode::Remove","System.Xml.Linq.XNode.ReplaceWith","System::Xml::Linq::XNode::ReplaceWith","System.Xml.Linq.XNode.ToString","System::Xml::Linq::XNode::ToString","System.Xml.Linq.XNode.WriteTo","System::Xml::Linq::XNode::WriteTo"],"dev_langs":["csharp"],"updated_at":"2017-03-01 01:37 AM","document_id":"2a813fc8-8033-8880-a53d-4736c1354995","content_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/xml/System.Xml.Linq/XNode.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"XNode class | Microsoft Docs","_op_ogTitle":"XNode class","description":"Represents the abstract concept of a node (element, comment, document type, processing instruction, or text node) in the XML tree.\n","toc_asset_id":"_splitted/System.Xml.Linq/toc.json","toc_rel":"_splitted/System.Xml.Linq/toc.json","source_url":"","ms.assetid":"System.Xml.Linq.XNode","canonical_url":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.xml.linq.xnode","_op_canonicalUrl":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.xml.linq.xnode","fileRelativePath":"System.Xml.Linq.XNode.html"},"themesRelativePathToOutputRoot":"_themes/"}