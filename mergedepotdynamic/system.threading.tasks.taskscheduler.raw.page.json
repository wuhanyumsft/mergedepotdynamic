{"content":"    \r\n    <h1 id=\"System_Threading_Tasks_TaskScheduler\">\r\n      <span class=\"lang-csharp\">TaskScheduler</span>\r\n        Class\r\n    </h1>\r\n    \r\n    \r\n    <nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n      <h3>In this Article</h3>\r\n    </nav><div class=\"summary\">\r\n    \t<p>Represents an object that handles the low-level work of queuing tasks onto threads.</p>\n\r\n    </div><h2>Syntax</h2>\r\n    \r\n    \t<h3>Declaration</h3>\r\n    \t<pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">[System.Diagnostics.DebuggerDisplay(&quot;Id={Id}&quot;)]\n[System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))]\npublic abstract class TaskScheduler</code></pre>\r\n    \r\n    \r\n    \r\n    <h3>Inheritance Hierarchy</h3>\r\n    <ul class=\"inheritance\">\r\n        <li class=\"l0\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a>\r\n          </div>\r\n        </li>\r\n      <li class=\"l1\">\r\n        <div class=\"xref\">\r\n          <div class=\"lang-csharp\">TaskScheduler</div>\r\n        </div>\r\n      </li>\r\n    </ul>\r\n    \r\n      <div class=\"referencebox inheritedMembers\">\r\n        <h3>Inherited Members</h3>\r\n        <h4></h4>\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a>\r\n          </div>\r\n          \r\n      </div>\r\n    \r\n    \r\n      <h2>Remarks</h2>\r\n      <p>An instance of the TaskScheduler class represents a task scheduler. A task scheduler ensures that the work of a task is eventually executed.  </p>\n<p> The default task scheduler is based on the .NET Framework 4 thread pool, which provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance. It should be sufficient for most scenarios.  </p>\n<p> The TaskScheduler class also serves as the extension point for all customizable scheduling logic.  This includes mechanisms such as how to schedule a task for execution, and how scheduled tasks should be exposed to debuggers. If you require special functionality, you can create a custom scheduler and enable it for specific tasks or queries.  </p>\n<p> In this topic:<br><a href=\"#Default\" data-linktype=\"self-bookmark\">The default task scheduler and the thread pool</a><br> <a href=\"#Queues\" data-linktype=\"self-bookmark\">The global queue vs. local queues</a><br> <a href=\"#Stealing\" data-linktype=\"self-bookmark\">Work stealing</a><br> <a href=\"#LongRunning\" data-linktype=\"self-bookmark\">Long-running tasks</a><br> <a href=\"#Inlining\" data-linktype=\"self-bookmark\">Task inlining</a><br><a href=\"#Sync\" data-linktype=\"self-bookmark\">Specifying a synchronization context</a>  </p>\n<p><a name=\"Default\"></a>   </p>\n<h2 id=\"the-default-task-scheduler-and-the-thread-pool\">The default task scheduler and the thread pool</h2>\n<p> The default scheduler for the Task Parallel Library and PLINQ uses the .NET Framework thread pool, which is represented by the <a class=\"xref\" href=\"system.threading.threadpool\" data-linktype=\"relative-path\">ThreadPool</a> class, to queue and execute work. The thread pool uses the information that is provided by the <a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a> type to efficiently     support the fine-grained parallelism (short-lived units of work) that parallel tasks and queries often represent.  </p>\n<p><a name=\"Queues\"></a>   </p>\n<h3 id=\"the-global-queue-vs-local-queues\">The global queue vs. local queues</h3>\n<p> The thread pool maintains a global FIFO (first-in, first-out) work queue for threads in each application domain. Whenever a program calls the <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_QueueUserWorkItem_\" data-linktype=\"relative-path\">QueueUserWorkItem</a> (or <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_UnsafeQueueUserWorkItem_\" data-linktype=\"relative-path\">UnsafeQueueUserWorkItem</a>) method, the work is put on this shared queue and eventually de-queued onto the next thread that becomes available. Starting with the .NET Framework 4, this queue has been improved to use a lock-free algorithm that resembles the <a class=\"xref\" href=\"system.collections.concurrent.concurrentqueue-1\" data-linktype=\"relative-path\">ConcurrentQueue&lt;T&gt;</a> class. By using this lock-free implementation, the thread pool spends less time when it queues and de-queues work items. This performance benefit is available to all programs that use the thread pool.  </p>\n<p> Top-level tasks, which are tasks that are not created in the context of another task, are put on the global queue just like any other work item. However, nested or child tasks, which are created in the context of another task, are handled quite differently. A child or nested task is put on a local queue that is specific to the thread on which the parent task is executing. The parent task may be a top-level task or it also may be the child of another task. When this thread is ready for more work, it first looks in the local queue. If work items are waiting there, they can be accessed quickly. The local queues are accessed in last-in, first-out order (LIFO) to preserve cache locality and reduce contention. For more information about child tasks and nested tasks, see <a href=\"../Topic/Attached%20and%20Detached%20Child%20Tasks.md\" data-linktype=\"relative-path\">Attached and Detached Child Tasks</a>.  </p>\n<p> The use of local queues not only reduces pressure on the global queue, but also takes advantage of data locality. Work items in the local queue frequently reference data structures that are physically near one another in memory. In these cases, the data is already in the cache after the first task has run and can be accessed quickly. Both <a href=\"../Topic/Parallel%20LINQ%20(PLINQ).md\" data-linktype=\"relative-path\">Parallel LINQ (PLINQ)</a> and the <a class=\"xref\" href=\"system.threading.tasks.parallel\" data-linktype=\"relative-path\">Parallel</a> class use nested tasks and child tasks extensively, and achieve significant speedups by using the local work queues.  </p>\n<p><a name=\"Stealing\"></a>   </p>\n<h3 id=\"work-stealing\">Work stealing</h3>\n<p> Starting with the .NET Framework 4, the thread pool also features a work-stealing algorithm to help make sure that no threads are sitting idle while others still have work in their queues. When a thread-pool thread is ready for more work, it first looks at the head of its local queue, then in the global queue, and then in the local queues of other threads. If it finds a work item in the local queue of another thread, it first applies heuristics to make sure that it can run the work efficiently. If it can, it de-queues the work item from the tail (in FIFO order). This reduces contention on each local queue and preserves data locality. This architecture helps the  thread pool load-balance work more efficiently than past versions did.  </p>\n<p><a name=\"LongRunning\"></a>   </p>\n<h3 id=\"long-running-tasks\">Long-running tasks</h3>\n<p> You may want to explicitly prevent a task from being put on a local queue. For example, you may know that a particular work item will run for a relatively long time and is likely to block all other work items on the local queue. In this case, you can specify the <a class=\"xref\" href=\"system.threading.tasks.taskcreationoptions\" data-linktype=\"relative-path\">System.Threading.Tasks.TaskCreationOptions</a> option, which provides a hint to the scheduler that an additional thread might be required for the task so that it does not block the forward progress of other threads or work items on the local queue. By using this option you avoid the thread pool completely, including the global and local queues.  </p>\n<p><a name=\"Inlining\"></a>   </p>\n<h3 id=\"task-inlining\">Task inlining</h3>\n<p> In some cases when a <a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a> is waited on, it may be executed synchronously on the thread that is performing the wait operation. This enhances performance by preventing the need for an additional thread and instead using the existing thread, which would have blocked otherwise. To prevent errors due to re-entrancy, task inlining only occurs when the wait target is found in the relevant thread&#39;s local queue.  </p>\n<p><a name=\"Sync\"></a>   </p>\n<h2 id=\"specifying-a-synchronization-context\">Specifying a synchronization context</h2>\n<p> You can use the <a class=\"xref\" href=\"system.threading.tasks.taskscheduler#System_Threading_Tasks_TaskScheduler_FromCurrentSynchronizationContext_\" data-linktype=\"relative-path\">FromCurrentSynchronizationContext</a> method to specify that a task should be scheduled to run on a particular thread. This is useful in frameworks such as Windows Forms and Windows Presentation Foundation where access to user interface objects is often restricted to code that is running on the same thread on which the UI object was created. For more information, see How to: Schedule Work on the User Interface (UI) Thread.  </p>\n<p> The following example uses the <a class=\"xref\" href=\"system.threading.tasks.taskscheduler#System_Threading_Tasks_TaskScheduler_FromCurrentSynchronizationContext_\" data-linktype=\"relative-path\">FromCurrentSynchronizationContext</a> method in a Windows Presentation Foundation (WPF) app to schedule a task on the same thread that the user interface (UI) control was created on.   The example creates a mosaic of images that are randomly selected from a specified directory. The WPF objects are used to load and resize the images. The raw pixels are then passed to a task that uses a <code>For</code> loop to write the pixel data into a large single-byte array. No synchronization is required because no two tiles occupy the same array elements. The tiles can also be written in any order because their position is calculated independently of any other tile. The large array is then passed to a task that runs on the UI thread, where the pixel data is loaded into an Image control.  </p>\n<p> The example moves data off the UI thread, modifies it by using parallel loops and <a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a> objects, and then passes it back to a task that runs on the UI thread. This approach is useful when you have to use the Task Parallel Library to perform operations that either are not supported by the WPF API, or are not sufficiently fast. Another way to create an image mosaic in WPF is to use a <a class=\"xref\" href=\"system.windows.controls.wrappanel\" data-linktype=\"relative-path\">System.Windows.Controls.WrapPanel</a> control and add images to it. The <a class=\"xref\" href=\"system.windows.controls.wrappanel\" data-linktype=\"relative-path\">WrapPanel</a> handles the work of positioning the tiles. However, this work can only be performed on the UI thread.  </p>\n<pre><code class=\"lang-cs\" name=\"TPL_SyncContext#01\">using System;\nusing System.Threading.Tasks;\nusing System.Windows;\nusing System.Windows.Media;\nusing System.Windows.Media.Imaging;\n\nnamespace WPF_CS1\n{\n    /// &lt;summary&gt;\n    /// Interaction logic for MainWindow.xaml\n    /// &lt;/summary&gt;\n    public partial class MainWindow : Window\n    {\n        private int fileCount;\n        int colCount;\n        int rowCount;\n        private int tilePixelHeight;\n        private int tilePixelWidth;\n        private int largeImagePixelHeight;\n        private int largeImagePixelWidth;\n        private int largeImageStride;\n        PixelFormat format;\n        BitmapPalette palette = null;\n\n        public MainWindow()\n        {\n            InitializeComponent();\n\n            // For this example, values are hard-coded to a mosaic of 8x8 tiles.\n            // Each tile is 50 pixels high and 66 pixels wide and 32 bits per pixel.\n            colCount = 12;\n            rowCount = 8;\n            tilePixelHeight = 50;\n            tilePixelWidth = 66;\n            largeImagePixelHeight = tilePixelHeight * rowCount;\n            largeImagePixelWidth = tilePixelWidth * colCount;\n            largeImageStride = largeImagePixelWidth * (32 / 8);\n            this.Width = largeImagePixelWidth + 40;\n            image.Width = largeImagePixelWidth;\n            image.Height = largeImagePixelHeight;\n\n\n        }\n\n        private void button_Click(object sender, RoutedEventArgs e)\n        {\n\n            // For best results use 1024 x 768 jpg files at 32bpp.\n            string[] files = System.IO.Directory.GetFiles(@&quot;C:\\Users\\Public\\Pictures\\Sample Pictures\\&quot;, &quot;*.jpg&quot;);\n\n            fileCount = files.Length;\n            Task&lt;byte[]&gt;[] images = new Task&lt;byte[]&gt;[fileCount];\n            for (int i = 0; i &lt; fileCount; i++)\n            {\n                int x = i;\n                images[x] = Task.Factory.StartNew(() =&gt; LoadImage(files[x]));\n            }\n\n            // When theyï¿½ve all been loaded, tile them into a single byte array.\n            var tiledImage = Task.Factory.ContinueWhenAll(\n                images, (i) =&gt; TileImages(i));\n\n            // We are currently on the UI thread. Save the sync context and pass it to\n            // the next task so that it can access the UI control &quot;image&quot;.\n            var UISyncContext = TaskScheduler.FromCurrentSynchronizationContext();\n\n            //  On the UI thread, put the bytes into a bitmap and\n            // and display it in the Image control.\n            var t3 = tiledImage.ContinueWith((antecedent) =&gt;\n            {\n                // Get System DPI.\n                Matrix m = PresentationSource.FromVisual(Application.Current.MainWindow)\n                                            .CompositionTarget.TransformToDevice;\n                double dpiX = m.M11;\n                double dpiY = m.M22;\n\n                BitmapSource bms = BitmapSource.Create(largeImagePixelWidth,\n                    largeImagePixelHeight,\n                    dpiX,\n                    dpiY,\n                    format,\n                    palette, //use default palette\n                    antecedent.Result,\n                    largeImageStride);\n                image.Source = bms;\n            }, UISyncContext);\n        }\n\n        byte[] LoadImage(string filename)\n        {\n            // Use the WPF BitmapImage class to load and \n            // resize the bitmap. NOTE: Only 32bpp formats are supported correctly.\n            // Support for additional color formats is left as an exercise\n            // for the reader. For more information, see documentation for ColorConvertedBitmap.\n\n            BitmapImage bitmapImage = new BitmapImage();\n            bitmapImage.BeginInit();\n            bitmapImage.UriSource = new Uri(filename);\n            bitmapImage.DecodePixelHeight = tilePixelHeight;\n            bitmapImage.DecodePixelWidth = tilePixelWidth;\n            bitmapImage.EndInit();\n\n            format = bitmapImage.Format;\n            int size = (int)(bitmapImage.Height * bitmapImage.Width);\n            int stride = (int)bitmapImage.Width * 4;\n            byte[] dest = new byte[stride * tilePixelHeight];\n\n            bitmapImage.CopyPixels(dest, stride, 0);\n\n            return dest;\n        }\n\n        int Stride(int pixelWidth, int bitsPerPixel)\n        {\n            return (((pixelWidth * bitsPerPixel + 31) / 32) * 4);\n        }\n\n        // Map the individual image tiles to the large image\n        // in parallel. Any kind of raw image manipulation can be\n        // done here because we are not attempting to access any \n        // WPF controls from multiple threads.\n        byte[] TileImages(Task&lt;byte[]&gt;[] sourceImages)\n        {\n            byte[] largeImage = new byte[largeImagePixelHeight * largeImageStride];\n            int tileImageStride = tilePixelWidth * 4; // hard coded to 32bpp\n\n            Random rand = new Random();\n            Parallel.For(0, rowCount * colCount, (i) =&gt;\n            {\n                // Pick one of the images at random for this tile.\n                int cur = rand.Next(0, sourceImages.Length);\n                byte[] pixels = sourceImages[cur].Result;\n\n                // Get the starting index for this tile.\n                int row = i / colCount;\n                int col = (int)(i % colCount);\n                int idx = ((row * (largeImageStride * tilePixelHeight)) + (col * tileImageStride));\n\n                // Write the pixels for the current tile. The pixels are not contiguous\n                // in the array, therefore we have to advance the index by the image stride\n                // (minus the stride of the tile) for each scanline of the tile.\n                int tileImageIndex = 0;\n                for (int j = 0; j &lt; tilePixelHeight; j++)\n                {\n                    // Write the next scanline for this tile.\n                    for (int k = 0; k &lt; tileImageStride; k++)\n                    {\n                        largeImage[idx++] = pixels[tileImageIndex++];\n                    }\n                    // Advance to the beginning of the next scanline.\n                    idx += largeImageStride - tileImageStride;\n                }\n            });\n            return largeImage;\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"TPL_SyncContext#01\">Imports System.Threading.Tasks\nImports System.Windows\nImports System.Windows.Media\nImports System.Windows.Media.Imaging\n\nPartial Public Class MainWindow : Inherits Window\n    Dim fileCount As Integer\n    Dim colCount As Integer\n    Dim rowCount As Integer\n    Dim tilePixelHeight As Integer\n    Dim tilePixelWidth As Integer\n    Dim largeImagePixelHeight As Integer\n    Dim largeImagePixelWidth As Integer\n    Dim largeImageStride As Integer\n    Dim format As PixelFormat\n    Dim palette As BitmapPalette = Nothing\n\n    Public Sub New()\n        InitializeComponent()\n\n        &#39; For this example, values are hard-coded to a mosaic of 8x8 tiles.\n        &#39; Each tile Is 50 pixels high And 66 pixels wide And 32 bits per pixel.\n        colCount = 12\n        rowCount = 8\n        tilePixelHeight = 50\n        tilePixelWidth = 66\n        largeImagePixelHeight = tilePixelHeight * rowCount\n        largeImagePixelWidth = tilePixelWidth * colCount\n        largeImageStride = largeImagePixelWidth * (32 / 8)\n        Me.Width = largeImagePixelWidth + 40\n        image.Width = largeImagePixelWidth\n        image.Height = largeImagePixelHeight\n    End Sub\n\n    Private Sub button_Click(sender As Object, e As RoutedEventArgs) _\n        Handles button.Click\n\n        &#39; For best results use 1024 x 768 jpg files at 32bpp.\n        Dim files() As String = System.IO.Directory.GetFiles(&quot;C:\\Users\\Public\\Pictures\\Sample Pictures\\&quot;, &quot;*.jpg&quot;)\n\n        fileCount = files.Length\n        Dim images(fileCount - 1) As Task(Of Byte())\n        For i As Integer = 0 To fileCount - 1\n            Dim x As Integer = i\n            images(x) = Task.Factory.StartNew(Function() LoadImage(files(x)))\n        Next\n\n        &#39; When theyï¿½ve all been loaded, tile them into a single byte array.\n        &#39;var tiledImage = Task.Factory.ContinueWhenAll(\n        &#39;        images, (i) &gt;= TileImages(i));\n\n        &#39;        Dim tiledImage As Task(Of Byte()) = Task.Factory.ContinueWhenAll(images, Function(i As Task(Of Byte())) TileImages(i))\n        Dim tiledImage = Task.Factory.ContinueWhenAll(images, Function(i As Task(Of Byte())()) TileImages(i))\n        &#39; We are currently on the UI thread. Save the sync context And pass it to\n        &#39; the next task so that it can access the UI control &quot;image1&quot;.\n        Dim UISyncContext = TaskScheduler.FromCurrentSynchronizationContext()\n\n        &#39;  On the UI thread, put the bytes into a bitmap And\n        &#39; And display it in the Image control.\n        Dim t3 = tiledImage.ContinueWith(Sub(antecedent)\n                                             &#39; Get System DPI.\n                                             Dim m As Matrix = PresentationSource.FromVisual(Application.Current.MainWindow).CompositionTarget.TransformToDevice\n                                             Dim dpiX As Double = m.M11\n                                             Dim dpiY As Double = m.M22\n\n                                             &#39; Use the default palette in creating the bitmap.\n                                             Dim bms As BitmapSource = BitmapSource.Create(largeImagePixelWidth,\n                                                                                           largeImagePixelHeight,\n                                             dpiX,\n                                             dpiY,\n                                             format,\n                                             palette,\n                                             antecedent.Result,\n                                             largeImageStride)\n                                             image.Source = bms\n                                         End Sub, UISyncContext)\n    End Sub\n\n    Public Function LoadImage(filename As String) As Byte()\n        &#39; Use the WPF BitmapImage class to load And \n        &#39; resize the bitmap. NOTE: Only 32bpp formats are supported correctly.\n        &#39; Support for additional color formats Is left as an exercise\n        &#39; for the reader. For more information, see documentation for ColorConvertedBitmap.\n        Dim bitmapImage As New BitmapImage()\n        bitmapImage.BeginInit()\n        bitmapImage.UriSource = New Uri(filename)\n        bitmapImage.DecodePixelHeight = tilePixelHeight\n        bitmapImage.DecodePixelWidth = tilePixelWidth\n        bitmapImage.EndInit()\n\n        format = bitmapImage.Format\n        Dim size As Integer = CInt(bitmapImage.Height * bitmapImage.Width)\n        Dim stride As Integer = CInt(bitmapImage.Width * 4)\n        Dim dest(stride * tilePixelHeight - 1) As Byte\n\n        bitmapImage.CopyPixels(dest, stride, 0)\n\n        Return dest\n    End Function\n\n    Function Stride(pixelWidth As Integer, bitsPerPixel As Integer) As Integer\n        Return (((pixelWidth * bitsPerPixel + 31) / 32) * 4)\n    End Function\n\n    &#39; Map the individual image tiles to the large image\n    &#39; in parallel. Any kind of raw image manipulation can be\n    &#39; done here because we are Not attempting to access any \n    &#39; WPF controls from multiple threads.\n    Function TileImages(sourceImages As Task(Of Byte())()) As Byte()\n        Dim largeImage(largeImagePixelHeight * largeImageStride - 1) As Byte\n        Dim tileImageStride As Integer = tilePixelWidth * 4 &#39; hard coded To 32bpp\n\n        Dim rand As New Random()\n        Parallel.For(0, rowCount * colCount, Sub(i)\n                                                 &#39; Pick one of the images at random for this tile.\n                                                 Dim cur As Integer = rand.Next(0, sourceImages.Length)\n                                                 Dim pixels() As Byte = sourceImages(cur).Result\n\n                                                 &#39; Get the starting index for this tile.\n                                                 Dim row As Integer = i \\ colCount\n                                                 Dim col As Integer = i Mod colCount\n                                                 Dim idx As Integer = ((row * (largeImageStride * tilePixelHeight)) + (col * tileImageStride))\n\n                                                 &#39; Write the pixels for the current tile. The pixels are Not contiguous\n                                                 &#39; in the array, therefore we have to advance the index by the image stride\n                                                 &#39; (minus the stride of the tile) for each scanline of the tile.\n                                                 Dim tileImageIndex As Integer = 0\n                                                 For j As Integer = 0 To tilePixelHeight - 1\n                                                     &#39; Write the next scanline for this tile.\n                                                     For k As Integer = 0 To tileImageStride - 1\n                                                         largeImage(idx) = pixels(tileImageIndex)\n                                                         idx += 1\n                                                         tileImageIndex += 1\n                                                     Next\n                                                     &#39; Advance to the beginning of the next scanline.\n                                                     idx += largeImageStride - tileImageStride\n                                                 Next\n                                             End Sub)\n        Return largeImage\n    End Function\nEnd Class\n</code></pre><p> To create the example, crate a WPF application project in Visual Studio and assign it a name of your choice. Then do the following:  </p>\n<ol>\n<li><p>In design view, drag an <a class=\"xref\" href=\"system.windows.controls.image\" data-linktype=\"relative-path\">Image</a> control from the <strong>Toolbox</strong> to the design surface. In XAML view, specify the horizontal alignment as &quot;Left.&quot; The size does not matter because the control is be dynamically resized at run time. Accept the default name, &quot;image&quot;.  </p>\n</li>\n<li><p>Drag a <a class=\"xref\" href=\"system.windows.controls.button\" data-linktype=\"relative-path\">Button</a> control from the <strong>Toolbox</strong> to the lower left part of the application window. Double-click the button to add a <a class=\"xref\" href=\"system.windows.controls.primitives.buttonbase#System_Windows_Controls_Primitives_ButtonBase_Click\" data-linktype=\"relative-path\">Click</a> event handler. In XAML view, specify the <a class=\"xref\" href=\"system.windows.controls.contentcontrol#System_Windows_Controls_ContentControl_Content_\" data-linktype=\"relative-path\">Content</a> property of the button as &quot;Make a Mosaic&quot; and specify its horizontal alignment as &quot;Left&quot;. Accept the default name, &quot;button&quot;.  </p>\n</li>\n<li><p>Replace the entire contents of the MainWindow.xaml.cs or MainWindow.xaml.vb file with the code from this example. Make sure that the name of the workspace matches the project name.  </p>\n</li>\n<li><p>The example reads JPEG images from a directory named C:\\Users\\Public\\Pictures\\Sample Pictures\\. Either create the directory and place some images in it, or change the path to refer to some other directory that contains images.  </p>\n<p>This example has some limitations. For example, only 32-bits-per-pixel images are supported; images in other formats are corrupted by the <a class=\"xref\" href=\"system.windows.media.imaging.bitmapimage\" data-linktype=\"relative-path\">BitmapImage</a> object during the resizing operation. Also, the source images must all be larger than the tile size. As a further exercise, you can add functionality to handle multiple pixel formats and file sizes.</p>\n</li>\n</ol>\n\r\n    \r\n    \r\n    <h2>Constructors\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Tasks_TaskScheduler__ctor\" data-linktype=\"self-bookmark\">TaskScheduler()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Initializes the <a class=\"xref\" href=\"system.threading.tasks.taskscheduler\" data-linktype=\"relative-path\">TaskScheduler</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Properties\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Tasks_TaskScheduler_Current\" data-linktype=\"self-bookmark\">Current</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the <a class=\"xref\" href=\"system.threading.tasks.taskscheduler\" data-linktype=\"relative-path\">TaskScheduler</a> associated with the currently executing task.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Tasks_TaskScheduler_Default\" data-linktype=\"self-bookmark\">Default</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the default <a class=\"xref\" href=\"system.threading.tasks.taskscheduler\" data-linktype=\"relative-path\">TaskScheduler</a> instance that is provided by the .NET Framework.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Tasks_TaskScheduler_Id\" data-linktype=\"self-bookmark\">Id</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the unique ID for this <a class=\"xref\" href=\"system.threading.tasks.taskscheduler\" data-linktype=\"relative-path\">TaskScheduler</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Tasks_TaskScheduler_MaximumConcurrencyLevel\" data-linktype=\"self-bookmark\">MaximumConcurrencyLevel</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Indicates the maximum concurrency level this <a class=\"xref\" href=\"system.threading.tasks.taskscheduler\" data-linktype=\"relative-path\">TaskScheduler</a> is able to support.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Methods\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Tasks_TaskScheduler_FromCurrentSynchronizationContext\" data-linktype=\"self-bookmark\">FromCurrentSynchronizationContext()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Creates a <a class=\"xref\" href=\"system.threading.tasks.taskscheduler\" data-linktype=\"relative-path\">TaskScheduler</a> associated with the current <a class=\"xref\" href=\"system.threading.synchronizationcontext\" data-linktype=\"relative-path\">SynchronizationContext</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Tasks_TaskScheduler_GetScheduledTasks\" data-linktype=\"self-bookmark\">GetScheduledTasks()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>For debugger support only, generates an enumerable of <a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a> instances currently queued to the scheduler waiting to be executed.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Tasks_TaskScheduler_QueueTask_System_Threading_Tasks_Task_\" data-linktype=\"self-bookmark\">QueueTask(Task)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Queues a <a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a> to the scheduler.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Tasks_TaskScheduler_TryDequeue_System_Threading_Tasks_Task_\" data-linktype=\"self-bookmark\">TryDequeue(Task)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Attempts to dequeue a <a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a> that was previously queued to this scheduler.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Tasks_TaskScheduler_TryExecuteTask_System_Threading_Tasks_Task_\" data-linktype=\"self-bookmark\">TryExecuteTask(Task)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Attempts to execute the provided <a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a> on this scheduler.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Tasks_TaskScheduler_TryExecuteTaskInline_System_Threading_Tasks_Task_System_Boolean_\" data-linktype=\"self-bookmark\">TryExecuteTaskInline(Task,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Determines whether the provided <a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a> can be executed synchronously in this call, and if it can, executes it.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Events\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Tasks_TaskScheduler_UnobservedTaskException\" data-linktype=\"self-bookmark\">UnobservedTaskException</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Occurs when a faulted task&#39;s unobserved exception is about to trigger exception escalation policy, which, by default, would terminate the process.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"constructors\">\r\n        <h2>Constructors\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Tasks_TaskScheduler__ctor\">\r\n    \r\n            <a id=\"System_Threading_Tasks_TaskScheduler__ctor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">TaskScheduler()</div>        \r\n          </div>\r\n    \r\n            <p>Initializes the <a class=\"xref\" href=\"system.threading.tasks.taskscheduler\" data-linktype=\"relative-path\">TaskScheduler</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected TaskScheduler ();</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"properties\">\r\n        <h2>Properties\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Tasks_TaskScheduler_Current\">\r\n    \r\n            <a id=\"System_Threading_Tasks_TaskScheduler_Current_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Current</div>        \r\n          </div>\r\n    \r\n            <p>Gets the <a class=\"xref\" href=\"system.threading.tasks.taskscheduler\" data-linktype=\"relative-path\">TaskScheduler</a> associated with the currently executing task.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Threading.Tasks.TaskScheduler Current { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.tasks.taskscheduler\" data-linktype=\"relative-path\">TaskScheduler</a></div>\r\n                  </div>\r\n                  <p>Returns the <a class=\"xref\" href=\"system.threading.tasks.taskscheduler\" data-linktype=\"relative-path\">TaskScheduler</a> associated with the currently executing task.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>When not called from within a task, Current will return the <a class=\"xref\" href=\"system.threading.tasks.taskscheduler#System_Threading_Tasks_TaskScheduler_Default_\" data-linktype=\"relative-path\">Default</a> scheduler.  </p>\n<p> For more information, see <a href=\"../Topic/Task%20Schedulers.md\" data-linktype=\"relative-path\">Task Schedulers</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Tasks_TaskScheduler_Default\">\r\n    \r\n            <a id=\"System_Threading_Tasks_TaskScheduler_Default_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Default</div>        \r\n          </div>\r\n    \r\n            <p>Gets the default <a class=\"xref\" href=\"system.threading.tasks.taskscheduler\" data-linktype=\"relative-path\">TaskScheduler</a> instance that is provided by the .NET Framework.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Threading.Tasks.TaskScheduler Default { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.tasks.taskscheduler\" data-linktype=\"relative-path\">TaskScheduler</a></div>\r\n                  </div>\r\n                  <p>Returns the default <a class=\"xref\" href=\"system.threading.tasks.taskscheduler\" data-linktype=\"relative-path\">TaskScheduler</a> instance.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>For more information, see <a href=\"../Topic/Task%20Schedulers.md\" data-linktype=\"relative-path\">Task Schedulers</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Tasks_TaskScheduler_Id\">\r\n    \r\n            <a id=\"System_Threading_Tasks_TaskScheduler_Id_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Id</div>        \r\n          </div>\r\n    \r\n            <p>Gets the unique ID for this <a class=\"xref\" href=\"system.threading.tasks.taskscheduler\" data-linktype=\"relative-path\">TaskScheduler</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public int Id { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </div>\r\n                  <p>Returns the unique ID for this <a class=\"xref\" href=\"system.threading.tasks.taskscheduler\" data-linktype=\"relative-path\">TaskScheduler</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>For more information, see <a href=\"../Topic/Task%20Schedulers.md\" data-linktype=\"relative-path\">Task Schedulers</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Tasks_TaskScheduler_MaximumConcurrencyLevel\">\r\n    \r\n            <a id=\"System_Threading_Tasks_TaskScheduler_MaximumConcurrencyLevel_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">MaximumConcurrencyLevel</div>        \r\n          </div>\r\n    \r\n            <p>Indicates the maximum concurrency level this <a class=\"xref\" href=\"system.threading.tasks.taskscheduler\" data-linktype=\"relative-path\">TaskScheduler</a> is able to support.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual int MaximumConcurrencyLevel { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </div>\r\n                  <p>Returns an integer that represents the maximum concurrency level. The default scheduler returns <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>For more information, see <a href=\"../Topic/Task%20Schedulers.md\" data-linktype=\"relative-path\">Task Schedulers</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"methods\">\r\n        <h2>Methods\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Tasks_TaskScheduler_FromCurrentSynchronizationContext\">\r\n    \r\n            <a id=\"System_Threading_Tasks_TaskScheduler_FromCurrentSynchronizationContext_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">FromCurrentSynchronizationContext()</div>        \r\n          </div>\r\n    \r\n            <p>Creates a <a class=\"xref\" href=\"system.threading.tasks.taskscheduler\" data-linktype=\"relative-path\">TaskScheduler</a> associated with the current <a class=\"xref\" href=\"system.threading.synchronizationcontext\" data-linktype=\"relative-path\">SynchronizationContext</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.tasks.taskscheduler\" data-linktype=\"relative-path\">TaskScheduler</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"system.threading.tasks.taskscheduler\" data-linktype=\"relative-path\">TaskScheduler</a> associated with the current <a class=\"xref\" href=\"system.threading.synchronizationcontext\" data-linktype=\"relative-path\">SynchronizationContext</a>, as determined by <span class=\"xref\">stem.Threading.SynchronizationContext.Current*</span>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The current SynchronizationContext may not be used as a TaskScheduler.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>All <a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a> instances queued to the returned scheduler will be executed through a call to the <a class=\"xref\" href=\"system.threading.synchronizationcontext#System_Threading_SynchronizationContext_Post_\" data-linktype=\"relative-path\">Post</a> method on that context.  </p>\n<p> For more information, see <a href=\"../Topic/Task%20Schedulers.md\" data-linktype=\"relative-path\">Task Schedulers</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Tasks_TaskScheduler_GetScheduledTasks\">\r\n    \r\n            <a id=\"System_Threading_Tasks_TaskScheduler_GetScheduledTasks_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetScheduledTasks()</div>        \r\n          </div>\r\n    \r\n            <p>For debugger support only, generates an enumerable of <a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a> instances currently queued to the scheduler waiting to be executed.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable</a>&lt;<a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a>&gt;</div>\r\n                  </div>\r\n                  <p>An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>This scheduler is unable to generate a list of queued tasks at this time.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A class derived from <a class=\"xref\" href=\"system.threading.tasks.taskscheduler\" data-linktype=\"relative-path\">TaskScheduler</a> implements this method in order to support integration with debuggers. This method will only be invoked by the .NET Framework when the debugger requests access to the data. The enumerable returned will be traversed by debugging utilities to access the tasks currently queued to this scheduler, enabling the debugger to provide a representation of this information in the user interface.  </p>\n<p> It is important to note that, when this method is called, all other threads in the process will be frozen. Therefore, it&#39;s important to avoid synchronization with other threads that may lead to blocking. If synchronization is necessary, and you are unable to acquire the lock in this method, then you should throw an exception so that the debugger does not hang. The following example shows one possible approach in C#:  </p>\n<pre><code>protected override IEnumerable&lt;Task&gt; GetScheduledTasks()  \n{  \n    bool lockTaken = false;  \n    try  \n    {  \n        Monitor.TryEnter(_syncObj, ref lockTaken);  \n        if (lockTaken)  \n        {  \n            return _tasks.ToArray();  \n        }  \n        else throw new NotSupportedException();  \n    }  \n    finally  \n    {  \n    if (lockTaken) Monitor.Exit(_syncObj);  \n    }}  \n</code></pre><p> Additionally, this method and the enumerable returned must not modify any globally visible state.  </p>\n<p> The returned enumerable should never be null. If there are currently no queued tasks, an empty enumerable should be returned instead.  </p>\n<p> Developers who are implementing custom debuggers shouldn&#39;t call this method directly, but should use the internal wrapper method <code>GetScheduledTasksForDebugger</code> instead: <code>internal Task[] GetScheduledTasksForDebugger()</code>. This wrapper method returns an array of tasks instead of an enumerable. To retrieve a list of active schedulers, use the internal method <code>internal static TaskScheduler[] GetTaskSchedulersForDebugger()</code>. This static method returns an array of all active <a class=\"xref\" href=\"system.threading.tasks.taskscheduler\" data-linktype=\"relative-path\">TaskScheduler</a> instances. You can then use <code>GetScheduledTasksForDebugger</code> on each scheduler instance to retrieve its list of scheduled tasks.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Tasks_TaskScheduler_QueueTask_System_Threading_Tasks_Task_\">\r\n    \r\n            <a id=\"System_Threading_Tasks_TaskScheduler_QueueTask_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">QueueTask(Task)</div>        \r\n          </div>\r\n    \r\n            <p>Queues a <a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a> to the scheduler.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected abstract void QueueTask (System.Threading.Tasks.Task task);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>task</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a> to be queued.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p>The <code>task</code> argument is null.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A class derived from <a class=\"xref\" href=\"system.threading.tasks.taskscheduler\" data-linktype=\"relative-path\">TaskScheduler</a> implements this method to accept tasks being scheduled on the scheduler.  </p>\n<p> A typical implementation would store the task in an internal data structure, which would be serviced by threads that would execute those tasks at some time in the future.  </p>\n<p> This method is only meant to be called by the .NET Framework and should not be called directly by the derived class. This is necessary for maintaining the consistency of the system.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Tasks_TaskScheduler_TryDequeue_System_Threading_Tasks_Task_\">\r\n    \r\n            <a id=\"System_Threading_Tasks_TaskScheduler_TryDequeue_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">TryDequeue(Task)</div>        \r\n          </div>\r\n    \r\n            <p>Attempts to dequeue a <a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a> that was previously queued to this scheduler.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected virtual bool TryDequeue (System.Threading.Tasks.Task task);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>task</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a> to be dequeued.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p>A Boolean denoting whether the <code>task</code> argument was successfully dequeued.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p>The <code>task</code> argument is null.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>For more information, see <a href=\"../Topic/Task%20Schedulers.md\" data-linktype=\"relative-path\">Task Schedulers</a>.  </p>\n<p> This method may execute in a finally block; therefore it should return as quickly as possible so that any resources such as <a class=\"xref\" href=\"system.threading.cancellationtokenregistration\" data-linktype=\"relative-path\">CancellationTokenRegistration</a> objects can be disposed of in a timely manner.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Tasks_TaskScheduler_TryExecuteTask_System_Threading_Tasks_Task_\">\r\n    \r\n            <a id=\"System_Threading_Tasks_TaskScheduler_TryExecuteTask_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">TryExecuteTask(Task)</div>        \r\n          </div>\r\n    \r\n            <p>Attempts to execute the provided <a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a> on this scheduler.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected bool TryExecuteTask (System.Threading.Tasks.Task task);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>task</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a> object to be executed.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p>A Boolean that is true if <code>task</code> was successfully executed, false if it was not. A common reason for execution failure is that the task had previously been executed or is in the process of being executed by another thread.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The <code>task</code> is not associated with this scheduler.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Scheduler implementations are provided with <a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a> instances to be executed through either the <a class=\"xref\" href=\"system.threading.tasks.taskscheduler#System_Threading_Tasks_TaskScheduler_QueueTask_\" data-linktype=\"relative-path\">QueueTask</a> method or the <a class=\"xref\" href=\"system.threading.tasks.taskscheduler#System_Threading_Tasks_TaskScheduler_TryExecuteTaskInline_\" data-linktype=\"relative-path\">TryExecuteTaskInline</a> method. When the scheduler deems it appropriate to run the provided task, TryExecuteTask should be used to do so. TryExecuteTask handles all aspects of executing a task, including action invocation, exception handling, state management, and lifecycle control.  </p>\n<p> TryExecuteTask must only be used for tasks provided to this scheduler by the .NET Framework infrastructure. It should not be used to execute arbitrary tasks obtained through custom mechanisms.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Tasks_TaskScheduler_TryExecuteTaskInline_System_Threading_Tasks_Task_System_Boolean_\">\r\n    \r\n            <a id=\"System_Threading_Tasks_TaskScheduler_TryExecuteTaskInline_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">TryExecuteTaskInline(Task,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Determines whether the provided <a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a> can be executed synchronously in this call, and if it can, executes it.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>task</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a> to be executed.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>taskWasPreviouslyQueued</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A Boolean denoting whether or not task has previously been queued. If this parameter is True, then the task may have been previously queued (scheduled); if False, then the task is known not to have been queued, and this call is being made in order to execute the task inline without queuing it.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p>A Boolean value indicating whether the task was executed inline.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p>The <code>task</code> argument is null.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The <code>task</code> was already executed.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A class derived from <a class=\"xref\" href=\"system.threading.tasks.taskscheduler\" data-linktype=\"relative-path\">TaskScheduler</a> implements this function to support inline execution of a task on a thread that initiates a wait on that task object. Inline execution is optional, and the request may be rejected by returning false. However, the more tasks that can be inlined, the better the scheduler will scale. In fact, a scheduler that inlines too little may be prone to deadlocks. A proper implementation should ensure that a request executing under the policies guaranteed by the scheduler can successfully inline. For example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that thread should succeed.  </p>\n<p> If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler&#39;s <a class=\"xref\" href=\"system.threading.tasks.taskscheduler#System_Threading_Tasks_TaskScheduler_TryExecuteTask_\" data-linktype=\"relative-path\">TryExecuteTask</a> method with the provided task object, propagating the return value. It may also be appropriate for the scheduler to remove an inlined task from its internal data structures if it decides to honor the inlining request. Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <a class=\"xref\" href=\"system.threading.tasks.taskscheduler#System_Threading_Tasks_TaskScheduler_QueueTask_\" data-linktype=\"relative-path\">QueueTask</a> method.  </p>\n<p> The derived scheduler is responsible for making sure that the calling thread is suitable for executing the given task as far as its own scheduling and execution policies are concerned.  </p>\n<p> For more information, see <a href=\"../Topic/Task%20Schedulers.md\" data-linktype=\"relative-path\">Task Schedulers</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"events\">\r\n        <h2>Events\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Tasks_TaskScheduler_UnobservedTaskException\">\r\n    \r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">UnobservedTaskException</div>        \r\n          </div>\r\n    \r\n            <p>Occurs when a faulted task&#39;s unobserved exception is about to trigger exception escalation policy, which, by default, would terminate the process.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This application domain-wide event provides a mechanism to prevent exception escalation policy (which, by default, terminates the process) from triggering.  </p>\n<p> To make it easier for developers to write asynchronous code based on tasks, the .NET Framework 4.5 changes the default exception behavior for unobserved exceptions. Although unobserved exceptions still raise the UnobservedTaskException exception, the process does not terminate by default. Instead, the exception is handled by the runtime after the event is raised, regardless of whether an event handler observes the exception. This behavior can be configured. Starting with the .NET Framework 4.5, you can use the  configuration element to revert to the behavior of the .NET Framework 4 and terminate the process:  </p>\n<pre><code class=\"lang-xml\">&lt;configuration&gt;   \n   &lt;runtime&gt;   \n      &lt;ThrowUnobservedTaskExceptions enabled=&quot;true&quot;/&gt;   \n   &lt;/runtime&gt;   \n&lt;/configuration&gt;  \n</code></pre>\r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n","outputRootRelativePath":"./","pageMetadata":"<meta name=\"breadcrumb_path\" content=\"breadcrumb/toc1.json\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"fulldocset\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.fulldocset\">\r\n<meta name=\"ref_skeleton_gitcommit\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Threading.Tasks.TaskScheduler.yml\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Threading.Tasks.TaskScheduler.yml\">\r\n<meta name=\"APIName\" content=\"System.Threading.Tasks.TaskScheduler\">\r\n<meta name=\"APIName\" content=\"System.Threading.Tasks.TaskScheduler..ctor\">\r\n<meta name=\"APIName\" content=\"System.Threading.Tasks.TaskScheduler.Current\">\r\n<meta name=\"APIName\" content=\"System.Threading.Tasks.TaskScheduler.Default\">\r\n<meta name=\"APIName\" content=\"System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext\">\r\n<meta name=\"APIName\" content=\"System.Threading.Tasks.TaskScheduler.GetScheduledTasks\">\r\n<meta name=\"APIName\" content=\"System.Threading.Tasks.TaskScheduler.Id\">\r\n<meta name=\"APIName\" content=\"System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel\">\r\n<meta name=\"APIName\" content=\"System.Threading.Tasks.TaskScheduler.QueueTask\">\r\n<meta name=\"APIName\" content=\"System.Threading.Tasks.TaskScheduler.TryDequeue\">\r\n<meta name=\"APIName\" content=\"System.Threading.Tasks.TaskScheduler.TryExecuteTask\">\r\n<meta name=\"APIName\" content=\"System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline\">\r\n<meta name=\"APIName\" content=\"System.Threading.Tasks.TaskScheduler.UnobservedTaskException\">\r\n<meta name=\"APIName\" content=\"System.Threading.Tasks.TaskScheduler.add_UnobservedTaskException\">\r\n<meta name=\"APIName\" content=\"System.Threading.Tasks.TaskScheduler.remove_UnobservedTaskException\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-01 01:37 AM\">\r\n<meta name=\"document_id\" content=\"7fb15b87-9044-96e2-db4f-15bcde2a5edd\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Represents an object that handles the low-level work of queuing tasks onto threads.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/System.Threading.Tasks/toc1.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Threading.Tasks.TaskScheduler\">\r\n","rawMetadata":{"breadcrumb_path":"breadcrumb/toc.json","search.ms_sitename":"Docs","search.ms_docsetname":"fulldocset","version":null,"_op_canonicalUrlPrefix":"https://ppe.docs.microsoft.com/en-us/fulldotnet/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":true,"depot_name":"MSDN.fulldocset","_op_gitRefSkeletonCommitHistory":[{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"use plugin in master","commit_sha":"501959ac03e19ac52a27aa4c6bbeb980f8b11c8c","commit_date":"2017-03-01 09:31:20 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"switch from platform to version","commit_sha":"78cdacb5ca782478af490a6b30c3a2cb2b6b873e","commit_date":"2017-02-28 15:09:51 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"update platforms","commit_sha":"39ad5a8919a59afc93a79ac4bd8e07c3b471b37a","commit_date":"2017-02-28 10:38:59 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"checkin yml","commit_sha":"da161b792852497df7140d7768cee2eccd9cb43f","commit_date":"2017-02-28 09:36:15 +0800"}],"ref_skeleton_gitcommit":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Threading.Tasks.TaskScheduler.yml","original_ref_skeleton_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Threading.Tasks.TaskScheduler.yml","open_to_public_contributors":true,"api_name":["System.Threading.Tasks.TaskScheduler","System.Threading.Tasks.TaskScheduler..ctor","System.Threading.Tasks.TaskScheduler.Current","System.Threading.Tasks.TaskScheduler.Default","System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext","System.Threading.Tasks.TaskScheduler.GetScheduledTasks","System.Threading.Tasks.TaskScheduler.Id","System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel","System.Threading.Tasks.TaskScheduler.QueueTask","System.Threading.Tasks.TaskScheduler.TryDequeue","System.Threading.Tasks.TaskScheduler.TryExecuteTask","System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline","System.Threading.Tasks.TaskScheduler.UnobservedTaskException","System.Threading.Tasks.TaskScheduler.add_UnobservedTaskException","System.Threading.Tasks.TaskScheduler.remove_UnobservedTaskException"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Threading.Tasks.TaskScheduler","System::Threading::Tasks::TaskScheduler","System.Threading.Tasks.TaskScheduler.#ctor","System::Threading::Tasks::TaskScheduler::#ctor","System.Threading.Tasks.TaskScheduler.Current","System::Threading::Tasks::TaskScheduler::Current","System.Threading.Tasks.TaskScheduler.Default","System::Threading::Tasks::TaskScheduler::Default","System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext","System::Threading::Tasks::TaskScheduler::FromCurrentSynchronizationContext","System.Threading.Tasks.TaskScheduler.GetScheduledTasks","System::Threading::Tasks::TaskScheduler::GetScheduledTasks","System.Threading.Tasks.TaskScheduler.Id","System::Threading::Tasks::TaskScheduler::Id","System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel","System::Threading::Tasks::TaskScheduler::MaximumConcurrencyLevel","System.Threading.Tasks.TaskScheduler.QueueTask","System::Threading::Tasks::TaskScheduler::QueueTask","System.Threading.Tasks.TaskScheduler.TryDequeue","System::Threading::Tasks::TaskScheduler::TryDequeue","System.Threading.Tasks.TaskScheduler.TryExecuteTask","System::Threading::Tasks::TaskScheduler::TryExecuteTask","System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline","System::Threading::Tasks::TaskScheduler::TryExecuteTaskInline","System.Threading.Tasks.TaskScheduler.UnobservedTaskException","System::Threading::Tasks::TaskScheduler::UnobservedTaskException"],"dev_langs":["csharp"],"updated_at":"2017-03-01 01:37 AM","document_id":"7fb15b87-9044-96e2-db4f-15bcde2a5edd","content_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/xml/System.Threading.Tasks/TaskScheduler.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"TaskScheduler class | Microsoft Docs","_op_ogTitle":"TaskScheduler class","description":"Represents an object that handles the low-level work of queuing tasks onto threads.\n","toc_asset_id":"_splitted/System.Threading.Tasks/toc.json","toc_rel":"_splitted/System.Threading.Tasks/toc.json","source_url":"","ms.assetid":"System.Threading.Tasks.TaskScheduler","canonical_url":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.threading.tasks.taskscheduler","_op_canonicalUrl":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.threading.tasks.taskscheduler","fileRelativePath":"System.Threading.Tasks.TaskScheduler.html"},"themesRelativePathToOutputRoot":"_themes/"}