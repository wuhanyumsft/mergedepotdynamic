{"content":"    \r\n    <h1 id=\"System_Threading_ThreadPool\">\r\n      <span class=\"lang-csharp\">ThreadPool</span>\r\n        Class\r\n    </h1>\r\n    \r\n    \r\n    <nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n      <h3>In this Article</h3>\r\n    </nav><div class=\"summary\">\r\n    \t<p>Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.</p>\n\r\n    </div><h2>Syntax</h2>\r\n    \r\n    \t<h3>Declaration</h3>\r\n    \t<pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static class ThreadPool</code></pre>\r\n    \r\n    \r\n    \r\n    <h3>Inheritance Hierarchy</h3>\r\n    <ul class=\"inheritance\">\r\n        <li class=\"l0\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a>\r\n          </div>\r\n        </li>\r\n      <li class=\"l1\">\r\n        <div class=\"xref\">\r\n          <div class=\"lang-csharp\">ThreadPool</div>\r\n        </div>\r\n      </li>\r\n    </ul>\r\n    \r\n      <div class=\"referencebox inheritedMembers\">\r\n        <h3>Inherited Members</h3>\r\n        <h4></h4>\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a>\r\n          </div>\r\n          \r\n      </div>\r\n    \r\n    \r\n      <h2>Remarks</h2>\r\n      <p>Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur. Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information. The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system. Examples of operations that use thread pool threads include the following:  </p>\n<ul>\n<li><p>When you create a <a class=\"xref\" href=\"system.threading.tasks.task\" data-linktype=\"relative-path\">Task</a> or <a class=\"xref\" href=\"system.threading.tasks.task-1\" data-linktype=\"relative-path\">Task&lt;TResult&gt;</a> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.  </p>\n</li>\n<li><p>Asynchronous timers use the thread pool. Thread pool threads execute callbacks from the <a class=\"xref\" href=\"system.threading.timer\" data-linktype=\"relative-path\">System.Threading.Timer</a> class and raise events from the <a class=\"xref\" href=\"system.timers.timer\" data-linktype=\"relative-path\">System.Timers.Timer</a> class.  </p>\n</li>\n<li><p>When you use registered wait handles, a system thread monitors the status of the wait handles. When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.  </p>\n</li>\n<li><p>When you call the <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_QueueUserWorkItem_\" data-linktype=\"relative-path\">QueueUserWorkItem</a> method to queue a method for execution on a thread pool thread. You do this by passing the method a <a class=\"xref\" href=\"system.threading.waitcallback\" data-linktype=\"relative-path\">WaitCallback</a> delegate.   The delegate has the signature  </p>\n</li>\n</ul>\n<p><codecontentplaceholder>0</codecontentplaceholder><br><codecontentplaceholder>1</codecontentplaceholder><br>     where <code>state</code> is an object that contains data to be used by the delegate. The actual data can be passed to the delegate by calling the <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_QueueUserWorkItem_System_Threading_WaitCallback_System_Object_\" data-linktype=\"relative-path\">QueueUserWorkItem(WaitCallback,Object)</a> method.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The threads in the managed thread pool are background threads. That is, their <a class=\"xref\" href=\"system.threading.thread#System_Threading_Thread_IsBackground_\" data-linktype=\"relative-path\">IsBackground</a> properties are <code>true</code>. This means that a ThreadPool thread will not keep an application running after all foreground threads have exited.  </p>\n</div>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <a class=\"xref\" href=\"system.threadstaticattribute\" data-linktype=\"relative-path\">ThreadStaticAttribute</a> attribute. Therefore, when a method examines thread local storage or fields that are marked with the <a class=\"xref\" href=\"system.threadstaticattribute\" data-linktype=\"relative-path\">ThreadStaticAttribute</a> attribute, the values it finds might be left over from an earlier use of the thread pool thread.  </p>\n</div>\n<p> You can also queue work items that are not related to a wait operation to the thread pool. To request that a work item be handled by a thread in the thread pool, call the <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_QueueUserWorkItem_\" data-linktype=\"relative-path\">QueueUserWorkItem</a> method. This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool. There is no way to cancel a work item after it has been queued.  </p>\n<p> Timer-queue timers and registered wait operations also use the thread pool. Their callback functions are queued to the thread pool.  </p>\n<p> There is one thread pool per process. Beginning with the .NET Framework 4, the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space. A process can call the <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_GetMaxThreads_\" data-linktype=\"relative-path\">GetMaxThreads</a> method to determine the number of threads. The number of threads in the thread pool can be changed by using the <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_SetMaxThreads_\" data-linktype=\"relative-path\">SetMaxThreads</a> method. Each thread uses the default stack size and runs at the default priority.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the <code>CorSetMaxThreads</code> function, defined in the mscoree.h file.  </p>\n</div>\n<p> The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category. When a minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete. Beginning with the .NET Framework 4, the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time. Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> When demand is low, the actual number of thread pool threads can fall below the minimum values.  </p>\n</div>\n<p> You can use the <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_GetMinThreads_\" data-linktype=\"relative-path\">GetMinThreads</a> method to obtain these minimum values.  </p>\n<div class=\"CAUTION\"><h5>Caution</h5><p> You can use the <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_SetMinThreads_\" data-linktype=\"relative-path\">SetMinThreads</a> method to increase the minimum number of threads. However, unnecessarily increasing these values can cause performance problems. If too many tasks start at the same time, all of them might appear to be slow. In most cases the thread pool will perform better with its own algorithm for allocating threads.</p>\n</div>\n\r\n    \r\n    \r\n    <h2>Methods\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_ThreadPool_BindHandle_System_IntPtr_\" data-linktype=\"self-bookmark\">BindHandle(IntPtr)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Binds an operating system handle to the <a class=\"xref\" href=\"system.threading.threadpool\" data-linktype=\"relative-path\">ThreadPool</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_ThreadPool_BindHandle_System_Runtime_InteropServices_SafeHandle_\" data-linktype=\"self-bookmark\">BindHandle(SafeHandle)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Binds an operating system handle to the <a class=\"xref\" href=\"system.threading.threadpool\" data-linktype=\"relative-path\">ThreadPool</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_ThreadPool_GetAvailableThreads_System_Int32__System_Int32__\" data-linktype=\"self-bookmark\">GetAvailableThreads(Int32,Int32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Retrieves the difference between the maximum number of thread pool threads returned by the <span class=\"xref\">stem.Threading.ThreadPool.GetMaxThreads*</span> method, and the number currently active.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_ThreadPool_GetMaxThreads_System_Int32__System_Int32__\" data-linktype=\"self-bookmark\">GetMaxThreads(Int32,Int32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Retrieves the number of requests to the thread pool that can be active concurrently. All requests above that number remain queued until thread pool threads become available.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_ThreadPool_GetMinThreads_System_Int32__System_Int32__\" data-linktype=\"self-bookmark\">GetMinThreads(Int32,Int32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_ThreadPool_QueueUserWorkItem_System_Threading_WaitCallback_\" data-linktype=\"self-bookmark\">QueueUserWorkItem(WaitCallback)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Queues a method for execution. The method executes when a thread pool thread becomes available.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_ThreadPool_QueueUserWorkItem_System_Threading_WaitCallback_System_Object_\" data-linktype=\"self-bookmark\">QueueUserWorkItem(WaitCallback,Object)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Queues a method for execution, and specifies an object containing data to be used by the method. The method executes when a thread pool thread becomes available.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int32_System_Boolean_\" data-linktype=\"self-bookmark\">RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Registers a delegate to wait for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>, specifying a 32-bit signed integer for the time-out in milliseconds.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean_\" data-linktype=\"self-bookmark\">RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Registers a delegate to wait for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>, specifying a 64-bit signed integer for the time-out in milliseconds.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_TimeSpan_System_Boolean_\" data-linktype=\"self-bookmark\">RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Registers a delegate to wait for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>, specifying a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> value for the time-out.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_UInt32_System_Boolean_\" data-linktype=\"self-bookmark\">RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Registers a delegate to wait for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>, specifying a 32-bit unsigned integer for the time-out in milliseconds.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_ThreadPool_SetMaxThreads_System_Int32_System_Int32_\" data-linktype=\"self-bookmark\">SetMaxThreads(Int32,Int32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets the number of requests to the thread pool that can be active concurrently. All requests above that number remain queued until thread pool threads become available.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_ThreadPool_SetMinThreads_System_Int32_System_Int32_\" data-linktype=\"self-bookmark\">SetMinThreads(Int32,Int32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_ThreadPool_UnsafeQueueNativeOverlapped_System_Threading_NativeOverlapped__\" data-linktype=\"self-bookmark\">UnsafeQueueNativeOverlapped(NativeOverlapped*)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Queues an overlapped I/O operation for execution.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_ThreadPool_UnsafeQueueUserWorkItem_System_Threading_WaitCallback_System_Object_\" data-linktype=\"self-bookmark\">UnsafeQueueUserWorkItem(WaitCallback,Object)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_ThreadPool_UnsafeRegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int32_System_Boolean_\" data-linktype=\"self-bookmark\">UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Registers a delegate to wait for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>, using a 32-bit signed integer for the time-out in milliseconds. This method does not propagate the calling stack to the worker thread.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_ThreadPool_UnsafeRegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean_\" data-linktype=\"self-bookmark\">UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Registers a delegate to wait for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>, specifying a 64-bit signed integer for the time-out in milliseconds. This method does not propagate the calling stack to the worker thread.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_ThreadPool_UnsafeRegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_TimeSpan_System_Boolean_\" data-linktype=\"self-bookmark\">UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Registers a delegate to wait for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>, specifying a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> value for the time-out. This method does not propagate the calling stack to the worker thread.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_ThreadPool_UnsafeRegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_UInt32_System_Boolean_\" data-linktype=\"self-bookmark\">UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Registers a delegate to wait for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>, specifying a 32-bit unsigned integer for the time-out in milliseconds. This method does not propagate the calling stack to the worker thread.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"methods\">\r\n        <h2>Methods\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_ThreadPool_BindHandle_System_IntPtr_\">\r\n    \r\n            <a id=\"System_Threading_ThreadPool_BindHandle_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">BindHandle(IntPtr)</div>        \r\n          </div>\r\n    \r\n            <p>Binds an operating system handle to the <a class=\"xref\" href=\"system.threading.threadpool\" data-linktype=\"relative-path\">ThreadPool</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool BindHandle (IntPtr osHandle);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>osHandle</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An <a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a> that holds the handle. The handle must have been opened for overlapped I/O on the unmanaged side.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the handle is bound; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.securityexception\" data-linktype=\"relative-path\">SecurityException</a></div>\r\n                  </div>\r\n                  <p>The caller does not have the required permission.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_ThreadPool_BindHandle_System_Runtime_InteropServices_SafeHandle_\">\r\n    \r\n            <a id=\"System_Threading_ThreadPool_BindHandle_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">BindHandle(SafeHandle)</div>        \r\n          </div>\r\n    \r\n            <p>Binds an operating system handle to the <a class=\"xref\" href=\"system.threading.threadpool\" data-linktype=\"relative-path\">ThreadPool</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>osHandle</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> that holds the operating system handle. The handle must have been opened for overlapped I/O on the unmanaged side.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the handle is bound; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>osHandle</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <code>osHandle</code> parameter should be a <a class=\"xref\" href=\"microsoft.win32.safehandles.safefilehandle\" data-linktype=\"relative-path\">SafeFileHandle</a>, which derives from the abstract <a class=\"xref\" href=\"system.runtime.interopservices.safehandle\" data-linktype=\"relative-path\">SafeHandle</a> class.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_ThreadPool_GetAvailableThreads_System_Int32__System_Int32__\">\r\n    \r\n            <a id=\"System_Threading_ThreadPool_GetAvailableThreads_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetAvailableThreads(Int32,Int32)</div>        \r\n          </div>\r\n    \r\n            <p>Retrieves the difference between the maximum number of thread pool threads returned by the <span class=\"xref\">stem.Threading.ThreadPool.GetMaxThreads*</span> method, and the number currently active.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>workerThreads</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The number of available worker threads.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>completionPortThreads</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The number of available asynchronous I/O threads.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>When GetAvailableThreads returns, the variable specified by <code>workerThreads</code> contains the number of additional worker threads that can be started, and the variable specified by <code>completionPortThreads</code> contains the number of additional asynchronous I/O threads that can be started.  </p>\n<p> If there are no available threads, additional thread pool requests remain queued until thread pool threads become available.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example displays the number of worker threads and I/O threads available when a simple app is started.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.ThreadPool.GetAvailableThreads#2\">using System;\nusing System.Threading;\n\npublic class Example\n{\n   public static void Main()\n   {\n      int worker = 0;\n      int io = 0;\n      ThreadPool.GetAvailableThreads(out worker, out io);\n      \n      Console.WriteLine(&quot;Thread pool threads available at startup: &quot;);\n      Console.WriteLine(&quot;   Worker threads: {0:N0}&quot;, worker);\n      Console.WriteLine(&quot;   Asynchronous I/O threads: {0:N0}&quot;, io);\n   }\n}\n// The example displays output like the following:\n//    Thread pool threads available at startup:\n//       Worker threads: 32,767\n//       Asynchronous I/O threads: 1,000\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.ThreadPool.GetAvailableThreads#2\">Imports System.Threading\n\n Module Example\n   Public Sub Main()\n      Dim worker As Integer = 0\n      Dim io As Integer = 0\n      ThreadPool.GetAvailableThreads(worker, io)\n      \n      Console.WriteLine(&quot;Thread pool threads available at startup: &quot;)\n      Console.WriteLine(&quot;   Worker threads: {0:N0}&quot;, worker)\n      Console.WriteLine(&quot;   Asynchronous I/O threads: {0:N0}&quot;, io)\n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;    Thread pool threads available at startup:\n&#39;       Worker threads: 32,767\n&#39;       Asynchronous I/O threads: 1,000\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_ThreadPool_GetMaxThreads_System_Int32__System_Int32__\">\r\n    \r\n            <a id=\"System_Threading_ThreadPool_GetMaxThreads_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetMaxThreads(Int32,Int32)</div>        \r\n          </div>\r\n    \r\n            <p>Retrieves the number of requests to the thread pool that can be active concurrently. All requests above that number remain queued until thread pool threads become available.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>workerThreads</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The maximum number of worker threads in the thread pool.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>completionPortThreads</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The maximum number of asynchronous I/O threads in the thread pool.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>When GetMaxThreads returns, the variable specified by <code>workerThreads</code> contains the maximum number of worker threads allowed in the thread pool, and the variable specified by <code>completionPortThreads</code> contains the maximum number of asynchronous I/O threads allowed in the thread pool.  </p>\n<p> You can use the <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_GetAvailableThreads_\" data-linktype=\"relative-path\">GetAvailableThreads</a> method to determine the actual number of threads in the thread pool at any given time.  </p>\n<p> You can use the <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_SetMaxThreads_\" data-linktype=\"relative-path\">SetMaxThreads</a> to set the maximum number of worker threads and asynchronous I/O threads in the thread pool.  </p>\n<p> You can queue as many thread pool requests as system memory allows. If there are more requests than thread pool threads, the additional requests remain queued until thread pool threads become available.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool. A work item is queued that uses <code>FileStream</code> to asynchronously write to two files. The callback methods are timed to overlap. A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Threading.ThreadPool.GetAvailableThreads#1\">using namespace System;\nusing namespace System::IO;\nusing namespace System::Security::Permissions;\nusing namespace System::Threading;\n\nref class ThreadPoolTest\n{\nprivate:\n\n   // Maintains state information to be passed to EndWriteCallback.\n   // This information allows the callback to end the asynchronous\n   // write operation and signal when it is finished.\n   ref class State\n   {\n   public:\n      FileStream^ fStream;\n      AutoResetEvent^ autoEvent;\n      State( FileStream^ fStream, AutoResetEvent^ autoEvent )\n      {\n         this-&gt;fStream = fStream;\n         this-&gt;autoEvent = autoEvent;\n      }\n\n   };\n\n\npublic:\n   ThreadPoolTest(){}\n\n   static void EndWriteCallback( IAsyncResult^ asyncResult )\n   {\n      Console::WriteLine( &quot;Starting EndWriteCallback.&quot; );\n      State^ stateInfo = dynamic_cast&lt;State^&gt;(asyncResult-&gt;AsyncState);\n      int workerThreads;\n      int portThreads;\n      try\n      {\n         ThreadPool::GetAvailableThreads( workerThreads, portThreads );\n         Console::WriteLine( &quot;<br>Available worker threads: &nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;\n         &quot;<br>Available completion port threads: {1}<br>&quot;, workerThreads.ToString(), portThreads.ToString() );\n         stateInfo-&gt;fStream-&gt;EndWrite( asyncResult );\n         \n         // Sleep so the other thread has a chance to run\n         // before the current thread ends.\n         Thread::Sleep( 1500 );\n      }\n      catch ( Exception^ e ) \n      {\n      }\n      finally\n      {\n         \n         // Signal that the current thread is finished.\n         stateInfo-&gt;autoEvent-&gt;Set();\n         Console::WriteLine( &quot;Ending EndWriteCallback.&quot; );\n      }\n\n   }\n\n   static void WorkItemMethod( Object^ mainEvent )\n   {\n      Console::WriteLine( &quot;<br>Starting WorkItem.<br>&quot; );\n      AutoResetEvent^ autoEvent = gcnew AutoResetEvent( false );\n      \n      // Create some data.\n      const int ArraySize = 10000;\n      const int BufferSize = 1000;\n      array&lt;Byte&gt;^byteArray = gcnew array&lt;Byte&gt;(ArraySize);\n      (gcnew Random)-&gt;NextBytes( byteArray );\n      \n      // Create two files and two State objects. \n      FileStream^ fileWriter1 = gcnew FileStream(  &quot;C:\\&nbsp;&nbsp;&nbsp;&nbsp;est1@##.dat&quot;,FileMode::Create,FileAccess::ReadWrite,FileShare::ReadWrite,BufferSize,true );\n      FileStream^ fileWriter2 = gcnew FileStream(  &quot;C:\\&nbsp;&nbsp;&nbsp;&nbsp;est2@##.dat&quot;,FileMode::Create,FileAccess::ReadWrite,FileShare::ReadWrite,BufferSize,true );\n      State^ stateInfo1 = gcnew State( fileWriter1,autoEvent );\n      State^ stateInfo2 = gcnew State( fileWriter2,autoEvent );\n      \n      // Asynchronously write to the files.\n      fileWriter1-&gt;BeginWrite( byteArray, 0, byteArray-&gt;Length, gcnew AsyncCallback( &amp;ThreadPoolTest::EndWriteCallback ), stateInfo1 );\n      fileWriter2-&gt;BeginWrite( byteArray, 0, byteArray-&gt;Length, gcnew AsyncCallback( &amp;ThreadPoolTest::EndWriteCallback ), stateInfo2 );\n      \n      // Wait for each callback to finish.\n      autoEvent-&gt;WaitOne();\n      autoEvent-&gt;WaitOne();\n      fileWriter1-&gt;Close();\n      fileWriter2-&gt;Close();\n      Console::WriteLine( &quot;<br>Ending WorkItem.<br>&quot; );\n      \n      // Signal Main that the work item is finished.\n      dynamic_cast&lt;AutoResetEvent^&gt;(mainEvent)-&gt;Set();\n   }\n\n};\n\nint main()\n{\n   AutoResetEvent^ mainEvent = gcnew AutoResetEvent( false );\n   int workerThreads;\n   int portThreads;\n   ThreadPool::GetMaxThreads( workerThreads, portThreads );\n   Console::WriteLine( &quot;<br>Maximum worker threads: &nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;\n   &quot;<br>Maximum completion port threads: {1}&quot;, workerThreads.ToString(), portThreads.ToString() );\n   ThreadPool::GetAvailableThreads( workerThreads, portThreads );\n   Console::WriteLine( &quot;<br>Available worker threads: &nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;\n   &quot;<br>Available completion port threads: {1}<br>&quot;, workerThreads.ToString(), portThreads.ToString() );\n   ThreadPool::QueueUserWorkItem( gcnew WaitCallback( &amp;ThreadPoolTest::WorkItemMethod ), mainEvent );\n   \n   // Since ThreadPool threads are background threads, \n   // wait for the work item to signal before ending main().\n   mainEvent-&gt;WaitOne( 5000, false );\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.ThreadPool.GetAvailableThreads#1\">using System;\nusing System.IO;\nusing System.Security.Permissions;\nusing System.Threading;\n\nclass Test\n{\n    static void Main()\n    {\n        AutoResetEvent mainEvent = new AutoResetEvent(false);\n        int workerThreads;\n        int portThreads;\n\n        ThreadPool.GetMaxThreads(out workerThreads, out portThreads);\n        Console.WriteLine(&quot;<br>Maximum worker threads: &nbsp;&nbsp;&nbsp;&nbsp;{0}&quot; +\n            &quot;<br>Maximum completion port threads: {1}&quot;,\n            workerThreads, portThreads);\n\n        ThreadPool.GetAvailableThreads(out workerThreads, \n            out portThreads);\n        Console.WriteLine(&quot;<br>Available worker threads: &nbsp;&nbsp;&nbsp;&nbsp;{0}&quot; +\n            &quot;<br>Available completion port threads: {1}<br>&quot;,\n            workerThreads, portThreads);\n\n        ThreadPool.QueueUserWorkItem(new \n            WaitCallback(ThreadPoolTest.WorkItemMethod), mainEvent);\n           \n        // Since ThreadPool threads are background threads, \n        // wait for the work item to signal before ending Main.\n        mainEvent.WaitOne(5000, false);\n    }\n}\n\nclass ThreadPoolTest\n{\n    // Maintains state information to be passed to EndWriteCallback.\n    // This information allows the callback to end the asynchronous\n    // write operation and signal when it is finished.\n    class State\n    {\n        public FileStream     fStream;\n        public AutoResetEvent autoEvent;\n\n        public State(FileStream fStream, AutoResetEvent autoEvent)\n        {\n            this.fStream   = fStream;\n            this.autoEvent = autoEvent;\n        }\n    }\n\n    ThreadPoolTest() {}\n\n    public static void WorkItemMethod(object mainEvent)\n    {\n        Console.WriteLine(&quot;<br>Starting WorkItem.<br>&quot;);\n        AutoResetEvent autoEvent = new AutoResetEvent(false);\n\n        // Create some data.\n        const int ArraySize  = 10000;\n        const int BufferSize =  1000;\n        byte[] byteArray = new Byte[ArraySize];\n        new Random().NextBytes(byteArray);\n\n        // Create two files and two State objects. \n        FileStream fileWriter1 = \n            new FileStream(@&quot;C:&nbsp;&nbsp;&nbsp;&nbsp;est1@##.dat&quot;, FileMode.Create, \n            FileAccess.ReadWrite, FileShare.ReadWrite, \n            BufferSize, true);\n        FileStream fileWriter2 = \n            new FileStream(@&quot;C:&nbsp;&nbsp;&nbsp;&nbsp;est2@##.dat&quot;, FileMode.Create, \n            FileAccess.ReadWrite, FileShare.ReadWrite, \n            BufferSize, true);\n        State stateInfo1 = new State(fileWriter1, autoEvent);\n        State stateInfo2 = new State(fileWriter2, autoEvent);\n\n        // Asynchronously write to the files.\n        fileWriter1.BeginWrite(byteArray, 0, byteArray.Length, \n            new AsyncCallback(EndWriteCallback), stateInfo1);\n        fileWriter2.BeginWrite(byteArray, 0, byteArray.Length, \n            new AsyncCallback(EndWriteCallback), stateInfo2);\n\n        // Wait for the callbacks to signal.\n        autoEvent.WaitOne();\n        autoEvent.WaitOne();\n\n        fileWriter1.Close();\n        fileWriter2.Close();\n        Console.WriteLine(&quot;<br>Ending WorkItem.<br>&quot;);\n\n        // Signal Main that the work item is finished.\n        ((AutoResetEvent)mainEvent).Set();\n    }\n\n    static void EndWriteCallback(IAsyncResult asyncResult)\n    {\n        Console.WriteLine(&quot;Starting EndWriteCallback.&quot;);\n\n        State stateInfo = (State)asyncResult.AsyncState;\n        int workerThreads;\n        int portThreads;\n        try\n        {\n            ThreadPool.GetAvailableThreads(out workerThreads, \n                out portThreads);\n            Console.WriteLine(&quot;<br>Available worker threads: &nbsp;&nbsp;&nbsp;&nbsp;{0}&quot; +\n                &quot;<br>Available completion port threads: {1}<br>&quot;,\n                workerThreads, portThreads);\n\n            stateInfo.fStream.EndWrite(asyncResult);\n\n            // Sleep so the other thread has a chance to run\n            // before the current thread ends.\n            Thread.Sleep(1500);\n        }\n        finally\n        {\n            // Signal that the current thread is finished.\n            stateInfo.autoEvent.Set();\n            Console.WriteLine(&quot;Ending EndWriteCallback.&quot;);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.ThreadPool.GetAvailableThreads#1\">Imports System.IO\nImports System.Security.Permissions\nImports System.Threading\n\nPublic Class Example\n    Shared Sub Main()\n        Dim mainEvent As New AutoResetEvent(False)\n        Dim workerThreads As Integer \n        Dim portThreads As Integer \n\n        ThreadPool.GetMaxThreads(workerThreads, portThreads)\n        Console.WriteLine(vbCrLf &amp; &quot;Maximum worker threads: &quot; &amp; _\n            vbTab &amp; &quot;{0}&quot; &amp; vbCrLf &amp; &quot;Maximum completion port &quot; &amp; _\n            &quot;threads: {1}&quot;, workerThreads, portThreads)\n\n        ThreadPool.GetAvailableThreads(workerThreads, portThreads)\n        Console.WriteLine(vbCrLf &amp; &quot;Available worker threads: &quot; &amp; _\n            vbTab &amp; &quot;{0}&quot; &amp; vbCrLf &amp; &quot;Available completion port &quot; &amp; _\n            &quot;threads: {1}&quot; &amp; vbCrLf, workerThreads, portThreads)\n\n        ThreadPool.QueueUserWorkItem(AddressOf _\n            ThreadPoolTest.WorkItemMethod, mainEvent)\n           \n        &#39; Since ThreadPool threads are background threads, \n        &#39; wait for the work item to signal before ending Main.\n        mainEvent.WaitOne(5000, False)\n    End Sub\n\nEnd Class\n\nPublic Class ThreadPoolTest\n\n    &#39; Maintains state information to be passed to EndWriteCallback.\n    &#39; This information allows the callback to end the asynchronous\n    &#39; write operation and signal when it is finished.\n    Class State\n        Public fStream As FileStream\n        Public autoEvent As AutoResetEvent\n\n        Public Sub New(aFileStream As FileStream, anEvent As AutoResetEvent)\n            fStream   = aFileStream\n            autoEvent = anEvent\n        End Sub\n    End Class   \n    \n    Private Sub New\n    End Sub\n\n    Shared Sub WorkItemMethod(mainEvent As Object)\n    \n        Console.WriteLine(vbCrLf &amp; &quot;Starting WorkItem.&quot; &amp; vbCrLf)\n        Dim autoEvent As New AutoResetEvent(False)\n\n        &#39; Create some data.\n        Const ArraySize As Integer  = 10000\n        Const BufferSize As Integer =  1000\n        Dim byteArray As Byte() = New Byte(ArraySize){}\n        Dim randomGenerator As New Random()\n        randomGenerator.NextBytes(byteArray)\n\n        &#39; Create two files and two State objects. \n        Dim fileWriter1 As FileStream = _\n            New FileStream(&quot;C:&nbsp;&nbsp;&nbsp;&nbsp;est1111.dat&quot;, FileMode.Create, _\n            FileAccess.ReadWrite, FileShare.ReadWrite, _\n            BufferSize, True)\n        Dim fileWriter2 As FileStream = _\n            New FileStream(&quot;C:&nbsp;&nbsp;&nbsp;&nbsp;est2222.dat&quot;, FileMode.Create, _\n            FileAccess.ReadWrite, FileShare.ReadWrite, _\n            BufferSize, True)\n        Dim stateInfo1 As New State(fileWriter1, autoEvent)\n        Dim stateInfo2 As New State(fileWriter2, autoEvent)\n\n        &#39; Asynchronously write to the files.\n        fileWriter1.BeginWrite(byteArray, 0, byteArray.Length, _\n            AddressOf EndWriteCallback, stateInfo1)\n        fileWriter2.BeginWrite(byteArray, 0, byteArray.Length, _\n            AddressOf EndWriteCallback, stateInfo2)\n\n        &#39; Wait for the callbacks to signal.\n        autoEvent.WaitOne()\n        autoEvent.WaitOne()\n\n        fileWriter1.Close()\n        fileWriter2.Close()\n        Console.WriteLine(vbCrLf &amp; &quot;Ending WorkItem.&quot; &amp; vbCrLf)\n\n        &#39; Signal Main that the work item is finished.\n        DirectCast(mainEvent, AutoResetEvent).Set()\n    \n    End Sub\n\n    Shared Sub EndWriteCallback(asyncResult As IAsyncResult)\n        Console.WriteLine(&quot;Starting EndWriteCallback.&quot;)\n\n        Dim stateInfo As State = _\n            DirectCast(asyncResult.AsyncState, State)\n        Dim workerThreads As Integer \n        Dim portThreads As Integer \n        Try\n            ThreadPool.GetAvailableThreads(workerThreads, portThreads)\n            Console.WriteLine(vbCrLf &amp; &quot;Available worker &quot; &amp; _\n                &quot;threads:&quot; &amp; vbTab &amp; &quot;{0}&quot; &amp; vbCrLf &amp; &quot;Available &quot; &amp; _\n                &quot;completion port threads: {1}&quot; &amp; vbCrLf, _\n                workerThreads, portThreads)\n\n            stateInfo.fStream.EndWrite(asyncResult)\n\n            &#39; Sleep so the other thread has a chance to run\n            &#39; before the current thread ends.\n            Thread.Sleep(1500)\n        Finally\n        \n            &#39; Signal that the current thread is finished.\n            stateInfo.autoEvent.Set()\n            Console.WriteLine(&quot;Ending EndWriteCallback.&quot;)\n        End Try\n    \n    End Sub\nEnd Class\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_ThreadPool_GetMinThreads_System_Int32__System_Int32__\">\r\n    \r\n            <a id=\"System_Threading_ThreadPool_GetMinThreads_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetMinThreads(Int32,Int32)</div>        \r\n          </div>\r\n    \r\n            <p>Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static void GetMinThreads (out int workerThreads, out int completionPortThreads);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>workerThreads</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>When this method returns, contains the minimum number of worker threads that the thread pool creates on demand.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>completionPortThreads</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>When this method returns, contains the minimum number of asynchronous I/O threads that the thread pool creates on demand.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category. By default, the minimum number of threads is set to the number of processors on a system. When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete. Beginning with the .NET Framework 4, the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time. Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> When demand is low, the actual number of thread pool threads can fall below the minimum values.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Threading.ThreadPool.GetSetMinThreads#1\">Imports System\nImports System.Threading\n\nPublic Class Test\n\n    &lt;MTAThread&gt; _\n    Public Shared Sub Main()\n        Dim minWorker, minIOC As Integer\n        &#39; Get the current settings.\n        ThreadPool.GetMinThreads(minWorker, minIOC)\n        &#39; Change the minimum number of worker threads to four, but\n        &#39; keep the old setting for minimum asynchronous I/O \n        &#39; completion threads.\n        If ThreadPool.SetMinThreads(4, minIOC) Then\n            &#39; The minimum number of threads was set successfully.\n        Else\n            &#39; The minimum number of threads was not changed.\n        End If\n    End Sub\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.ThreadPool.GetSetMinThreads#1\">using System;\nusing System.Threading;\n\npublic class Test\n{\n    public static void Main()\n    {\n        int minWorker, minIOC;\n        // Get the current settings.\n        ThreadPool.GetMinThreads(out minWorker, out minIOC);\n        // Change the minimum number of worker threads to four, but\n        // keep the old setting for minimum asynchronous I/O \n        // completion threads.\n        if (ThreadPool.SetMinThreads(4, minIOC))\n        {\n            // The minimum number of threads was set successfully.\n        }\n        else\n        {\n            // The minimum number of threads was not changed.\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.ThreadPool.GetSetMinThreads#1\">using namespace System;\nusing namespace System::Threading;\nint main()\n{\n   int minWorker;\n   int minIOC;\n   \n   // Get the current settings.\n   ThreadPool::GetMinThreads( minWorker, minIOC );\n   \n   // Change the minimum number of worker threads to four, but\n   // keep the old setting for minimum asynchronous I/O\n   // completion threads.\n   if ( ThreadPool::SetMinThreads( 4, minIOC ) )\n   {\n      \n      // The minimum number of threads was set successfully.\n   }\n   else\n   {\n      \n      // The minimum number of threads was not changed.\n   }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_ThreadPool_QueueUserWorkItem_System_Threading_WaitCallback_\">\r\n    \r\n            <a id=\"System_Threading_ThreadPool_QueueUserWorkItem_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">QueueUserWorkItem(WaitCallback)</div>        \r\n          </div>\r\n    \r\n            <p>Queues a method for execution. The method executes when a thread pool thread becomes available.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>callBack</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waitcallback\" data-linktype=\"relative-path\">WaitCallback</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <a class=\"xref\" href=\"system.threading.waitcallback\" data-linktype=\"relative-path\">WaitCallback</a> that represents the method to be executed.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the method is successfully queued; <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> is thrown if the work item could not be queued.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>callBack</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The common language runtime (CLR) is hosted, and the host does not support this action.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_QueueUserWorkItem_System_Threading_WaitCallback_System_Object_\" data-linktype=\"relative-path\">QueueUserWorkItem(WaitCallback,Object)</a> overload that accepts an object containing the necessary data.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Visual Basic users can omit the <a class=\"xref\" href=\"system.threading.waitcallback\" data-linktype=\"relative-path\">WaitCallback</a> constructor, and simply use the <code>AddressOf</code> operator when passing the callback method to <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_QueueUserWorkItem_\" data-linktype=\"relative-path\">QueueUserWorkItem</a>. Visual Basic automatically calls the correct delegate constructor.  </p>\n</div>\n<h2 id=\"version-information\">Version Information</h2>\n<p> In the .NET Framework version 2.0, the <a class=\"xref\" href=\"system.threading.thread#System_Threading_Thread_CurrentPrincipal_\" data-linktype=\"relative-path\">CurrentPrincipal</a> property value is propagated to worker threads queued using the <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_QueueUserWorkItem_\" data-linktype=\"relative-path\">QueueUserWorkItem</a> method. In earlier versions, the principal information is not propagated.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses the QueueUserWorkItem method overload to queue a task, which is represented by the <code>ThreadProc</code> method, to execute when a thread becomes available. No task information is supplied with this overload. Therefore, the information that is available to the <code>ThreadProc</code> method is limited to the object the method belongs to.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Threading.ThreadPool QueueUserWorkItem0#1\">using namespace System;\nusing namespace System::Threading;\n\nref class Example\n{\npublic:\n\n   // This thread procedure performs the task.\n   static void ThreadProc(Object^ stateInfo)\n   {\n      \n      // No state object was passed to QueueUserWorkItem, so stateInfo is 0.\n      Console::WriteLine( &quot;Hello from the thread pool.&quot; );\n   }\n};\n\nint main()\n{\n   // Queue the task.\n   ThreadPool::QueueUserWorkItem(gcnew WaitCallback(Example::ThreadProc));\n\n   Console::WriteLine(&quot;Main thread does some work, then sleeps.&quot;);\n   \n   Thread::Sleep(1000);\n   Console::WriteLine(&quot;Main thread exits.&quot;);\n   return 0;\n}\n// The example displays output like the following:\n//       Main thread does some work, then sleeps.\n//       Hello from the thread pool.\n//       Main thread exits.\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.ThreadPool QueueUserWorkItem0#1\">Imports System.Threading\n\nPublic Module Example\n    Public Sub Main()\n        &#39; Queue the work for execution.\n        ThreadPool.QueueUserWorkItem(AddressOf ThreadProc)\n        \n        Console.WriteLine(&quot;Main thread does some work, then sleeps.&quot;)\n\n        Thread.Sleep(1000)\n\n        Console.WriteLine(&quot;Main thread exits.&quot;)\n    End Sub\n\n    &#39; This thread procedure performs the task.\n    Sub ThreadProc(stateInfo As Object)\n        &#39; No state object was passed to QueueUserWorkItem, so stateInfo is null.\n        Console.WriteLine(&quot;Hello from the thread pool.&quot;)\n    End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;       Main thread does some work, then sleeps.\n&#39;       Hello from the thread pool.\n&#39;       Main thread exits.\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.ThreadPool QueueUserWorkItem0#1\">using System;\nusing System.Threading;\n\npublic class Example \n{\n    public static void Main() \n    {\n        // Queue the task.\n        ThreadPool.QueueUserWorkItem(ThreadProc);\n        Console.WriteLine(&quot;Main thread does some work, then sleeps.&quot;);\n        Thread.Sleep(1000);\n\n        Console.WriteLine(&quot;Main thread exits.&quot;);\n    }\n\n    // This thread procedure performs the task.\n    static void ThreadProc(Object stateInfo) \n    {\n        // No state object was passed to QueueUserWorkItem, so stateInfo is null.\n        Console.WriteLine(&quot;Hello from the thread pool.&quot;);\n    }\n}\n// The example displays output like the following:\n//       Main thread does some work, then sleeps.\n//       Hello from the thread pool.\n//       Main thread exits.\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_ThreadPool_QueueUserWorkItem_System_Threading_WaitCallback_System_Object_\">\r\n    \r\n            <a id=\"System_Threading_ThreadPool_QueueUserWorkItem_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">QueueUserWorkItem(WaitCallback,Object)</div>        \r\n          </div>\r\n    \r\n            <p>Queues a method for execution, and specifies an object containing data to be used by the method. The method executes when a thread pool thread becomes available.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>callBack</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waitcallback\" data-linktype=\"relative-path\">WaitCallback</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <a class=\"xref\" href=\"system.threading.waitcallback\" data-linktype=\"relative-path\">WaitCallback</a> representing the method to execute.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>state</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An object containing data to be used by the method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the method is successfully queued; <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> is thrown if the work item could not be queued.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The common language runtime (CLR) is hosted, and the host does not support this action.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>callBack</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the callback method requires complex data, you can define a class to contain the data.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Visual Basic users can omit the <a class=\"xref\" href=\"system.threading.waitcallback\" data-linktype=\"relative-path\">WaitCallback</a> constructor, and simply use the <code>AddressOf</code> operator when passing the callback method to QueueUserWorkItem. Visual Basic automatically calls the correct delegate constructor.  </p>\n</div>\n<h2 id=\"version-information\">Version Information</h2>\n<p> In the .NET Framework version 2.0, the <a class=\"xref\" href=\"system.threading.thread#System_Threading_Thread_CurrentPrincipal_\" data-linktype=\"relative-path\">CurrentPrincipal</a> property value is propagated to worker threads queued using the <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_QueueUserWorkItem_\" data-linktype=\"relative-path\">QueueUserWorkItem</a> method. In earlier versions, the principal information is not propagated.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example shows how to create an object that contains task information. It also demonstrates how to pass that object to a task that is queued for execution by the thread pool.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Threading.ThreadPool QueueUserWorkItem1#1\">// This example shows how to create an Object* containing task\n// information, and pass that Object* to a task queued for\n// execution by the thread pool.\nusing namespace System;\nusing namespace System::Threading;\n\n// TaskInfo holds state information for a task that will be\n// executed by a ThreadPool thread.\npublic ref class TaskInfo\n{\npublic:\n\n   // State information for the task.  These members\n   // can be implemented as read-only properties, read/write\n   // properties with validation, and so on, as required.\n   String^ Boilerplate;\n   int Value;\n\n   // Public constructor provides an easy way to supply all\n   // the information needed for the task.\n   TaskInfo( String^ text, int number )\n   {\n      Boilerplate = text;\n      Value = number;\n   }\n\n};\n\npublic ref struct Example\n{\npublic:\n\n   // The thread procedure performs the independent task, in this case\n   // formatting and printing a very simple report.\n   //\n   static void ThreadProc( Object^ stateInfo )\n   {\n      TaskInfo^ ti = dynamic_cast&lt;TaskInfo^&gt;(stateInfo);\n      Console::WriteLine( ti-&gt;Boilerplate, ti-&gt;Value );\n   }\n\n};\n\nvoid main()\n{\n   \n   // Create an object containing the information needed\n   // for the task.\n   TaskInfo^ ti = gcnew TaskInfo( &quot;This report displays the number {0}.&quot;,42 );\n   \n   // Queue the task and data.\n   ThreadPool::QueueUserWorkItem( gcnew WaitCallback( Example::ThreadProc ), ti );\n\n   Console::WriteLine( &quot;Main thread does some work, then sleeps.&quot; );\n      \n   // If you comment out the Sleep, the main thread exits before\n   // the ThreadPool task has a chance to run.  ThreadPool uses \n   // background threads, which do not keep the application \n   // running.  (This is a simple example of a race condition.)\n   Thread::Sleep( 1000 );\n   Console::WriteLine( &quot;Main thread exits.&quot; );\n}\n// The example displays output like the following:\n//       Main thread does some work, then sleeps.\n//       This report displays the number 42.\n//       Main thread exits.\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.ThreadPool QueueUserWorkItem1#1\">// This example shows how to create an object containing task\n// information, and pass that object to a task queued for\n// execution by the thread pool.\nusing System;\nusing System.Threading;\n\n// TaskInfo holds state information for a task that will be\n// executed by a ThreadPool thread.\npublic class TaskInfo \n    {\n    // State information for the task.  These members\n    // can be implemented as read-only properties, read/write\n    // properties with validation, and so on, as required.\n    public string Boilerplate;\n    public int Value;\n\n    // Public constructor provides an easy way to supply all\n    // the information needed for the task.\n    public TaskInfo(string text, int number) {\n        Boilerplate = text;\n        Value = number;\n    }\n}\n\npublic class Example {\n    public static void Main()\n    {\n        // Create an object containing the information needed\n        // for the task.\n        TaskInfo ti = new TaskInfo(&quot;This report displays the number {0}.&quot;, 42);\n\n        // Queue the task and data.\n        ThreadPool.QueueUserWorkItem(new WaitCallback(ThreadProc), ti);\n\n        Console.WriteLine(&quot;Main thread does some work, then sleeps.&quot;);\n\n        // If you comment out the Sleep, the main thread exits before\n        // the ThreadPool task has a chance to run.  ThreadPool uses \n        // background threads, which do not keep the application \n        // running.  (This is a simple example of a race condition.)\n        Thread.Sleep(1000);\n\n        Console.WriteLine(&quot;Main thread exits.&quot;);\n    }\n\n    // The thread procedure performs the independent task, in this case\n    // formatting and printing a very simple report.\n    //\n    static void ThreadProc(Object stateInfo) \n    {\n        TaskInfo ti = (TaskInfo) stateInfo;\n        Console.WriteLine(ti.Boilerplate, ti.Value); \n    }\n}\n// The example displays output like the following:\n//       Main thread does some work, then sleeps.\n//       This report displays the number 42.\n//       Main thread exits.\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.ThreadPool QueueUserWorkItem1#1\">&#39; This example shows how to create an object containing task\n&#39; information, and pass that object to a task queued for\n&#39; execution by the thread pool.\nImports System\nImports System.Threading\n&#39; TaskInfo holds state information for a task that will be\n&#39; executed by a ThreadPool thread.\nPublic Class TaskInfo\n    &#39; State information for the task.  These members\n    &#39; can be implemented as read-only properties, read/write\n    &#39; properties with validation, and so on, as required.\n    Public Boilerplate As String\n    Public Value As Integer\n\n    &#39; Public constructor provides an easy way to supply all\n    &#39; the information needed for the task.\n    Public Sub New(text As String, number As Integer)\n        Boilerplate = text\n        Value = number\n    End Sub\nEnd Class\n\nPublic Class Example\n\n    &lt;MTAThread&gt; _\n    Public Shared Sub Main()\n        &#39; Create an object containing the information needed\n        &#39; for the task.\n        Dim ti As New TaskInfo(&quot;This report displays the number {0}.&quot;, 42)\n\n        &#39; Queue the task and data.\n        ThreadPool.QueueUserWorkItem( _\n                New WaitCallback(AddressOf ThreadProc), ti)\n        \n        Console.WriteLine(&quot;Main thread does some work, then sleeps.&quot;)\n\n        &#39; If you comment out the Sleep, the main thread exits before\n        &#39; the ThreadPool task has a chance to run.  ThreadPool uses \n        &#39; background threads, which do not keep the application \n        &#39; running.  (This is a simple example of a race condition.)\n        Thread.Sleep(1000)\n\n        Console.WriteLine(&quot;Main thread exits.&quot;)\n    End Sub\n\n    &#39; The thread procedure performs the independent task, in this case\n    &#39; formatting and printing a very simple report.\n    &#39;\n    Shared Sub ThreadProc(stateInfo As Object)\n        Dim ti As TaskInfo = CType(stateInfo, TaskInfo)\n        Console.WriteLine(ti.Boilerplate, ti.Value)\n    End Sub\nEnd Class\n&#39; The example displays output like the following:\n&#39;        Main thread does some work, then sleeps.\n&#39;        This report displays the number 42.\n&#39;        Main thread exits.\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int32_System_Boolean_\">\r\n    \r\n            <a id=\"System_Threading_ThreadPool_RegisterWaitForSingleObject_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Registers a delegate to wait for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>, specifying a 32-bit signed integer for the time-out in milliseconds.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>waitObject</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> to register. Use a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> other than <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>callBack</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waitortimercallback\" data-linktype=\"relative-path\">WaitOrTimerCallback</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.waitortimercallback\" data-linktype=\"relative-path\">WaitOrTimerCallback</a> delegate to call when the <code>waitObject</code> parameter is signaled.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>state</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object that is passed to the delegate.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>millisecondsTimeOutInterval</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The time-out in milliseconds. If the <code>millisecondsTimeOutInterval</code> parameter is 0 (zero), the function tests the object&#39;s state and returns immediately. If <code>millisecondsTimeOutInterval</code> is -1, the function&#39;s time-out interval never elapses.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>executeOnlyOnce</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to indicate that the thread will no longer wait on the <code>waitObject</code> parameter after the delegate has been called; <code>false</code> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a></div>\r\n                  </div>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a> that encapsulates the native handle.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p>The <code>millisecondsTimeOutInterval</code> parameter is less than -1.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>When you are finished using the <a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a> that is returned by this method, call its <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method to release references to the wait handle. We recommend that you always call the <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method, even if you specify <code>true</code> for <code>executeOnlyOnce</code>. Garbage collection works more efficiently if you call the <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method instead of depending on the registered wait handle&#39;s finalizer.  </p>\n<p> The RegisterWaitForSingleObject method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs:  </p>\n<ul>\n<li><p>The specified object is in the signaled state.  </p>\n</li>\n<li><p>The time-out interval elapses.  </p>\n<p>The RegisterWaitForSingleObject method checks the current state of the specified object&#39;s <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>. If the object&#39;s state is unsignaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object&#39;s state becomes signaled or the time-out interval elapses. If the <code>timeOutInterval</code> parameter is not 0 (zero) and the <code>executeOnlyOnce</code> parameter is <code>false</code>, the timer is reset every time the event is signaled or the time-out interval elapses.  </p>\n</li>\n</ul>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> Using a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> for <code>waitObject</code> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default <code>WT_EXECUTEDEFAULT</code> flag, so each callback is dispatched on a separate thread pool thread. Instead of a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a>, use a <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> with a maximum count of 1.  </p>\n</div>\n<p> To cancel the wait operation, call the <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method.  </p>\n<p> The wait thread uses the Win32 <code>WaitForMultipleObjects</code> function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to RegisterWaitForSingleObject, you must duplicate the handle using the Win32 <code>DuplicateHandle</code> function. Note that you should not pulse an event object passed to RegisterWaitForSingleObject, because the wait thread might not detect that the event is signaled before it is reset.  </p>\n<p> Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.  </p>\n<h2 id=\"version-information\">Version Information</h2>\n<p> Starting with the .NET Framework version 2.0, the <a class=\"xref\" href=\"system.threading.thread#System_Threading_Thread_CurrentPrincipal_\" data-linktype=\"relative-path\">CurrentPrincipal</a> property value is propagated to worker threads queued using the <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_RegisterWaitForSingleObject_\" data-linktype=\"relative-path\">RegisterWaitForSingleObject</a> method. In earlier versions, the principal information is not propagated.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean_\">\r\n    \r\n            <a id=\"System_Threading_ThreadPool_RegisterWaitForSingleObject_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Registers a delegate to wait for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>, specifying a 64-bit signed integer for the time-out in milliseconds.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>waitObject</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> to register. Use a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> other than <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>callBack</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waitortimercallback\" data-linktype=\"relative-path\">WaitOrTimerCallback</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.waitortimercallback\" data-linktype=\"relative-path\">WaitOrTimerCallback</a> delegate to call when the <code>waitObject</code> parameter is signaled.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>state</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object passed to the delegate.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>millisecondsTimeOutInterval</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The time-out in milliseconds. If the <code>millisecondsTimeOutInterval</code> parameter is 0 (zero), the function tests the object&#39;s state and returns immediately. If <code>millisecondsTimeOutInterval</code> is -1, the function&#39;s time-out interval never elapses.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>executeOnlyOnce</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to indicate that the thread will no longer wait on the <code>waitObject</code> parameter after the delegate has been called; <code>false</code> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a></div>\r\n                  </div>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a> that encapsulates the native handle.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p>The <code>millisecondsTimeOutInterval</code> parameter is less than -1.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>When you are finished using the <a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a> that is returned by this method, call its <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method to release references to the wait handle. We recommend that you always call the <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method, even if you specify <code>true</code> for <code>executeOnlyOnce</code>. Garbage collection works more efficiently if you call the <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method instead of depending on the registered wait handle&#39;s finalizer.  </p>\n<p> The RegisterWaitForSingleObject method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs:  </p>\n<ul>\n<li><p>The specified object is in the signaled state.  </p>\n</li>\n<li><p>The time-out interval elapses.  </p>\n<p>The RegisterWaitForSingleObject method checks the current state of the specified object&#39;s <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>. If the object&#39;s state is unsignaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object&#39;s state becomes signaled or the time-out interval elapses. If the <code>timeOutInterval</code> parameter is not 0 (zero) and the <code>executeOnlyOnce</code> parameter is <code>false</code>, the timer is reset every time the event is signaled or the time-out interval elapses.  </p>\n</li>\n</ul>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> Using a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> for <code>waitObject</code> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default <code>WT_EXECUTEDEFAULT</code> flag, so each callback is dispatched on a separate thread pool thread. Instead of a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a>, use a <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> with a maximum count of 1.  </p>\n</div>\n<p> To cancel the wait operation, call the <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method.  </p>\n<p> The wait thread uses the Win32 <code>WaitForMultipleObjects</code> function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to RegisterWaitForSingleObject, you must duplicate the handle using the Win32 <code>DuplicateHandle</code> function. Note that you should not pulse an event object passed to RegisterWaitForSingleObject, because the wait thread might not detect that the event is signaled before it is reset.  </p>\n<p> Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.  </p>\n<h2 id=\"version-information\">Version Information</h2>\n<p> Starting with the .NET Framework version 2.0, the <a class=\"xref\" href=\"system.threading.thread#System_Threading_Thread_CurrentPrincipal_\" data-linktype=\"relative-path\">CurrentPrincipal</a> property value is propagated to worker threads queued using the <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_RegisterWaitForSingleObject_\" data-linktype=\"relative-path\">RegisterWaitForSingleObject</a> method. In earlier versions, the principal information is not propagated.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_TimeSpan_System_Boolean_\">\r\n    \r\n            <a id=\"System_Threading_ThreadPool_RegisterWaitForSingleObject_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Registers a delegate to wait for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>, specifying a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> value for the time-out.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>waitObject</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> to register. Use a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> other than <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>callBack</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waitortimercallback\" data-linktype=\"relative-path\">WaitOrTimerCallback</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.waitortimercallback\" data-linktype=\"relative-path\">WaitOrTimerCallback</a> delegate to call when the <code>waitObject</code> parameter is signaled.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>state</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object passed to the delegate.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>timeout</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The time-out represented by a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a>. If <code>timeout</code> is 0 (zero), the function tests the object&#39;s state and returns immediately. If <code>timeout</code> is -1, the function&#39;s time-out interval never elapses.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>executeOnlyOnce</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to indicate that the thread will no longer wait on the <code>waitObject</code> parameter after the delegate has been called; <code>false</code> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a></div>\r\n                  </div>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a> that encapsulates the native handle.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p>The <code>timeout</code> parameter is less than -1.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The <code>timeout</code> parameter is greater than <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">MaxValue</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>When you are finished using the <a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a> that is returned by this method, call its <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method to release references to the wait handle. We recommend that you always call the <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method, even if you specify <code>true</code> for <code>executeOnlyOnce</code>. Garbage collection works more efficiently if you call the <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method instead of depending on the registered wait handle&#39;s finalizer.  </p>\n<p> The RegisterWaitForSingleObject method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs:  </p>\n<ul>\n<li><p>The specified object is in the signaled state.  </p>\n</li>\n<li><p>The time-out interval elapses.  </p>\n<p>The RegisterWaitForSingleObject method checks the current state of the specified object&#39;s <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>. If the object&#39;s state is unsignaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object&#39;s state becomes signaled or the time-out interval elapses. If the <code>timeOutInterval</code> parameter is not 0 (zero) and the <code>executeOnlyOnce</code> parameter is <code>false</code>, the timer is reset every time the event is signaled or the time-out interval elapses.  </p>\n</li>\n</ul>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> Using a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> for <code>waitObject</code> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default <code>WT_EXECUTEDEFAULT</code> flag, so each callback is dispatched on a separate thread pool thread. Instead of a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a>, use a <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> with a maximum count of 1.  </p>\n</div>\n<p> To cancel the wait operation, call the <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method.  </p>\n<p> The wait thread uses the Win32 <code>WaitForMultipleObjects</code> function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to RegisterWaitForSingleObject, you must duplicate the handle using the Win32 <code>DuplicateHandle</code> function. Note that you should not pulse an event object passed to RegisterWaitForSingleObject, because the wait thread might not detect that the event is signaled before it is reset.  </p>\n<p> Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.  </p>\n<h2 id=\"version-information\">Version Information</h2>\n<p> Starting with the .NET Framework version 2.0, the <a class=\"xref\" href=\"system.threading.thread#System_Threading_Thread_CurrentPrincipal_\" data-linktype=\"relative-path\">CurrentPrincipal</a> property value is propagated to worker threads queued using the <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_RegisterWaitForSingleObject_\" data-linktype=\"relative-path\">RegisterWaitForSingleObject</a> method. In earlier versions, the principal information is not propagated.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_ThreadPool_RegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_UInt32_System_Boolean_\">\r\n    \r\n            <a id=\"System_Threading_ThreadPool_RegisterWaitForSingleObject_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">RegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Registers a delegate to wait for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>, specifying a 32-bit unsigned integer for the time-out in milliseconds.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>waitObject</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> to register. Use a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> other than <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>callBack</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waitortimercallback\" data-linktype=\"relative-path\">WaitOrTimerCallback</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.waitortimercallback\" data-linktype=\"relative-path\">WaitOrTimerCallback</a> delegate to call when the <code>waitObject</code> parameter is signaled.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>state</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object passed to the delegate.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>millisecondsTimeOutInterval</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The time-out in milliseconds. If the <code>millisecondsTimeOutInterval</code> parameter is 0 (zero), the function tests the object&#39;s state and returns immediately. If <code>millisecondsTimeOutInterval</code> is -1, the function&#39;s time-out interval never elapses.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>executeOnlyOnce</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to indicate that the thread will no longer wait on the <code>waitObject</code> parameter after the delegate has been called; <code>false</code> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a></div>\r\n                  </div>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a> that can be used to cancel the registered wait operation.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p>The <code>millisecondsTimeOutInterval</code> parameter is less than -1.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>When you are finished using the <a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a> that is returned by this method, call its <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method to release references to the wait handle. We recommend that you always call the <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method, even if you specify <code>true</code> for <code>executeOnlyOnce</code>. Garbage collection works more efficiently if you call the <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method instead of depending on the registered wait handle&#39;s finalizer.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_RegisterWaitForSingleObject_\" data-linktype=\"relative-path\">RegisterWaitForSingleObject</a> method queues the specified delegate to the thread pool. A worker thread will execute the delegate when one of the following occurs:  </p>\n<ul>\n<li><p>The specified object is in the signaled state.  </p>\n</li>\n<li><p>The time-out interval elapses.  </p>\n<p>The <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_RegisterWaitForSingleObject_\" data-linktype=\"relative-path\">RegisterWaitForSingleObject</a>method checks the current state of the specified object&#39;s <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>. If the object&#39;s state is unsignaled, the method registers a wait operation. The wait operation is performed by a thread from the thread pool. The delegate is executed by a worker thread when the object&#39;s state becomes signaled or the time-out interval elapses. If the <code>timeOutInterval</code> parameter is not 0 (zero) and the <code>executeOnlyOnce</code> parameter is <code>false</code>, the timer is reset every time the event is signaled or the time-out interval elapses.  </p>\n</li>\n</ul>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> Using a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> for <code>waitObject</code> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default <code>WT_EXECUTEDEFAULT</code> flag, so each callback is dispatched on a separate thread pool thread. Instead of a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a>, use a <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> with a maximum count of 1.  </p>\n</div>\n<p> To cancel the wait operation, call the <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method.  </p>\n<p> The wait thread uses the Win32 <code>WaitForMultipleObjects</code> function to monitor registered wait operations. Therefore, if you must use the same native operating system handle in multiple calls to <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_RegisterWaitForSingleObject_\" data-linktype=\"relative-path\">RegisterWaitForSingleObject</a>, you must duplicate the handle using the Win32 <code>DuplicateHandle</code> function. Note that you should not pulse an event object passed to <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_RegisterWaitForSingleObject_\" data-linktype=\"relative-path\">RegisterWaitForSingleObject</a>, because the wait thread might not detect that the event is signaled before it is reset.  </p>\n<p> Before returning, the function modifies the state of some types of synchronization objects. Modification occurs only for the object whose signaled state caused the wait condition to be satisfied. For example, the count of a semaphore is decreased by one.  </p>\n<h2 id=\"version-information\">Version Information</h2>\n<p> Starting with the .NET Framework version 2.0, the <a class=\"xref\" href=\"system.threading.thread#System_Threading_Thread_CurrentPrincipal_\" data-linktype=\"relative-path\">CurrentPrincipal</a> property value is propagated to worker threads queued using the <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_RegisterWaitForSingleObject_\" data-linktype=\"relative-path\">RegisterWaitForSingleObject</a> method. In earlier versions, the principal information is not propagated.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example shows how to use the RegisterWaitForSingleObject method to execute a specified callback method when a specified wait handle is signaled. In this example, the callback method is <code>WaitProc</code>, and the wait handle is an <a class=\"xref\" href=\"system.threading.autoresetevent\" data-linktype=\"relative-path\">AutoResetEvent</a>.  </p>\n<p> The example defines a <code>TaskInfo</code> class to hold the information that is passed to the callback when it executes. The example creates a <code>TaskInfo</code> object and assigns it some string data. The <a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a> that is returned by the RegisterWaitForSingleObject method is assigned to the <code>Handle</code> field of the <code>TaskInfo</code> object so that the callback method has access to the <a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a>.  </p>\n<p> In addition to specifying <code>TaskInfo</code> as the object to pass to the callback method, the call to the RegisterWaitForSingleObject method specifies the <a class=\"xref\" href=\"system.threading.autoresetevent\" data-linktype=\"relative-path\">AutoResetEvent</a> that the task will wait for, a <a class=\"xref\" href=\"system.threading.waitortimercallback\" data-linktype=\"relative-path\">WaitOrTimerCallback</a> delegate that represents the <code>WaitProc</code> callback method, a one second time-out interval, and multiple callbacks.  </p>\n<p> When the main thread signals the <a class=\"xref\" href=\"system.threading.autoresetevent\" data-linktype=\"relative-path\">AutoResetEvent</a> by calling its <a class=\"xref\" href=\"system.threading.eventwaithandle#System_Threading_EventWaitHandle_Set_\" data-linktype=\"relative-path\">Set</a> method, the <a class=\"xref\" href=\"system.threading.waitortimercallback\" data-linktype=\"relative-path\">WaitOrTimerCallback</a> delegate is invoked. The <code>WaitProc</code> method tests <a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a> to determine whether a time-out occurred. If the callback was invoked because the wait handle was signaled, the <code>WaitProc</code> method unregisters the <a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a>, stopping additional callbacks. In the case of a time-out, the task continues to wait. The <code>WaitProc</code> method ends by printing a message to the console.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.ThreadPool RegisterWaitForSingleObject0#1\">using System;\nusing System.Threading;\n\n// TaskInfo contains data that will be passed to the callback\n// method.\npublic class TaskInfo {\n    public RegisteredWaitHandle Handle = null;\n    public string OtherInfo = &quot;default&quot;;\n}\n\npublic class Example {\n    public static void Main(string[] args) {\n        // The main thread uses AutoResetEvent to signal the\n        // registered wait handle, which executes the callback\n        // method.\n        AutoResetEvent ev = new AutoResetEvent(false);\n\n        TaskInfo ti = new TaskInfo();\n        ti.OtherInfo = &quot;First task&quot;;\n        // The TaskInfo for the task includes the registered wait\n        // handle returned by RegisterWaitForSingleObject.  This\n        // allows the wait to be terminated when the object has\n        // been signaled once (see WaitProc).\n        ti.Handle = ThreadPool.RegisterWaitForSingleObject(\n            ev,\n            new WaitOrTimerCallback(WaitProc),\n            ti,\n            1000,\n            false\n        );\n\n        // The main thread waits three seconds, to demonstrate the\n        // time-outs on the queued thread, and then signals.\n        Thread.Sleep(3100);\n        Console.WriteLine(&quot;Main thread signals.&quot;);\n        ev.Set();\n\n        // The main thread sleeps, which should give the callback\n        // method time to execute.  If you comment out this line, the\n        // program usually ends before the ThreadPool thread can execute.\n        Thread.Sleep(1000);\n        // If you start a thread yourself, you can wait for it to end\n        // by calling Thread.Join.  This option is not available with \n        // thread pool threads.\n    }\n   \n    // The callback method executes when the registered wait times out,\n    // or when the WaitHandle (in this case AutoResetEvent) is signaled.\n    // WaitProc unregisters the WaitHandle the first time the event is \n    // signaled.\n    public static void WaitProc(object state, bool timedOut) {\n        // The state object must be cast to the correct type, because the\n        // signature of the WaitOrTimerCallback delegate specifies type\n        // Object.\n        TaskInfo ti = (TaskInfo) state;\n\n        string cause = &quot;TIMED OUT&quot;;\n        if (!timedOut) {\n            cause = &quot;SIGNALED&quot;;\n            // If the callback method executes because the WaitHandle is\n            // signaled, stop future execution of the callback method\n            // by unregistering the WaitHandle.\n            if (ti.Handle != null)\n                ti.Handle.Unregister(null);\n        } \n\n        Console.WriteLine(&quot;WaitProc( {0} ) executes on thread {1}; cause = {2}.&quot;,\n            ti.OtherInfo, \n            Thread.CurrentThread.GetHashCode().ToString(), \n            cause\n        );\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.ThreadPool RegisterWaitForSingleObject0#1\">using namespace System;\nusing namespace System::Threading;\n\n// TaskInfo contains data that will be passed to the callback\n// method.\npublic ref class TaskInfo\n{\npublic:\n   TaskInfo()\n   {\n      Handle = nullptr;\n      OtherInfo = &quot;default&quot;;\n   }\n\n   RegisteredWaitHandle^ Handle;\n   String^ OtherInfo;\n};\n\nref class Example\n{\npublic:\n\n   // The callback method executes when the registered wait times out,\n   // or when the WaitHandle (in this case AutoResetEvent) is signaled.\n   // WaitProc unregisters the WaitHandle the first time the event is \n   // signaled.\n   static void WaitProc( Object^ state, bool timedOut )\n   {\n      \n      // The state Object must be cast to the correct type, because the\n      // signature of the WaitOrTimerCallback delegate specifies type\n      // Object.\n      TaskInfo^ ti = static_cast&lt;TaskInfo^&gt;(state);\n      String^ cause = &quot;TIMED OUT&quot;;\n      if (  !timedOut )\n      {\n         cause = &quot;SIGNALED&quot;;\n         \n         // If the callback method executes because the WaitHandle is\n         // signaled, stop future execution of the callback method\n         // by unregistering the WaitHandle.\n         if ( ti-&gt;Handle != nullptr )\n                  ti-&gt;Handle-&gt;Unregister( nullptr );\n      }\n\n      Console::WriteLine( &quot;WaitProc( {0}) executes on thread {1}; cause = {2}.&quot;, ti-&gt;OtherInfo, Thread::CurrentThread-&gt;GetHashCode(), cause );\n   }\n\n};\n\nint main()\n{\n   \n   // The main thread uses AutoResetEvent to signal the\n   // registered wait handle, which executes the callback\n   // method.\n   AutoResetEvent^ ev = gcnew AutoResetEvent( false );\n   TaskInfo^ ti = gcnew TaskInfo;\n   ti-&gt;OtherInfo = &quot;First task&quot;;\n   \n   // The TaskInfo for the task includes the registered wait\n   // handle returned by RegisterWaitForSingleObject.  This\n   // allows the wait to be terminated when the object has\n   // been signaled once (see WaitProc).\n   ti-&gt;Handle = ThreadPool::RegisterWaitForSingleObject( ev, gcnew WaitOrTimerCallback( Example::WaitProc ), ti, 1000, false );\n   \n   // The main thread waits three seconds, to demonstrate the\n   // time-outs on the queued thread, and then signals.\n   Thread::Sleep( 3100 );\n   Console::WriteLine( &quot;Main thread signals.&quot; );\n   ev-&gt;Set();\n   \n   // The main thread sleeps, which should give the callback\n   // method time to execute.  If you comment out this line, the\n   // program usually ends before the ThreadPool thread can execute.\n   Thread::Sleep( 1000 );\n   \n   // If you start a thread yourself, you can wait for it to end\n   // by calling Thread::Join.  This option is not available with \n   // thread pool threads.\n   return 0;\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.ThreadPool RegisterWaitForSingleObject0#1\">Imports System\nImports System.Threading\n\n&#39; TaskInfo contains data that will be passed to the callback\n&#39; method.\nPublic Class TaskInfo\n    public Handle As RegisteredWaitHandle = Nothing\n    public OtherInfo As String = &quot;default&quot;\nEnd Class\n\nPublic Class Example\n\n    &lt;MTAThread&gt; _\n    Public Shared Sub Main()\n        &#39; The main thread uses AutoResetEvent to signal the\n        &#39; registered wait handle, which executes the callback\n        &#39; method.\n        Dim ev As New AutoResetEvent(false)\n\n        Dim ti As New TaskInfo()\n        ti.OtherInfo = &quot;First task&quot;\n        &#39; The TaskInfo for the task includes the registered wait\n        &#39; handle returned by RegisterWaitForSingleObject.  This\n        &#39; allows the wait to be terminated when the object has\n        &#39; been signaled once (see WaitProc).\n        ti.Handle = ThreadPool.RegisterWaitForSingleObject( _\n            ev, _\n            New WaitOrTimerCallback(AddressOf WaitProc), _\n            ti, _\n            1000, _\n            false _\n        )\n\n        &#39; The main thread waits about three seconds, to demonstrate \n        &#39; the time-outs on the queued task, and then signals.\n        Thread.Sleep(3100)\n        Console.WriteLine(&quot;Main thread signals.&quot;)\n        ev.Set()\n\n        &#39; The main thread sleeps, which should give the callback\n        &#39; method time to execute.  If you comment out this line, the\n        &#39; program usually ends before the ThreadPool thread can execute.\n        Thread.Sleep(1000)\n        &#39; If you start a thread yourself, you can wait for it to end\n        &#39; by calling Thread.Join.  This option is not available with \n        &#39; thread pool threads.\n    End Sub\n   \n    &#39; The callback method executes when the registered wait times out,\n    &#39; or when the WaitHandle (in this case AutoResetEvent) is signaled.\n    &#39; WaitProc unregisters the WaitHandle the first time the event is \n    &#39; signaled.\n    Public Shared Sub WaitProc(state As Object, timedOut As Boolean)\n        &#39; The state object must be cast to the correct type, because the\n        &#39; signature of the WaitOrTimerCallback delegate specifies type\n        &#39; Object.\n        Dim ti As TaskInfo = CType(state, TaskInfo)\n\n        Dim cause As String = &quot;TIMED OUT&quot;\n        If Not timedOut Then\n            cause = &quot;SIGNALED&quot;\n            &#39; If the callback method executes because the WaitHandle is\n            &#39; signaled, stop future execution of the callback method\n            &#39; by unregistering the WaitHandle.\n            If Not ti.Handle Is Nothing Then\n                ti.Handle.Unregister(Nothing)\n            End If\n        End If \n\n        Console.WriteLine(&quot;WaitProc( {0} ) executes on thread {1}; cause = {2}.&quot;, _\n            ti.OtherInfo, _\n            Thread.CurrentThread.GetHashCode().ToString(), _\n            cause _\n        )\n    End Sub\nEnd Class\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_ThreadPool_SetMaxThreads_System_Int32_System_Int32_\">\r\n    \r\n            <a id=\"System_Threading_ThreadPool_SetMaxThreads_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">SetMaxThreads(Int32,Int32)</div>        \r\n          </div>\r\n    \r\n            <p>Sets the number of requests to the thread pool that can be active concurrently. All requests above that number remain queued until thread pool threads become available.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool SetMaxThreads (int workerThreads, int completionPortThreads);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>workerThreads</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The maximum number of worker threads in the thread pool.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>completionPortThreads</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The maximum number of asynchronous I/O threads in the thread pool.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the change is successful; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>You cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the number of processors on the computer. To determine how many processors are present, retrieve the value of the <a class=\"xref\" href=\"system.environment#System_Environment_ProcessorCount_\" data-linktype=\"relative-path\">ProcessorCount</a> property. In addition, you cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the corresponding minimum number of worker threads or I/O completion threads. To determine the minimum thread pool size,  call the <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_GetMinThreads_\" data-linktype=\"relative-path\">GetMinThreads</a> method.  </p>\n<p> If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.  </p>\n<p> Use caution when changing the maximum number of threads in the thread pool. While your code might benefit, the changes might have an adverse effect on code libraries you use.  </p>\n<p> Setting the thread pool size too large can cause performance problems. If too many threads are executing at the same time, the task switching overhead becomes a significant factor.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_ThreadPool_SetMinThreads_System_Int32_System_Int32_\">\r\n    \r\n            <a id=\"System_Threading_ThreadPool_SetMinThreads_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">SetMinThreads(Int32,Int32)</div>        \r\n          </div>\r\n    \r\n            <p>Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool SetMinThreads (int workerThreads, int completionPortThreads);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>workerThreads</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The minimum number of worker threads that the thread pool creates on demand.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>completionPortThreads</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The minimum number of asynchronous I/O threads that the thread pool creates on demand.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the change is successful; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category. When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete. Beginning with the .NET Framework 4, the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time. Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.  </p>\n<p> When demand is low, the actual number of thread pool threads can fall below the minimum values.  </p>\n<p> If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_GetMaxThreads_\" data-linktype=\"relative-path\">GetMaxThreads</a>), SetMinThreads returns <code>false</code> and does not change either of the minimum values.  </p>\n<div class=\"CAUTION\"><h5>Caution</h5><p> By default, the minimum number of threads is set to the number of processors on a system. You can use the SetMinThreads method to increase the minimum number ofthreads. However, unnecessarily increasing these values can cause performance problems. If too many tasks start at the same time, all of them might appear to be slow. In most cases, the thread pool will perform better with its own algorithm for allocating threads. Reducing the minimum to less than the number of processors can also hurt performance.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Threading.ThreadPool.GetSetMinThreads#1\">Imports System\nImports System.Threading\n\nPublic Class Test\n\n    &lt;MTAThread&gt; _\n    Public Shared Sub Main()\n        Dim minWorker, minIOC As Integer\n        &#39; Get the current settings.\n        ThreadPool.GetMinThreads(minWorker, minIOC)\n        &#39; Change the minimum number of worker threads to four, but\n        &#39; keep the old setting for minimum asynchronous I/O \n        &#39; completion threads.\n        If ThreadPool.SetMinThreads(4, minIOC) Then\n            &#39; The minimum number of threads was set successfully.\n        Else\n            &#39; The minimum number of threads was not changed.\n        End If\n    End Sub\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.ThreadPool.GetSetMinThreads#1\">using System;\nusing System.Threading;\n\npublic class Test\n{\n    public static void Main()\n    {\n        int minWorker, minIOC;\n        // Get the current settings.\n        ThreadPool.GetMinThreads(out minWorker, out minIOC);\n        // Change the minimum number of worker threads to four, but\n        // keep the old setting for minimum asynchronous I/O \n        // completion threads.\n        if (ThreadPool.SetMinThreads(4, minIOC))\n        {\n            // The minimum number of threads was set successfully.\n        }\n        else\n        {\n            // The minimum number of threads was not changed.\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.ThreadPool.GetSetMinThreads#1\">using namespace System;\nusing namespace System::Threading;\nint main()\n{\n   int minWorker;\n   int minIOC;\n   \n   // Get the current settings.\n   ThreadPool::GetMinThreads( minWorker, minIOC );\n   \n   // Change the minimum number of worker threads to four, but\n   // keep the old setting for minimum asynchronous I/O\n   // completion threads.\n   if ( ThreadPool::SetMinThreads( 4, minIOC ) )\n   {\n      \n      // The minimum number of threads was set successfully.\n   }\n   else\n   {\n      \n      // The minimum number of threads was not changed.\n   }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_ThreadPool_UnsafeQueueNativeOverlapped_System_Threading_NativeOverlapped__\">\r\n    \r\n            <a id=\"System_Threading_ThreadPool_UnsafeQueueNativeOverlapped_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">UnsafeQueueNativeOverlapped(NativeOverlapped*)</div>        \r\n          </div>\r\n    \r\n            <p>Queues an overlapped I/O operation for execution.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>overlapped</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.nativeoverlapped\" data-linktype=\"relative-path\">NativeOverlapped</a>*</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.nativeoverlapped\" data-linktype=\"relative-path\">NativeOverlapped</a> structure to queue.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the operation was successfully queued to an I/O completion port; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>For information about using native Win32 overlapped I/O, see the <a class=\"xref\" href=\"system.threading.overlapped\" data-linktype=\"relative-path\">Overlapped</a> class, the <a class=\"xref\" href=\"system.threading.nativeoverlapped\" data-linktype=\"relative-path\">NativeOverlapped</a> structure, and the <code>OVERLAPPED</code> structure in the Win32 Platform SDK.  </p>\n<div class=\"CAUTION\"><h5>Caution</h5><p> Using the UnsafeQueueNativeOverlapped method could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. When work is queued on a thread pool thread using UnsafeQueueNativeOverlapped, the stack of the thread pool thread does not have the context of the actual callers. Malicious code might be able exploit this to avoid permission checks.</p>\n</div>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_ThreadPool_UnsafeQueueUserWorkItem_System_Threading_WaitCallback_System_Object_\">\r\n    \r\n            <a id=\"System_Threading_ThreadPool_UnsafeQueueUserWorkItem_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">UnsafeQueueUserWorkItem(WaitCallback,Object)</div>        \r\n          </div>\r\n    \r\n            <p>Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>callBack</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waitcallback\" data-linktype=\"relative-path\">WaitCallback</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <a class=\"xref\" href=\"system.threading.waitcallback\" data-linktype=\"relative-path\">WaitCallback</a> that represents the delegate to invoke when a thread in the thread pool picks up the work item.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>state</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object that is passed to the delegate when serviced from the thread pool.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the method succeeds; <a class=\"xref\" href=\"system.outofmemoryexception\" data-linktype=\"relative-path\">OutOfMemoryException</a> is thrown if the work item could not be queued.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.securityexception\" data-linktype=\"relative-path\">SecurityException</a></div>\r\n                  </div>\r\n                  <p>The caller does not have the required permission.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a></div>\r\n                  </div>\r\n                  <p>An out-of-memory condition was encountered.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.outofmemoryexception\" data-linktype=\"relative-path\">OutOfMemoryException</a></div>\r\n                  </div>\r\n                  <p>The work item could not be queued.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>callBack</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Unlike the <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_QueueUserWorkItem_\" data-linktype=\"relative-path\">QueueUserWorkItem</a> method, UnsafeQueueUserWorkItem does not propagate the calling stack to the worker thread. This allows code to lose the calling stack and thereby to elevate its security privileges.  </p>\n<div class=\"CAUTION\"><h5>Caution</h5><p> Using UnsafeQueueUserWorkItem could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. When work is queued on a thread pool thread using UnsafeQueueUserWorkItem, the stack of the thread pool thread will not have the context of the actual callers. Malicious code might be able exploit this to avoid permission checks.</p>\n</div>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_ThreadPool_UnsafeRegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int32_System_Boolean_\">\r\n    \r\n            <a id=\"System_Threading_ThreadPool_UnsafeRegisterWaitForSingleObject_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int32,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Registers a delegate to wait for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>, using a 32-bit signed integer for the time-out in milliseconds. This method does not propagate the calling stack to the worker thread.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>waitObject</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> to register. Use a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> other than <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>callBack</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waitortimercallback\" data-linktype=\"relative-path\">WaitOrTimerCallback</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The delegate to call when the <code>waitObject</code> parameter is signaled.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>state</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object that is passed to the delegate.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>millisecondsTimeOutInterval</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The time-out in milliseconds. If the <code>millisecondsTimeOutInterval</code> parameter is 0 (zero), the function tests the object&#39;s state and returns immediately. If <code>millisecondsTimeOutInterval</code> is -1, the function&#39;s time-out interval never elapses.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>executeOnlyOnce</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to indicate that the thread will no longer wait on the <code>waitObject</code> parameter after the delegate has been called; <code>false</code> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a></div>\r\n                  </div>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a> object that can be used to cancel the registered wait operation.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p>The <code>millisecondsTimeOutInterval</code> parameter is less than -1.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.securityexception\" data-linktype=\"relative-path\">SecurityException</a></div>\r\n                  </div>\r\n                  <p>The caller does not have the required permission.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Unlike the <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_RegisterWaitForSingleObject_\" data-linktype=\"relative-path\">RegisterWaitForSingleObject</a> method, UnsafeRegisterWaitForSingleObject does not propagate the calling stack to the worker thread. This allows code to lose the calling stack and thereby to elevate its security privileges.  </p>\n<div class=\"CAUTION\"><h5>Caution</h5><p> Using UnsafeRegisterWaitForSingleObject could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. When work is queued on a thread pool thread using UnsafeRegisterWaitForSingleObject, the stack of the thread pool thread will not have the context of the actual callers. Malicious code might be able exploit this to avoid permission checks.  </p>\n</div>\n<p> Using a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> for <code>waitObject</code> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default <code>WT_EXECUTEDEFAULT</code> flag, so each callback is dispatched on a separate thread pool thread.  </p>\n<p> When you are finished using the <a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a> that is returned by this method, call its <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method to release references to the wait handle. We recommend that you always call the <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method, even if you specify <code>true</code> for <code>executeOnlyOnce</code>. Garbage collection works more efficiently if you call the <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method instead of depending on the registered wait handle&#39;s finalizer.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_ThreadPool_UnsafeRegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_Int64_System_Boolean_\">\r\n    \r\n            <a id=\"System_Threading_ThreadPool_UnsafeRegisterWaitForSingleObject_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,Int64,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Registers a delegate to wait for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>, specifying a 64-bit signed integer for the time-out in milliseconds. This method does not propagate the calling stack to the worker thread.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>waitObject</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> to register. Use a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> other than <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>callBack</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waitortimercallback\" data-linktype=\"relative-path\">WaitOrTimerCallback</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The delegate to call when the <code>waitObject</code> parameter is signaled.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>state</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object that is passed to the delegate.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>millisecondsTimeOutInterval</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The time-out in milliseconds. If the <code>millisecondsTimeOutInterval</code> parameter is 0 (zero), the function tests the object&#39;s state and returns immediately. If <code>millisecondsTimeOutInterval</code> is -1, the function&#39;s time-out interval never elapses.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>executeOnlyOnce</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to indicate that the thread will no longer wait on the <code>waitObject</code> parameter after the delegate has been called; <code>false</code> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a></div>\r\n                  </div>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a> object that can be used to cancel the registered wait operation.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p>The <code>millisecondsTimeOutInterval</code> parameter is less than -1.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.securityexception\" data-linktype=\"relative-path\">SecurityException</a></div>\r\n                  </div>\r\n                  <p>The caller does not have the required permission.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Unlike the <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_RegisterWaitForSingleObject_\" data-linktype=\"relative-path\">RegisterWaitForSingleObject</a> method, UnsafeRegisterWaitForSingleObject does not propagate the calling stack to the worker thread. This allows code to lose the calling stack and thereby to elevate its security privileges.  </p>\n<div class=\"CAUTION\"><h5>Caution</h5><p> Using UnsafeRegisterWaitForSingleObject could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. When work is queued on a thread pool thread using UnsafeRegisterWaitForSingleObject, the stack of the thread pool thread will not have the context of the actual callers. Malicious code might be able exploit this to avoid permission checks.  </p>\n</div>\n<p> Using a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> for <code>waitObject</code> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default <code>WT_EXECUTEDEFAULT</code> flag, so each callback is dispatched on a separate thread pool thread.  </p>\n<p> When you are finished using the <a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a> that is returned by this method, call its <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method to release references to the wait handle. We recommend that you always call the <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method, even if you specify <code>true</code> for <code>executeOnlyOnce</code>. Garbage collection works more efficiently if you call the <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method instead of depending on the registered wait handle&#39;s finalizer.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_ThreadPool_UnsafeRegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_TimeSpan_System_Boolean_\">\r\n    \r\n            <a id=\"System_Threading_ThreadPool_UnsafeRegisterWaitForSingleObject_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,TimeSpan,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Registers a delegate to wait for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>, specifying a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a> value for the time-out. This method does not propagate the calling stack to the worker thread.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>waitObject</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> to register. Use a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> other than <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>callBack</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waitortimercallback\" data-linktype=\"relative-path\">WaitOrTimerCallback</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The delegate to call when the <code>waitObject</code> parameter is signaled.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>state</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object that is passed to the delegate.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>timeout</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The time-out represented by a <a class=\"xref\" href=\"system.timespan\" data-linktype=\"relative-path\">TimeSpan</a>. If <code>timeout</code> is 0 (zero), the function tests the object&#39;s state and returns immediately. If <code>timeout</code> is -1, the function&#39;s time-out interval never elapses.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>executeOnlyOnce</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to indicate that the thread will no longer wait on the <code>waitObject</code> parameter after the delegate has been called; <code>false</code> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a></div>\r\n                  </div>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a> object that can be used to cancel the registered wait operation.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p>The <code>timeout</code> parameter is less than -1.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The <code>timeout</code> parameter is greater than <a class=\"xref\" href=\"system.int32#System_Int32_MaxValue\" data-linktype=\"relative-path\">MaxValue</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.securityexception\" data-linktype=\"relative-path\">SecurityException</a></div>\r\n                  </div>\r\n                  <p>The caller does not have the required permission.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Unlike the <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_RegisterWaitForSingleObject_\" data-linktype=\"relative-path\">RegisterWaitForSingleObject</a> method, UnsafeRegisterWaitForSingleObject does not propagate the calling stack to the worker thread. This allows code to lose the calling stack and thereby to elevate its security privileges.  </p>\n<div class=\"CAUTION\"><h5>Caution</h5><p> Using UnsafeRegisterWaitForSingleObject could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. When work is queued on a thread pool thread using UnsafeRegisterWaitForSingleObject, the stack of the thread pool thread will not have the context of the actual callers. Malicious code might be able exploit this to avoid permission checks.  </p>\n</div>\n<p> Using a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> for <code>waitObject</code> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default <code>WT_EXECUTEDEFAULT</code> flag, so each callback is dispatched on a separate thread pool thread.  </p>\n<p> When you are finished using the <a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a> that is returned by this method, call its <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method to release references to the wait handle. We recommend that you always call the <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method, even if you specify <code>true</code> for <code>executeOnlyOnce</code>. Garbage collection works more efficiently if you call the <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method instead of depending on the registered wait handle&#39;s finalizer.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_ThreadPool_UnsafeRegisterWaitForSingleObject_System_Threading_WaitHandle_System_Threading_WaitOrTimerCallback_System_Object_System_UInt32_System_Boolean_\">\r\n    \r\n            <a id=\"System_Threading_ThreadPool_UnsafeRegisterWaitForSingleObject_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">UnsafeRegisterWaitForSingleObject(WaitHandle,WaitOrTimerCallback,Object,UInt32,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Registers a delegate to wait for a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>, specifying a 32-bit unsigned integer for the time-out in milliseconds. This method does not propagate the calling stack to the worker thread.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>waitObject</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> to register. Use a <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> other than <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>callBack</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waitortimercallback\" data-linktype=\"relative-path\">WaitOrTimerCallback</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The delegate to call when the <code>waitObject</code> parameter is signaled.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>state</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object that is passed to the delegate.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>millisecondsTimeOutInterval</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The time-out in milliseconds. If the <code>millisecondsTimeOutInterval</code> parameter is 0 (zero), the function tests the object&#39;s state and returns immediately. If <code>millisecondsTimeOutInterval</code> is -1, the function&#39;s time-out interval never elapses.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>executeOnlyOnce</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to indicate that the thread will no longer wait on the <code>waitObject</code> parameter after the delegate has been called; <code>false</code> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a></div>\r\n                  </div>\r\n                  <p>The <a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a> object that can be used to cancel the registered wait operation.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.securityexception\" data-linktype=\"relative-path\">SecurityException</a></div>\r\n                  </div>\r\n                  <p>The caller does not have the required permission.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Unlike the <a class=\"xref\" href=\"system.threading.threadpool#System_Threading_ThreadPool_RegisterWaitForSingleObject_\" data-linktype=\"relative-path\">RegisterWaitForSingleObject</a> method, UnsafeRegisterWaitForSingleObject does not propagate the calling stack to the worker thread. This allows code to lose the calling stack and thereby to elevate its security privileges.  </p>\n<div class=\"CAUTION\"><h5>Caution</h5><p> Using UnsafeRegisterWaitForSingleObject could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. When work is queued on a thread pool thread using UnsafeRegisterWaitForSingleObject, the stack of the thread pool thread will not have the context of the actual callers. Malicious code might be able exploit this to avoid permission checks.  </p>\n</div>\n<p> Using a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> for <code>waitObject</code> does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default <code>WT_EXECUTEDEFAULT</code> flag, so each callback is dispatched on a separate thread pool thread.  </p>\n<p> When you are finished using the <a class=\"xref\" href=\"system.threading.registeredwaithandle\" data-linktype=\"relative-path\">RegisteredWaitHandle</a> that is returned by this method, call its <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method to release references to the wait handle. We recommend that you always call the <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method, even if you specify <code>true</code> for <code>executeOnlyOnce</code>. Garbage collection works more efficiently if you call the <a class=\"xref\" href=\"system.threading.registeredwaithandle#System_Threading_RegisteredWaitHandle_Unregister_\" data-linktype=\"relative-path\">Unregister</a> method instead of depending on the registered wait handle&#39;s finalizer.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n","outputRootRelativePath":"./","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"breadcrumb_path\" content=\"breadcrumb/toc.json\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"fulldocset\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.fulldocset\">\r\n<meta name=\"ref_skeleton_gitcommit\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Threading.ThreadPool.yml\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Threading.ThreadPool.yml\">\r\n<meta name=\"APIName\" content=\"System.Threading.ThreadPool\">\r\n<meta name=\"APIName\" content=\"System.Threading.ThreadPool.BindHandle\">\r\n<meta name=\"APIName\" content=\"System.Threading.ThreadPool.GetAvailableThreads\">\r\n<meta name=\"APIName\" content=\"System.Threading.ThreadPool.GetMaxThreads\">\r\n<meta name=\"APIName\" content=\"System.Threading.ThreadPool.GetMinThreads\">\r\n<meta name=\"APIName\" content=\"System.Threading.ThreadPool.QueueUserWorkItem\">\r\n<meta name=\"APIName\" content=\"System.Threading.ThreadPool.RegisterWaitForSingleObject\">\r\n<meta name=\"APIName\" content=\"System.Threading.ThreadPool.SetMaxThreads\">\r\n<meta name=\"APIName\" content=\"System.Threading.ThreadPool.SetMinThreads\">\r\n<meta name=\"APIName\" content=\"System.Threading.ThreadPool.UnsafeQueueNativeOverlapped\">\r\n<meta name=\"APIName\" content=\"System.Threading.ThreadPool.UnsafeQueueUserWorkItem\">\r\n<meta name=\"APIName\" content=\"System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-01 01:37 AM\">\r\n<meta name=\"document_id\" content=\"662c05c7-2758-689b-91ca-8d6809fb5aac\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/System.Threading/toc.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Threading.ThreadPool\">\r\n","rawMetadata":{"author":"dotnet-bot","breadcrumb_path":"breadcrumb/toc.json","search.ms_sitename":"Docs","search.ms_docsetname":"fulldocset","version":null,"_op_canonicalUrlPrefix":"https://ppe.docs.microsoft.com/en-us/fulldotnet/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":true,"depot_name":"MSDN.fulldocset","_op_gitRefSkeletonCommitHistory":[{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"use plugin in master","commit_sha":"501959ac03e19ac52a27aa4c6bbeb980f8b11c8c","commit_date":"2017-03-01 09:31:20 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"fix pointer ref","commit_sha":"76befb0e7f7b41839ec719047e5b39a5981298f3","commit_date":"2017-02-28 15:47:23 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"switch from platform to version","commit_sha":"78cdacb5ca782478af490a6b30c3a2cb2b6b873e","commit_date":"2017-02-28 15:09:51 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"update platforms","commit_sha":"39ad5a8919a59afc93a79ac4bd8e07c3b471b37a","commit_date":"2017-02-28 10:38:59 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"checkin yml","commit_sha":"da161b792852497df7140d7768cee2eccd9cb43f","commit_date":"2017-02-28 09:36:15 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"delete ymls","commit_sha":"417c04fd1daf0cb211ec4909020356fc1fe69260","commit_date":"2017-02-27 14:12:48 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"update latest xml","commit_sha":"1e40a158586a88a698e0cb5342785002a56898b2","commit_date":"2017-02-24 16:20:57 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"add exceptions to reference section","commit_sha":"2f337ac32baa36b4ee4b5d8987b29dba4ce77336","commit_date":"2017-02-24 11:22:25 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"transform see cref and fix paramref format","commit_sha":"3d0ea34483c97ac77f4020a7f294757d67a5c1d4","commit_date":"2017-02-23 10:03:17 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"fix param transform, fix escaped xref","commit_sha":"2af997a764c82488dfa824f1c7bc4d736757d943","commit_date":"2017-02-22 17:04:48 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"convert exceptions","commit_sha":"0a5bf3370731dd35a596c91081e5dc82e2eace3a","commit_date":"2017-02-22 11:54:30 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"remove _yml from url","commit_sha":"f9314af8858edb8c329d223328490093aef4f55f","commit_date":"2017-02-17 15:31:12 +0800"}],"ref_skeleton_gitcommit":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Threading.ThreadPool.yml","original_ref_skeleton_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Threading.ThreadPool.yml","open_to_public_contributors":true,"api_name":["System.Threading.ThreadPool","System.Threading.ThreadPool.BindHandle","System.Threading.ThreadPool.GetAvailableThreads","System.Threading.ThreadPool.GetMaxThreads","System.Threading.ThreadPool.GetMinThreads","System.Threading.ThreadPool.QueueUserWorkItem","System.Threading.ThreadPool.RegisterWaitForSingleObject","System.Threading.ThreadPool.SetMaxThreads","System.Threading.ThreadPool.SetMinThreads","System.Threading.ThreadPool.UnsafeQueueNativeOverlapped","System.Threading.ThreadPool.UnsafeQueueUserWorkItem","System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Threading.ThreadPool","System::Threading::ThreadPool","System.Threading.ThreadPool.BindHandle","System::Threading::ThreadPool::BindHandle","System.Threading.ThreadPool.GetAvailableThreads","System::Threading::ThreadPool::GetAvailableThreads","System.Threading.ThreadPool.GetMaxThreads","System::Threading::ThreadPool::GetMaxThreads","System.Threading.ThreadPool.GetMinThreads","System::Threading::ThreadPool::GetMinThreads","System.Threading.ThreadPool.QueueUserWorkItem","System::Threading::ThreadPool::QueueUserWorkItem","System.Threading.ThreadPool.RegisterWaitForSingleObject","System::Threading::ThreadPool::RegisterWaitForSingleObject","System.Threading.ThreadPool.SetMaxThreads","System::Threading::ThreadPool::SetMaxThreads","System.Threading.ThreadPool.SetMinThreads","System::Threading::ThreadPool::SetMinThreads","System.Threading.ThreadPool.UnsafeQueueNativeOverlapped","System::Threading::ThreadPool::UnsafeQueueNativeOverlapped","System.Threading.ThreadPool.UnsafeQueueUserWorkItem","System::Threading::ThreadPool::UnsafeQueueUserWorkItem","System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject","System::Threading::ThreadPool::UnsafeRegisterWaitForSingleObject"],"dev_langs":["csharp"],"updated_at":"2017-03-01 01:37 AM","document_id":"662c05c7-2758-689b-91ca-8d6809fb5aac","content_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/xml/System.Threading/ThreadPool.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"ThreadPool class | Microsoft Docs","_op_ogTitle":"ThreadPool class","description":"Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.\n","toc_asset_id":"_splitted/System.Threading/toc.json","toc_rel":"_splitted/System.Threading/toc.json","source_url":"","ms.assetid":"System.Threading.ThreadPool","canonical_url":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.threading.threadpool","_op_canonicalUrl":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.threading.threadpool","fileRelativePath":"System.Threading.ThreadPool.html"},"themesRelativePathToOutputRoot":"_themes/"}