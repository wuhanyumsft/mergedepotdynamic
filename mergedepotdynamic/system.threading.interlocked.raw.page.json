{"content":"    \r\n    <h1 id=\"System_Threading_Interlocked\">\r\n      <span class=\"lang-csharp\">Interlocked</span>\r\n        Class\r\n    </h1>\r\n    \r\n    \r\n    <nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n      <h3>In this Article</h3>\r\n    </nav><div class=\"summary\">\r\n    \t<p>Provides atomic operations for variables that are shared by multiple threads.</p>\n\r\n    </div><h2>Syntax</h2>\r\n    \r\n    \t<h3>Declaration</h3>\r\n    \t<pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static class Interlocked</code></pre>\r\n    \r\n    \r\n    \r\n    <h3>Inheritance Hierarchy</h3>\r\n    <ul class=\"inheritance\">\r\n        <li class=\"l0\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a>\r\n          </div>\r\n        </li>\r\n      <li class=\"l1\">\r\n        <div class=\"xref\">\r\n          <div class=\"lang-csharp\">Interlocked</div>\r\n        </div>\r\n      </li>\r\n    </ul>\r\n    \r\n      <div class=\"referencebox inheritedMembers\">\r\n        <h3>Inherited Members</h3>\r\n        <h4></h4>\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a>\r\n          </div>\r\n          \r\n      </div>\r\n    \r\n    \r\n      <h2>Remarks</h2>\r\n      <p>The methods of this class help protect against errors that can occur when the scheduler switches contexts while a thread is updating a variable that can be accessed by other threads, or when two threads are executing concurrently on separate processors. The members of this class do not throw exceptions.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_Increment_\" data-linktype=\"relative-path\">Increment</a> and <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_Decrement_\" data-linktype=\"relative-path\">Decrement</a> methods increment or decrement a variable and store the resulting value in a single operation. On most computers, incrementing a variable is not an atomic operation, requiring the following steps:  </p>\n<ol>\n<li><p>Load a value from an instance variable into a register.  </p>\n</li>\n<li><p>Increment or decrement the value.  </p>\n</li>\n<li><p>Store the value in the instance variable.  </p>\n<p>If you do not use <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_Increment_\" data-linktype=\"relative-path\">Increment</a> and <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_Decrement_\" data-linktype=\"relative-path\">Decrement</a>, a thread can be preempted after executing the first two steps. Another thread can then execute all three steps. When the first thread resumes execution, it overwrites the value in the instance variable, and the effect of the increment or decrement performed by the second thread is lost.  </p>\n<p>The <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_Exchange_\" data-linktype=\"relative-path\">Exchange</a> method atomically exchanges the values of the specified variables. The <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_CompareExchange_\" data-linktype=\"relative-path\">CompareExchange</a> method combines two operations: comparing two values and storing a third value in one of the variables, based on the outcome of the comparison. The compare and exchange operations are performed as an atomic operation.</p>\n</li>\n</ol>\n\r\n    \r\n    \r\n    <h2>Methods\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Interlocked_Add_System_Int32__System_Int32_\" data-linktype=\"self-bookmark\">Add(Int32,Int32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Interlocked_Add_System_Int64__System_Int64_\" data-linktype=\"self-bookmark\">Add(Int64,Int64)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Interlocked_CompareExchange_System_Double__System_Double_System_Double_\" data-linktype=\"self-bookmark\">CompareExchange(Double,Double,Double)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Interlocked_CompareExchange_System_Int32__System_Int32_System_Int32_\" data-linktype=\"self-bookmark\">CompareExchange(Int32,Int32,Int32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Interlocked_CompareExchange_System_Int64__System_Int64_System_Int64_\" data-linktype=\"self-bookmark\">CompareExchange(Int64,Int64,Int64)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Interlocked_CompareExchange_System_IntPtr__System_IntPtr_System_IntPtr_\" data-linktype=\"self-bookmark\">CompareExchange(IntPtr,IntPtr,IntPtr)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Interlocked_CompareExchange_System_Object__System_Object_System_Object_\" data-linktype=\"self-bookmark\">CompareExchange(Object,Object,Object)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Compares two objects for reference equality and, if they are equal, replaces the first object.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Interlocked_CompareExchange_System_Single__System_Single_System_Single_\" data-linktype=\"self-bookmark\">CompareExchange(Single,Single,Single)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Interlocked_CompareExchange__1___0____0___0_\" data-linktype=\"self-bookmark\">CompareExchange&lt;T&gt;(T,T,T)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Compares two instances of the specified reference type <code>T</code> for equality and, if they are equal, replaces the first one.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Interlocked_Decrement_System_Int32__\" data-linktype=\"self-bookmark\">Decrement(Int32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Decrements a specified variable and stores the result, as an atomic operation.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Interlocked_Decrement_System_Int64__\" data-linktype=\"self-bookmark\">Decrement(Int64)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Decrements the specified variable and stores the result, as an atomic operation.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Interlocked_Exchange_System_Double__System_Double_\" data-linktype=\"self-bookmark\">Exchange(Double,Double)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Interlocked_Exchange_System_Int32__System_Int32_\" data-linktype=\"self-bookmark\">Exchange(Int32,Int32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Interlocked_Exchange_System_Int64__System_Int64_\" data-linktype=\"self-bookmark\">Exchange(Int64,Int64)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Interlocked_Exchange_System_IntPtr__System_IntPtr_\" data-linktype=\"self-bookmark\">Exchange(IntPtr,IntPtr)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Interlocked_Exchange_System_Object__System_Object_\" data-linktype=\"self-bookmark\">Exchange(Object,Object)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets an object to a specified value and returns a reference to the original object, as an atomic operation.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Interlocked_Exchange_System_Single__System_Single_\" data-linktype=\"self-bookmark\">Exchange(Single,Single)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Interlocked_Exchange__1___0____0_\" data-linktype=\"self-bookmark\">Exchange&lt;T&gt;(T,T)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets a variable of the specified type <code>T</code> to a specified value and returns the original value, as an atomic operation.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Interlocked_Increment_System_Int32__\" data-linktype=\"self-bookmark\">Increment(Int32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Increments a specified variable and stores the result, as an atomic operation.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Interlocked_Increment_System_Int64__\" data-linktype=\"self-bookmark\">Increment(Int64)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Increments a specified variable and stores the result, as an atomic operation.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Interlocked_MemoryBarrier\" data-linktype=\"self-bookmark\">MemoryBarrier()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to MemoryBarrier execute after memory accesses that follow the call to MemoryBarrier.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Interlocked_Read_System_Int64__\" data-linktype=\"self-bookmark\">Read(Int64)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns a 64-bit value, loaded as an atomic operation.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"methods\">\r\n        <h2>Methods\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Interlocked_Add_System_Int32__System_Int32_\">\r\n    \r\n            <a id=\"System_Threading_Interlocked_Add_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Add(Int32,Int32)</div>        \r\n          </div>\r\n    \r\n            <p>Adds two 32-bit integers and replaces the first integer with the sum, as an atomic operation.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static int Add (ref int location1, int value);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>location1</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A variable containing the first value to be added. The sum of the two values is stored in <code>location1</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>value</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The value to be added to the integer at <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </div>\r\n                  <p>The new value stored at <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a></div>\r\n                  </div>\r\n                  <p>The address of <code>location1</code> is a null pointer.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method handles an overflow condition by wrapping: if the value at <code>location1</code> is <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">System.Int32</a> and <code>value</code> is 1, the result is <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">System.Int32</a>; if <code>value</code> is 2, the result is (<a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">System.Int32</a> + 1); and so on. No exception is thrown.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Interlocked_Add_System_Int64__System_Int64_\">\r\n    \r\n            <a id=\"System_Threading_Interlocked_Add_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Add(Int64,Int64)</div>        \r\n          </div>\r\n    \r\n            <p>Adds two 64-bit integers and replaces the first integer with the sum, as an atomic operation.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static long Add (ref long location1, long value);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>location1</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A variable containing the first value to be added. The sum of the two values is stored in <code>location1</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>value</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The value to be added to the integer at <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a></div>\r\n                  </div>\r\n                  <p>The new value stored at <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a></div>\r\n                  </div>\r\n                  <p>The address of <code>location1</code> is a null pointer.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method handles an overflow condition by wrapping: if the value at <code>location1</code> is <a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">System.Int64</a> and <code>value</code> is 1, the result is <a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">System.Int64</a>; if <code>value</code> is 2, the result is (<a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">System.Int64</a> + 1); and so on. No exception is thrown.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_Read_\" data-linktype=\"relative-path\">Read</a> method and the 64-bit overloads of the <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_Increment_\" data-linktype=\"relative-path\">Increment</a>, <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_Decrement_\" data-linktype=\"relative-path\">Decrement</a>, and <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_Add_\" data-linktype=\"relative-path\">Add</a> methods are truly atomic only on systems where a <a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">System.IntPtr</a> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <a class=\"xref\" href=\"system.threading.interlocked\" data-linktype=\"relative-path\">Interlocked</a> class.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Interlocked_CompareExchange_System_Double__System_Double_System_Double_\">\r\n    \r\n            <a id=\"System_Threading_Interlocked_CompareExchange_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">CompareExchange(Double,Double,Double)</div>        \r\n          </div>\r\n    \r\n            <p>Compares two double-precision floating point numbers for equality and, if they are equal, replaces the first value.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static double CompareExchange (ref double location1, double value, double comparand);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>location1</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.double\" data-linktype=\"relative-path\">Double</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The destination, whose value is compared with <code>comparand</code> and possibly replaced.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>value</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.double\" data-linktype=\"relative-path\">Double</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The value that replaces the destination value if the comparison results in equality.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>comparand</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.double\" data-linktype=\"relative-path\">Double</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The value that is compared to the value at <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.double\" data-linktype=\"relative-path\">Double</a></div>\r\n                  </div>\r\n                  <p>The original value in <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a></div>\r\n                  </div>\r\n                  <p>The address of <code>location1</code> is a null pointer.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If <code>comparand</code> and the value in <code>location1</code> are equal, then <code>value</code> is stored in <code>location1</code>. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_CompareExchange_\" data-linktype=\"relative-path\">CompareExchange</a> is the original value in <code>location1</code>, whether or not the exchange takes place.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates a thread-safe method that accumulates a running total of <a class=\"xref\" href=\"system.double\" data-linktype=\"relative-path\">Double</a> values. Two threads add a series of <a class=\"xref\" href=\"system.double\" data-linktype=\"relative-path\">Double</a> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared. On a dual-processor computer, there is a significant difference in the totals.  </p>\n<p> In the thread-safe method, the initial value of the running total is saved, and then the CompareExchange method is used to exchange the newly computed total with the old total. If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime. In that case, the attempt to update the running total must be repeated.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Threading.Interlocked CompareExchange Double#1\">&#39; This example demonstrates a thread-safe method that adds to a\n&#39; running total.  \nImports System.Threading\n\nPublic Class ThreadSafe\n    &#39; Field totalValue contains a running total that can be updated\n    &#39; by multiple threads. It must be protected from unsynchronized \n    &#39; access.\n    Private totalValue As Double = 0.0\n\n    &#39; The Total property returns the running total.\n    Public ReadOnly Property Total As Double\n        Get\n            Return totalValue\n        End Get\n    End Property\n\n    &#39; AddToTotal safely adds a value to the running total.\n    Public Function AddToTotal(ByVal addend As Double) As Double\n        Dim initialValue, computedValue As Double\n        Do\n            &#39; Save the current running total in a local variable.\n            initialValue = totalValue\n\n            &#39; Add the new value to the running total.\n            computedValue = initialValue + addend\n\n            &#39; CompareExchange compares totalValue to initialValue. If\n            &#39; they are not equal, then another thread has updated the\n            &#39; running total since this loop started. CompareExchange\n            &#39; does not update totalValue. CompareExchange returns the\n            &#39; contents of totalValue, which do not equal initialValue,\n            &#39; so the loop executes again.\n        Loop While initialValue &lt;&gt; Interlocked.CompareExchange( _\n            totalValue, computedValue, initialValue)\n        &#39; If no other thread updated the running total, then \n        &#39; totalValue and initialValue are equal when CompareExchange\n        &#39; compares them, and computedValue is stored in totalValue.\n        &#39; CompareExchange returns the value that was in totalValue\n        &#39; before the update, which is equal to initialValue, so the \n        &#39; loop ends.\n\n        &#39; The function returns computedValue, not totalValue, because\n        &#39; totalValue could be changed by another thread between\n        &#39; the time the loop ends and the function returns.\n        Return computedValue\n    End Function\nEnd Class\n\nPublic Class Test\n    &#39; Create an instance of the ThreadSafe class to test.\n    Private Shared ts As New ThreadSafe()\n    Private Shared control As Double\n\n    Private Shared r As New Random()\n    Private Shared mre As New ManualResetEvent(false)\n\n    &lt;MTAThread&gt; _\n    Public Shared Sub Main()\n        &#39; Create two threads, name them, and start them. The\n        &#39; threads will block on mre.\n        Dim t1 As New Thread(AddressOf TestThread)\n        t1.Name = &quot;Thread 1&quot;\n        t1.Start()\n        Dim t2 As New Thread(AddressOf TestThread)\n        t2.Name = &quot;Thread 2&quot;\n        t2.Start()\n\n        &#39; Now let the threads begin adding random numbers to \n        &#39; the total.\n        mre.Set()\n        \n        &#39; Wait until all the threads are done.\n        t1.Join()\n        t2.Join()\n\n        Console.WriteLine(&quot;Thread safe: {0}  Ordinary Double: {1}&quot;, ts.Total, control)\n    End Sub\n\n    Private Shared Sub TestThread()\n        &#39; Wait until the signal.\n        mre.WaitOne()\n\n        For i As Integer = 1 to 1000000\n            &#39; Add to the running total in the ThreadSafe instance, and\n            &#39; to an ordinary double.\n            &#39;\n            Dim testValue As Double = r.NextDouble\n            control += testValue\n            ts.AddToTotal(testValue)\n        Next\n    End Sub\nEnd Class\n\n&#39; On a dual-processor computer, this code example produces output \n&#39; similar to the following:\n&#39;\n&#39;Thread safe: 998068.049623744  Ordinary Double: 759775.417190589\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.Interlocked CompareExchange Double#1\">// This example demonstrates a thread-safe method that adds to a\n// running total.  \nusing System;\nusing System.Threading;\n\npublic class ThreadSafe\n{\n    // Field totalValue contains a running total that can be updated\n    // by multiple threads. It must be protected from unsynchronized \n    // access.\n    private double totalValue = 0.0;\n\n    // The Total property returns the running total.\n    public double Total { get { return totalValue; }}\n\n    // AddToTotal safely adds a value to the running total.\n    public double AddToTotal(double addend)\n    {\n        double initialValue, computedValue;\n        do\n        {\n            // Save the current running total in a local variable.\n            initialValue = totalValue;\n\n            // Add the new value to the running total.\n            computedValue = initialValue + addend;\n\n            // CompareExchange compares totalValue to initialValue. If\n            // they are not equal, then another thread has updated the\n            // running total since this loop started. CompareExchange\n            // does not update totalValue. CompareExchange returns the\n            // contents of totalValue, which do not equal initialValue,\n            // so the loop executes again.\n        }\n        while (initialValue != Interlocked.CompareExchange(ref totalValue, \n            computedValue, initialValue));\n        // If no other thread updated the running total, then \n        // totalValue and initialValue are equal when CompareExchange\n        // compares them, and computedValue is stored in totalValue.\n        // CompareExchange returns the value that was in totalValue\n        // before the update, which is equal to initialValue, so the \n        // loop ends.\n\n        // The function returns computedValue, not totalValue, because\n        // totalValue could be changed by another thread between\n        // the time the loop ends and the function returns.\n        return computedValue;\n    }\n}\n\npublic class Test\n{\n    // Create an instance of the ThreadSafe class to test.\n    private static ThreadSafe ts = new ThreadSafe();\n    private static double control;\n\n    private static Random r = new Random();\n    private static ManualResetEvent mre = new ManualResetEvent(false);\n\n    public static void Main()\n    {\n        // Create two threads, name them, and start them. The\n        // thread will block on mre.\n        Thread t1 = new Thread(TestThread);\n        t1.Name = &quot;Thread 1&quot;;\n        t1.Start();\n        Thread t2 = new Thread(TestThread);\n        t2.Name = &quot;Thread 2&quot;;\n        t2.Start();\n\n        // Now let the threads begin adding random numbers to \n        // the total.\n        mre.Set();\n        \n        // Wait until all the threads are done.\n        t1.Join();\n        t2.Join();\n\n        Console.WriteLine(&quot;Thread safe: {0}  Ordinary Double: {1}&quot;, \n            ts.Total, control);\n    }\n\n    private static void TestThread()\n    {\n        // Wait until the signal.\n        mre.WaitOne();\n\n        for(int i = 1; i &lt;= 1000000; i++)\n        {\n            // Add to the running total in the ThreadSafe instance, and\n            // to an ordinary double.\n            //\n            double testValue = r.NextDouble();\n            control += testValue;\n            ts.AddToTotal(testValue);\n        }\n    }\n}\n\n/* On a dual-processor computer, this code example produces output \n   similar to the following:\n\nThread safe: 998068.049623744  Ordinary Double: 759775.417190589\n */\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Interlocked_CompareExchange_System_Int32__System_Int32_System_Int32_\">\r\n    \r\n            <a id=\"System_Threading_Interlocked_CompareExchange_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">CompareExchange(Int32,Int32,Int32)</div>        \r\n          </div>\r\n    \r\n            <p>Compares two 32-bit signed integers for equality and, if they are equal, replaces the first value.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static int CompareExchange (ref int location1, int value, int comparand);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>location1</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The destination, whose value is compared with <code>comparand</code> and possibly replaced.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>value</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The value that replaces the destination value if the comparison results in equality.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>comparand</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The value that is compared to the value at <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </div>\r\n                  <p>The original value in <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a></div>\r\n                  </div>\r\n                  <p>The address of <code>location1</code> is a null pointer.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If <code>comparand</code> and the value in <code>location1</code> are equal, then <code>value</code> is stored in <code>location1</code>. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_CompareExchange_\" data-linktype=\"relative-path\">CompareExchange</a> is the original value in <code>location1</code>, whether or not the exchange takes place.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates a thread-safe method that accumulates a running total. The initial value of the running total is saved, and then the CompareExchange method is used to exchange the newly computed total with the old total. If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime. In that case, the attempt to update the running total must be repeated.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_Add_\" data-linktype=\"relative-path\">Add</a> method, introduced in version 2.0 of the .NET Framework, provides a more convenient way to accumulate thread-safe running totals for integers.  </p>\n</div>\n<pre><code class=\"lang-vb\" name=\"System.Threading.Interlocked CompareExchange0#1\">&#39; This example demonstrates a thread-safe method that adds to a\n&#39; running total.  It cannot be run directly.  You can compile it\n&#39; as a library, or add the class to a project.\nImports System.Threading\n\nPublic Class ThreadSafe\n    &#39; Field totalValue contains a running total that can be updated\n    &#39; by multiple threads. It must be protected from unsynchronized \n    &#39; access.\n    Private totalValue As Integer = 0\n\n    &#39; The Total property returns the running total.\n    Public ReadOnly Property Total As Integer\n        Get\n            Return totalValue\n        End Get\n    End Property\n\n    &#39; AddToTotal safely adds a value to the running total.\n    Public Function AddToTotal(ByVal addend As Integer) As Integer\n        Dim initialValue, computedValue As Integer\n        Do\n            &#39; Save the current running total in a local variable.\n            initialValue = totalValue\n\n            &#39; Add the new value to the running total.\n            computedValue = initialValue + addend\n\n            &#39; CompareExchange compares totalValue to initialValue. If\n            &#39; they are not equal, then another thread has updated the\n            &#39; running total since this loop started. CompareExchange\n            &#39; does not update totalValue. CompareExchange returns the\n            &#39; contents of totalValue, which do not equal initialValue,\n            &#39; so the loop executes again.\n        Loop While initialValue &lt;&gt; Interlocked.CompareExchange( _\n            totalValue, computedValue, initialValue)\n        &#39; If no other thread updated the running total, then \n        &#39; totalValue and initialValue are equal when CompareExchange\n        &#39; compares them, and computedValue is stored in totalValue.\n        &#39; CompareExchange returns the value that was in totalValue\n        &#39; before the update, which is equal to initialValue, so the \n        &#39; loop ends.\n\n        &#39; The function returns computedValue, not totalValue, because\n        &#39; totalValue could be changed by another thread between\n        &#39; the time the loop ends and the function returns.\n        Return computedValue\n    End Function\nEnd Class\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.Interlocked CompareExchange0#1\">// This example demonstrates a thread-safe method that adds to a\n// running total.  It cannot be run directly.  You can compile it\n// as a library, or add the class to a project.\n#using &lt;system.dll&gt;\n\nusing namespace System::Threading;\npublic ref class ThreadSafe\n{\nprivate:\n\n   // totalValue contains a running total that can be updated\n   // by multiple threads. It must be protected from unsynchronized \n   // access.\n   int totalValue;\n\npublic:\n\n   property int Total \n   {\n\n      // The Total property returns the running total.\n      int get()\n      {\n         return totalValue;\n      }\n\n   }\n\n   // AddToTotal safely adds a value to the running total.\n   int AddToTotal( int addend )\n   {\n      int initialValue;\n      int computedValue;\n      do\n      {\n         \n         // Save the current running total in a local variable.\n         initialValue = totalValue;\n         \n         // Add the new value to the running total.\n         computedValue = initialValue + addend;\n         \n         // CompareExchange compares totalValue to initialValue. If\n         // they are not equal, then another thread has updated the\n         // running total since this loop started. CompareExchange\n         // does not update totalValue. CompareExchange returns the\n         // contents of totalValue, which do not equal initialValue,\n         // so the loop executes again.\n      }\n      while ( initialValue != Interlocked::CompareExchange( totalValue, computedValue, initialValue ) );\n\n      \n      // If no other thread updated the running total, then \n      // totalValue and initialValue are equal when CompareExchange\n      // compares them, and computedValue is stored in totalValue.\n      // CompareExchange returns the value that was in totalValue\n      // before the update, which is equal to initialValue, so the \n      // loop ends.\n      // The function returns computedValue, not totalValue, because\n      // totalValue could be changed by another thread between\n      // the time the loop ends and the function returns.\n      return computedValue;\n   }\n\n};\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.Interlocked CompareExchange0#1\">// This example demonstrates a thread-safe method that adds to a\n// running total.  It cannot be run directly.  You can compile it\n// as a library, or add the class to a project.\nusing System.Threading;\n\npublic class ThreadSafe {\n    // totalValue contains a running total that can be updated\n    // by multiple threads. It must be protected from unsynchronized \n    // access.\n    private int totalValue = 0;\n\n    // The Total property returns the running total.\n    public int Total {\n        get { return totalValue; }\n    }\n\n    // AddToTotal safely adds a value to the running total.\n    public int AddToTotal(int addend) {\n        int initialValue, computedValue;\n        do {\n            // Save the current running total in a local variable.\n            initialValue = totalValue;\n\n            // Add the new value to the running total.\n            computedValue = initialValue + addend;\n\n            // CompareExchange compares totalValue to initialValue. If\n            // they are not equal, then another thread has updated the\n            // running total since this loop started. CompareExchange\n            // does not update totalValue. CompareExchange returns the\n            // contents of totalValue, which do not equal initialValue,\n            // so the loop executes again.\n        } while (initialValue != Interlocked.CompareExchange(\n            ref totalValue, computedValue, initialValue));\n        // If no other thread updated the running total, then \n        // totalValue and initialValue are equal when CompareExchange\n        // compares them, and computedValue is stored in totalValue.\n        // CompareExchange returns the value that was in totalValue\n        // before the update, which is equal to initialValue, so the \n        // loop ends.\n\n        // The function returns computedValue, not totalValue, because\n        // totalValue could be changed by another thread between\n        // the time the loop ends and the function returns.\n        return computedValue;\n    }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Interlocked_CompareExchange_System_Int64__System_Int64_System_Int64_\">\r\n    \r\n            <a id=\"System_Threading_Interlocked_CompareExchange_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">CompareExchange(Int64,Int64,Int64)</div>        \r\n          </div>\r\n    \r\n            <p>Compares two 64-bit signed integers for equality and, if they are equal, replaces the first value.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static long CompareExchange (ref long location1, long value, long comparand);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>location1</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The destination, whose value is compared with <code>comparand</code> and possibly replaced.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>value</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The value that replaces the destination value if the comparison results in equality.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>comparand</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The value that is compared to the value at <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a></div>\r\n                  </div>\r\n                  <p>The original value in <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a></div>\r\n                  </div>\r\n                  <p>The address of <code>location1</code> is a null pointer.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If <code>comparand</code> and the value in <code>location1</code> are equal, then <code>value</code> is stored in <code>location1</code>. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_CompareExchange_\" data-linktype=\"relative-path\">CompareExchange</a> is the original value in <code>location1</code>, whether or not the exchange takes place.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Interlocked_CompareExchange_System_IntPtr__System_IntPtr_System_IntPtr_\">\r\n    \r\n            <a id=\"System_Threading_Interlocked_CompareExchange_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">CompareExchange(IntPtr,IntPtr,IntPtr)</div>        \r\n          </div>\r\n    \r\n            <p>Compares two platform-specific handles or pointers for equality and, if they are equal, replaces the first one.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static IntPtr CompareExchange (ref IntPtr location1, IntPtr value, IntPtr comparand);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>location1</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The destination <a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a>, whose value is compared with the value of <code>comparand</code> and possibly replaced by <code>value</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>value</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a> that replaces the destination value if the comparison results in equality.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>comparand</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a> that is compared to the value at <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </div>\r\n                  <p>The original value in <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a></div>\r\n                  </div>\r\n                  <p>The address of <code>location1</code> is a null pointer.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If <code>comparand</code> and the value in <code>location1</code> are equal, then <code>value</code> is stored in <code>location1</code>. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of this method is the original value in <code>location1</code>, whether or not the exchange takes place.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> <a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a> is a platform-specific type.</p>\n</div>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Interlocked_CompareExchange_System_Object__System_Object_System_Object_\">\r\n    \r\n            <a id=\"System_Threading_Interlocked_CompareExchange_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">CompareExchange(Object,Object,Object)</div>        \r\n          </div>\r\n    \r\n            <p>Compares two objects for reference equality and, if they are equal, replaces the first object.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static object CompareExchange (ref object location1, object value, object comparand);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>location1</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The destination object that is compared with <code>comparand</code> and possibly replaced.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>value</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object that replaces the destination object if the comparison results in equality.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>comparand</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object that is compared to the object at <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a></div>\r\n                  </div>\r\n                  <p>The original value in <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p>The address of <code>location1</code> is a null pointer.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If <code>comparand</code> and the object in <code>location1</code> are equal, then <code>value</code> is stored in <code>location1</code>. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_CompareExchange_\" data-linktype=\"relative-path\">CompareExchange</a> is the original value in <code>location1</code>, whether or not the exchange takes place.  </p>\n<p> Beginning with .NET Framework version 2.0, the <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_CompareExchange__1___0____0___0_\" data-linktype=\"relative-path\">CompareExchange&lt;T&gt;(T,T,T)</a> method overload provides a type-safe alternative for reference types.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The objects are compared for reference equality, rather than <a class=\"xref\" href=\"system.object#System_Object_Equals_\" data-linktype=\"relative-path\">Equals</a>. As a result, two boxed instances of the same value type (for example, the integer 3) always appear to be unequal, and no operation is performed. Do not use this overload with value types.</p>\n</div>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Interlocked_CompareExchange_System_Single__System_Single_System_Single_\">\r\n    \r\n            <a id=\"System_Threading_Interlocked_CompareExchange_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">CompareExchange(Single,Single,Single)</div>        \r\n          </div>\r\n    \r\n            <p>Compares two single-precision floating point numbers for equality and, if they are equal, replaces the first value.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static float CompareExchange (ref float location1, float value, float comparand);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>location1</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.single\" data-linktype=\"relative-path\">Single</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The destination, whose value is compared with <code>comparand</code> and possibly replaced.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>value</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.single\" data-linktype=\"relative-path\">Single</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The value that replaces the destination value if the comparison results in equality.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>comparand</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.single\" data-linktype=\"relative-path\">Single</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The value that is compared to the value at <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.single\" data-linktype=\"relative-path\">Single</a></div>\r\n                  </div>\r\n                  <p>The original value in <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a></div>\r\n                  </div>\r\n                  <p>The address of <code>location1</code> is a null pointer.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If <code>comparand</code> and the value in <code>location1</code> are equal, then <code>value</code> is stored in <code>location1</code>. Otherwise, no operation is performed. The compare and exchange operations are performed as an atomic operation. The return value of <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_CompareExchange_\" data-linktype=\"relative-path\">CompareExchange</a> is the original value in <code>location1</code>, whether or not the exchange takes place.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates a thread-safe method that accumulates a running total of <a class=\"xref\" href=\"system.single\" data-linktype=\"relative-path\">Single</a> values. Two threads add a series of <a class=\"xref\" href=\"system.single\" data-linktype=\"relative-path\">Single</a> values using the thread-safe method and ordinary addition, and when the threads complete the totals are compared. On a dual-processor computer, there is a significant difference in the totals.  </p>\n<p> In the thread-safe method, the initial value of the running total is saved, and then the CompareExchange method is used to exchange the newly computed total with the old total. If the return value is not equal to the saved value of the running total, then another thread has updated the total in the meantime. In that case, the attempt to update the running total must be repeated.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.Interlocked CompareExchange Single#1\">// This example demonstrates a thread-safe method that adds to a\n// running total.  \nusing System;\nusing System.Threading;\n\npublic class ThreadSafe\n{\n    // Field totalValue contains a running total that can be updated\n    // by multiple threads. It must be protected from unsynchronized \n    // access.\n    private float totalValue = 0.0F;\n\n    // The Total property returns the running total.\n    public float Total { get { return totalValue; }}\n\n    // AddToTotal safely adds a value to the running total.\n    public float AddToTotal(float addend)\n    {\n        float initialValue, computedValue;\n        do\n        {\n            // Save the current running total in a local variable.\n            initialValue = totalValue;\n\n            // Add the new value to the running total.\n            computedValue = initialValue + addend;\n\n            // CompareExchange compares totalValue to initialValue. If\n            // they are not equal, then another thread has updated the\n            // running total since this loop started. CompareExchange\n            // does not update totalValue. CompareExchange returns the\n            // contents of totalValue, which do not equal initialValue,\n            // so the loop executes again.\n        }\n        while (initialValue != Interlocked.CompareExchange(ref totalValue, \n            computedValue, initialValue));\n        // If no other thread updated the running total, then \n        // totalValue and initialValue are equal when CompareExchange\n        // compares them, and computedValue is stored in totalValue.\n        // CompareExchange returns the value that was in totalValue\n        // before the update, which is equal to initialValue, so the \n        // loop ends.\n\n        // The function returns computedValue, not totalValue, because\n        // totalValue could be changed by another thread between\n        // the time the loop ends and the function returns.\n        return computedValue;\n    }\n}\n\npublic class Test\n{\n    // Create an instance of the ThreadSafe class to test.\n    private static ThreadSafe ts = new ThreadSafe();\n    private static float control;\n\n    private static Random r = new Random();\n    private static ManualResetEvent mre = new ManualResetEvent(false);\n\n    public static void Main()\n    {\n        // Create two threads, name them, and start them. The\n        // thread will block on mre.\n        Thread t1 = new Thread(TestThread);\n        t1.Name = &quot;Thread 1&quot;;\n        t1.Start();\n        Thread t2 = new Thread(TestThread);\n        t2.Name = &quot;Thread 2&quot;;\n        t2.Start();\n\n        // Now let the threads begin adding random numbers to \n        // the total.\n        mre.Set();\n        \n        // Wait until all the threads are done.\n        t1.Join();\n        t2.Join();\n\n        Console.WriteLine(&quot;Thread safe: {0}  Ordinary float: {1}&quot;, \n            ts.Total, control);\n    }\n\n    private static void TestThread()\n    {\n        // Wait until the signal.\n        mre.WaitOne();\n\n        for(int i = 1; i &lt;= 1000000; i++)\n        {\n            // Add to the running total in the ThreadSafe instance, and\n            // to an ordinary float.\n            //\n            float testValue = (float) r.NextDouble();\n            control += testValue;\n            ts.AddToTotal(testValue);\n        }\n    }\n}\n\n/* On a dual-processor computer, this code example produces output \n   similar to the following:\n\nThread safe: 17039.57  Ordinary float: 15706.44\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Interlocked CompareExchange Single#1\">&#39; This example demonstrates a thread-safe method that adds to a\n&#39; running total.  \nImports System.Threading\n\nPublic Class ThreadSafe\n    &#39; Field totalValue contains a running total that can be updated\n    &#39; by multiple threads. It must be protected from unsynchronized \n    &#39; access.\n    Private totalValue As Single = 0.0\n\n    &#39; The Total property returns the running total.\n    Public ReadOnly Property Total As Single\n        Get\n            Return totalValue\n        End Get\n    End Property\n\n    &#39; AddToTotal safely adds a value to the running total.\n    Public Function AddToTotal(ByVal addend As Single) As Single\n        Dim initialValue, computedValue As Single\n        Do\n            &#39; Save the current running total in a local variable.\n            initialValue = totalValue\n\n            &#39; Add the new value to the running total.\n            computedValue = initialValue + addend\n\n            &#39; CompareExchange compares totalValue to initialValue. If\n            &#39; they are not equal, then another thread has updated the\n            &#39; running total since this loop started. CompareExchange\n            &#39; does not update totalValue. CompareExchange returns the\n            &#39; contents of totalValue, which do not equal initialValue,\n            &#39; so the loop executes again.\n        Loop While initialValue &lt;&gt; Interlocked.CompareExchange( _\n            totalValue, computedValue, initialValue)\n        &#39; If no other thread updated the running total, then \n        &#39; totalValue and initialValue are equal when CompareExchange\n        &#39; compares them, and computedValue is stored in totalValue.\n        &#39; CompareExchange returns the value that was in totalValue\n        &#39; before the update, which is equal to initialValue, so the \n        &#39; loop ends.\n\n        &#39; The function returns computedValue, not totalValue, because\n        &#39; totalValue could be changed by another thread between\n        &#39; the time the loop ends and the function returns.\n        Return computedValue\n    End Function\nEnd Class\n\nPublic Class Test\n    &#39; Create an instance of the ThreadSafe class to test.\n    Private Shared ts As New ThreadSafe()\n    Private Shared control As Single\n\n    Private Shared r As New Random()\n    Private Shared mre As New ManualResetEvent(false)\n\n    &lt;MTAThread&gt; _\n    Public Shared Sub Main()\n        &#39; Create two threads, name them, and start them. The\n        &#39; threads will block on mre.\n        Dim t1 As New Thread(AddressOf TestThread)\n        t1.Name = &quot;Thread 1&quot;\n        t1.Start()\n        Dim t2 As New Thread(AddressOf TestThread)\n        t2.Name = &quot;Thread 2&quot;\n        t2.Start()\n\n        &#39; Now let the threads begin adding random numbers to \n        &#39; the total.\n        mre.Set()\n        \n        &#39; Wait until all the threads are done.\n        t1.Join()\n        t2.Join()\n\n        Console.WriteLine(&quot;Thread safe: {0}  Ordinary Single: {1}&quot;, ts.Total, control)\n    End Sub\n\n    Private Shared Sub TestThread()\n        &#39; Wait until the signal.\n        mre.WaitOne()\n\n        For i As Integer = 1 to 1000000\n            &#39; Add to the running total in the ThreadSafe instance, and\n            &#39; to an ordinary Single.\n            &#39;\n            Dim testValue As Single = r.NextDouble()\n            control += testValue\n            ts.AddToTotal(testValue)\n        Next\n    End Sub\nEnd Class\n\n&#39; On a dual-processor computer, this code example produces output \n&#39; similar to the following:\n&#39;\n&#39;Thread safe: 17039.57  Ordinary Single: 15706.44\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Interlocked_CompareExchange__1___0____0___0_\">\r\n    \r\n            <a id=\"System_Threading_Interlocked_CompareExchange_T__\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">CompareExchange&lt;T&gt;(T,T,T)</div>        \r\n          </div>\r\n    \r\n            <p>Compares two instances of the specified reference type <code>T</code> for equality and, if they are equal, replaces the first one.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static T CompareExchange&lt;T&gt; (ref T location1, T value, T comparand) where T : class;</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>location1</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><span class=\"xref\">T</span></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The destination, whose value is compared with <code>comparand</code> and possibly replaced. This is a reference parameter (<code>ref</code> in C#, <code>ByRef</code> in Visual Basic).</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>value</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><span class=\"xref\">T</span></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The value that replaces the destination value if the comparison results in equality.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>comparand</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><span class=\"xref\">T</span></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The value that is compared to the value at <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><span class=\"xref\">T</span></div>\r\n                  </div>\r\n                  <p>The original value in <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a></div>\r\n                  </div>\r\n                  <p>The address of <code>location1</code> is a null pointer.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If <code>comparand</code> and the value in <code>location1</code> are equal, then <code>value</code> is stored in <code>location1</code>. Otherwise, no operation is performed. The comparison and the exchange are performed as an atomic operation. The return value of this method is the original value in <code>location1</code>, whether or not the exchange takes place.  </p>\n<p> This method only supports reference types. There are overloads of the <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_CompareExchange_\" data-linktype=\"relative-path\">CompareExchange</a> method for the value types <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a>, <a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a>, <a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a>, <a class=\"xref\" href=\"system.single\" data-linktype=\"relative-path\">Single</a>, and <a class=\"xref\" href=\"system.double\" data-linktype=\"relative-path\">Double</a>, but there is no support for other value types.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> This method overload is preferable to the <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_CompareExchange_System_Object__System_Object_System_Object_\" data-linktype=\"relative-path\">CompareExchange(Object,Object,Object)</a> method overload, because the latter requires the destination object to be accessed late-bound.</p>\n</div>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Interlocked_Decrement_System_Int32__\">\r\n    \r\n            <a id=\"System_Threading_Interlocked_Decrement_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Decrement(Int32)</div>        \r\n          </div>\r\n    \r\n            <p>Decrements a specified variable and stores the result, as an atomic operation.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static int Decrement (ref int location);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>location</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The variable whose value is to be decremented.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </div>\r\n                  <p>The decremented value.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p>The address of <code>location</code> is a null pointer.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method handles an overflow condition by wrapping: If <code>location</code> = <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">System.Int32</a>, <code>location</code> - 1 = <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">System.Int32</a>. No exception is thrown.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value. To keep track of the number of midpoint values, a variable, <code>midpointCount</code>, is set equal to 1,000 and decremented each time the random number generator returns a midpoint value. Because three threads generate the random numbers, the Decrement method is called to ensure that multiple threads don&#39;t update <code>midpointCount</code> concurrently. Note that a lock is also used to protect the random number generator, and that a <a class=\"xref\" href=\"system.threading.countdownevent\" data-linktype=\"relative-path\">CountdownEvent</a> object is used to ensure that the <code>Main</code> method doesn&#39;t finish execution before the three threads.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.Interlocked.Decrement#1\">using System;\nusing System.Threading;\n\npublic class Example\n{\n   const int LOWERBOUND = 0;\n   const int UPPERBOUND = 1001;\n   \n   static Object lockObj = new Object();\n   static Random rnd = new Random();\n   static CountdownEvent cte;\n   \n   static int totalCount = 0;\n   static int totalMidpoint = 0;\n   static int midpointCount = 10000;\n\n   public static void Main()\n   {\n      cte = new CountdownEvent(1);\n      // Start three threads. \n      for (int ctr = 0; ctr &lt;= 2; ctr++) {\n         cte.AddCount();\n         Thread th = new Thread(GenerateNumbers);\n         th.Name = &quot;Thread&quot; + ctr.ToString();\n         th.Start();\n      }\n      cte.Signal();\n      cte.Wait();\n      Console.WriteLine();\n      Console.WriteLine(&quot;Total midpoint values:  {0,10:N0} ({1:P3})&quot;,\n                        totalMidpoint, totalMidpoint/((double)totalCount));\n      Console.WriteLine(&quot;Total number of values: {0,10:N0}&quot;, \n                        totalCount);                  \n   }\n\n   private static void GenerateNumbers()\n   {\n      int midpoint = (UPPERBOUND - LOWERBOUND) / 2;\n      int value = 0;\n      int total = 0;\n      int midpt = 0;\n      \n      do {\n         lock (lockObj) {\n            value = rnd.Next(LOWERBOUND, UPPERBOUND);\n         }\n         if (value == midpoint) { \n            Interlocked.Decrement(ref midpointCount);\n            midpt++;\n         }\n         total++;    \n      } while (midpointCount &gt; 0);\n      \n      Interlocked.Add(ref totalCount, total);\n      Interlocked.Add(ref totalMidpoint, midpt);\n      \n      string s = String.Format(&quot;Thread {0}:<br>&quot;, Thread.CurrentThread.Name) +\n                 String.Format(&quot;   Random Numbers: {0:N0}<br>&quot;, total) + \n                 String.Format(&quot;   Midpoint values: {0:N0} ({1:P3})&quot;, midpt, \n                               ((double) midpt)/total);\n      Console.WriteLine(s);\n      cte.Signal();\n   }\n}\n// The example displays output like the following:\n//       Thread Thread2:\n//          Random Numbers: 3,204,021\n//          Midpoint values: 3,156 (0.099 %)\n//       Thread Thread0:\n//          Random Numbers: 4,073,592\n//          Midpoint values: 4,015 (0.099 %)\n//       Thread Thread1:\n//          Random Numbers: 2,828,192\n//          Midpoint values: 2,829 (0.100 %)\n//       \n//       Total midpoint values:      10,000 (0.099 %)\n//       Total number of values: 10,105,805\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Interlocked.Decrement#1\">Imports System.Threading\n\nModule Example\n   Const LOWERBOUND As Integer = 0\n   Const UPPERBOUND As Integer = 1001\n   \n   Dim lockObj As New Object()\n   Dim rnd As New Random()\n   Dim cte As CountdownEvent\n   \n   Dim totalCount As Integer = 0\n   Dim totalMidpoint As Integer = 0\n   Dim midpointCount As Integer = 10000\n\n   Public Sub Main()\n      cte = New CountdownEvent(1)\n      &#39; Start three threads. \n      For ctr As Integer = 0 To 2\n         cte.AddCount()\n         Dim th As New Thread(AddressOf GenerateNumbers)\n         th.Name = &quot;Thread&quot; + ctr.ToString()\n         th.Start()\n      Next\n      cte.Signal()\n      cte.Wait()\n      Console.WriteLine()\n      Console.WriteLine(&quot;Total midpoint values:  {0,10:N0} ({1:P3})&quot;,\n                        totalMidpoint, totalMidpoint/totalCount)\n      Console.WriteLine(&quot;Total number of values: {0,10:N0}&quot;, \n                        totalCount)                  \n   End Sub\n   \n   Private Sub GenerateNumbers()\n      Dim midpoint As Integer = (upperBound - lowerBound) \\ 2\n      Dim value As Integer = 0\n      Dim total As Integer = 0\n      Dim midpt As Integer = 0\n      Do\n         SyncLock lockObj\n            value = rnd.Next(lowerBound, upperBound)\n         End SyncLock\n         If value = midpoint Then \n            Interlocked.Decrement(midpointCount)\n            midpt += 1\n         End If\n         total += 1    \n      Loop While midpointCount &gt; 0\n      \n      Interlocked.Add(totalCount, total)\n      Interlocked.Add(totalMidpoint, midpt)\n      \n      Dim s As String = String.Format(&quot;Thread {0}:&quot;, Thread.CurrentThread.Name) + vbCrLf +\n                        String.Format(&quot;   Random Numbers: {0:N0}&quot;, total) + vbCrLf +\n                        String.Format(&quot;   Midpoint values: {0:N0} ({1:P3})&quot;, midpt, midpt/total)\n      Console.WriteLine(s)\n      cte.Signal()\n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;       Thread Thread2:\n&#39;          Random Numbers: 3,204,021\n&#39;          Midpoint values: 3,156 (0.099 %)\n&#39;       Thread Thread0:\n&#39;          Random Numbers: 4,073,592\n&#39;          Midpoint values: 4,015 (0.099 %)\n&#39;       Thread Thread1:\n&#39;          Random Numbers: 2,828,192\n&#39;          Midpoint values: 2,829 (0.100 %)\n&#39;       \n&#39;       Total midpoint values:      10,000 (0.099 %)\n&#39;       Total number of values: 10,105,805\n</code></pre><p> The following example is similar to the previous one, except that it uses the  instead of a thread procedure to generate 50,000 random midpoint integers. In this example, a lambda expression replaces the <code>GenerateNumbers</code> thread procedure, and the call to the <a class=\"xref\" href=\"system.threading.tasks.task#System_Threading_Tasks_Task_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method eliminates the need for the <a class=\"xref\" href=\"system.threading.countdownevent\" data-linktype=\"relative-path\">CountdownEvent</a> object.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.Interlocked.Decrement#2\">using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\n\npublic class Example\n{\n   const int LOWERBOUND = 0;\n   const int UPPERBOUND = 1001;\n   \n   static Object lockObj = new Object();\n   static Random rnd = new Random();\n   \n   static int totalCount = 0;\n   static int totalMidpoint = 0;\n   static int midpointCount = 50000;\n\n   public static void Main()\n   {\n      List&lt;Task&gt; tasks = new List&lt;Task&gt;();\n\n      // Start three tasks. \n      for (int ctr = 0; ctr &lt;= 2; ctr++) \n         tasks.Add(Task.Run( () =&gt; { int midpoint = (UPPERBOUND - LOWERBOUND) / 2;\n                                     int value = 0;\n                                     int total = 0;\n                                     int midpt = 0;\n      \n                                     do {\n                                        lock (lockObj) {\n                                           value = rnd.Next(LOWERBOUND, UPPERBOUND);\n                                        }\n                                        if (value == midpoint) { \n                                           Interlocked.Decrement(ref midpointCount);\n                                           midpt++;\n                                        }\n                                        total++;    \n                                     } while (midpointCount &gt; 0 );\n                                          \n                                     Interlocked.Add(ref totalCount, total);\n                                     Interlocked.Add(ref totalMidpoint, midpt);\n                                          \n                                     string s = String.Format(&quot;Task {0}:<br>&quot;, Task.CurrentId) +\n                                                String.Format(&quot;   Random Numbers: {0:N0}<br>&quot;, total) + \n                                                String.Format(&quot;   Midpoint values: {0:N0} ({1:P3})&quot;, midpt, \n                                                              ((double) midpt)/total);\n                                     Console.WriteLine(s); \n                                   } ));\n\n      Task.WaitAll(tasks.ToArray());\n\n      Console.WriteLine();\n      Console.WriteLine(&quot;Total midpoint values:  {0,10:N0} ({1:P3})&quot;,\n                        totalMidpoint, totalMidpoint/((double)totalCount));\n      Console.WriteLine(&quot;Total number of values: {0,10:N0}&quot;, \n                        totalCount);                  \n   }\n}\n// The example displays output like the following:\n//       Task 1:\n//          Random Numbers: 24,530,624\n//          Midpoint values: 24,675 (0.101 %)\n//       Task 2:\n//          Random Numbers: 7,079,718\n//          Midpoint values: 7,093 (0.100 %)\n//       Task 3:\n//          Random Numbers: 18,284,617\n//          Midpoint values: 18,232 (0.100 %)\n//       \n//       Total midpoint values:      50,000 (0.100 %)\n//       Total number of values: 49,894,959\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Interlocked.Decrement#2\">Imports System.Collections.Generic\nImports System.Threading\nImports System.Threading.Tasks\n\nModule Example\n   Const LOWERBOUND As Integer = 0\n   Const UPPERBOUND As Integer = 1001\n   \n   Dim lockObj As New Object()\n   Dim rnd As New Random()\n   \n   Dim totalCount As Integer = 0\n   Dim totalMidpoint As Integer = 0\n   Dim midpointCount As Integer = 50000\n\n   Public Sub Main()\n      Dim tasks As New List(Of Task)()\n\n      &#39; Start three tasks. \n      For ctr As Integer = 0 To 2\n         tasks.Add( Task.Run(Sub() \n                                Dim midpoint As Integer = (upperBound - lowerBound) \\ 2\n                                Dim value As Integer = 0\n                                Dim total As Integer = 0\n                                Dim midpt As Integer = 0\n                                Do\n                                   SyncLock lockObj\n                                      value = rnd.Next(lowerBound, upperBound)\n                                   End SyncLock\n                                   If value = midpoint Then \n                                      Interlocked.Decrement(midpointCount)\n                                      midpt += 1\n                                   End If\n                                   total += 1    \n                                Loop While midpointCount &gt; 0\n                              \n                                Interlocked.Add(totalCount, total)\n                                Interlocked.Add(totalMidpoint, midpt)\n                              \n                                Dim s As String = String.Format(&quot;Task {0}:&quot;, Task.CurrentId) + vbCrLf +\n                                                  String.Format(&quot;   Random Numbers: {0:N0}&quot;, total) + vbCrLf +\n                                                  String.Format(&quot;   Midpoint values: {0:N0} ({1:P3})&quot;, midpt, midpt/total)\n                                Console.WriteLine(s)\n                             End Sub ))\n      Next\n      Task.WaitAll(tasks.ToArray())\n      Console.WriteLine()\n      Console.WriteLine(&quot;Total midpoint values:  {0,10:N0} ({1:P3})&quot;,\n                        totalMidpoint, totalMidpoint/totalCount)\n      Console.WriteLine(&quot;Total number of values: {0,10:N0}&quot;, \n                        totalCount)                  \n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;       Task 1:\n&#39;          Random Numbers: 24,530,624\n&#39;          Midpoint values: 24,675 (0.101 %)\n&#39;       Task 2:\n&#39;          Random Numbers: 7,079,718\n&#39;          Midpoint values: 7,093 (0.100 %)\n&#39;       Task 3:\n&#39;          Random Numbers: 18,284,617\n&#39;          Midpoint values: 18,232 (0.100 %)\n&#39;       \n&#39;       Total midpoint values:      50,000 (0.100 %)\n&#39;       Total number of values: 49,894,959\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Interlocked_Decrement_System_Int64__\">\r\n    \r\n            <a id=\"System_Threading_Interlocked_Decrement_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Decrement(Int64)</div>        \r\n          </div>\r\n    \r\n            <p>Decrements the specified variable and stores the result, as an atomic operation.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static long Decrement (ref long location);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>location</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The variable whose value is to be decremented.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a></div>\r\n                  </div>\r\n                  <p>The decremented value.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p>The address of <code>location</code> is a null pointer.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method handles an overflow condition by wrapping: if <code>location</code> = <a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">System.Int64</a>, <code>location</code> - 1 = <a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">System.Int64</a>. No exception is thrown.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_Read_\" data-linktype=\"relative-path\">Read</a> method and the 64-bit overloads of the <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_Increment_\" data-linktype=\"relative-path\">Increment</a>, <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_Decrement_\" data-linktype=\"relative-path\">Decrement</a>, and <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_Add_\" data-linktype=\"relative-path\">Add</a> methods are truly atomic only on systems where a <a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">System.IntPtr</a> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <a class=\"xref\" href=\"system.threading.interlocked\" data-linktype=\"relative-path\">Interlocked</a> class.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Interlocked_Exchange_System_Double__System_Double_\">\r\n    \r\n            <a id=\"System_Threading_Interlocked_Exchange_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Exchange(Double,Double)</div>        \r\n          </div>\r\n    \r\n            <p>Sets a double-precision floating point number to a specified value and returns the original value, as an atomic operation.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static double Exchange (ref double location1, double value);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>location1</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.double\" data-linktype=\"relative-path\">Double</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The variable to set to the specified value.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>value</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.double\" data-linktype=\"relative-path\">Double</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The value to which the <code>location1</code> parameter is set.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.double\" data-linktype=\"relative-path\">Double</a></div>\r\n                  </div>\r\n                  <p>The original value of <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a></div>\r\n                  </div>\r\n                  <p>The address of <code>location1</code> is a null pointer.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Interlocked_Exchange_System_Int32__System_Int32_\">\r\n    \r\n            <a id=\"System_Threading_Interlocked_Exchange_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Exchange(Int32,Int32)</div>        \r\n          </div>\r\n    \r\n            <p>Sets a 32-bit signed integer to a specified value and returns the original value, as an atomic operation.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static int Exchange (ref int location1, int value);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>location1</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The variable to set to the specified value.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>value</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The value to which the <code>location1</code> parameter is set.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </div>\r\n                  <p>The original value of <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p>The address of <code>location1</code> is a null pointer.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example shows a thread-safe resource locking mechanism.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Threading.Interlocked.Exchange Int32 Example#1\">using namespace System;\nusing namespace System::Threading;\n\nconst int numThreads = 10;\nconst int numThreadIterations = 5;\nref class MyInterlockedExchangeExampleClass\n{\npublic:\n   static void MyThreadProc()\n   {\n      for ( int i = 0; i &lt; numThreadIterations; i++ )\n      {\n         UseResource();\n         \n         //Wait 1 second before next attempt.\n         Thread::Sleep( 1000 );\n\n      }\n   }\n\n\nprivate:\n   //A simple method that denies reentrancy.\n   static bool UseResource()\n   {\n      \n      //0 indicates that the method is not in use.\n      if ( 0 == Interlocked::Exchange( usingResource, 1 ) )\n      {\n         Console::WriteLine( &quot; {0} acquired the lock&quot;, Thread::CurrentThread-&gt;Name );\n         \n         //Code to access a resource that is not thread safe would go here.\n         //Simulate some work\n         Thread::Sleep( 500 );\n         Console::WriteLine( &quot; {0} exiting lock&quot;, Thread::CurrentThread-&gt;Name );\n         \n         //Release the lock\n         Interlocked::Exchange( usingResource, 0 );\n         return true;\n      }\n      else\n      {\n         Console::WriteLine( &quot; {0} was denied the lock&quot;, Thread::CurrentThread-&gt;Name );\n         return false;\n      }\n   }\n\n\n   //0 for false, 1 for true.\n   static int usingResource;\n};\n\nint main()\n{\n   Thread^ myThread;\n   Random^ rnd = gcnew Random;\n   for ( int i = 0; i &lt; numThreads; i++ )\n   {\n      myThread = gcnew Thread( gcnew ThreadStart( MyInterlockedExchangeExampleClass::MyThreadProc ) );\n      myThread-&gt;Name = String::Format( &quot;Thread {0}&quot;, i + 1 );\n      \n      //Wait a random amount of time before starting next thread.\n      Thread::Sleep( rnd-&gt;Next( 0, 1000 ) );\n      myThread-&gt;Start();\n\n   }\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.Interlocked.Exchange Int32 Example#1\">using System;\nusing System.Threading;\n\nnamespace InterlockedExchange_Example\n{\n    class MyInterlockedExchangeExampleClass\n    {\n        //0 for false, 1 for true.\n        private static int usingResource = 0;\n\n        private const int numThreadIterations = 5;\n        private const int numThreads = 10;\n\n        static void Main()\n        {\n            Thread myThread;\n            Random rnd = new Random();\n\n            for(int i = 0; i &lt; numThreads; i++)\n            {\n                myThread = new Thread(new ThreadStart(MyThreadProc));\n                myThread.Name = String.Format(&quot;Thread{0}&quot;, i + 1);\n            \n                //Wait a random amount of time before starting next thread.\n                Thread.Sleep(rnd.Next(0, 1000));\n                myThread.Start();\n            }\n        }\n\n        private static void MyThreadProc()\n        {\n            for(int i = 0; i &lt; numThreadIterations; i++)\n            {\n                UseResource();\n            \n                //Wait 1 second before next attempt.\n                Thread.Sleep(1000);\n            }\n        }\n\n        //A simple method that denies reentrancy.\n        static bool UseResource()\n        {\n            //0 indicates that the method is not in use.\n            if(0 == Interlocked.Exchange(ref usingResource, 1))\n            {\n                Console.WriteLine(&quot;{0} acquired the lock&quot;, Thread.CurrentThread.Name);\n            \n                //Code to access a resource that is not thread safe would go here.\n            \n                //Simulate some work\n                Thread.Sleep(500);\n\n                Console.WriteLine(&quot;{0} exiting lock&quot;, Thread.CurrentThread.Name);\n            \n                //Release the lock\n                Interlocked.Exchange(ref usingResource, 0);\n                return true;\n            }\n            else\n            {\n                Console.WriteLine(&quot;   {0} was denied the lock&quot;, Thread.CurrentThread.Name);\n                return false;\n            }\n        }\n\n    }\n}  \n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Interlocked.Exchange Int32 Example#1\">Imports System\nImports System.Threading\n\nNamespace InterlockedExchange_Example\n    Class MyInterlockedExchangeExampleClass\n        &#39;0 for false, 1 for true.\n        Private Shared usingResource As Integer = 0\n\n        Private Const numThreadIterations As Integer = 5\n        Private Const numThreads As Integer = 10\n\n        &lt;MTAThread&gt; _\n        Shared Sub Main()\n            Dim myThread As Thread\n            Dim rnd As New Random()\n\n            Dim i As Integer\n            For i = 0 To numThreads - 1\n                myThread = New Thread(AddressOf MyThreadProc)\n                myThread.Name = String.Format(&quot;Thread{0}&quot;, i + 1)\n\n                &#39;Wait a random amount of time before starting next thread.\n                Thread.Sleep(rnd.Next(0, 1000))\n                myThread.Start()\n            Next i\n        End Sub &#39;Main\n\n        Private Shared Sub MyThreadProc()\n            Dim i As Integer\n            For i = 0 To numThreadIterations - 1\n                UseResource()\n\n                &#39;Wait 1 second before next attempt.\n                Thread.Sleep(1000)\n            Next i\n        End Sub \n\n        &#39;A simple method that denies reentrancy.\n        Shared Function UseResource() As Boolean\n            &#39;0 indicates that the method is not in use.\n            If 0 = Interlocked.Exchange(usingResource, 1) Then\n                Console.WriteLine(&quot;{0} acquired the lock&quot;, Thread.CurrentThread.Name)\n\n                &#39;Code to access a resource that is not thread safe would go here.\n                &#39;Simulate some work\n                Thread.Sleep(500)\n\n                Console.WriteLine(&quot;{0} exiting lock&quot;, Thread.CurrentThread.Name)\n\n                &#39;Release the lock\n                Interlocked.Exchange(usingResource, 0)\n                Return True\n            Else\n                Console.WriteLine(&quot;   {0} was denied the lock&quot;, Thread.CurrentThread.Name)\n                Return False\n            End If\n        End Function \n    End Class \nEnd Namespace \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Interlocked_Exchange_System_Int64__System_Int64_\">\r\n    \r\n            <a id=\"System_Threading_Interlocked_Exchange_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Exchange(Int64,Int64)</div>        \r\n          </div>\r\n    \r\n            <p>Sets a 64-bit signed integer to a specified value and returns the original value, as an atomic operation.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static long Exchange (ref long location1, long value);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>location1</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The variable to set to the specified value.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>value</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The value to which the <code>location1</code> parameter is set.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a></div>\r\n                  </div>\r\n                  <p>The original value of <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a></div>\r\n                  </div>\r\n                  <p>The address of <code>location1</code> is a null pointer.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Interlocked_Exchange_System_IntPtr__System_IntPtr_\">\r\n    \r\n            <a id=\"System_Threading_Interlocked_Exchange_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Exchange(IntPtr,IntPtr)</div>        \r\n          </div>\r\n    \r\n            <p>Sets a platform-specific handle or pointer to a specified value and returns the original value, as an atomic operation.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static IntPtr Exchange (ref IntPtr location1, IntPtr value);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>location1</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The variable to set to the specified value.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>value</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The value to which the <code>location1</code> parameter is set.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </div>\r\n                  <p>The original value of <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a></div>\r\n                  </div>\r\n                  <p>The address of <code>location1</code> is a null pointer.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Interlocked_Exchange_System_Object__System_Object_\">\r\n    \r\n            <a id=\"System_Threading_Interlocked_Exchange_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Exchange(Object,Object)</div>        \r\n          </div>\r\n    \r\n            <p>Sets an object to a specified value and returns a reference to the original object, as an atomic operation.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static object Exchange (ref object location1, object value);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>location1</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The variable to set to the specified value.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>value</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The value to which the <code>location1</code> parameter is set.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a></div>\r\n                  </div>\r\n                  <p>The original value of <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p>The address of <code>location1</code> is a null pointer.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Beginning with .NET Framework version 2.0, the <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_Exchange__1___0____0_\" data-linktype=\"relative-path\">Exchange&lt;T&gt;(T,T)</a> method overload provides a type-safe alternative for reference types.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example shows the syntax for using <code>Exchange</code> with any reference type object.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Threading.Interlocked.Exchange#1\">using namespace System;\nusing namespace System::Threading;\nref class AtomicExchange\n{\nprivate:\n   ref class SomeType{};\n\n\n   // To use Interlocked::Exchange, someType1 \n   // must be declared as type Object*.\n   Object^ someType1;\n   SomeType^ someType2;\n\npublic:\n   AtomicExchange()\n   {\n      someType1 = gcnew SomeType;\n      someType2 = gcnew SomeType;\n   }\n\n   void Switch()\n   {\n      someType2 = dynamic_cast&lt;SomeType^&gt;(Interlocked::Exchange( someType1, dynamic_cast&lt;Object^&gt;(someType2) ));\n   }\n\n};\n\nint main()\n{\n   AtomicExchange^ atomicExchange = gcnew AtomicExchange;\n   Thread^ firstThread = gcnew Thread( gcnew ThreadStart( atomicExchange, &amp;AtomicExchange::Switch ) );\n   firstThread-&gt;Start();\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Interlocked.Exchange#1\">Imports System\nImports System.Threading\n\nPublic Class AtomicTest\n\n    &lt;MTAThread&gt; _\n    Shared Sub Main()\n        Dim atomicExchange As New AtomicExchange()\n        Dim firstThread As New Thread(AddressOf atomicExchange.Switch)\n        firstThread.Start()\n    End Sub\n\nEnd Class\n\nPublic Class AtomicExchange\n\n    Public Class SomeType\n    End Class\n\n    &#39; To use Interlocked.Exchange, someType1 \n    &#39; must be declared as type Object.\n    Dim someType1 As Object   \n    Dim someType2 As SomeType \n\n    Sub New() \n        someType1 = New SomeType()\n        someType2 = New SomeType()\n    End Sub\n\n    Sub Switch()\n        someType2 = CType(Interlocked.Exchange( _\n            someType1, CType(someType2, Object)), SomeType)\n    End Sub\n\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.Interlocked.Exchange#1\">using System;\nusing System.Threading;\n\nclass AtomicTest\n{\n    static void Main()\n    {\n        AtomicExchange atomicExchange = new AtomicExchange();\n        Thread firstThread = \n            new Thread(new ThreadStart(atomicExchange.Switch));\n        firstThread.Start();\n    }\n}\n\nclass AtomicExchange\n{\n    class SomeType{}\n\n    // To use Interlocked.Exchange, someType1 \n    // must be declared as type Object.\n    object   someType1;\n    SomeType someType2;\n\n    public AtomicExchange() \n    {\n        someType1 = new SomeType();\n        someType2 = new SomeType();\n    }\n\n    public void Switch()\n    {\n        someType2 = (SomeType)Interlocked.Exchange(\n            ref someType1, (object)someType2);\n    }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Interlocked_Exchange_System_Single__System_Single_\">\r\n    \r\n            <a id=\"System_Threading_Interlocked_Exchange_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Exchange(Single,Single)</div>        \r\n          </div>\r\n    \r\n            <p>Sets a single-precision floating point number to a specified value and returns the original value, as an atomic operation.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static float Exchange (ref float location1, float value);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>location1</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.single\" data-linktype=\"relative-path\">Single</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The variable to set to the specified value.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>value</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.single\" data-linktype=\"relative-path\">Single</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The value to which the <code>location1</code> parameter is set.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.single\" data-linktype=\"relative-path\">Single</a></div>\r\n                  </div>\r\n                  <p>The original value of <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a></div>\r\n                  </div>\r\n                  <p>The address of <code>location1</code> is a null pointer.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Interlocked_Exchange__1___0____0_\">\r\n    \r\n            <a id=\"System_Threading_Interlocked_Exchange_T__\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Exchange&lt;T&gt;(T,T)</div>        \r\n          </div>\r\n    \r\n            <p>Sets a variable of the specified type <code>T</code> to a specified value and returns the original value, as an atomic operation.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static T Exchange&lt;T&gt; (ref T location1, T value) where T : class;</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>location1</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><span class=\"xref\">T</span></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The variable to set to the specified value. This is a reference parameter (<code>ref</code> in C#, <code>ByRef</code> in Visual Basic).</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>value</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><span class=\"xref\">T</span></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The value to which the <code>location1</code> parameter is set.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><span class=\"xref\">T</span></div>\r\n                  </div>\r\n                  <p>The original value of <code>location1</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a></div>\r\n                  </div>\r\n                  <p>The address of <code>location1</code> is a null pointer.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method only supports reference types. There are overloads of the <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_Exchange_\" data-linktype=\"relative-path\">Exchange</a> method for the <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a>, <a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a>, <a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a>, <a class=\"xref\" href=\"system.single\" data-linktype=\"relative-path\">Single</a>, and <a class=\"xref\" href=\"system.double\" data-linktype=\"relative-path\">Double</a> value types, but there is no support for other value types.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> This method overload is preferable to the <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_Exchange_System_Object__System_Object_\" data-linktype=\"relative-path\">Exchange(Object,Object)</a> method overload, because the latter requires late-bound access to the destination object .</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example launches ten tasks, each of which generates  100 ten-character part numbers. It then the part number that is first alphabetically.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.Interlocked.Exchange#2\">using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\n\npublic class Widget\n{\n   public Widget(String id)\n   {\n      this.Id = id;\n   }\n\n   public String Id { get; set; }\n   public String Description { get; set; }\n}\n\n\npublic class Example\n{\n   public static void Main()\n   {\n      Widget firstWidget = null;\n      var tasks = new List&lt;Task&gt;();\n      for (int ctr = 0; ctr &lt;= 10; ctr++) {\n         tasks.Add(Task.Run( () =&gt; { // Give each task its own random number generator.\n                                     var rnd = new Random();\n                                     for (int widgetIndex = 0; widgetIndex &lt;= 100; widgetIndex++) {\n                                        //Generate ten random characters from U+0041 to U+005A.\n                                        String id = String.Empty;\n                                        for (int charCtr = 0; charCtr &lt;= 9; charCtr++)\n                                           id += Convert.ToChar(rnd.Next(0x0041, 0x005B));\n\n                                        var newWidget = new Widget(id);\n                                        if (firstWidget == null)\n                                           firstWidget = newWidget;\n                                        else if (newWidget.Id.CompareTo(firstWidget.Id) &lt; 0)\n                                           Interlocked.Exchange(ref firstWidget, newWidget);\n\n                                     }\n                                   } ));\n      }\n      try {\n         Task.WaitAll(tasks.ToArray());\n         Console.WriteLine(&quot;The widget with the lowest id: {0}&quot;, firstWidget.Id);\n      }\n      catch (AggregateException ae) {\n         foreach (var e in ae.InnerExceptions)\n            Console.WriteLine(&quot;{0}: {1}&quot;, e.GetType().Name, e.Message);\n      }\n   }\n}\n// The example displays output like the following:\n//   The widget with the lowest id: ACHZVFBYNU\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Interlocked.Exchange#2\">Imports System.Collections.Generic\nImports System.Threading\nImports System.Threading.Tasks\n\nPublic Class Widget\n   Public Sub New(id As String)\n      Me.Id = id\n   End Sub\n   \n   Public Property Id As String = String.Empty\n   Public Property Description As String = String.Empty\nEnd Class\n\n\nModule Example\n   Public Sub Main()\n      Dim firstWidget As Widget = Nothing\n      Dim tasks As New List(Of Task)()\n      For ctr As Integer = 0 To 10\n         tasks.Add(Task.Run(Sub()\n                               &#39; Give each task its own random number generator.\n                               Dim rnd As New Random()\n                               For widgetIndex = 0 To 100\n                                  &#39;Generate ten random characters from U+0041 to U+005A.\n                                  Dim id As String = String.Empty\n                                  For charCtr As Integer = 0 To 9\n                                     id += ChrW(rnd.Next(&amp;h0041, &amp;h005B))\n                                  Next\n                                  Dim newWidget As New Widget(id)\n                                  If firstWidget Is Nothing Then\n                                     firstWidget = newWidget\n                                  Else If newWidget.Id &lt; firstWidget.Id Then\n                                     Interlocked.Exchange(firstWidget, newWidget)\n                                  End If\n                                Next\n                             End Sub))\n      Next\n      Try\n         Task.WaitAll(tasks.ToArray())\n         Console.WriteLine(&quot;The widget with the lowest id: {0}&quot;, firstWidget.Id)\n      Catch ae As AggregateException\n         For Each e In ae.InnerExceptions\n            Console.WriteLine(&quot;{0}: {1}&quot;, e.GetType().Name, e.Message)\n         Next\n      End Try\n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;   The widget with the lowest id: ACHZVFBYNU\n</code></pre><p> The example uses the <code>firstWidget</code> variable to store the ID that occurs first in the sort order. It compares each ID that it generates with the <code>firstWidget</code> value.  If the new value precedes the current value of <code>firstWidget</code> in the sort order, the example calls the Exchange(T) method to assign the new value to <code>firstWidget</code>.</p>\n\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Interlocked_Increment_System_Int32__\">\r\n    \r\n            <a id=\"System_Threading_Interlocked_Increment_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Increment(Int32)</div>        \r\n          </div>\r\n    \r\n            <p>Increments a specified variable and stores the result, as an atomic operation.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static int Increment (ref int location);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>location</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The variable whose value is to be incremented.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </div>\r\n                  <p>The incremented value.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a></div>\r\n                  </div>\r\n                  <p>The address of <code>location</code> is a null pointer.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method handles an overflow condition by wrapping: if <code>location</code> = <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">System.Int32</a>, <code>location</code> + 1 = <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">System.Int32</a>. No exception is thrown.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example determines how many random numbers that range from 0 to 1,000 are required to generate 1,000 random numbers with a midpoint value. To keep track of the number of midpoint values, a variable, <code>midpointCount</code>, is set equal to 0 and incremented each time the random number generator returns a midpoint value until it reaches 10,000. Because three threads generate the random numbers, the Increment method is called to ensure that multiple threads don&#39;t update <code>midpointCount</code> concurrently. Note that a lock is also used to protect the random number generator, and that a <a class=\"xref\" href=\"system.threading.countdownevent\" data-linktype=\"relative-path\">CountdownEvent</a> object is used to ensure that the <code>Main</code> method doesn&#39;t finish execution before the three threads.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Threading.Interlocked.Increment2#3\">Imports System.Threading\n\nModule Example\n   Const LOWERBOUND As Integer = 0\n   Const UPPERBOUND As Integer = 1001\n   \n   Dim lockObj As New Object()\n   Dim rnd As New Random()\n   Dim cte As CountdownEvent\n   \n   Dim totalCount As Integer = 0\n   Dim totalMidpoint As Integer = 0\n   Dim midpointCount As Integer = 0\n\n   Public Sub Main()\n      cte = New CountdownEvent(1)\n      &#39; Start three threads. \n      For ctr As Integer = 0 To 2\n         cte.AddCount()\n         Dim th As New Thread(AddressOf GenerateNumbers)\n         th.Name = &quot;Thread&quot; + ctr.ToString()\n         th.Start()\n      Next\n      cte.Signal()\n      cte.Wait()\n      Console.WriteLine()\n      Console.WriteLine(&quot;Total midpoint values:  {0,10:N0} ({1:P3})&quot;,\n                        totalMidpoint, totalMidpoint/totalCount)\n      Console.WriteLine(&quot;Total number of values: {0,10:N0}&quot;, \n                        totalCount)                  \n   End Sub\n   \n   Private Sub GenerateNumbers()\n      Dim midpoint As Integer = (upperBound - lowerBound) \\ 2\n      Dim value As Integer = 0\n      Dim total As Integer = 0\n      Dim midpt As Integer = 0\n      Do\n         SyncLock lockObj\n            value = rnd.Next(lowerBound, upperBound)\n         End SyncLock\n         If value = midpoint Then \n            Interlocked.Increment(midpointCount)\n            midpt += 1\n         End If\n         total += 1    \n      Loop While midpointCount &lt; 10000\n      \n      Interlocked.Add(totalCount, total)\n      Interlocked.Add(totalMidpoint, midpt)\n      \n      Dim s As String = String.Format(&quot;Thread {0}:&quot;, Thread.CurrentThread.Name) + vbCrLf +\n                        String.Format(&quot;   Random Numbers: {0:N0}&quot;, total) + vbCrLf +\n                        String.Format(&quot;   Midpoint values: {0:N0} ({1:P3})&quot;, midpt, midpt/total)\n      Console.WriteLine(s)\n      cte.Signal()\n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;       Thread Thread2:\n&#39;          Random Numbers: 2,776,674\n&#39;          Midpoint values: 2,773 (0.100 %)\n&#39;       Thread Thread1:\n&#39;          Random Numbers: 4,876,100\n&#39;          Midpoint values: 4,873 (0.100 %)\n&#39;       Thread Thread0:\n&#39;          Random Numbers: 2,312,310\n&#39;          Midpoint values: 2,354 (0.102 %)\n&#39;       \n&#39;       Total midpoint values:      10,000 (0.100 %)\n&#39;       Total number of values:  9,965,084\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.Interlocked.Increment2#3\">using System;\nusing System.Threading;\n\npublic class Example\n{\n   const int LOWERBOUND = 0;\n   const int UPPERBOUND = 1001;\n   \n   static Object lockObj = new Object();\n   static Random rnd = new Random();\n   static CountdownEvent cte;\n   \n   static int totalCount = 0;\n   static int totalMidpoint = 0;\n   static int midpointCount = 0;\n\n   public static void Main()\n   {\n      cte = new CountdownEvent(1);\n      // Start three threads. \n      for (int ctr = 0; ctr &lt;= 2; ctr++) {\n         cte.AddCount();\n         Thread th = new Thread(GenerateNumbers);\n         th.Name = &quot;Thread&quot; + ctr.ToString();\n         th.Start();\n      }\n      cte.Signal();\n      cte.Wait();\n      Console.WriteLine();\n      Console.WriteLine(&quot;Total midpoint values:  {0,10:N0} ({1:P3})&quot;,\n                        totalMidpoint, totalMidpoint/((double)totalCount));\n      Console.WriteLine(&quot;Total number of values: {0,10:N0}&quot;, \n                        totalCount);                  \n   }\n\n   private static void GenerateNumbers()\n   {\n      int midpoint = (UPPERBOUND - LOWERBOUND) / 2;\n      int value = 0;\n      int total = 0;\n      int midpt = 0;\n      \n      do {\n         lock (lockObj) {\n            value = rnd.Next(LOWERBOUND, UPPERBOUND);\n         }\n         if (value == midpoint) { \n            Interlocked.Increment(ref midpointCount);\n            midpt++;\n         }\n         total++;    \n      } while (midpointCount &lt; 10000);\n      \n      Interlocked.Add(ref totalCount, total);\n      Interlocked.Add(ref totalMidpoint, midpt);\n      \n      string s = String.Format(&quot;Thread {0}:<br>&quot;, Thread.CurrentThread.Name) +\n                 String.Format(&quot;   Random Numbers: {0:N0}<br>&quot;, total) + \n                 String.Format(&quot;   Midpoint values: {0:N0} ({1:P3})&quot;, midpt, \n                               ((double) midpt)/total);\n      Console.WriteLine(s);\n      cte.Signal();\n   }\n}\n// The example displays output like the following:\n//       Thread Thread2:\n//          Random Numbers: 2,776,674\n//          Midpoint values: 2,773 (0.100 %)\n//       Thread Thread1:\n//          Random Numbers: 4,876,100\n//          Midpoint values: 4,873 (0.100 %)\n//       Thread Thread0:\n//          Random Numbers: 2,312,310\n//          Midpoint values: 2,354 (0.102 %)\n//       \n//       Total midpoint values:      10,000 (0.100 %)\n//       Total number of values:  9,965,084\n</code></pre><p> The following example is similar to the previous one, except that it uses the  instead of a thread procedure to generate 50,000 random midpoint integers. In this example, a lambda expression replaces the <code>GenerateNumbers</code> thread procedure, and the call to the <a class=\"xref\" href=\"system.threading.tasks.task#System_Threading_Tasks_Task_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> method eliminates the need for the <a class=\"xref\" href=\"system.threading.countdownevent\" data-linktype=\"relative-path\">CountdownEvent</a> object.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.Interlocked.Increment2#4\">using System;\nusing System.Collections.Generic;\nusing System.Threading;\nusing System.Threading.Tasks;\n\npublic class Example\n{\n   const int LOWERBOUND = 0;\n   const int UPPERBOUND = 1001;\n   \n   static Object lockObj = new Object();\n   static Random rnd = new Random();\n   \n   static int totalCount = 0;\n   static int totalMidpoint = 0;\n   static int midpointCount = 0;\n\n   public static void Main()\n   {\n      List&lt;Task&gt; tasks = new List&lt;Task&gt;();\n      // Start three tasks. \n      for (int ctr = 0; ctr &lt;= 2; ctr++) \n         tasks.Add(Task.Run( () =&gt; { int midpoint = (UPPERBOUND - LOWERBOUND) / 2;\n                                     int value = 0;\n                                     int total = 0;\n                                     int midpt = 0;\n                                    \n                                     do {\n                                        lock (lockObj) {\n                                           value = rnd.Next(LOWERBOUND, UPPERBOUND);\n                                        }\n                                        if (value == midpoint) { \n                                           Interlocked.Increment(ref midpointCount);\n                                           midpt++;\n                                        }\n                                        total++;    \n                                     } while (midpointCount &lt; 50000);\n                                    \n                                     Interlocked.Add(ref totalCount, total);\n                                     Interlocked.Add(ref totalMidpoint, midpt);\n                                    \n                                     string s = String.Format(&quot;Task {0}:<br>&quot;, Task.CurrentId) +\n                                                String.Format(&quot;   Random Numbers: {0:N0}<br>&quot;, total) + \n                                                String.Format(&quot;   Midpoint values: {0:N0} ({1:P3})&quot;, midpt, \n                                                              ((double) midpt)/total);\n                                     Console.WriteLine(s); } ));\n      \n      Task.WaitAll(tasks.ToArray());\n      Console.WriteLine();\n      Console.WriteLine(&quot;Total midpoint values:  {0,10:N0} ({1:P3})&quot;,\n                        totalMidpoint, totalMidpoint/((double)totalCount));\n      Console.WriteLine(&quot;Total number of values: {0,10:N0}&quot;, \n                        totalCount);                  \n   }\n}\n// The example displays output like the following:\n//       Task 3:\n//          Random Numbers: 10,855,250\n//          Midpoint values: 10,823 (0.100 %)\n//       Task 1:\n//          Random Numbers: 15,243,703\n//          Midpoint values: 15,110 (0.099 %)\n//       Task 2:\n//          Random Numbers: 24,107,425\n//          Midpoint values: 24,067 (0.100 %)\n//       \n//       Total midpoint values:      50,000 (0.100 %)\n//       Total number of values: 50,206,378\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Interlocked.Increment2#4\">Imports System.Collections.Generic\nImports System.Threading\nImports System.Threading.Tasks\n\nModule Example\n   Const LOWERBOUND As Integer = 0\n   Const UPPERBOUND As Integer = 1001\n   \n   Dim lockObj As New Object()\n   Dim rnd As New Random()\n   \n   Dim totalCount As Integer = 0\n   Dim totalMidpoint As Integer = 0\n   Dim midpointCount As Integer = 0\n\n   Public Sub Main()\n      Dim tasks As New List(Of Task)()\n      &#39; Start three tasks. \n      For ctr As Integer = 0 To 2\n         tasks.Add(Task.Run( Sub()\n                                Dim midpoint As Integer = (upperBound - lowerBound) \\ 2\n                                Dim value As Integer = 0\n                                Dim total As Integer = 0\n                                Dim midpt As Integer = 0\n                                Do\n                                   SyncLock lockObj\n                                      value = rnd.Next(lowerBound, upperBound)\n                                   End SyncLock\n                                   If value = midpoint Then \n                                      Interlocked.Increment(midpointCount)\n                                      midpt += 1\n                                   End If\n                                   total += 1    \n                                Loop While midpointCount &lt; 50000\n                              \n                                Interlocked.Add(totalCount, total)\n                                Interlocked.Add(totalMidpoint, midpt)\n                              \n                                Dim s As String = String.Format(&quot;Task {0}:&quot;, Task.CurrentId) + vbCrLf +\n                                                  String.Format(&quot;   Random Numbers: {0:N0}&quot;, total) + vbCrLf +\n                                                  String.Format(&quot;   Midpoint values: {0:N0} ({1:P3})&quot;, midpt, midpt/total)\n                                Console.WriteLine(s)\n                             End Sub ))\n      Next\n\n      Task.WaitAll(tasks.ToArray())\n      Console.WriteLine()\n      Console.WriteLine(&quot;Total midpoint values:  {0,10:N0} ({1:P3})&quot;,\n                        totalMidpoint, totalMidpoint/totalCount)\n      Console.WriteLine(&quot;Total number of values: {0,10:N0}&quot;, \n                        totalCount)                  \n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;       Task 3:\n&#39;          Random Numbers: 10,855,250\n&#39;          Midpoint values: 10,823 (0.100 %)\n&#39;       Task 1:\n&#39;          Random Numbers: 15,243,703\n&#39;          Midpoint values: 15,110 (0.099 %)\n&#39;       Task 2:\n&#39;          Random Numbers: 24,107,425\n&#39;          Midpoint values: 24,067 (0.100 %)\n&#39;       \n&#39;       Total midpoint values:      50,000 (0.100 %)\n&#39;       Total number of values: 50,206,378\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Interlocked_Increment_System_Int64__\">\r\n    \r\n            <a id=\"System_Threading_Interlocked_Increment_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Increment(Int64)</div>        \r\n          </div>\r\n    \r\n            <p>Increments a specified variable and stores the result, as an atomic operation.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static long Increment (ref long location);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>location</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The variable whose value is to be incremented.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a></div>\r\n                  </div>\r\n                  <p>The incremented value.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a></div>\r\n                  </div>\r\n                  <p>The address of <code>location</code> is a null pointer.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method handles an overflow condition by wrapping: if <code>location</code> = <a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">System.Int64</a>, <code>location</code> + 1 = <a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">System.Int64</a>. No exception is thrown.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_Read_\" data-linktype=\"relative-path\">Read</a> method and the 64-bit overloads of the <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_Increment_\" data-linktype=\"relative-path\">Increment</a>, <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_Decrement_\" data-linktype=\"relative-path\">Decrement</a>, and <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_Add_\" data-linktype=\"relative-path\">Add</a> methods are truly atomic only on systems where a <a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">System.IntPtr</a> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <a class=\"xref\" href=\"system.threading.interlocked\" data-linktype=\"relative-path\">Interlocked</a> class.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Interlocked_MemoryBarrier\">\r\n    \r\n            <a id=\"System_Threading_Interlocked_MemoryBarrier_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">MemoryBarrier()</div>        \r\n          </div>\r\n    \r\n            <p>Synchronizes memory access as follows: The processor that executes the current thread cannot reorder instructions in such a way that memory accesses before the call to MemoryBarrier execute after memory accesses that follow the call to MemoryBarrier.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static void MemoryBarrier ();</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method was added to the <a class=\"xref\" href=\"system.threading.interlocked\" data-linktype=\"relative-path\">Interlocked</a> class in the .NET Framework 4.5 as a convenience; it&#39;s a wrapper for the <a class=\"xref\" href=\"system.threading.thread#System_Threading_Thread_MemoryBarrier_\" data-linktype=\"relative-path\">MemoryBarrier</a> method.  </p>\n<p> MemoryBarrier is required only on multiprocessor systems that have weak memory ordering (for example, a system that employs multiple Intel Itanium processors).  </p>\n<p> For most purposes, the C# <code>lock</code> statement, the Visual Basic <code>SyncLock</code> statement, or the <a class=\"xref\" href=\"system.threading.monitor\" data-linktype=\"relative-path\">Monitor</a> class provide easier ways to synchronize data.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Interlocked_Read_System_Int64__\">\r\n    \r\n            <a id=\"System_Threading_Interlocked_Read_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Read(Int64)</div>        \r\n          </div>\r\n    \r\n            <p>Returns a 64-bit value, loaded as an atomic operation.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static long Read (ref long location);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>location</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The 64-bit value to be loaded.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a></div>\r\n                  </div>\r\n                  <p>The loaded value.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The Read method is unnecessary on 64-bit systems, because 64-bit read operations are already atomic. On 32-bit systems, 64-bit read operations are not atomic unless performed using Read.  </p>\n<p> The Read method and the 64-bit overloads of the <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_Increment_\" data-linktype=\"relative-path\">Increment</a>, <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_Decrement_\" data-linktype=\"relative-path\">Decrement</a>, and <a class=\"xref\" href=\"system.threading.interlocked#System_Threading_Interlocked_Add_\" data-linktype=\"relative-path\">Add</a> methods are truly atomic only on systems where a <a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">System.IntPtr</a> is 64 bits long. On other systems, these methods are atomic with respect to each other, but not with respect to other means of accessing the data. Thus, to be thread safe on 32-bit systems, any access to a 64-bit value must be made through the members of the <a class=\"xref\" href=\"system.threading.interlocked\" data-linktype=\"relative-path\">Interlocked</a> class.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> <a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a> is a platform-specific type.</p>\n</div>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n","outputRootRelativePath":"./","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"breadcrumb_path\" content=\"breadcrumb/toc.json\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"fulldocset\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.fulldocset\">\r\n<meta name=\"ref_skeleton_gitcommit\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Threading.Interlocked.yml\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Threading.Interlocked.yml\">\r\n<meta name=\"APIName\" content=\"System.Threading.Interlocked\">\r\n<meta name=\"APIName\" content=\"System.Threading.Interlocked.Add\">\r\n<meta name=\"APIName\" content=\"System.Threading.Interlocked.CompareExchange\">\r\n<meta name=\"APIName\" content=\"System.Threading.Interlocked.CompareExchange&lt;T&gt;\">\r\n<meta name=\"APIName\" content=\"System.Threading.Interlocked.Decrement\">\r\n<meta name=\"APIName\" content=\"System.Threading.Interlocked.Exchange\">\r\n<meta name=\"APIName\" content=\"System.Threading.Interlocked.Exchange&lt;T&gt;\">\r\n<meta name=\"APIName\" content=\"System.Threading.Interlocked.Increment\">\r\n<meta name=\"APIName\" content=\"System.Threading.Interlocked.MemoryBarrier\">\r\n<meta name=\"APIName\" content=\"System.Threading.Interlocked.Read\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-01 01:37 AM\">\r\n<meta name=\"document_id\" content=\"5c112134-1804-a9ec-d085-22fb5aa6fe9c\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Provides atomic operations for variables that are shared by multiple threads.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/System.Threading/toc.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Threading.Interlocked\">\r\n","rawMetadata":{"author":"dotnet-bot","breadcrumb_path":"breadcrumb/toc.json","search.ms_sitename":"Docs","search.ms_docsetname":"fulldocset","version":null,"_op_canonicalUrlPrefix":"https://ppe.docs.microsoft.com/en-us/fulldotnet/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":true,"depot_name":"MSDN.fulldocset","_op_gitRefSkeletonCommitHistory":[{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"use plugin in master","commit_sha":"501959ac03e19ac52a27aa4c6bbeb980f8b11c8c","commit_date":"2017-03-01 09:31:20 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"switch from platform to version","commit_sha":"78cdacb5ca782478af490a6b30c3a2cb2b6b873e","commit_date":"2017-02-28 15:09:51 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"update platforms","commit_sha":"39ad5a8919a59afc93a79ac4bd8e07c3b471b37a","commit_date":"2017-02-28 10:38:59 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"checkin yml","commit_sha":"da161b792852497df7140d7768cee2eccd9cb43f","commit_date":"2017-02-28 09:36:15 +0800"}],"ref_skeleton_gitcommit":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Threading.Interlocked.yml","original_ref_skeleton_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Threading.Interlocked.yml","open_to_public_contributors":true,"api_name":["System.Threading.Interlocked","System.Threading.Interlocked.Add","System.Threading.Interlocked.CompareExchange","System.Threading.Interlocked.CompareExchange<T>","System.Threading.Interlocked.Decrement","System.Threading.Interlocked.Exchange","System.Threading.Interlocked.Exchange<T>","System.Threading.Interlocked.Increment","System.Threading.Interlocked.MemoryBarrier","System.Threading.Interlocked.Read"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Threading.Interlocked","System::Threading::Interlocked","System.Threading.Interlocked.Add","System::Threading::Interlocked::Add","System.Threading.Interlocked.CompareExchange","System::Threading::Interlocked::CompareExchange","System.Threading.Interlocked.CompareExchange``1","System::Threading::Interlocked::CompareExchange``1","System.Threading.Interlocked.Decrement","System::Threading::Interlocked::Decrement","System.Threading.Interlocked.Exchange","System::Threading::Interlocked::Exchange","System.Threading.Interlocked.Exchange``1","System::Threading::Interlocked::Exchange``1","System.Threading.Interlocked.Increment","System::Threading::Interlocked::Increment","System.Threading.Interlocked.MemoryBarrier","System::Threading::Interlocked::MemoryBarrier","System.Threading.Interlocked.Read","System::Threading::Interlocked::Read"],"dev_langs":["csharp"],"updated_at":"2017-03-01 01:37 AM","document_id":"5c112134-1804-a9ec-d085-22fb5aa6fe9c","content_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/xml/System.Threading/Interlocked.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"Interlocked class | Microsoft Docs","_op_ogTitle":"Interlocked class","description":"Provides atomic operations for variables that are shared by multiple threads.\n","toc_asset_id":"_splitted/System.Threading/toc.json","toc_rel":"_splitted/System.Threading/toc.json","source_url":"","ms.assetid":"System.Threading.Interlocked","canonical_url":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.threading.interlocked","_op_canonicalUrl":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.threading.interlocked","fileRelativePath":"System.Threading.Interlocked.html"},"themesRelativePathToOutputRoot":"_themes/"}