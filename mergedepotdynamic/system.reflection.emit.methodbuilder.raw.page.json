{"content":"    \r\n    <h1 id=\"System_Reflection_Emit_MethodBuilder\">\r\n      <span class=\"lang-csharp\">MethodBuilder</span>\r\n        Class\r\n    </h1>\r\n    \r\n    \r\n    <nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n      <h3>In this Article</h3>\r\n    </nav><div class=\"summary\">\r\n    \t<p>Defines and represents a method (or constructor) on a dynamic class.</p>\n\r\n    </div><h2>Syntax</h2>\r\n    \r\n    \t<h3>Declaration</h3>\r\n    \t<pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]\n[System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBuilder))]\n[System.Runtime.InteropServices.ComVisible(true)]\npublic sealed class MethodBuilder : System.Reflection.MethodInfo, System.Runtime.InteropServices._MethodBuilder</code></pre>\r\n    \r\n    \r\n    \r\n    <h3>Inheritance Hierarchy</h3>\r\n    <ul class=\"inheritance\">\r\n        <li class=\"l0\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>\r\n          </div>\r\n        </li>\r\n        <li class=\"l1\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a>\r\n          </div>\r\n        </li>\r\n        <li class=\"l2\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a>\r\n          </div>\r\n        </li>\r\n        <li class=\"l3\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">System.Reflection.MethodInfo</a>\r\n          </div>\r\n        </li>\r\n      <li class=\"l4\">\r\n        <div class=\"xref\">\r\n          <div class=\"lang-csharp\">MethodBuilder</div>\r\n        </div>\r\n      </li>\r\n    </ul>\r\n    \r\n      <div class=\"referencebox inheritedMembers\">\r\n        <h3>Inherited Members</h3>\r\n        <h4></h4>\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_CustomAttributes\" data-linktype=\"relative-path\">CustomAttributes</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_GetCustomAttributesData\" data-linktype=\"relative-path\">GetCustomAttributesData()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_MetadataToken\" data-linktype=\"relative-path\">MetadataToken</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_op_Equality_System_Reflection_MemberInfo_System_Reflection_MemberInfo_\" data-linktype=\"relative-path\">op_Equality(MemberInfo,MemberInfo)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_op_Inequality_System_Reflection_MemberInfo_System_Reflection_MemberInfo_\" data-linktype=\"relative-path\">op_Inequality(MemberInfo,MemberInfo)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_System_Runtime_InteropServices__MemberInfo_GetIDsOfNames_System_Guid__System_IntPtr_System_UInt32_System_UInt32_System_IntPtr_\" data-linktype=\"relative-path\">_MemberInfo.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_System_Runtime_InteropServices__MemberInfo_GetType\" data-linktype=\"relative-path\">_MemberInfo.GetType()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_System_Runtime_InteropServices__MemberInfo_GetTypeInfo_System_UInt32_System_UInt32_System_IntPtr_\" data-linktype=\"relative-path\">_MemberInfo.GetTypeInfo(UInt32,UInt32,IntPtr)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_System_Runtime_InteropServices__MemberInfo_GetTypeInfoCount_System_UInt32__\" data-linktype=\"relative-path\">_MemberInfo.GetTypeInfoCount(UInt32)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_System_Runtime_InteropServices__MemberInfo_Invoke_System_UInt32_System_Guid__System_UInt32_System_Int16_System_IntPtr_System_IntPtr_System_IntPtr_System_IntPtr_\" data-linktype=\"relative-path\">_MemberInfo.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_GetCurrentMethod\" data-linktype=\"relative-path\">GetCurrentMethod()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_GetMethodBody\" data-linktype=\"relative-path\">GetMethodBody()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_GetMethodFromHandle_System_RuntimeMethodHandle_\" data-linktype=\"relative-path\">GetMethodFromHandle(RuntimeMethodHandle)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_GetMethodFromHandle_System_RuntimeMethodHandle_System_RuntimeTypeHandle_\" data-linktype=\"relative-path\">GetMethodFromHandle(RuntimeMethodHandle,RuntimeTypeHandle)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_Invoke_System_Object_System_Object___\" data-linktype=\"relative-path\">Invoke(Object,Object[])</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsAbstract\" data-linktype=\"relative-path\">IsAbstract</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsAssembly\" data-linktype=\"relative-path\">IsAssembly</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsConstructor\" data-linktype=\"relative-path\">IsConstructor</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsFamily\" data-linktype=\"relative-path\">IsFamily</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsFamilyAndAssembly\" data-linktype=\"relative-path\">IsFamilyAndAssembly</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsFamilyOrAssembly\" data-linktype=\"relative-path\">IsFamilyOrAssembly</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsFinal\" data-linktype=\"relative-path\">IsFinal</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsHideBySig\" data-linktype=\"relative-path\">IsHideBySig</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsPrivate\" data-linktype=\"relative-path\">IsPrivate</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsPublic\" data-linktype=\"relative-path\">IsPublic</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsSpecialName\" data-linktype=\"relative-path\">IsSpecialName</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsStatic\" data-linktype=\"relative-path\">IsStatic</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsVirtual\" data-linktype=\"relative-path\">IsVirtual</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_MethodImplementationFlags\" data-linktype=\"relative-path\">MethodImplementationFlags</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_op_Equality_System_Reflection_MethodBase_System_Reflection_MethodBase_\" data-linktype=\"relative-path\">op_Equality(MethodBase,MethodBase)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_op_Inequality_System_Reflection_MethodBase_System_Reflection_MethodBase_\" data-linktype=\"relative-path\">op_Inequality(MethodBase,MethodBase)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_GetIDsOfNames_System_Guid__System_IntPtr_System_UInt32_System_UInt32_System_IntPtr_\" data-linktype=\"relative-path\">_MethodBase.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_GetType\" data-linktype=\"relative-path\">_MethodBase.GetType()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_GetTypeInfo_System_UInt32_System_UInt32_System_IntPtr_\" data-linktype=\"relative-path\">_MethodBase.GetTypeInfo(UInt32,UInt32,IntPtr)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_GetTypeInfoCount_System_UInt32__\" data-linktype=\"relative-path\">_MethodBase.GetTypeInfoCount(UInt32)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_Invoke_System_UInt32_System_Guid__System_UInt32_System_Int16_System_IntPtr_System_IntPtr_System_IntPtr_System_IntPtr_\" data-linktype=\"relative-path\">_MethodBase.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsAbstract\" data-linktype=\"relative-path\">_MethodBase.IsAbstract</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsAssembly\" data-linktype=\"relative-path\">_MethodBase.IsAssembly</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsConstructor\" data-linktype=\"relative-path\">_MethodBase.IsConstructor</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsFamily\" data-linktype=\"relative-path\">_MethodBase.IsFamily</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsFamilyAndAssembly\" data-linktype=\"relative-path\">_MethodBase.IsFamilyAndAssembly</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsFamilyOrAssembly\" data-linktype=\"relative-path\">_MethodBase.IsFamilyOrAssembly</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsFinal\" data-linktype=\"relative-path\">_MethodBase.IsFinal</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsHideBySig\" data-linktype=\"relative-path\">_MethodBase.IsHideBySig</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsPrivate\" data-linktype=\"relative-path\">_MethodBase.IsPrivate</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsPublic\" data-linktype=\"relative-path\">_MethodBase.IsPublic</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsSpecialName\" data-linktype=\"relative-path\">_MethodBase.IsSpecialName</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsStatic\" data-linktype=\"relative-path\">_MethodBase.IsStatic</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsVirtual\" data-linktype=\"relative-path\">_MethodBase.IsVirtual</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodinfo#System_Reflection_MethodInfo_CreateDelegate_System_Type_\" data-linktype=\"relative-path\">CreateDelegate(Type)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodinfo#System_Reflection_MethodInfo_CreateDelegate_System_Type_System_Object_\" data-linktype=\"relative-path\">CreateDelegate(Type,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodinfo#System_Reflection_MethodInfo_MemberType\" data-linktype=\"relative-path\">MemberType</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodinfo#System_Reflection_MethodInfo_op_Equality_System_Reflection_MethodInfo_System_Reflection_MethodInfo_\" data-linktype=\"relative-path\">op_Equality(MethodInfo,MethodInfo)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodinfo#System_Reflection_MethodInfo_op_Inequality_System_Reflection_MethodInfo_System_Reflection_MethodInfo_\" data-linktype=\"relative-path\">op_Inequality(MethodInfo,MethodInfo)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodinfo#System_Reflection_MethodInfo_System_Runtime_InteropServices__MethodInfo_GetIDsOfNames_System_Guid__System_IntPtr_System_UInt32_System_UInt32_System_IntPtr_\" data-linktype=\"relative-path\">_MethodInfo.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodinfo#System_Reflection_MethodInfo_System_Runtime_InteropServices__MethodInfo_GetType\" data-linktype=\"relative-path\">_MethodInfo.GetType()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodinfo#System_Reflection_MethodInfo_System_Runtime_InteropServices__MethodInfo_GetTypeInfo_System_UInt32_System_UInt32_System_IntPtr_\" data-linktype=\"relative-path\">_MethodInfo.GetTypeInfo(UInt32,UInt32,IntPtr)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodinfo#System_Reflection_MethodInfo_System_Runtime_InteropServices__MethodInfo_GetTypeInfoCount_System_UInt32__\" data-linktype=\"relative-path\">_MethodInfo.GetTypeInfoCount(UInt32)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.methodinfo#System_Reflection_MethodInfo_System_Runtime_InteropServices__MethodInfo_Invoke_System_UInt32_System_Guid__System_UInt32_System_Int16_System_IntPtr_System_IntPtr_System_IntPtr_System_IntPtr_\" data-linktype=\"relative-path\">_MethodInfo.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)</a>\r\n          </div>\r\n          \r\n      </div>\r\n    \r\n    \r\n      <h2>Remarks</h2>\r\n      <p>The MethodBuilder class is used to fully describe a method in Microsoft intermediate language (MSIL), including the name, attributes, signature, and method body. It is used in conjunction with the <a class=\"xref\" href=\"system.reflection.emit.typebuilder\" data-linktype=\"relative-path\">TypeBuilder</a> class to create classes at runtime.  </p>\n<h2 id=\"global-methods-and-methods-as-type-members\">Global methods and methods as type members</h2>\n<p> You can use reflection emit to define global methods and to define methods as type members. The APIs that define methods return MethodBuilder objects.  </p>\n<h3 id=\"global-methods\">Global methods</h3>\n<p> A global method is defined by using the <a class=\"xref\" href=\"system.reflection.emit.modulebuilder#System_Reflection_Emit_ModuleBuilder_DefineGlobalMethod_\" data-linktype=\"relative-path\">DefineGlobalMethod</a> method, which returns a <strong>MethodBuilder</strong> object.  </p>\n<p> Global methods must be static. If a dynamic module contains global methods, the <a class=\"xref\" href=\"system.reflection.emit.modulebuilder#System_Reflection_Emit_ModuleBuilder_CreateGlobalFunctions_\" data-linktype=\"relative-path\">CreateGlobalFunctions</a> method must be called before persisting the dynamic module or the containing dynamic assembly because the common language runtime postpones fixing up the dynamic module until all global functions have been defined.  </p>\n<p> A global native method is defined by using the <a class=\"xref\" href=\"system.reflection.emit.modulebuilder#System_Reflection_Emit_ModuleBuilder_DefinePInvokeMethod_\" data-linktype=\"relative-path\">DefinePInvokeMethod</a> method. Platform invoke (PInvoke) methods must not be declared abstract or virtual. The runtime sets the <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">System.Reflection.MethodAttributes</a> attribute for a platform invoke method.  </p>\n<h3 id=\"methods-as-members-of-types\">Methods as members of types</h3>\n<p> A method is defined as a type member by using the <a class=\"xref\" href=\"system.reflection.emit.typebuilder#System_Reflection_Emit_TypeBuilder_DefineMethod_\" data-linktype=\"relative-path\">DefineMethod</a> method, which returns a MethodBuilder object.  </p>\n<p> The <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_DefineParameter_\" data-linktype=\"relative-path\">DefineParameter</a> method is used to set the name and parameter attributes of a parameter, or of the return value. The<a class=\"xref\" href=\"system.reflection.emit.parameterbuilder\" data-linktype=\"relative-path\">ParameterBuilder</a> object returned by this method represents a parameter or the return value. The <a class=\"xref\" href=\"system.reflection.emit.parameterbuilder\" data-linktype=\"relative-path\">ParameterBuilder</a> object can be used to set the marshaling, to set the constant value, and to apply custom attributes.  </p>\n<h2 id=\"attributes\">Attributes</h2>\n<p> Members of the <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a> enumeration define the precise character of a dynamic method:  </p>\n<ul>\n<li><p>Static methods are specified using the <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">System.Reflection.MethodAttributes</a> attribute.  </p>\n</li>\n<li><p>Final methods (methods that cannot be overridden) are specified using the <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">System.Reflection.MethodAttributes</a> attribute.  </p>\n</li>\n<li><p>Virtual methods are specified using the <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">System.Reflection.MethodAttributes</a> attribute.  </p>\n</li>\n<li><p>Abstract methods are specified using the <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">System.Reflection.MethodAttributes</a> attribute.  </p>\n</li>\n<li><p>Several attributes determine method visibility. See the description of the <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a> enumeration.  </p>\n</li>\n<li><p>Methods that implement overloaded operators must set the <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">System.Reflection.MethodAttributes</a> attribute.  </p>\n</li>\n<li><p>Finalizers must set the <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">System.Reflection.MethodAttributes</a> attribute.  </p>\n</li>\n</ul>\n<h2 id=\"known-issues\">Known Issues</h2>\n<ul>\n<li><p>Although MethodBuilder is derived from <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a>, some of the abstract methods defined in the <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> class are not fully implemented in MethodBuilder. These MethodBuilder methods throw the <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a>. For example the <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_Invoke_\" data-linktype=\"relative-path\">Invoke</a> method is not fully implemented. You can reflect on these methods by retrieving the enclosing type using the <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> or <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_GetType_\" data-linktype=\"relative-path\">GetType</a> methods.  </p>\n</li>\n<li><p>Custom modifiers are supported starting with the .NET Framework version 2.0. They are not supported in earlier versions.</p>\n</li>\n</ul>\n\r\n    \r\n    \r\n    <h2>Properties\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_Attributes\" data-linktype=\"self-bookmark\">Attributes</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Retrieves the attributes for this method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_CallingConvention\" data-linktype=\"self-bookmark\">CallingConvention</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns the calling convention of the method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_ContainsGenericParameters\" data-linktype=\"self-bookmark\">ContainsGenericParameters</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Not supported for this type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_DeclaringType\" data-linktype=\"self-bookmark\">DeclaringType</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns the type that declares this method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_InitLocals\" data-linktype=\"self-bookmark\">InitLocals</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets or sets a Boolean value that specifies whether the local variables in this method are zero initialized. The default value of this property is <code>true</code>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_IsGenericMethod\" data-linktype=\"self-bookmark\">IsGenericMethod</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the method is a generic method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_IsGenericMethodDefinition\" data-linktype=\"self-bookmark\">IsGenericMethodDefinition</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the current <a class=\"xref\" href=\"system.reflection.emit.methodbuilder\" data-linktype=\"relative-path\">MethodBuilder</a> object represents the definition of a generic method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_IsSecurityCritical\" data-linktype=\"self-bookmark\">IsSecurityCritical</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Throws a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> in all cases.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_IsSecuritySafeCritical\" data-linktype=\"self-bookmark\">IsSecuritySafeCritical</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Throws a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> in all cases.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_IsSecurityTransparent\" data-linktype=\"self-bookmark\">IsSecurityTransparent</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Throws a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> in all cases.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_MethodHandle\" data-linktype=\"self-bookmark\">MethodHandle</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Retrieves the internal handle for the method. Use this handle to access the underlying metadata handle.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_Module\" data-linktype=\"self-bookmark\">Module</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the module in which the current method is being defined.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_Name\" data-linktype=\"self-bookmark\">Name</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Retrieves the name of this method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_ReflectedType\" data-linktype=\"self-bookmark\">ReflectedType</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Retrieves the class that was used in reflection to obtain this object.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_ReturnParameter\" data-linktype=\"self-bookmark\">ReturnParameter</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a <a class=\"xref\" href=\"system.reflection.parameterinfo\" data-linktype=\"relative-path\">ParameterInfo</a> object that contains information about the return type of the method, such as whether the return type has custom modifiers.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_ReturnType\" data-linktype=\"self-bookmark\">ReturnType</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the return type of the method represented by this <a class=\"xref\" href=\"system.reflection.emit.methodbuilder\" data-linktype=\"relative-path\">MethodBuilder</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_ReturnTypeCustomAttributes\" data-linktype=\"self-bookmark\">ReturnTypeCustomAttributes</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns the custom attributes of the method&#39;s return type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_Signature\" data-linktype=\"self-bookmark\">Signature</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Retrieves the signature of the method.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Methods\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_AddDeclarativeSecurity_System_Security_Permissions_SecurityAction_System_Security_PermissionSet_\" data-linktype=\"self-bookmark\">AddDeclarativeSecurity(SecurityAction,PermissionSet)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Adds declarative security to this method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_CreateMethodBody_System_Byte___System_Int32_\" data-linktype=\"self-bookmark\">CreateMethodBody(Byte[],Int32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Creates the body of the method using a supplied byte array of Microsoft intermediate language (MSIL) instructions.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_DefineGenericParameters_System_String___\" data-linktype=\"self-bookmark\">DefineGenericParameters(String[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets the number of generic type parameters for the current method, specifies their names, and returns an array of <a class=\"xref\" href=\"system.reflection.emit.generictypeparameterbuilder\" data-linktype=\"relative-path\">GenericTypeParameterBuilder</a> objects that can be used to define their constraints.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_DefineParameter_System_Int32_System_Reflection_ParameterAttributes_System_String_\" data-linktype=\"self-bookmark\">DefineParameter(Int32,ParameterAttributes,String)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets the parameter attributes and the name of a parameter of this method, or of the return value of this method. Returns a ParameterBuilder that can be used to apply custom attributes.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_Equals_System_Object_\" data-linktype=\"self-bookmark\">Equals(Object)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Determines whether the given object is equal to this instance.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_GetBaseDefinition\" data-linktype=\"self-bookmark\">GetBaseDefinition()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Return the base implementation for a method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_GetCustomAttributes_System_Boolean_\" data-linktype=\"self-bookmark\">GetCustomAttributes(Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns all the custom attributes defined for this method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_GetCustomAttributes_System_Type_System_Boolean_\" data-linktype=\"self-bookmark\">GetCustomAttributes(Type,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns the custom attributes identified by the given type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_GetGenericArguments\" data-linktype=\"self-bookmark\">GetGenericArguments()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns an array of <a class=\"xref\" href=\"system.reflection.emit.generictypeparameterbuilder\" data-linktype=\"relative-path\">GenericTypeParameterBuilder</a> objects that represent the type parameters of the method, if it is generic.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_GetGenericMethodDefinition\" data-linktype=\"self-bookmark\">GetGenericMethodDefinition()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns this method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_GetHashCode\" data-linktype=\"self-bookmark\">GetHashCode()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the hash code for this method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_GetILGenerator\" data-linktype=\"self-bookmark\">GetILGenerator()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns an <code>ILGenerator</code> for this method with a default Microsoft intermediate language (MSIL) stream size of 64 bytes.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_GetILGenerator_System_Int32_\" data-linktype=\"self-bookmark\">GetILGenerator(Int32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns an <code>ILGenerator</code> for this method with the specified Microsoft intermediate language (MSIL) stream size.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_GetMethodImplementationFlags\" data-linktype=\"self-bookmark\">GetMethodImplementationFlags()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns the implementation flags for the method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_GetModule\" data-linktype=\"self-bookmark\">GetModule()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns a reference to the module that contains this method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_GetParameters\" data-linktype=\"self-bookmark\">GetParameters()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns the parameters of this method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_GetToken\" data-linktype=\"self-bookmark\">GetToken()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns the <code>MethodToken</code> that represents the token for this method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_Invoke_System_Object_System_Reflection_BindingFlags_System_Reflection_Binder_System_Object___System_Globalization_CultureInfo_\" data-linktype=\"self-bookmark\">Invoke(Object,BindingFlags,Binder,Object[],CultureInfo)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Dynamically invokes the method reflected by this instance on the given object, passing along the specified parameters, and under the constraints of the given binder.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_IsDefined_System_Type_System_Boolean_\" data-linktype=\"self-bookmark\">IsDefined(Type,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Checks if the specified custom attribute type is defined.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_MakeGenericMethod_System_Type___\" data-linktype=\"self-bookmark\">MakeGenericMethod(Type[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns a generic method constructed from the current generic method definition using the specified generic type arguments.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_SetCustomAttribute_System_Reflection_Emit_CustomAttributeBuilder_\" data-linktype=\"self-bookmark\">SetCustomAttribute(CustomAttributeBuilder)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets a custom attribute using a custom attribute builder.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_SetCustomAttribute_System_Reflection_ConstructorInfo_System_Byte___\" data-linktype=\"self-bookmark\">SetCustomAttribute(ConstructorInfo,Byte[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets a custom attribute using a specified custom attribute blob.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_SetImplementationFlags_System_Reflection_MethodImplAttributes_\" data-linktype=\"self-bookmark\">SetImplementationFlags(MethodImplAttributes)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets the implementation flags for this method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_SetMarshal_System_Reflection_Emit_UnmanagedMarshal_\" data-linktype=\"self-bookmark\">SetMarshal(UnmanagedMarshal)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets marshaling information for the return type of this method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_SetMethodBody_System_Byte___System_Int32_System_Byte___System_Collections_Generic_IEnumerable_System_Reflection_Emit_ExceptionHandler__System_Collections_Generic_IEnumerable_System_Int32__\" data-linktype=\"self-bookmark\">SetMethodBody(Byte[],Int32,Byte[],IEnumerable&lt;ExceptionHandler&gt;,IEnumerable&lt;Int32&gt;)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Creates the body of the method by using a specified byte array of Microsoft intermediate language (MSIL) instructions.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_SetParameters_System_Type___\" data-linktype=\"self-bookmark\">SetParameters(Type[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets the number and types of parameters for a method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_SetReturnType_System_Type_\" data-linktype=\"self-bookmark\">SetReturnType(Type)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets the return type of the method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_SetSignature_System_Type_System_Type___System_Type___System_Type___System_Type_____System_Type_____\" data-linktype=\"self-bookmark\">SetSignature(Type,Type[],Type[],Type[],Type[][],Type[][])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets the method signature, including the return type, the parameter types, and the required and optional custom modifiers of the return type and parameter types.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_SetSymCustomAttribute_System_String_System_Byte___\" data-linktype=\"self-bookmark\">SetSymCustomAttribute(String,Byte[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Set a symbolic custom attribute using a blob.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_ToString\" data-linktype=\"self-bookmark\">ToString()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns this <code>MethodBuilder</code> instance as a string.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Explicit Interface Implementations\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_System_Runtime_InteropServices__MethodBuilder_GetIDsOfNames_System_Guid__System_IntPtr_System_UInt32_System_UInt32_System_IntPtr_\" data-linktype=\"self-bookmark\">_MethodBuilder.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Maps a set of names to a corresponding set of dispatch identifiers.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_System_Runtime_InteropServices__MethodBuilder_GetTypeInfo_System_UInt32_System_UInt32_System_IntPtr_\" data-linktype=\"self-bookmark\">_MethodBuilder.GetTypeInfo(UInt32,UInt32,IntPtr)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Retrieves the type information for an object, which can then be used to get the type information for an interface.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_System_Runtime_InteropServices__MethodBuilder_GetTypeInfoCount_System_UInt32__\" data-linktype=\"self-bookmark\">_MethodBuilder.GetTypeInfoCount(UInt32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_MethodBuilder_System_Runtime_InteropServices__MethodBuilder_Invoke_System_UInt32_System_Guid__System_UInt32_System_Int16_System_IntPtr_System_IntPtr_System_IntPtr_System_IntPtr_\" data-linktype=\"self-bookmark\">_MethodBuilder.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Provides access to properties and methods exposed by an object.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"properties\">\r\n        <h2>Properties\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_Attributes\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_Attributes_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Attributes</div>        \r\n          </div>\r\n    \r\n            <p>Retrieves the attributes for this method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override System.Reflection.MethodAttributes Attributes { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a></div>\r\n                  </div>\r\n                  <p>Read-only. Retrieves the <code>MethodAttributes</code> for this method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_CallingConvention\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_CallingConvention_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">CallingConvention</div>        \r\n          </div>\r\n    \r\n            <p>Returns the calling convention of the method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override System.Reflection.CallingConventions CallingConvention { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.callingconventions\" data-linktype=\"relative-path\">CallingConventions</a></div>\r\n                  </div>\r\n                  <p>Read-only. The calling convention of the method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_ContainsGenericParameters\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_ContainsGenericParameters_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ContainsGenericParameters</div>        \r\n          </div>\r\n    \r\n            <p>Not supported for this type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override bool ContainsGenericParameters { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p>Not supported.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The invoked method is not supported in the base class.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A <a class=\"xref\" href=\"system.reflection.emit.methodbuilder\" data-linktype=\"relative-path\">MethodBuilder</a> always represents a generic method definition, and thus cannot be invoked.  </p>\n<p> For more information, see &lt;xref:System.Reflection.MethodInfo.IsGenericMethod%2A?displayProperty=fullName&gt; and &lt;xref:System.Reflection.MethodInfo.ContainsGenericParameters%2A?displayProperty=fullName&gt;. For information on generic types, see <a class=\"xref\" href=\"system.type#System_Type_IsGenericType_\" data-linktype=\"relative-path\">IsGenericType</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_DeclaringType\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_DeclaringType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">DeclaringType</div>        \r\n          </div>\r\n    \r\n            <p>Returns the type that declares this method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override Type DeclaringType { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>Read-only. The type that declares this method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code illustrates the use of the <code>Type</code> property.  </p>\n<pre><code class=\"lang-cs\" name=\"MethodBuilderClass_TypeSample#1\">using System;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\npublic class MethodBuilderClass\n{\n   public static void Main()\n   {\n      try\n      {\n         // Get the current AppDomain.\n         AppDomain myAppDomain = AppDomain.CurrentDomain;\n         AssemblyName myAssemblyName = new AssemblyName();\n         myAssemblyName.Name = &quot;MyDynamicAssembly&quot;;\n\n         // Create the dynamic assembly and set its access mode to &#39;Save&#39;.\n         AssemblyBuilder myAssemblyBuilder = myAppDomain.DefineDynamicAssembly(\n                        myAssemblyName, AssemblyBuilderAccess.Save);\n         // Create a dynamic module &#39;myModuleBuilder&#39;.\n         ModuleBuilder myModuleBuilder =\n              myAssemblyBuilder.DefineDynamicModule(&quot;MyDynamicModule&quot;, true);\n         // Define a public class &#39;MyDynamicClass&#39;.\n         TypeBuilder myTypeBuilder = myModuleBuilder.DefineType(&quot;MyDynamicClass&quot;,\n                                                 TypeAttributes.Public);\n         // Define a public string field named &#39;myField&#39;.\n         FieldBuilder myField = myTypeBuilder.DefineField(&quot;MyDynamicField&quot;,\n                        typeof(String), FieldAttributes.Public);\n         \n         // Define the dynamic method &#39;MyDynamicMethod&#39;.\n         MethodBuilder myMethodBuilder = myTypeBuilder.DefineMethod(&quot;MyDynamicMethod&quot;,\n                              MethodAttributes.Private, typeof(int), new Type[] {});\n         // Generate the IL for &#39;myMethodBuilder&#39;.\n         ILGenerator myMethodIL = myMethodBuilder.GetILGenerator();\n         // Emit the necessary opcodes.\n         myMethodIL.Emit(OpCodes.Ldarg_0);\n         myMethodIL.Emit(OpCodes.Ldfld, myField);\n         myMethodIL.Emit(OpCodes.Ret);\n\n         // Create &#39;myTypeBuilder&#39; class.\n         Type myType1 = myTypeBuilder.CreateType();\n\n         // Get the method information of &#39;myTypeBuilder&#39;.\n         MethodInfo[] myInfo = myType1.GetMethods(BindingFlags.NonPublic |\n                                                BindingFlags.Instance);\n         // Print non-public methods present of &#39;myType1&#39;.\n         Console.WriteLine(&quot;<br>The Non-Public methods present in &#39;myType1&#39; are:<br>&quot;);\n         for(int i = 0; i &lt; myInfo.Length; i++)\n         {\n            Console.WriteLine(myInfo[i].Name);\n         }\n         // Print the &#39;Attribute&#39;, &#39;Signature&#39; of &#39;myMethodBuilder&#39;.\n         Console.WriteLine(&quot;<br>The Attribute of &#39;MyDynamicMethod&#39; is :{0}&quot; ,\n                                    myMethodBuilder.Attributes);\n         Console.WriteLine(&quot;<br>The Signature of &#39;MyDynamicMethod&#39; is : <br>&quot;\n                                    + myMethodBuilder.Signature);\n      }\n      catch(Exception e)\n      {\n         Console.WriteLine(&quot;Exception :{0}&quot;, e.Message);\n      }\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"MethodBuilderClass_TypeSample#1\">Imports System\nImports System.Reflection\nImports System.Reflection.Emit\nImports MicroSoft.VisualBasic\n\nPublic Class MethodBuilderClass\n\n   Public Shared Sub Main()\n      Try\n         &#39; Get the current AppDomain.\n         Dim myAppDomain As AppDomain = AppDomain.CurrentDomain\n         Dim myAssemblyName As New AssemblyName()\n         myAssemblyName.Name = &quot;MyDynamicAssembly&quot;\n\n         &#39; Create the dynamic assembly and set its access mode to &#39;Save&#39;.\n         Dim myAssemblyBuilder As AssemblyBuilder = myAppDomain.DefineDynamicAssembly _\n                                                      (myAssemblyName, AssemblyBuilderAccess.Save)\n         &#39; Create a dynamic module &#39;myModuleBuilder&#39;.\n         Dim myModuleBuilder As ModuleBuilder = myAssemblyBuilder.DefineDynamicModule _\n                                                                     (&quot;MyDynamicModule&quot;, True)\n         &#39; Define a public class &#39;MyDynamicClass&#39;.\n         Dim myTypeBuilder As TypeBuilder = myModuleBuilder.DefineType _\n                                                      (&quot;MyDynamicClass&quot;, TypeAttributes.Public)\n         &#39; Define a public string field named &#39;myField&#39;.\n         Dim myField As FieldBuilder = myTypeBuilder.DefineField(&quot;MyDynamicField&quot;, _\n                                                   GetType(String), FieldAttributes.Public)\n         &#39; Define the dynamic method &#39;MyDynamicMethod&#39;.\n         Dim myMethodBuilder As MethodBuilder = myTypeBuilder.DefineMethod(&quot;MyDynamicMethod&quot;, _\n                                 MethodAttributes.Private, GetType(Integer), New Type() {})\n         &#39; Generate the IL for &#39;myMethodBuilder&#39;.\n         Dim myMethodIL As ILGenerator = myMethodBuilder.GetILGenerator()\n         &#39; Emit the necessary opcodes.\n         myMethodIL.Emit(OpCodes.Ldarg_0)\n         myMethodIL.Emit(OpCodes.Ldfld, myField)\n         myMethodIL.Emit(OpCodes.Ret)\n\n         &#39; Create &#39;myTypeBuilder&#39; class.\n         Dim myType1 As Type = myTypeBuilder.CreateType()\n\n         &#39; Get the method information of &#39;myTypeBuilder&#39;.\n         Dim myInfo As MethodInfo() = myType1.GetMethods(BindingFlags.NonPublic Or _\n                                                         BindingFlags.Instance)\n         &#39; Print non-public methods present of &#39;myType1&#39;.\n         Console.WriteLine(ControlChars.Newline + &quot;The Non-Public methods present in &#39;myType1&#39; are:&quot; + _\n                                                                           ControlChars.NewLine)\n         Dim i As Integer\n         For i = 0 To myInfo.Length - 1\n            Console.WriteLine(myInfo(i).Name)\n         Next i\n         &#39; Print the &#39;Attribute&#39;, &#39;Signature&#39; of &#39;myMethodBuilder&#39;.\n         Console.WriteLine(ControlChars.Newline + &quot;The Attribute of &#39;MyDynamicMethod&#39; is :{0}&quot;, _\n                                                                        myMethodBuilder.Attributes)\n         Console.WriteLine(ControlChars.Newline + &quot;The Signature of &#39;MyDynamicMethod&#39; is : &quot; + _\n                                                ControlChars.Newline + myMethodBuilder.Signature)\n      Catch e As Exception\n         Console.WriteLine(&quot;Exception :{0}&quot;, e.Message)\n      End Try\n   End Sub &#39;Main\nEnd Class &#39;MethodBuilderClass\n</code></pre><pre><code class=\"lang-cpp\" name=\"MethodBuilderClass_TypeSample#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Reflection::Emit;\nint main()\n{\n   try\n   {\n      // Get the current AppDomain.\n      AppDomain^ myAppDomain = AppDomain::CurrentDomain;\n      AssemblyName^ myAssemblyName = gcnew AssemblyName;\n      myAssemblyName-&gt;Name = &quot;MyDynamicAssembly&quot;;\n\n      // Create the dynamic assembly and set its access mode to &#39;Save&#39;.\n      AssemblyBuilder^ myAssemblyBuilder = myAppDomain-&gt;DefineDynamicAssembly( myAssemblyName, AssemblyBuilderAccess::Save );\n\n      // Create a dynamic module &#39;myModuleBuilder&#39;.\n      ModuleBuilder^ myModuleBuilder = myAssemblyBuilder-&gt;DefineDynamicModule( &quot;MyDynamicModule&quot;, true );\n\n      // Define a public class &#39;MyDynamicClass&#39;.\n      TypeBuilder^ myTypeBuilder = myModuleBuilder-&gt;DefineType( &quot;MyDynamicClass&quot;, TypeAttributes::Public );\n\n      // Define a public string field named &#39;myField&#39;.\n      FieldBuilder^ myField = myTypeBuilder-&gt;DefineField( &quot;MyDynamicField&quot;, String::typeid, FieldAttributes::Public );\n\n      // Define the dynamic method &#39;MyDynamicMethod&#39;.\n      array&lt;Type^&gt;^temp0 = gcnew array&lt;Type^&gt;(0);\n      MethodBuilder^ myMethodBuilder = myTypeBuilder-&gt;DefineMethod( &quot;MyDynamicMethod&quot;, MethodAttributes::Private, int::typeid, temp0 );\n\n      // Generate the IL for &#39;myMethodBuilder&#39;.\n      ILGenerator^ myMethodIL = myMethodBuilder-&gt;GetILGenerator();\n\n      // Emit the necessary opcodes.\n      myMethodIL-&gt;Emit( OpCodes::Ldarg_0 );\n      myMethodIL-&gt;Emit( OpCodes::Ldfld, myField );\n      myMethodIL-&gt;Emit( OpCodes::Ret );\n\n      // Create &#39;myTypeBuilder&#39; class.\n      Type^ myType1 = myTypeBuilder-&gt;CreateType();\n\n      // Get the method information of &#39;myTypeBuilder&#39;.\n      array&lt;MethodInfo^&gt;^myInfo = myType1-&gt;GetMethods( static_cast&lt;BindingFlags&gt;(BindingFlags::NonPublic | BindingFlags::Instance) );\n\n      // Print non-public methods present of &#39;myType1&#39;.\n      Console::WriteLine( &quot;<br>The Non-Public methods present in &#39;myType1&#39; are:<br>&quot; );\n      for ( int i = 0; i &lt; myInfo-&gt;Length; i++ )\n      {\n         Console::WriteLine( myInfo[ i ]-&gt;Name );\n      }\n      Console::WriteLine( &quot;<br>The Attribute of &#39;MyDynamicMethod&#39; is :{0}&quot;, myMethodBuilder-&gt;Attributes );\n      Console::WriteLine( &quot;<br>The Signature of &#39;MyDynamicMethod&#39; is : <br>{0}&quot;, myMethodBuilder-&gt;Signature );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception :{0}&quot;, e-&gt;Message );\n   }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_InitLocals\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_InitLocals_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">InitLocals</div>        \r\n          </div>\r\n    \r\n            <p>Gets or sets a Boolean value that specifies whether the local variables in this method are zero initialized. The default value of this property is <code>true</code>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool InitLocals { get; set; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the local variables in this method should be zero initialized; otherwise <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>For the current method, the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethod*</span> property is <code>true</code>, but the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition*</span> property is <code>false</code>. (Get or set.)</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If this property is set to <code>true</code>, the emitted MSIL includes initialization of local variables. If it is set to <code>false</code>, local variables are not initialized and the generated code is unverifiable.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_IsGenericMethod\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_IsGenericMethod_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsGenericMethod</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the method is a generic method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override bool IsGenericMethod { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the method is generic; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A method is generic if it has type parameters. You can make a method generic by calling the <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_DefineGenericParameters_\" data-linktype=\"relative-path\">DefineGenericParameters</a> method to add type parameters. This change cannot be reversed.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example displays the status of a method. This code is part of a larger example provided for the <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_DefineGenericParameters_\" data-linktype=\"relative-path\">DefineGenericParameters</a> method.  </p>\n<pre><code class=\"lang-cs\" name=\"GenericMethodBuilder#7\">        // Use the IsGenericMethod property to find out if a\n        // dynamic method is generic, and IsGenericMethodDefinition\n        // to find out if it defines a generic method.\n        Console.WriteLine(&quot;Is DemoMethod generic? {0}&quot;, \n            demoMethod.IsGenericMethod);\n        Console.WriteLine(&quot;Is DemoMethod a generic method definition? {0}&quot;, \n            demoMethod.IsGenericMethodDefinition);\n</code></pre><pre><code class=\"lang-cpp\" name=\"GenericMethodBuilder#7\">    // Use the IsGenericMethod property to find out if a\n    // dynamic method is generic, and IsGenericMethodDefinition\n    // to find out if it defines a generic method.\n    Console::WriteLine(&quot;Is SampleMethod generic? {0}&quot;,\n        sampleMethodBuilder-&gt;IsGenericMethod);\n    Console::WriteLine(\n        &quot;Is SampleMethod a generic method definition? {0}&quot;,\n        sampleMethodBuilder-&gt;IsGenericMethodDefinition);\n</code></pre><pre><code class=\"lang-vb\" name=\"GenericMethodBuilder#7\">        &#39; Use the IsGenericMethod property to find out if a\n        &#39; dynamic method is generic, and IsGenericMethodDefinition\n        &#39; to find out if it defines a generic method.\n        Console.WriteLine(&quot;Is DemoMethod generic? {0}&quot;, _\n            demoMethod.IsGenericMethod)\n        Console.WriteLine(&quot;Is DemoMethod a generic method definition? {0}&quot;, _\n            demoMethod.IsGenericMethodDefinition)\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_IsGenericMethodDefinition\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_IsGenericMethodDefinition_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsGenericMethodDefinition</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the current <a class=\"xref\" href=\"system.reflection.emit.methodbuilder\" data-linktype=\"relative-path\">MethodBuilder</a> object represents the definition of a generic method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override bool IsGenericMethodDefinition { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the current <a class=\"xref\" href=\"system.reflection.emit.methodbuilder\" data-linktype=\"relative-path\">MethodBuilder</a> object represents the definition of a generic method; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A <a class=\"xref\" href=\"system.reflection.emit.methodbuilder\" data-linktype=\"relative-path\">MethodBuilder</a> can only be used to create generic method definitions; it cannot be used to create a constructed generic method directly. However, a subclass of <a class=\"xref\" href=\"system.reflection.emit.methodbuilder\" data-linktype=\"relative-path\">MethodBuilder</a> might represent a constructed generic method.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example displays the status of a method. This code is part of a larger example provided for the <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_DefineGenericParameters_\" data-linktype=\"relative-path\">DefineGenericParameters</a> method.  </p>\n<pre><code class=\"lang-cs\" name=\"GenericMethodBuilder#7\">        // Use the IsGenericMethod property to find out if a\n        // dynamic method is generic, and IsGenericMethodDefinition\n        // to find out if it defines a generic method.\n        Console.WriteLine(&quot;Is DemoMethod generic? {0}&quot;, \n            demoMethod.IsGenericMethod);\n        Console.WriteLine(&quot;Is DemoMethod a generic method definition? {0}&quot;, \n            demoMethod.IsGenericMethodDefinition);\n</code></pre><pre><code class=\"lang-cpp\" name=\"GenericMethodBuilder#7\">    // Use the IsGenericMethod property to find out if a\n    // dynamic method is generic, and IsGenericMethodDefinition\n    // to find out if it defines a generic method.\n    Console::WriteLine(&quot;Is SampleMethod generic? {0}&quot;,\n        sampleMethodBuilder-&gt;IsGenericMethod);\n    Console::WriteLine(\n        &quot;Is SampleMethod a generic method definition? {0}&quot;,\n        sampleMethodBuilder-&gt;IsGenericMethodDefinition);\n</code></pre><pre><code class=\"lang-vb\" name=\"GenericMethodBuilder#7\">        &#39; Use the IsGenericMethod property to find out if a\n        &#39; dynamic method is generic, and IsGenericMethodDefinition\n        &#39; to find out if it defines a generic method.\n        Console.WriteLine(&quot;Is DemoMethod generic? {0}&quot;, _\n            demoMethod.IsGenericMethod)\n        Console.WriteLine(&quot;Is DemoMethod a generic method definition? {0}&quot;, _\n            demoMethod.IsGenericMethodDefinition)\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_IsSecurityCritical\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_IsSecurityCritical_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsSecurityCritical</div>        \r\n          </div>\r\n    \r\n            <p>Throws a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> in all cases.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override bool IsSecurityCritical { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p>Throws a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> in all cases.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>In all cases. This property is not supported in dynamic assemblies. See Remarks.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>To determine whether a method in a dynamic assembly is security-critical, complete the type by calling <a class=\"xref\" href=\"system.reflection.emit.typebuilder#System_Reflection_Emit_TypeBuilder_CreateType_\" data-linktype=\"relative-path\">CreateType</a>, call the <a class=\"xref\" href=\"system.type#System_Type_GetMethod_\" data-linktype=\"relative-path\">GetMethod</a> method on the completed type, and get the <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsSecurityCritical_\" data-linktype=\"relative-path\">IsSecurityCritical</a> property on the resulting <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_IsSecuritySafeCritical\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_IsSecuritySafeCritical_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsSecuritySafeCritical</div>        \r\n          </div>\r\n    \r\n            <p>Throws a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> in all cases.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override bool IsSecuritySafeCritical { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p>Throws a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> in all cases.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>In all cases. This property is not supported in dynamic assemblies. See Remarks.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>To determine whether a method in a dynamic assembly is security-safe-critical, complete the type by calling <a class=\"xref\" href=\"system.reflection.emit.typebuilder#System_Reflection_Emit_TypeBuilder_CreateType_\" data-linktype=\"relative-path\">CreateType</a>, call the <a class=\"xref\" href=\"system.type#System_Type_GetMethod_\" data-linktype=\"relative-path\">GetMethod</a> method on the completed type, and get the <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsSecuritySafeCritical_\" data-linktype=\"relative-path\">IsSecuritySafeCritical</a> property on the resulting <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_IsSecurityTransparent\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_IsSecurityTransparent_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsSecurityTransparent</div>        \r\n          </div>\r\n    \r\n            <p>Throws a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> in all cases.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override bool IsSecurityTransparent { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p>Throws a <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> in all cases.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>In all cases. This property is not supported in dynamic assemblies. See Remarks.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>To determine whether a method in a dynamic assembly is security-transparent, complete the type by calling <a class=\"xref\" href=\"system.reflection.emit.typebuilder#System_Reflection_Emit_TypeBuilder_CreateType_\" data-linktype=\"relative-path\">CreateType</a>, call the <a class=\"xref\" href=\"system.type#System_Type_GetMethod_\" data-linktype=\"relative-path\">GetMethod</a> method on the completed type, and get the <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsSecurityTransparent_\" data-linktype=\"relative-path\">IsSecurityTransparent</a> property on the resulting <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_MethodHandle\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_MethodHandle_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">MethodHandle</div>        \r\n          </div>\r\n    \r\n            <p>Retrieves the internal handle for the method. Use this handle to access the underlying metadata handle.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override RuntimeMethodHandle MethodHandle { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtimemethodhandle\" data-linktype=\"relative-path\">RuntimeMethodHandle</a></div>\r\n                  </div>\r\n                  <p>Read-only. The internal handle for the method. Use this handle to access the underlying metadata handle.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>This method is not currently supported. Retrieve the method using <span class=\"xref\">stem.Type.GetMethod*</span> and call <span class=\"xref\">stem.Reflection.MethodBase.MethodHandle*</span> on the returned <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_Module\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_Module_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Module</div>        \r\n          </div>\r\n    \r\n            <p>Gets the module in which the current method is being defined.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override System.Reflection.Module Module { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.module\" data-linktype=\"relative-path\">Module</a></div>\r\n                  </div>\r\n                  <p>The <a class=\"xref\" href=\"system.reflection.module\" data-linktype=\"relative-path\">Module</a> in which the member represented by the current <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a> is being defined.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This property is provided as a convenience. It is equivalent to using the <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_DeclaringType_\" data-linktype=\"relative-path\">DeclaringType</a> property to get the type in which the method is being declared, and then calling the <a class=\"xref\" href=\"system.type#System_Type_Module_\" data-linktype=\"relative-path\">Module</a> property of the resulting <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object.  </p>\n<p> This property is also equivalent to calling <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_GetModule_\" data-linktype=\"relative-path\">GetModule</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_Name\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_Name_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Name</div>        \r\n          </div>\r\n    \r\n            <p>Retrieves the name of this method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override string Name { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </div>\r\n                  <p>Read-only. Retrieves a string containing the simple name of this method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_ReflectedType\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_ReflectedType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ReflectedType</div>        \r\n          </div>\r\n    \r\n            <p>Retrieves the class that was used in reflection to obtain this object.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override Type ReflectedType { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>Read-only. The type used to obtain this method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_ReturnParameter\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_ReturnParameter_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ReturnParameter</div>        \r\n          </div>\r\n    \r\n            <p>Gets a <a class=\"xref\" href=\"system.reflection.parameterinfo\" data-linktype=\"relative-path\">ParameterInfo</a> object that contains information about the return type of the method, such as whether the return type has custom modifiers.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override System.Reflection.ParameterInfo ReturnParameter { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.parameterinfo\" data-linktype=\"relative-path\">ParameterInfo</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"system.reflection.parameterinfo\" data-linktype=\"relative-path\">ParameterInfo</a> object that contains information about the return type.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The declaring type has not been created.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Compiler designers can use the <a class=\"xref\" href=\"system.reflection.parameterinfo\" data-linktype=\"relative-path\">ParameterInfo</a> object returned by this property to discover whether custom modifiers, such as <a class=\"xref\" href=\"microsoft.visualc.isconstmodifier\" data-linktype=\"relative-path\">IsConstModifier</a>, have been applied to the return type.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_ReturnType\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_ReturnType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ReturnType</div>        \r\n          </div>\r\n    \r\n            <p>Gets the return type of the method represented by this <a class=\"xref\" href=\"system.reflection.emit.methodbuilder\" data-linktype=\"relative-path\">MethodBuilder</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override Type ReturnType { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>The return type of the method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <div class=\"NOTE\"><h5>Note</h5><p> Starting with the .NET Framework 2.0 and the .NET Compact Framework 2.0, this member is inherited from the base class, <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a>. See <a class=\"xref\" href=\"system.reflection.methodinfo#System_Reflection_MethodInfo_ReturnType_\" data-linktype=\"relative-path\">ReturnType</a>.</p>\n</div>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_ReturnTypeCustomAttributes\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_ReturnTypeCustomAttributes_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ReturnTypeCustomAttributes</div>        \r\n          </div>\r\n    \r\n            <p>Returns the custom attributes of the method&#39;s return type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.icustomattributeprovider\" data-linktype=\"relative-path\">ICustomAttributeProvider</a></div>\r\n                  </div>\r\n                  <p>Read-only. The custom attributes of the method&#39;s return type.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method always returns <code>null</code>. Get the <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> after the containing <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> has been created and invoked <a class=\"xref\" href=\"system.reflection.methodinfo#System_Reflection_MethodInfo_ReturnTypeCustomAttributes_\" data-linktype=\"relative-path\">ReturnTypeCustomAttributes</a> on the <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_Signature\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_Signature_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Signature</div>        \r\n          </div>\r\n    \r\n            <p>Retrieves the signature of the method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public string Signature { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </div>\r\n                  <p>Read-only. A String containing the signature of the method reflected by this <code>MethodBase</code> instance.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"methods\">\r\n        <h2>Methods\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_AddDeclarativeSecurity_System_Security_Permissions_SecurityAction_System_Security_PermissionSet_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_AddDeclarativeSecurity_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">AddDeclarativeSecurity(SecurityAction,PermissionSet)</div>        \r\n          </div>\r\n    \r\n            <p>Adds declarative security to this method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void AddDeclarativeSecurity (System.Security.Permissions.SecurityAction action, System.Security.PermissionSet pset);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>action</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.permissions.securityaction\" data-linktype=\"relative-path\">SecurityAction</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The security action to be taken (Demand, Assert, and so on).</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>pset</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.permissionset\" data-linktype=\"relative-path\">PermissionSet</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The set of permissions the action applies to.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p>The <code>action</code> is invalid (<code>RequestMinimum</code>, <code>RequestOptional</code>, and <code>RequestRefuse</code> are invalid).</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The containing type has been created using <span class=\"xref\">stem.Reflection.Emit.TypeBuilder.CreateType*</span>.  </p>\n<p> -or-  </p>\n<p> The permission set <code>pset</code> contains an action that was added earlier by AddDeclarativeSecurity.  </p>\n<p> -or-  </p>\n<p> For the current method, the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethod*</span> property is <code>true</code>, but the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition*</span> property is <code>false</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>pset</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>AddDeclarativeSecurity can be called several times, with each call specifying a security action (such as <code>Demand</code>, <code>Assert</code>, and <code>Deny</code>) and a set of permissions that the action applies to.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> In the .NET Framework versions 1.0, 1.1, and 2.0, the declarative security attributes applied to a method by using the AddDeclarativeSecurity method are stored in the old XML metadata format. See Emitting Declarative Security Attributes.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The code sample below illustrates the contextual use of <code>AddDeclarativeSecurity</code> to require the caller of a method to have unrestricted permissions.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1\">\t// myModBuilder is an instance of ModuleBuilder.\n\t// Note that for the use of PermissionSet and SecurityAction,\n\t// the namespaces System.Security and System.Security.Permissions\n\t// should be included.\n\t\n\tTypeBuilder myTypeBuilder = myModBuilder.DefineType(&quot;MyType&quot;,\n\t\t\t\t    \tTypeAttributes.Public);\n\n\t\t\t\t\t\t\n\tMethodBuilder myMethod1 = myTypeBuilder.DefineMethod(&quot;MyMethod&quot;,\n\t\t\t\t\t\tMethodAttributes.Public, \n\t\t\t\t\t\ttypeof(int),\n\t\t\t\t\t\tnew Type[] \n\t\t\t\t\t\t{typeof(int), typeof(int)});\t\n\n\tPermissionSet myMethodPermissions = new PermissionSet(\n\t\t\t\tPermissionState.Unrestricted);\n\t\n\tmyMethod1.AddDeclarativeSecurity(SecurityAction.Demand,\n\t\t\t\t\t myMethodPermissions);\n\t\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1\">      &#39; myModBuilder is an instance of ModuleBuilder.\n      &#39; Note that for the use of PermissionSet and SecurityAction,\n      &#39; the namespaces System.Security and System.Security.Permissions\n      &#39; should be included.\n      Dim myTypeBuilder As TypeBuilder = myModBuilder.DefineType(&quot;MyType&quot;, _\n\t\t\t\t\t\t      TypeAttributes.Public)\n      \n      Dim myMethod1 As MethodBuilder = myTypeBuilder.DefineMethod(&quot;MyMethod&quot;, _\n\t\t\t\t\t\t     MethodAttributes.Public, _\n\t\t\t\t\t\t     GetType(Integer), _\n\t\t\t\t\t\t     New Type() {GetType(Integer), GetType(Integer)})\n      \n      Dim myMethodPermissions As New PermissionSet(PermissionState.Unrestricted)\n      \n      myMethod1.AddDeclarativeSecurity(SecurityAction.Demand, myMethodPermissions)\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity Example#1\">      // myModBuilder is an instance of ModuleBuilder.\n      // Note that for the use of PermissionSet and SecurityAction,\n      // the namespaces System::Security and System::Security::Permissions\n      // should be included.\n\n      TypeBuilder^ myTypeBuilder = myModBuilder-&gt;DefineType( &quot;MyType&quot;,\n                                   TypeAttributes::Public );\n\n      array&lt;Type^&gt;^ temp0 = {int::typeid, int::typeid};\n      MethodBuilder^ myMethod1 = myTypeBuilder-&gt;DefineMethod( &quot;MyMethod&quot;,\n                                 MethodAttributes::Public,\n                                 int::typeid, temp0 );\n\n      PermissionSet^ myMethodPermissions = gcnew PermissionSet(\n                                           PermissionState::Unrestricted );\n\n      myMethod1-&gt;AddDeclarativeSecurity( SecurityAction::Demand,\n                                         myMethodPermissions );\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_CreateMethodBody_System_Byte___System_Int32_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_CreateMethodBody_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">CreateMethodBody(Byte[],Int32)</div>        \r\n          </div>\r\n    \r\n            <p>Creates the body of the method using a supplied byte array of Microsoft intermediate language (MSIL) instructions.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void CreateMethodBody (byte[] il, int count);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>il</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.byte\" data-linktype=\"relative-path\">Byte</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array containing valid MSIL instructions. If this parameter is <code>null</code>, the method&#39;s body is cleared.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>count</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The number of valid bytes in the MSIL array. This value is ignored if MSIL is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p>The <code>count</code> is not within the range of indexes of the supplied MSIL instruction array and <code>il</code> is not <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The containing type was previously created using <span class=\"xref\">stem.Reflection.Emit.TypeBuilder.CreateType*</span>.  </p>\n<p> -or-  </p>\n<p> This method was called previously on this <code>MethodBuilder</code> with an <code>il</code> argument that was not <code>null</code>.  </p>\n<p> -or-  </p>\n<p> For the current method, the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethod*</span> property is <code>true</code>, but the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition*</span> property is <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method creates the method&#39;s body from <code>il</code>, an array containing MSIL instructions as opcodes. The number of bytes of valid MSIL is given by count.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> This is currently not fully supported. The user cannot supply the location of token fix ups and exception handlers.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>In the example provided below, a simple method that adds two integers is generated via opcode using <code>CreateMethodBody</code>.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1\">Imports System\nImports System.Threading\nImports System.Reflection\nImports System.Reflection.Emit\n\n _\n\nClass MethodBodyDemo\n   \n   &#39; This class will demonstrate how to create a method body using \n   &#39; the MethodBuilder.CreateMethodBody(byte[], int) method.\n\n   Public Shared Function BuildDynType() As Type\n      \n      Dim addType As Type = Nothing\n      \n      Dim currentDom As AppDomain = Thread.GetDomain()\n      \n      Dim myAsmName As New AssemblyName()\n      myAsmName.Name = &quot;MyDynamicAssembly&quot;\n      \n      Dim myAsmBldr As AssemblyBuilder = currentDom.DefineDynamicAssembly(myAsmName, _\n\t\t\t\t         AssemblyBuilderAccess.RunAndSave)\n      \n      &#39; The dynamic assembly space has been created.  Next, create a module\n      &#39; within it.  The type Point will be reflected into this module.\n      Dim myModuleBldr As ModuleBuilder = myAsmBldr.DefineDynamicModule(&quot;MyModule&quot;)\n      \n      Dim myTypeBldr As TypeBuilder = myModuleBldr.DefineType(&quot;Adder&quot;)\n      \n      Dim myMthdBldr As MethodBuilder = myTypeBldr.DefineMethod(&quot;DoAdd&quot;, _\n\t\t\t\t\tMethodAttributes.Public Or MethodAttributes.Static, _\n\t\t\t\t        GetType(Integer), _\n\t\t\t\t\tNew Type() {GetType(Integer), GetType(Integer)})\n\n      &#39; Build the array of Bytes holding the MSIL instructions.\n\n      Dim ILcodes() As Byte = {&amp;H2, &amp;H3, &amp;H58, &amp;H2A}\n\n      &#39; 02h is the opcode for ldarg.0 \n      &#39; 03h is the opcode for ldarg.1 \n      &#39; 58h is the opcode for add     \n      &#39; 2Ah is the opcode for ret     \n      \n      myMthdBldr.CreateMethodBody(ILcodes, ILcodes.Length)\n      \n      addType = myTypeBldr.CreateType()\n      \n      Return addType\n\n   End Function &#39;BuildDynType\n   \n   \n   Public Shared Sub Main()\n      \n      Dim myType As Type = BuildDynType()\n      Console.WriteLine(&quot;---&quot;)\n      Console.Write(&quot;Enter the first integer to add: &quot;)\n      Dim aVal As Integer = Convert.ToInt32(Console.ReadLine())\n      \n      Console.Write(&quot;Enter the second integer to add: &quot;)\n      Dim bVal As Integer = Convert.ToInt32(Console.ReadLine())\n      \n      Dim adderInst As Object = Activator.CreateInstance(myType, New Object() {})\n      \n      Console.WriteLine(&quot;The value of adding {0} to {1} is: {2}.&quot;, _\n\t\t\t aVal, bVal, _\n\t\t\t myType.InvokeMember(&quot;DoAdd&quot;, _\n\t\t\t\t\t      BindingFlags.InvokeMethod, _\n\t\t\t\t\t      Nothing, _\n\t\t\t\t\t      adderInst, _\n\t\t\t\t\t      New Object() {aVal, bVal}))\n\n   End Sub &#39;Main\n\nEnd Class &#39;MethodBodyDemo\n\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1\">\nusing System;\nusing System.Threading;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\nclass MethodBodyDemo {\n// This class will demonstrate how to create a method body using \n// the MethodBuilder.CreateMethodBody(byte[], int) method.\n\n   public static Type BuildDynType() {\n    \n  \tType addType = null;\n\n    \tAppDomain currentDom = Thread.GetDomain();\n\n        AssemblyName myAsmName = new AssemblyName();\n\tmyAsmName.Name = &quot;MyDynamicAssembly&quot;;\n\n        AssemblyBuilder myAsmBldr = currentDom.DefineDynamicAssembly(\n\t\t\t\t\t       myAsmName,\n\t\t\t\t\t       AssemblyBuilderAccess.RunAndSave);\n\n        // The dynamic assembly space has been created.  Next, create a module\n        // within it.  The type Point will be reflected into this module.\n\n\tModuleBuilder myModuleBldr = myAsmBldr.DefineDynamicModule(&quot;MyModule&quot;);\n      \n\tTypeBuilder myTypeBldr =  myModuleBldr.DefineType(&quot;Adder&quot;);\n\n        MethodBuilder myMthdBldr = myTypeBldr.DefineMethod(&quot;DoAdd&quot;,\n\t\t\t\t\t\t\t    MethodAttributes.Public |\n\t\t\t\t\t\t\t    MethodAttributes.Static,\n\t\t\t\t\t\t\t    typeof(int),\n\t\t\t\t\t\t\t    new Type[] \n\t\t\t\t\t\t\t    {typeof(int), typeof(int)});\n        // Build the array of Bytes holding the MSIL instructions.\n\n        byte[] ILcodes = new byte[] {\n          0x02,   /* 02h is the opcode for ldarg.0 */\n\t  0x03,   /* 03h is the opcode for ldarg.1 */\n\t  0x58,   /* 58h is the opcode for add     */\n\t  0x2A    /* 2Ah is the opcode for ret     */\n\t};\n\t\n\tmyMthdBldr.CreateMethodBody(ILcodes, ILcodes.Length);\n\n        addType = myTypeBldr.CreateType();\n\n\treturn addType;\n   }\n\n   public static void Main() {\n\n\tType myType = BuildDynType(); \n        Console.WriteLine(&quot;---&quot;);\n\tConsole.Write(&quot;Enter the first integer to add: &quot;); \n        int aVal = Convert.ToInt32(Console.ReadLine());\n     \n     \tConsole.Write(&quot;Enter the second integer to add: &quot;);\n     \tint bVal = Convert.ToInt32(Console.ReadLine());\n   \n     \tobject adderInst = Activator.CreateInstance(myType, new object[0]); \n\n\tConsole.WriteLine(&quot;The value of adding {0} to {1} is: {2}.&quot;,\n\t\t\t   aVal, bVal,\t\n     \t\t\t   myType.InvokeMember(&quot;DoAdd&quot;,\n\t\t\t  \t\t       BindingFlags.InvokeMethod,\n\t\t\t  \t\t       null,\n\t\t\t  \t\t       adderInst,\n\t\t\t  \t\t       new object[] {aVal, bVal})); \n   }\n\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Refelction.Emit.MethodBuilder.CreateMethodBody Example#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Reflection;\nusing namespace System::Reflection::Emit;\nclass MethodBodyDemo\n{\npublic:\n\n   // This class will demonstrate how to create a method body using\n   // the MethodBuilder::CreateMethodBody(Byte[], int) method.\n   static Type^ BuildDynType()\n   {\n      Type^ addType = nullptr;\n      AppDomain^ currentDom = Thread::GetDomain();\n      AssemblyName^ myAsmName = gcnew AssemblyName;\n      myAsmName-&gt;Name = &quot;MyDynamicAssembly&quot;;\n      AssemblyBuilder^ myAsmBldr = currentDom-&gt;DefineDynamicAssembly( myAsmName, AssemblyBuilderAccess::RunAndSave );\n      \n      // The dynamic assembly space has been created.  Next, create a module\n      // within it.  The type Point will be reflected into this module.\n      ModuleBuilder^ myModuleBldr = myAsmBldr-&gt;DefineDynamicModule( &quot;MyModule&quot; );\n      TypeBuilder^ myTypeBldr = myModuleBldr-&gt;DefineType( &quot;Adder&quot; );\n      array&lt;Type^&gt;^temp0 = {int::typeid,int::typeid};\n      MethodBuilder^ myMthdBldr = myTypeBldr-&gt;DefineMethod( &quot;DoAdd&quot;, static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::Static), int::typeid, temp0 );\n      \n      // Build the array of Bytes holding the MSIL instructions.\n      \n      /* 02h is the opcode for ldarg.0 */\n      /* 03h is the opcode for ldarg.1 */\n      /* 58h is the opcode for add     */\n      /* 2Ah is the opcode for ret     */\n      array&lt;Byte&gt;^temp1 = {0x02,0x03,0x58,0x2A};\n      array&lt;Byte&gt;^ILcodes = temp1;\n      myMthdBldr-&gt;CreateMethodBody( ILcodes, ILcodes-&gt;Length );\n      addType = myTypeBldr-&gt;CreateType();\n      return addType;\n   }\n\n};\n\nint main()\n{\n   Type^ myType = MethodBodyDemo::BuildDynType();\n   Console::WriteLine( &quot;---&quot; );\n   Console::Write( &quot;Enter the first integer to add: &quot; );\n   int aVal = Convert::ToInt32( Console::ReadLine() );\n   Console::Write( &quot;Enter the second integer to add: &quot; );\n   int bVal = Convert::ToInt32( Console::ReadLine() );\n   Object^ adderInst = Activator::CreateInstance( myType, gcnew array&lt;Object^&gt;(0) );\n   array&lt;Object^&gt;^temp1 = {aVal,bVal};\n   Console::WriteLine( &quot;The value of adding {0} to {1} is: {2}.&quot;, aVal, bVal, myType-&gt;InvokeMember( &quot;DoAdd&quot;, BindingFlags::InvokeMethod, nullptr, adderInst, temp1 ) );\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_DefineGenericParameters_System_String___\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_DefineGenericParameters_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">DefineGenericParameters(String[])</div>        \r\n          </div>\r\n    \r\n            <p>Sets the number of generic type parameters for the current method, specifies their names, and returns an array of <a class=\"xref\" href=\"system.reflection.emit.generictypeparameterbuilder\" data-linktype=\"relative-path\">GenericTypeParameterBuilder</a> objects that can be used to define their constraints.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.Emit.GenericTypeParameterBuilder[] DefineGenericParameters (string[] names);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>names</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of strings that represent the names of the generic type parameters.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.generictypeparameterbuilder\" data-linktype=\"relative-path\">GenericTypeParameterBuilder</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.emit.generictypeparameterbuilder\" data-linktype=\"relative-path\">GenericTypeParameterBuilder</a> objects representing the type parameters of the generic method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>Generic type parameters have already been defined for this method.  </p>\n<p> -or-  </p>\n<p> The method has been completed already.  </p>\n<p> -or-  </p>\n<p> The <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.SetImplementationFlags*</span> method has been called for the current method.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>names</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> An element of <code>names</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>names</code> is an empty array.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Calling the DefineGenericParameters method makes the current method generic. There is no way to undo this change. Calling this method a second time causes an <a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a>.  </p>\n<p> The type parameters of the generic method can be retrieved later by using the <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_GetGenericArguments_\" data-linktype=\"relative-path\">GetGenericArguments</a> method.  </p>\n<p> By convention, a type parameter name is a single uppercase letter.  </p>\n<p> For more information, see &lt;xref:System.Reflection.MethodInfo.IsGenericMethod%2A?displayProperty=fullName&gt; and <a class=\"xref\" href=\"system.reflection.methodinfo#System_Reflection_MethodInfo_GetGenericMethodDefinition_\" data-linktype=\"relative-path\">GetGenericMethodDefinition</a>. For information on generic types, see <a class=\"xref\" href=\"system.type#System_Type_IsGenericType_\" data-linktype=\"relative-path\">IsGenericType</a>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example creates a dynamic type, <code>DemoType</code>, which contains the dynamic generic method <code>DemoMethod</code>. This method has two generic type parameters, one of which is used as a parameter, and the other as the return type.  </p>\n<p> When the code is executed, the dynamic assembly is saved as DemoGenericMethod1.dll, and can be examined using the <a href=\"../Topic/Ildasm.exe%20(IL%20Disassembler).md\" data-linktype=\"relative-path\">Ildasm.exe (IL Disassembler)</a>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> This code example generates a simple method body that merely returns a null reference. For a code example with a more fully developed method body that creates and uses generic types, see <a href=\"../Topic/How%20to:%20Define%20a%20Generic%20Method%20with%20Reflection%20Emit.md\" data-linktype=\"relative-path\">How to: Define a Generic Method with Reflection Emit</a>.  </p>\n</div>\n<pre><code class=\"lang-cs\" name=\"GenericMethodBuilder#1\">using System;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\nclass DemoMethodBuilder\n{\n   \n    public static void Main()\n    {\n        // Creating a dynamic assembly requires an AssemblyName\n        // object, and the current application domain.\n        //\n        AssemblyName asmName = \n            new AssemblyName(&quot;DemoMethodBuilder1&quot;);\n        AppDomain domain = AppDomain.CurrentDomain;\n        AssemblyBuilder demoAssembly = \n            domain.DefineDynamicAssembly(\n                asmName, \n                AssemblyBuilderAccess.RunAndSave\n            );\n\n        // Define the module that contains the code. For an \n        // assembly with one module, the module name is the \n        // assembly name plus a file extension.\n        ModuleBuilder demoModule = \n            demoAssembly.DefineDynamicModule(\n                asmName.Name, \n                asmName.Name + &quot;.dll&quot;\n            );\n      \n        TypeBuilder demoType = demoModule.DefineType(\n            &quot;DemoType&quot;, \n            TypeAttributes.Public | TypeAttributes.Abstract\n        );\n\n        // Define a Shared, Public method with standard calling\n        // conventions. Do not specify the parameter types or the\n        // return type, because type parameters will be used for \n        // those types, and the type parameters have not been\n        // defined yet.\n        MethodBuilder demoMethod = demoType.DefineMethod(\n            &quot;DemoMethod&quot;, \n            MethodAttributes.Public | MethodAttributes.Static\n        );\n\n        // Defining generic parameters for the method makes it a\n        // generic method. By convention, type parameters are \n        // single alphabetic characters. T and U are used here.\n        //\n        string[] typeParamNames = {&quot;T&quot;, &quot;U&quot;};\n        GenericTypeParameterBuilder[] typeParameters = \n            demoMethod.DefineGenericParameters(typeParamNames);\n\n        // The second type parameter is constrained to be a \n        // reference type.\n        typeParameters[1].SetGenericParameterAttributes( \n            GenericParameterAttributes.ReferenceTypeConstraint);\n\n        // Use the IsGenericMethod property to find out if a\n        // dynamic method is generic, and IsGenericMethodDefinition\n        // to find out if it defines a generic method.\n        Console.WriteLine(&quot;Is DemoMethod generic? {0}&quot;, \n            demoMethod.IsGenericMethod);\n        Console.WriteLine(&quot;Is DemoMethod a generic method definition? {0}&quot;, \n            demoMethod.IsGenericMethodDefinition);\n\n        // Set parameter types for the method. The method takes\n        // one parameter, and its type is specified by the first\n        // type parameter, T.\n        Type[] parms = {typeParameters[0]};\n        demoMethod.SetParameters(parms);\n\n        // Set the return type for the method. The return type is\n        // specified by the second type parameter, U.\n        demoMethod.SetReturnType(typeParameters[1]);\n\n        // Generate a code body for the method. The method doesn&#39;t\n        // do anything except return null.\n        //\n        ILGenerator ilgen = demoMethod.GetILGenerator();\n        ilgen.Emit(OpCodes.Ldnull);\n        ilgen.Emit(OpCodes.Ret);\n\n        // Complete the type.\n        Type dt = demoType.CreateType();\n\n        // To bind types to a dynamic generic method, you must \n        // first call the GetMethod method on the completed type.\n        // You can then define an array of types, and bind them\n        // to the method.\n        MethodInfo m = dt.GetMethod(&quot;DemoMethod&quot;);\n        Type[] typeArgs = {typeof(string), typeof(DemoMethodBuilder)};\n        MethodInfo bound = m.MakeGenericMethod(typeArgs);\n        // Display a string representing the bound method.\n        Console.WriteLine(bound);\n\n        // Save the assembly, so it can be examined with Ildasm.exe.\n        demoAssembly.Save(asmName.Name + &quot;.dll&quot;);\n    }\n}\n\n/* This code example produces the following output:\nIs DemoMethod generic? True\nIs DemoMethod a generic method definition? True\nDemoMethodBuilder DemoMethod[String,DemoMethodBuilder](System.String)\n*/\n</code></pre><pre><code class=\"lang-cpp\" name=\"GenericMethodBuilder#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Reflection::Emit;\n\npublic ref class GenericReflectionSample\n{\n};\n\nint main()\n{\n    // Creating a dynamic assembly requires an AssemblyName\n    // object, and the current application domain.\n    //\n    AssemblyName^ asmName =\n        gcnew AssemblyName(&quot;EmittedAssembly&quot;);\n    AppDomain^ domain = AppDomain::CurrentDomain;\n    AssemblyBuilder^ sampleAssemblyBuilder =\n        domain-&gt;DefineDynamicAssembly(asmName,\n        AssemblyBuilderAccess::RunAndSave);\n\n    // Define the module that contains the code. For an\n    // assembly with one module, the module name is the\n    // assembly name plus a file extension.\n    ModuleBuilder^ sampleModuleBuilder =\n        sampleAssemblyBuilder-&gt;DefineDynamicModule(asmName-&gt;Name,\n        asmName-&gt;Name + &quot;.dll&quot;);\n\n    TypeBuilder^ sampleTypeBuilder =\n        sampleModuleBuilder-&gt;DefineType(&quot;SampleType&quot;,\n        TypeAttributes::Public | TypeAttributes::Abstract);\n\n    // Define a Shared, Public method with standard calling\n    // conventions. Do not specify the parameter types or the\n    // return type, because type parameters will be used for\n    // those types, and the type parameters have not been\n    // defined yet.\n    MethodBuilder^ sampleMethodBuilder =\n        sampleTypeBuilder-&gt;DefineMethod(&quot;SampleMethod&quot;,\n        MethodAttributes::Public | MethodAttributes::Static);\n\n    // Defining generic parameters for the method makes it a\n    // generic method. By convention, type parameters are\n    // single alphabetic characters. T and U are used here.\n    //\n    array&lt;String^&gt;^ genericTypeNames = {&quot;T&quot;, &quot;U&quot;};\n    array&lt;GenericTypeParameterBuilder^&gt;^ genericTypes =\n        sampleMethodBuilder-&gt;DefineGenericParameters(\n        genericTypeNames);\n\n    // Use the IsGenericMethod property to find out if a\n    // dynamic method is generic, and IsGenericMethodDefinition\n    // to find out if it defines a generic method.\n    Console::WriteLine(&quot;Is SampleMethod generic? {0}&quot;,\n        sampleMethodBuilder-&gt;IsGenericMethod);\n    Console::WriteLine(\n        &quot;Is SampleMethod a generic method definition? {0}&quot;,\n        sampleMethodBuilder-&gt;IsGenericMethodDefinition);\n\n    // Set parameter types for the method. The method takes\n    // one parameter, and its type is specified by the first\n    // type parameter, T.\n    array&lt;Type^&gt;^ parameterTypes = {genericTypes[0]};\n    sampleMethodBuilder-&gt;SetParameters(parameterTypes);\n\n    // Set the return type for the method. The return type is\n    // specified by the second type parameter, U.\n    sampleMethodBuilder-&gt;SetReturnType(genericTypes[1]);\n\n    // Generate a code body for the method. The method doesn&#39;t\n    // do anything except return null.\n    //\n    ILGenerator^ ilgen = sampleMethodBuilder-&gt;GetILGenerator();\n    ilgen-&gt;Emit(OpCodes::Ldnull);\n    ilgen-&gt;Emit(OpCodes::Ret);\n\n    // Complete the type.\n    Type^ sampleType = sampleTypeBuilder-&gt;CreateType();\n\n    // To bind types to a dynamic generic method, you must\n    // first call the GetMethod method on the completed type.\n    // You can then define an array of types, and bind them\n    // to the method.\n    MethodInfo^ sampleMethodInfo = sampleType-&gt;GetMethod(&quot;SampleMethod&quot;);\n    array&lt;Type^&gt;^ boundParameters =\n        {String::typeid, GenericReflectionSample::typeid};\n    MethodInfo^ boundMethodInfo =\n        sampleMethodInfo-&gt;MakeGenericMethod(boundParameters);\n    // Display a string representing the bound method.\n    Console::WriteLine(boundMethodInfo);\n\n    // Save the assembly, so it can be examined with Ildasm.exe.\n    sampleAssemblyBuilder-&gt;Save(asmName-&gt;Name + &quot;.dll&quot;);\n}\n\n/* This code example produces the following output:\nIs SampleMethod generic? True\nIs SampleMethod a generic method definition? True\nGenericReflectionSample SampleMethod[String,GenericReflectionSample](System.String)\n*/\n</code></pre><pre><code class=\"lang-vb\" name=\"GenericMethodBuilder#1\">Imports System\nImports System.Reflection\nImports System.Reflection.Emit\n\nClass DemoMethodBuilder\n   \n    Public Shared Sub Main()\n        &#39; Creating a dynamic assembly requires an AssemblyName\n        &#39; object, and the current application domain.\n        &#39;\n        Dim asmName As New AssemblyName(&quot;DemoMethodBuilder1&quot;)\n        Dim domain As AppDomain = AppDomain.CurrentDomain\n        Dim demoAssembly As AssemblyBuilder = _\n            domain.DefineDynamicAssembly(asmName, _\n                AssemblyBuilderAccess.RunAndSave)\n\n        &#39; Define the module that contains the code. For an \n        &#39; assembly with one module, the module name is the \n        &#39; assembly name plus a file extension.\n        Dim demoModule As ModuleBuilder = _\n            demoAssembly.DefineDynamicModule( _\n                asmName.Name, _\n                asmName.Name &amp; &quot;.dll&quot;)\n      \n        Dim demoType As TypeBuilder = demoModule.DefineType( _\n            &quot;DemoType&quot;, _\n            TypeAttributes.Public Or TypeAttributes.Abstract)\n\n        &#39; Define a Shared, Public method with standard calling\n        &#39; conventions. Do not specify the parameter types or the\n        &#39; return type, because type parameters will be used for \n        &#39; those types, and the type parameters have not been\n        &#39; defined yet.\n        Dim demoMethod As MethodBuilder = _\n            demoType.DefineMethod(&quot;DemoMethod&quot;, _\n                MethodAttributes.Public Or MethodAttributes.Static)\n\n        &#39; Defining generic parameters for the method makes it a\n        &#39; generic method. By convention, type parameters are \n        &#39; single alphabetic characters. T and U are used here.\n        &#39;\n        Dim typeParamNames() As String = {&quot;T&quot;, &quot;U&quot;}\n        Dim typeParameters() As GenericTypeParameterBuilder = _\n            demoMethod.DefineGenericParameters(typeParamNames)\n\n        &#39; The second type parameter is constrained to be a \n        &#39; reference type.\n        typeParameters(1).SetGenericParameterAttributes( _\n            GenericParameterAttributes.ReferenceTypeConstraint)\n\n        &#39; Use the IsGenericMethod property to find out if a\n        &#39; dynamic method is generic, and IsGenericMethodDefinition\n        &#39; to find out if it defines a generic method.\n        Console.WriteLine(&quot;Is DemoMethod generic? {0}&quot;, _\n            demoMethod.IsGenericMethod)\n        Console.WriteLine(&quot;Is DemoMethod a generic method definition? {0}&quot;, _\n            demoMethod.IsGenericMethodDefinition)\n\n        &#39; Set parameter types for the method. The method takes\n        &#39; one parameter, and its type is specified by the first\n        &#39; type parameter, T.\n        Dim params() As Type = {typeParameters(0)}\n        demoMethod.SetParameters(params)\n\n        &#39; Set the return type for the method. The return type is\n        &#39; specified by the second type parameter, U.\n        demoMethod.SetReturnType(typeParameters(1))\n\n        &#39; Generate a code body for the method. The method doesn&#39;t\n        &#39; do anything except return Nothing.\n        &#39;\n        Dim ilgen As ILGenerator = demoMethod.GetILGenerator()\n        ilgen.Emit(OpCodes.Ldnull)\n        ilgen.Emit(OpCodes.Ret)\n\n        &#39; Complete the type.\n        Dim dt As Type = demoType.CreateType()\n\n        &#39; To bind types to a dynamic generic method, you must \n        &#39; first call the GetMethod method on the completed type.\n        &#39; You can then define an array of types, and bind them\n        &#39; to the method.\n        Dim m As MethodInfo = dt.GetMethod(&quot;DemoMethod&quot;)\n        Dim typeArgs() As Type = _\n            {GetType(String), GetType(DemoMethodBuilder)}\n        Dim bound As MethodInfo = m.MakeGenericMethod(typeArgs)\n        &#39; Display a string representing the bound method.\n        Console.WriteLine(bound)\n\n        &#39; Save the assembly, so it can be examined with Ildasm.exe.\n        demoAssembly.Save(asmName.Name &amp; &quot;.dll&quot;)\n    End Sub  \nEnd Class \n\n&#39; This code example produces the following output:\n&#39;Is DemoMethod generic? True\n&#39;Is DemoMethod a generic method definition? True\n&#39;DemoMethodBuilder DemoMethod[String,DemoMethodBuilder](System.String)\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_DefineParameter_System_Int32_System_Reflection_ParameterAttributes_System_String_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_DefineParameter_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">DefineParameter(Int32,ParameterAttributes,String)</div>        \r\n          </div>\r\n    \r\n            <p>Sets the parameter attributes and the name of a parameter of this method, or of the return value of this method. Returns a ParameterBuilder that can be used to apply custom attributes.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.Emit.ParameterBuilder DefineParameter (int position, System.Reflection.ParameterAttributes attributes, string strParamName);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>position</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The position of the parameter in the parameter list. Parameters are indexed beginning with the number 1 for the first parameter; the number 0 represents the return value of the method.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>attributes</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.parameterattributes\" data-linktype=\"relative-path\">ParameterAttributes</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The parameter attributes of the parameter.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>strParamName</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of the parameter. The name can be the null string.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.parameterbuilder\" data-linktype=\"relative-path\">ParameterBuilder</a></div>\r\n                  </div>\r\n                  <p>Returns a <code>ParameterBuilder</code> object that represents a parameter of this method or the return value of this method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p>The method has no parameters.  </p>\n<p> -or-  </p>\n<p> <code>position</code> is less than zero.  </p>\n<p> -or-  </p>\n<p> <code>position</code> is greater than the number of the method&#39;s parameters.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The containing type was previously created using <span class=\"xref\">stem.Reflection.Emit.TypeBuilder.CreateType*</span>.  </p>\n<p> -or-  </p>\n<p> For the current method, the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethod*</span> property is <code>true</code>, but the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition*</span> property is <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <a class=\"xref\" href=\"system.reflection.emit.parameterbuilder\" data-linktype=\"relative-path\">ParameterBuilder</a> object returned by this method can be used to set the default value for a parameter or to apply custom attributes.  </p>\n<p> Parameter numbering begins with 1, so <code>position</code> is 1 for the first parameter. If <code>position</code> is zero, this method affects the return value.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> In the .NET Framework versions 1.0 and 1.1, an exception is thrown if <code>position</code> is zero, so this method cannot be used to modify attributes of the return value in those versions.</p>\n</div>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_Equals_System_Object_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_Equals_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Equals(Object)</div>        \r\n          </div>\r\n    \r\n            <p>Determines whether the given object is equal to this instance.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override bool Equals (object obj);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>obj</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object to compare with this <code>MethodBuilder</code> instance.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if <code>obj</code> is an instance of <code>MethodBuilder</code> and is equal to this object; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Equality is determined by having the same name, attributes, and signature.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_GetBaseDefinition\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_GetBaseDefinition_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetBaseDefinition()</div>        \r\n          </div>\r\n    \r\n            <p>Return the base implementation for a method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override System.Reflection.MethodInfo GetBaseDefinition ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">System.Reflection.MethodInfo</a></div>\r\n                  </div>\r\n                  <p>The base implementation of this method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This always returns the current <code>MethodBuilder</code> object.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_GetCustomAttributes_System_Boolean_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_GetCustomAttributes_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetCustomAttributes(Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Returns all the custom attributes defined for this method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override object[] GetCustomAttributes (bool inherit);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>inherit</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Specifies whether to search this member&#39;s inheritance chain to find the custom attributes.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>[]</div>\r\n                  </div>\r\n                  <p>Returns an array of objects representing all the custom attributes of this method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>This method is not currently supported. Retrieve the method using <span class=\"xref\">stem.Type.GetMethod*</span> and call <span class=\"xref\">stem.Reflection.MemberInfo.GetCustomAttributes*</span> on the returned <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_GetCustomAttributes_System_Type_System_Boolean_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_GetCustomAttributes_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetCustomAttributes(Type,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Returns the custom attributes identified by the given type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override object[] GetCustomAttributes (Type attributeType, bool inherit);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>attributeType</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The custom attribute type.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>inherit</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Specifies whether to search this member&#39;s inheritance chain to find the custom attributes.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>[]</div>\r\n                  </div>\r\n                  <p>Returns an array of objects representing the attributes of this method that are of type <code>attributeType</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>This method is not currently supported. Retrieve the method using <span class=\"xref\">stem.Type.GetMethod*</span> and call <span class=\"xref\">stem.Reflection.MemberInfo.GetCustomAttributes*</span> on the returned <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_GetGenericArguments\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_GetGenericArguments_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetGenericArguments()</div>        \r\n          </div>\r\n    \r\n            <p>Returns an array of <a class=\"xref\" href=\"system.reflection.emit.generictypeparameterbuilder\" data-linktype=\"relative-path\">GenericTypeParameterBuilder</a> objects that represent the type parameters of the method, if it is generic.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override Type[] GetGenericArguments ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.emit.generictypeparameterbuilder\" data-linktype=\"relative-path\">GenericTypeParameterBuilder</a> objects representing the type parameters, if the method is generic, or <code>null</code> if the method is not generic.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The type parameters of a generic method also are returned by the <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_DefineGenericParameters_\" data-linktype=\"relative-path\">DefineGenericParameters</a> method that is used to define them.  </p>\n<p> For more information, see &lt;xref:System.Reflection.MethodInfo.IsGenericMethod%2A?displayProperty=fullName&gt; and <a class=\"xref\" href=\"system.reflection.methodinfo#System_Reflection_MethodInfo_GetGenericArguments_\" data-linktype=\"relative-path\">GetGenericArguments</a>. For information on generic types, see <a class=\"xref\" href=\"system.type#System_Type_IsGenericType_\" data-linktype=\"relative-path\">IsGenericType</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_GetGenericMethodDefinition\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_GetGenericMethodDefinition_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetGenericMethodDefinition()</div>        \r\n          </div>\r\n    \r\n            <p>Returns this method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override System.Reflection.MethodInfo GetGenericMethodDefinition ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">System.Reflection.MethodInfo</a></div>\r\n                  </div>\r\n                  <p>The current instance of <a class=\"xref\" href=\"system.reflection.emit.methodbuilder\" data-linktype=\"relative-path\">MethodBuilder</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The current method is not generic. That is, the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethod*</span> property returns <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A <a class=\"xref\" href=\"system.reflection.emit.methodbuilder\" data-linktype=\"relative-path\">MethodBuilder</a> cannot be used to emit a constructed generic method directly. The emitted method is a generic method definition.  </p>\n<p> For more information, see &lt;xref:System.Reflection.MethodInfo.IsGenericMethod%2A?displayProperty=fullName&gt; and <a class=\"xref\" href=\"system.reflection.methodinfo#System_Reflection_MethodInfo_GetGenericMethodDefinition_\" data-linktype=\"relative-path\">GetGenericMethodDefinition</a>. For information on generic types, see <a class=\"xref\" href=\"system.type#System_Type_IsGenericType_\" data-linktype=\"relative-path\">IsGenericType</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_GetHashCode\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_GetHashCode_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetHashCode()</div>        \r\n          </div>\r\n    \r\n            <p>Gets the hash code for this method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override int GetHashCode ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </div>\r\n                  <p>The hash code for this method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_GetILGenerator\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_GetILGenerator_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetILGenerator()</div>        \r\n          </div>\r\n    \r\n            <p>Returns an <code>ILGenerator</code> for this method with a default Microsoft intermediate language (MSIL) stream size of 64 bytes.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.Emit.ILGenerator GetILGenerator ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.ilgenerator\" data-linktype=\"relative-path\">ILGenerator</a></div>\r\n                  </div>\r\n                  <p>Returns an <code>ILGenerator</code> object for this method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The method should not have a body because of its <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a> or <a class=\"xref\" href=\"system.reflection.methodimplattributes\" data-linktype=\"relative-path\">MethodImplAttributes</a> flags, for example because it has the <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a> flag.  </p>\n<p> -or-  </p>\n<p> The method is a generic method, but not a generic method definition. That is, the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethod*</span> property is <code>true</code>, but the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition*</span> property is <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The code sample below demonstrates the contextual usage of the <code>GetILGenerator</code> method, creating and emitting a dynamic assembly that will calculate the dot product of two points in 3D space.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Reflection.Emit ILGenerator Example#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Reflection;\nusing namespace System::Reflection::Emit;\nType^ DynamicDotProductGen()\n{\n   Type^ ivType = nullptr;\n   array&lt;Type^&gt;^temp0 = {int::typeid,int::typeid,int::typeid};\n   array&lt;Type^&gt;^ctorParams = temp0;\n   AppDomain^ myDomain = Thread::GetDomain();\n   AssemblyName^ myAsmName = gcnew AssemblyName;\n   myAsmName-&gt;Name = &quot;IntVectorAsm&quot;;\n   AssemblyBuilder^ myAsmBuilder = myDomain-&gt;DefineDynamicAssembly( myAsmName, AssemblyBuilderAccess::RunAndSave );\n   ModuleBuilder^ IntVectorModule = myAsmBuilder-&gt;DefineDynamicModule( &quot;IntVectorModule&quot;, &quot;Vector.dll&quot; );\n   TypeBuilder^ ivTypeBld = IntVectorModule-&gt;DefineType( &quot;IntVector&quot;, TypeAttributes::Public );\n   FieldBuilder^ xField = ivTypeBld-&gt;DefineField( &quot;x&quot;, int::typeid, FieldAttributes::Private );\n   FieldBuilder^ yField = ivTypeBld-&gt;DefineField( &quot;y&quot;, int::typeid, FieldAttributes::Private );\n   FieldBuilder^ zField = ivTypeBld-&gt;DefineField( &quot;z&quot;, int::typeid, FieldAttributes::Private );\n   Type^ objType = Type::GetType( &quot;System.Object&quot; );\n   ConstructorInfo^ objCtor = objType-&gt;GetConstructor( gcnew array&lt;Type^&gt;(0) );\n   ConstructorBuilder^ ivCtor = ivTypeBld-&gt;DefineConstructor( MethodAttributes::Public, CallingConventions::Standard, ctorParams );\n   ILGenerator^ ctorIL = ivCtor-&gt;GetILGenerator();\n   ctorIL-&gt;Emit( OpCodes::Ldarg_0 );\n   ctorIL-&gt;Emit( OpCodes::Call, objCtor );\n   ctorIL-&gt;Emit( OpCodes::Ldarg_0 );\n   ctorIL-&gt;Emit( OpCodes::Ldarg_1 );\n   ctorIL-&gt;Emit( OpCodes::Stfld, xField );\n   ctorIL-&gt;Emit( OpCodes::Ldarg_0 );\n   ctorIL-&gt;Emit( OpCodes::Ldarg_2 );\n   ctorIL-&gt;Emit( OpCodes::Stfld, yField );\n   ctorIL-&gt;Emit( OpCodes::Ldarg_0 );\n   ctorIL-&gt;Emit( OpCodes::Ldarg_3 );\n   ctorIL-&gt;Emit( OpCodes::Stfld, zField );\n   ctorIL-&gt;Emit( OpCodes::Ret );\n   \n   // This method will find the dot product of the stored vector\n   // with another.\n   array&lt;Type^&gt;^temp1 = {ivTypeBld};\n   array&lt;Type^&gt;^dpParams = temp1;\n   \n   // Here, you create a MethodBuilder containing the\n   // name, the attributes (public, static, private, and so on),\n   // the return type (int, in this case), and a array of Type\n   // indicating the type of each parameter. Since the sole parameter\n   // is a IntVector, the very class you&#39;re creating, you will\n   // pass in the TypeBuilder (which is derived from Type) instead of\n   // a Type object for IntVector, avoiding an exception.\n   // -- This method would be declared in C# as:\n   //    public int DotProduct(IntVector aVector)\n   MethodBuilder^ dotProductMthd = ivTypeBld-&gt;DefineMethod( &quot;DotProduct&quot;, MethodAttributes::Public, int::typeid, dpParams );\n   \n   // A ILGenerator can now be spawned, attached to the MethodBuilder.\n   ILGenerator^ mthdIL = dotProductMthd-&gt;GetILGenerator();\n   \n   // Here&#39;s the body of our function, in MSIL form. We&#39;re going to find the\n   // &quot;dot product&quot; of the current vector instance with the passed vector\n   // instance. For reference purposes, the equation is:\n   // (x1 * x2) + (y1 * y2) + (z1 * z2) = the dot product\n   // First, you&#39;ll load the reference to the current instance &quot;this&quot;\n   // stored in argument 0 (ldarg.0) onto the stack. Ldfld, the subsequent\n   // instruction, will pop the reference off the stack and look up the\n   // field &quot;x&quot;, specified by the FieldInfo token &quot;xField&quot;.\n   mthdIL-&gt;Emit( OpCodes::Ldarg_0 );\n   mthdIL-&gt;Emit( OpCodes::Ldfld, xField );\n   \n   // That completed, the value stored at field &quot;x&quot; is now atop the stack.\n   // Now, you&#39;ll do the same for the Object reference we passed as a\n   // parameter, stored in argument 1 (ldarg.1). After Ldfld executed,\n   // you&#39;ll have the value stored in field &quot;x&quot; for the passed instance\n   // atop the stack.\n   mthdIL-&gt;Emit( OpCodes::Ldarg_1 );\n   mthdIL-&gt;Emit( OpCodes::Ldfld, xField );\n   \n   // There will now be two values atop the stack - the &quot;x&quot; value for the\n   // current vector instance, and the &quot;x&quot; value for the passed instance.\n   // You&#39;ll now multiply them, and push the result onto the evaluation stack.\n   mthdIL-&gt;Emit( OpCodes::Mul_Ovf_Un );\n   \n   // Now, repeat this for the &quot;y&quot; fields of both vectors.\n   mthdIL-&gt;Emit( OpCodes::Ldarg_0 );\n   mthdIL-&gt;Emit( OpCodes::Ldfld, yField );\n   mthdIL-&gt;Emit( OpCodes::Ldarg_1 );\n   mthdIL-&gt;Emit( OpCodes::Ldfld, yField );\n   mthdIL-&gt;Emit( OpCodes::Mul_Ovf_Un );\n   \n   // At this time, the results of both multiplications should be atop\n   // the stack. You&#39;ll now add them and push the result onto the stack.\n   mthdIL-&gt;Emit( OpCodes::Add_Ovf_Un );\n   \n   // Multiply both &quot;z&quot; field and push the result onto the stack.\n   mthdIL-&gt;Emit( OpCodes::Ldarg_0 );\n   mthdIL-&gt;Emit( OpCodes::Ldfld, zField );\n   mthdIL-&gt;Emit( OpCodes::Ldarg_1 );\n   mthdIL-&gt;Emit( OpCodes::Ldfld, zField );\n   mthdIL-&gt;Emit( OpCodes::Mul_Ovf_Un );\n   \n   // Finally, add the result of multiplying the &quot;z&quot; fields with the\n   // result of the earlier addition, and push the result - the dot product -\n   // onto the stack.\n   mthdIL-&gt;Emit( OpCodes::Add_Ovf_Un );\n   \n   // The &quot;ret&quot; opcode will pop the last value from the stack and return it\n   // to the calling method. You&#39;re all done!\n   mthdIL-&gt;Emit( OpCodes::Ret );\n   ivType = ivTypeBld-&gt;CreateType();\n   return ivType;\n}\n\nint main()\n{\n   Type^ IVType = nullptr;\n   Object^ aVector1 = nullptr;\n   Object^ aVector2 = nullptr;\n   array&lt;Type^&gt;^temp2 = {int::typeid,int::typeid,int::typeid};\n   array&lt;Type^&gt;^aVtypes = temp2;\n   array&lt;Object^&gt;^temp3 = {10,10,10};\n   array&lt;Object^&gt;^aVargs1 = temp3;\n   array&lt;Object^&gt;^temp4 = {20,20,20};\n   array&lt;Object^&gt;^aVargs2 = temp4;\n   \n   // Call the  method to build our dynamic class.\n   IVType = DynamicDotProductGen();\n   Console::WriteLine( &quot;---&quot; );\n   ConstructorInfo^ myDTctor = IVType-&gt;GetConstructor( aVtypes );\n   aVector1 = myDTctor-&gt;Invoke( aVargs1 );\n   aVector2 = myDTctor-&gt;Invoke( aVargs2 );\n   array&lt;Object^&gt;^passMe = gcnew array&lt;Object^&gt;(1);\n   passMe[ 0 ] = dynamic_cast&lt;Object^&gt;(aVector2);\n   Console::WriteLine( &quot;(10, 10, 10) . (20, 20, 20) = {0}&quot;, IVType-&gt;InvokeMember( &quot;DotProduct&quot;, BindingFlags::InvokeMethod, nullptr, aVector1, passMe ) );\n}\n\n// +++ OUTPUT +++\n// ---\n// (10, 10, 10) . (20, 20, 20) = 600\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Reflection.Emit ILGenerator Example#1\">Imports System\nImports System.Threading\nImports System.Reflection\nImports System.Reflection.Emit\n\n _\n\n\nClass TestILGenerator\n   \n   \n   Public Shared Function DynamicDotProductGen() As Type\n      \n      Dim ivType As Type = Nothing\n      Dim ctorParams() As Type = {GetType(Integer), GetType(Integer), GetType(Integer)}\n      \n      Dim myDomain As AppDomain = Thread.GetDomain()\n      Dim myAsmName As New AssemblyName()\n      myAsmName.Name = &quot;IntVectorAsm&quot;\n      \n      Dim myAsmBuilder As AssemblyBuilder = myDomain.DefineDynamicAssembly( _\n\t\t\t\t\t    myAsmName, _\n\t\t\t\t\t    AssemblyBuilderAccess.RunAndSave)\n      \n      Dim IntVectorModule As ModuleBuilder = myAsmBuilder.DefineDynamicModule( _\n\t\t\t\t\t     &quot;IntVectorModule&quot;, _\n\t\t\t\t\t     &quot;Vector.dll&quot;)\n      \n      Dim ivTypeBld As TypeBuilder = IntVectorModule.DefineType(&quot;IntVector&quot;, TypeAttributes.Public)\n      \n      Dim xField As FieldBuilder = ivTypeBld.DefineField(&quot;x&quot;, _\n\t\t\t\t\t\t         GetType(Integer), _\n\t\t\t\t\t\t         FieldAttributes.Private)\n      Dim yField As FieldBuilder = ivTypeBld.DefineField(&quot;y&quot;, _ \n\t\t\t\t\t\t         GetType(Integer), _\n\t\t\t\t\t\t         FieldAttributes.Private)\n      Dim zField As FieldBuilder = ivTypeBld.DefineField(&quot;z&quot;, _\n\t\t\t\t\t\t         GetType(Integer), _\n\t\t\t\t\t\t         FieldAttributes.Private)\n      \n      \n      Dim objType As Type = Type.GetType(&quot;System.Object&quot;)\n      Dim objCtor As ConstructorInfo = objType.GetConstructor(New Type() {})\n      \n      Dim ivCtor As ConstructorBuilder = ivTypeBld.DefineConstructor( _\n\t\t\t\t\t MethodAttributes.Public, _\n\t\t\t\t\t CallingConventions.Standard, _\n\t\t\t\t\t ctorParams)\n      Dim ctorIL As ILGenerator = ivCtor.GetILGenerator()\n      ctorIL.Emit(OpCodes.Ldarg_0)\n      ctorIL.Emit(OpCodes.Call, objCtor)\n      ctorIL.Emit(OpCodes.Ldarg_0)\n      ctorIL.Emit(OpCodes.Ldarg_1)\n      ctorIL.Emit(OpCodes.Stfld, xField)\n      ctorIL.Emit(OpCodes.Ldarg_0)\n      ctorIL.Emit(OpCodes.Ldarg_2)\n      ctorIL.Emit(OpCodes.Stfld, yField)\n      ctorIL.Emit(OpCodes.Ldarg_0)\n      ctorIL.Emit(OpCodes.Ldarg_3)\n      ctorIL.Emit(OpCodes.Stfld, zField)\n      ctorIL.Emit(OpCodes.Ret)\n     \n\n      &#39; Now, you&#39;ll construct the method find the dot product of two vectors. First,\n      &#39; let&#39;s define the parameters that will be accepted by the method. In this case,\n      &#39; it&#39;s an IntVector itself!\n\n      Dim dpParams() As Type = {ivTypeBld}\n      \n      &#39; Here, you create a MethodBuilder containing the\n      &#39; name, the attributes (public, static, private, and so on),\n      &#39; the return type (int, in this case), and a array of Type\n      &#39; indicating the type of each parameter. Since the sole parameter\n      &#39; is a IntVector, the very class you&#39;re creating, you will\n      &#39; pass in the TypeBuilder (which is derived from Type) instead of \n      &#39; a Type object for IntVector, avoiding an exception. \n      &#39; -- This method would be declared in VB.NET as:\n      &#39;    Public Function DotProduct(IntVector aVector) As Integer\n\n      Dim dotProductMthd As MethodBuilder = ivTypeBld.DefineMethod(&quot;DotProduct&quot;, _\n\t\t\t\t\t    MethodAttributes.Public, GetType(Integer), _\n                                            dpParams)\n      \n      &#39; A ILGenerator can now be spawned, attached to the MethodBuilder.\n      Dim mthdIL As ILGenerator = dotProductMthd.GetILGenerator()\n      \n      &#39; Here&#39;s the body of our function, in MSIL form. We&#39;re going to find the\n      &#39; &quot;dot product&quot; of the current vector instance with the passed vector \n      &#39; instance. For reference purposes, the equation is:\n      &#39; (x1 * x2) + (y1 * y2) + (z1 * z2) = the dot product\n      &#39; First, you&#39;ll load the reference to the current instance &quot;this&quot;\n      &#39; stored in argument 0 (ldarg.0) onto the stack. Ldfld, the subsequent\n      &#39; instruction, will pop the reference off the stack and look up the\n      &#39; field &quot;x&quot;, specified by the FieldInfo token &quot;xField&quot;.\n      mthdIL.Emit(OpCodes.Ldarg_0)\n      mthdIL.Emit(OpCodes.Ldfld, xField)\n      \n      &#39; That completed, the value stored at field &quot;x&quot; is now atop the stack.\n      &#39; Now, you&#39;ll do the same for the object reference we passed as a\n      &#39; parameter, stored in argument 1 (ldarg.1). After Ldfld executed,\n      &#39; you&#39;ll have the value stored in field &quot;x&quot; for the passed instance\n      &#39; atop the stack.\n      mthdIL.Emit(OpCodes.Ldarg_1)\n      mthdIL.Emit(OpCodes.Ldfld, xField)\n      \n      &#39; There will now be two values atop the stack - the &quot;x&quot; value for the\n      &#39; current vector instance, and the &quot;x&quot; value for the passed instance.\n      &#39; You&#39;ll now multiply them, and push the result onto the evaluation stack.\n      mthdIL.Emit(OpCodes.Mul_Ovf_Un)\n      \n      &#39; Now, repeat this for the &quot;y&quot; fields of both vectors.\n      mthdIL.Emit(OpCodes.Ldarg_0)\n      mthdIL.Emit(OpCodes.Ldfld, yField)\n      mthdIL.Emit(OpCodes.Ldarg_1)\n      mthdIL.Emit(OpCodes.Ldfld, yField)\n      mthdIL.Emit(OpCodes.Mul_Ovf_Un)\n      \n      &#39; At this time, the results of both multiplications should be atop\n      &#39; the stack. You&#39;ll now add them and push the result onto the stack.\n      mthdIL.Emit(OpCodes.Add_Ovf_Un)\n      \n      &#39; Multiply both &quot;z&quot; field and push the result onto the stack.\n      mthdIL.Emit(OpCodes.Ldarg_0)\n      mthdIL.Emit(OpCodes.Ldfld, zField)\n      mthdIL.Emit(OpCodes.Ldarg_1)\n      mthdIL.Emit(OpCodes.Ldfld, zField)\n      mthdIL.Emit(OpCodes.Mul_Ovf_Un)\n      \n      &#39; Finally, add the result of multiplying the &quot;z&quot; fields with the\n      &#39; result of the earlier addition, and push the result - the dot product -\n      &#39; onto the stack.\n      mthdIL.Emit(OpCodes.Add_Ovf_Un)\n      \n      &#39; The &quot;ret&quot; opcode will pop the last value from the stack and return it\n      &#39; to the calling method. You&#39;re all done!\n      mthdIL.Emit(OpCodes.Ret)\n      \n      \n      ivType = ivTypeBld.CreateType()\n      \n      Return ivType\n   End Function &#39;DynamicDotProductGen\n    \n   \n   Public Shared Sub Main()\n      \n      Dim IVType As Type = Nothing\n      Dim aVector1 As Object = Nothing\n      Dim aVector2 As Object = Nothing\n      Dim aVtypes() As Type = {GetType(Integer), GetType(Integer), GetType(Integer)}\n      Dim aVargs1() As Object = {10, 10, 10}\n      Dim aVargs2() As Object = {20, 20, 20}\n      \n      &#39; Call the  method to build our dynamic class.\n      IVType = DynamicDotProductGen()\n      \n      \n      Dim myDTctor As ConstructorInfo = IVType.GetConstructor(aVtypes)\n      aVector1 = myDTctor.Invoke(aVargs1)\n      aVector2 = myDTctor.Invoke(aVargs2)\n      \n      Console.WriteLine(&quot;---&quot;)\n      Dim passMe(0) As Object\n      passMe(0) = CType(aVector2, Object)\n      \n      Console.WriteLine(&quot;(10, 10, 10) . (20, 20, 20) = {0}&quot;, _\n                        IVType.InvokeMember(&quot;DotProduct&quot;, BindingFlags.InvokeMethod, _\n                        Nothing, aVector1, passMe))\n   End Sub &#39;Main\nEnd Class &#39;TestILGenerator\n\n\n\n&#39; +++ OUTPUT +++\n&#39; ---\n&#39; (10, 10, 10) . (20, 20, 20) = 600 \n\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Reflection.Emit ILGenerator Example#1\">\nusing System;\nusing System.Threading;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\n\nclass TestILGenerator {\n \n  \tpublic static Type DynamicDotProductGen() {\n\t  \n\t   Type ivType = null;\n\t   Type[] ctorParams = new Type[] { typeof(int),\n\t\t               \t\t    typeof(int),\n\t\t\t\t\t    typeof(int)};\n \t\n\t   AppDomain myDomain = Thread.GetDomain();\n\t   AssemblyName myAsmName = new AssemblyName();\n\t   myAsmName.Name = &quot;IntVectorAsm&quot;;\n\t\n\t   AssemblyBuilder myAsmBuilder = myDomain.DefineDynamicAssembly(\n\t\t\t\t\t  myAsmName, \n\t\t\t\t\t  AssemblyBuilderAccess.RunAndSave);\n\n   \t   ModuleBuilder IntVectorModule = myAsmBuilder.DefineDynamicModule(&quot;IntVectorModule&quot;,\n\t\t\t\t\t\t\t\t\t    &quot;Vector.dll&quot;);\n\n\t   TypeBuilder ivTypeBld = IntVectorModule.DefineType(&quot;IntVector&quot;,\n\t\t\t\t\t\t              TypeAttributes.Public);\n\n\t   FieldBuilder xField = ivTypeBld.DefineField(&quot;x&quot;, typeof(int),\n                                                       FieldAttributes.Private);\n\t   FieldBuilder yField = ivTypeBld.DefineField(&quot;y&quot;, typeof(int), \n                                                       FieldAttributes.Private);\n\t   FieldBuilder zField = ivTypeBld.DefineField(&quot;z&quot;, typeof(int),\n                                                       FieldAttributes.Private);\n\n\n           Type objType = Type.GetType(&quot;System.Object&quot;); \n           ConstructorInfo objCtor = objType.GetConstructor(new Type[0]);\n\n\t   ConstructorBuilder ivCtor = ivTypeBld.DefineConstructor(\n\t\t\t\t\t  MethodAttributes.Public,\n\t\t\t\t\t  CallingConventions.Standard,\n\t\t\t\t\t  ctorParams);\n\t   ILGenerator ctorIL = ivCtor.GetILGenerator();\n           ctorIL.Emit(OpCodes.Ldarg_0);\n           ctorIL.Emit(OpCodes.Call, objCtor);\n           ctorIL.Emit(OpCodes.Ldarg_0);\n           ctorIL.Emit(OpCodes.Ldarg_1);\n           ctorIL.Emit(OpCodes.Stfld, xField); \n           ctorIL.Emit(OpCodes.Ldarg_0);\n           ctorIL.Emit(OpCodes.Ldarg_2);\n           ctorIL.Emit(OpCodes.Stfld, yField); \n           ctorIL.Emit(OpCodes.Ldarg_0);\n           ctorIL.Emit(OpCodes.Ldarg_3);\n           ctorIL.Emit(OpCodes.Stfld, zField); \n\t   ctorIL.Emit(OpCodes.Ret); \n\n\n\t   // This method will find the dot product of the stored vector\n\t   // with another.\n\n\t   Type[] dpParams = new Type[] { ivTypeBld };\n\n           // Here, you create a MethodBuilder containing the\n\t   // name, the attributes (public, static, private, and so on),\n\t   // the return type (int, in this case), and a array of Type\n\t   // indicating the type of each parameter. Since the sole parameter\n\t   // is a IntVector, the very class you&#39;re creating, you will\n\t   // pass in the TypeBuilder (which is derived from Type) instead of \n\t   // a Type object for IntVector, avoiding an exception. \n\n\t   // -- This method would be declared in C# as:\n\t   //    public int DotProduct(IntVector aVector)\n\n           MethodBuilder dotProductMthd = ivTypeBld.DefineMethod(\n\t    \t\t                  &quot;DotProduct&quot;, \n\t\t\t\t          MethodAttributes.Public,\n                                          typeof(int), \n                                          dpParams);\n\n\t   // A ILGenerator can now be spawned, attached to the MethodBuilder.\n\n\t   ILGenerator mthdIL = dotProductMthd.GetILGenerator();\n\t   \n \t   // Here&#39;s the body of our function, in MSIL form. We&#39;re going to find the\n\t   // &quot;dot product&quot; of the current vector instance with the passed vector \n\t   // instance. For reference purposes, the equation is:\n\t   // (x1 * x2) + (y1 * y2) + (z1 * z2) = the dot product\n\n\t   // First, you&#39;ll load the reference to the current instance &quot;this&quot;\n\t   // stored in argument 0 (ldarg.0) onto the stack. Ldfld, the subsequent\n\t   // instruction, will pop the reference off the stack and look up the\n\t   // field &quot;x&quot;, specified by the FieldInfo token &quot;xField&quot;.\n\n\t   mthdIL.Emit(OpCodes.Ldarg_0);\n\t   mthdIL.Emit(OpCodes.Ldfld, xField);\n\n\t   // That completed, the value stored at field &quot;x&quot; is now atop the stack.\n\t   // Now, you&#39;ll do the same for the object reference we passed as a\n\t   // parameter, stored in argument 1 (ldarg.1). After Ldfld executed,\n\t   // you&#39;ll have the value stored in field &quot;x&quot; for the passed instance\n\t   // atop the stack.\n\n\t   mthdIL.Emit(OpCodes.Ldarg_1);\n\t   mthdIL.Emit(OpCodes.Ldfld, xField);\n\n           // There will now be two values atop the stack - the &quot;x&quot; value for the\n\t   // current vector instance, and the &quot;x&quot; value for the passed instance.\n\t   // You&#39;ll now multiply them, and push the result onto the evaluation stack.\n\n\t   mthdIL.Emit(OpCodes.Mul_Ovf_Un);\n\n\t   // Now, repeat this for the &quot;y&quot; fields of both vectors.\n\n\t   mthdIL.Emit(OpCodes.Ldarg_0);\n\t   mthdIL.Emit(OpCodes.Ldfld, yField);\n\t   mthdIL.Emit(OpCodes.Ldarg_1);\n\t   mthdIL.Emit(OpCodes.Ldfld, yField);\n\t   mthdIL.Emit(OpCodes.Mul_Ovf_Un);\n\n\t   // At this time, the results of both multiplications should be atop\n\t   // the stack. You&#39;ll now add them and push the result onto the stack.\n\n\t   mthdIL.Emit(OpCodes.Add_Ovf_Un);\n\n\t   // Multiply both &quot;z&quot; field and push the result onto the stack.\n\t   mthdIL.Emit(OpCodes.Ldarg_0);\n\t   mthdIL.Emit(OpCodes.Ldfld, zField);\n\t   mthdIL.Emit(OpCodes.Ldarg_1);\n\t   mthdIL.Emit(OpCodes.Ldfld, zField);\n\t   mthdIL.Emit(OpCodes.Mul_Ovf_Un);\n\n\t   // Finally, add the result of multiplying the &quot;z&quot; fields with the\n\t   // result of the earlier addition, and push the result - the dot product -\n\t   // onto the stack.\n\t   mthdIL.Emit(OpCodes.Add_Ovf_Un);\n\n\t   // The &quot;ret&quot; opcode will pop the last value from the stack and return it\n\t   // to the calling method. You&#39;re all done!\n\n\t   mthdIL.Emit(OpCodes.Ret);\n\n\n \t   ivType = ivTypeBld.CreateType();\n\n\t   return ivType;\n\n \t}\n\n\tpublic static void Main() {\n\t\n\t   Type IVType = null;\n           object aVector1 = null;\n           object aVector2 = null;\n\t   Type[] aVtypes = new Type[] {typeof(int), typeof(int), typeof(int)};\n           object[] aVargs1 = new object[] {10, 10, 10};\n           object[] aVargs2 = new object[] {20, 20, 20};\n\t\n\t   // Call the  method to build our dynamic class.\n\n\t   IVType = DynamicDotProductGen();\n\n           Console.WriteLine(&quot;---&quot;);\n\n\t   ConstructorInfo myDTctor = IVType.GetConstructor(aVtypes);\n\t   aVector1 = myDTctor.Invoke(aVargs1);\n\t   aVector2 = myDTctor.Invoke(aVargs2);\n\n\t   object[] passMe = new object[1];\n           passMe[0] = (object)aVector2; \n\n\t   Console.WriteLine(&quot;(10, 10, 10) . (20, 20, 20) = {0}&quot;,\n\t\t\t     IVType.InvokeMember(&quot;DotProduct&quot;,\n\t\t\t\t\t\t  BindingFlags.InvokeMethod,\n\t\t\t\t\t\t  null,\n\t\t\t\t\t\t  aVector1,\n\t\t\t\t\t\t  passMe));\n\n\t    \n\n\t   // +++ OUTPUT +++\n\t   // ---\n\t   // (10, 10, 10) . (20, 20, 20) = 600 \n\t    \n\t}\n    \n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_GetILGenerator_System_Int32_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_GetILGenerator_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetILGenerator(Int32)</div>        \r\n          </div>\r\n    \r\n            <p>Returns an <code>ILGenerator</code> for this method with the specified Microsoft intermediate language (MSIL) stream size.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.Emit.ILGenerator GetILGenerator (int size);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>size</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The size of the MSIL stream, in bytes.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.ilgenerator\" data-linktype=\"relative-path\">ILGenerator</a></div>\r\n                  </div>\r\n                  <p>Returns an <code>ILGenerator</code> object for this method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The method should not have a body because of its <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a> or <a class=\"xref\" href=\"system.reflection.methodimplattributes\" data-linktype=\"relative-path\">MethodImplAttributes</a> flags, for example because it has the <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a> flag.  </p>\n<p> -or-  </p>\n<p> The method is a generic method, but not a generic method definition. That is, the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethod*</span> property is <code>true</code>, but the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition*</span> property is <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The code sample below demonstrates the contextual usage of the <code>GetILGenerator</code> method, creating and emitting a dynamic assembly that will calculate the dot product of two points in 3D space.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Reflection.Emit ILGenerator Example#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Reflection;\nusing namespace System::Reflection::Emit;\nType^ DynamicDotProductGen()\n{\n   Type^ ivType = nullptr;\n   array&lt;Type^&gt;^temp0 = {int::typeid,int::typeid,int::typeid};\n   array&lt;Type^&gt;^ctorParams = temp0;\n   AppDomain^ myDomain = Thread::GetDomain();\n   AssemblyName^ myAsmName = gcnew AssemblyName;\n   myAsmName-&gt;Name = &quot;IntVectorAsm&quot;;\n   AssemblyBuilder^ myAsmBuilder = myDomain-&gt;DefineDynamicAssembly( myAsmName, AssemblyBuilderAccess::RunAndSave );\n   ModuleBuilder^ IntVectorModule = myAsmBuilder-&gt;DefineDynamicModule( &quot;IntVectorModule&quot;, &quot;Vector.dll&quot; );\n   TypeBuilder^ ivTypeBld = IntVectorModule-&gt;DefineType( &quot;IntVector&quot;, TypeAttributes::Public );\n   FieldBuilder^ xField = ivTypeBld-&gt;DefineField( &quot;x&quot;, int::typeid, FieldAttributes::Private );\n   FieldBuilder^ yField = ivTypeBld-&gt;DefineField( &quot;y&quot;, int::typeid, FieldAttributes::Private );\n   FieldBuilder^ zField = ivTypeBld-&gt;DefineField( &quot;z&quot;, int::typeid, FieldAttributes::Private );\n   Type^ objType = Type::GetType( &quot;System.Object&quot; );\n   ConstructorInfo^ objCtor = objType-&gt;GetConstructor( gcnew array&lt;Type^&gt;(0) );\n   ConstructorBuilder^ ivCtor = ivTypeBld-&gt;DefineConstructor( MethodAttributes::Public, CallingConventions::Standard, ctorParams );\n   ILGenerator^ ctorIL = ivCtor-&gt;GetILGenerator();\n   ctorIL-&gt;Emit( OpCodes::Ldarg_0 );\n   ctorIL-&gt;Emit( OpCodes::Call, objCtor );\n   ctorIL-&gt;Emit( OpCodes::Ldarg_0 );\n   ctorIL-&gt;Emit( OpCodes::Ldarg_1 );\n   ctorIL-&gt;Emit( OpCodes::Stfld, xField );\n   ctorIL-&gt;Emit( OpCodes::Ldarg_0 );\n   ctorIL-&gt;Emit( OpCodes::Ldarg_2 );\n   ctorIL-&gt;Emit( OpCodes::Stfld, yField );\n   ctorIL-&gt;Emit( OpCodes::Ldarg_0 );\n   ctorIL-&gt;Emit( OpCodes::Ldarg_3 );\n   ctorIL-&gt;Emit( OpCodes::Stfld, zField );\n   ctorIL-&gt;Emit( OpCodes::Ret );\n   \n   // This method will find the dot product of the stored vector\n   // with another.\n   array&lt;Type^&gt;^temp1 = {ivTypeBld};\n   array&lt;Type^&gt;^dpParams = temp1;\n   \n   // Here, you create a MethodBuilder containing the\n   // name, the attributes (public, static, private, and so on),\n   // the return type (int, in this case), and a array of Type\n   // indicating the type of each parameter. Since the sole parameter\n   // is a IntVector, the very class you&#39;re creating, you will\n   // pass in the TypeBuilder (which is derived from Type) instead of\n   // a Type object for IntVector, avoiding an exception.\n   // -- This method would be declared in C# as:\n   //    public int DotProduct(IntVector aVector)\n   MethodBuilder^ dotProductMthd = ivTypeBld-&gt;DefineMethod( &quot;DotProduct&quot;, MethodAttributes::Public, int::typeid, dpParams );\n   \n   // A ILGenerator can now be spawned, attached to the MethodBuilder.\n   ILGenerator^ mthdIL = dotProductMthd-&gt;GetILGenerator();\n   \n   // Here&#39;s the body of our function, in MSIL form. We&#39;re going to find the\n   // &quot;dot product&quot; of the current vector instance with the passed vector\n   // instance. For reference purposes, the equation is:\n   // (x1 * x2) + (y1 * y2) + (z1 * z2) = the dot product\n   // First, you&#39;ll load the reference to the current instance &quot;this&quot;\n   // stored in argument 0 (ldarg.0) onto the stack. Ldfld, the subsequent\n   // instruction, will pop the reference off the stack and look up the\n   // field &quot;x&quot;, specified by the FieldInfo token &quot;xField&quot;.\n   mthdIL-&gt;Emit( OpCodes::Ldarg_0 );\n   mthdIL-&gt;Emit( OpCodes::Ldfld, xField );\n   \n   // That completed, the value stored at field &quot;x&quot; is now atop the stack.\n   // Now, you&#39;ll do the same for the Object reference we passed as a\n   // parameter, stored in argument 1 (ldarg.1). After Ldfld executed,\n   // you&#39;ll have the value stored in field &quot;x&quot; for the passed instance\n   // atop the stack.\n   mthdIL-&gt;Emit( OpCodes::Ldarg_1 );\n   mthdIL-&gt;Emit( OpCodes::Ldfld, xField );\n   \n   // There will now be two values atop the stack - the &quot;x&quot; value for the\n   // current vector instance, and the &quot;x&quot; value for the passed instance.\n   // You&#39;ll now multiply them, and push the result onto the evaluation stack.\n   mthdIL-&gt;Emit( OpCodes::Mul_Ovf_Un );\n   \n   // Now, repeat this for the &quot;y&quot; fields of both vectors.\n   mthdIL-&gt;Emit( OpCodes::Ldarg_0 );\n   mthdIL-&gt;Emit( OpCodes::Ldfld, yField );\n   mthdIL-&gt;Emit( OpCodes::Ldarg_1 );\n   mthdIL-&gt;Emit( OpCodes::Ldfld, yField );\n   mthdIL-&gt;Emit( OpCodes::Mul_Ovf_Un );\n   \n   // At this time, the results of both multiplications should be atop\n   // the stack. You&#39;ll now add them and push the result onto the stack.\n   mthdIL-&gt;Emit( OpCodes::Add_Ovf_Un );\n   \n   // Multiply both &quot;z&quot; field and push the result onto the stack.\n   mthdIL-&gt;Emit( OpCodes::Ldarg_0 );\n   mthdIL-&gt;Emit( OpCodes::Ldfld, zField );\n   mthdIL-&gt;Emit( OpCodes::Ldarg_1 );\n   mthdIL-&gt;Emit( OpCodes::Ldfld, zField );\n   mthdIL-&gt;Emit( OpCodes::Mul_Ovf_Un );\n   \n   // Finally, add the result of multiplying the &quot;z&quot; fields with the\n   // result of the earlier addition, and push the result - the dot product -\n   // onto the stack.\n   mthdIL-&gt;Emit( OpCodes::Add_Ovf_Un );\n   \n   // The &quot;ret&quot; opcode will pop the last value from the stack and return it\n   // to the calling method. You&#39;re all done!\n   mthdIL-&gt;Emit( OpCodes::Ret );\n   ivType = ivTypeBld-&gt;CreateType();\n   return ivType;\n}\n\nint main()\n{\n   Type^ IVType = nullptr;\n   Object^ aVector1 = nullptr;\n   Object^ aVector2 = nullptr;\n   array&lt;Type^&gt;^temp2 = {int::typeid,int::typeid,int::typeid};\n   array&lt;Type^&gt;^aVtypes = temp2;\n   array&lt;Object^&gt;^temp3 = {10,10,10};\n   array&lt;Object^&gt;^aVargs1 = temp3;\n   array&lt;Object^&gt;^temp4 = {20,20,20};\n   array&lt;Object^&gt;^aVargs2 = temp4;\n   \n   // Call the  method to build our dynamic class.\n   IVType = DynamicDotProductGen();\n   Console::WriteLine( &quot;---&quot; );\n   ConstructorInfo^ myDTctor = IVType-&gt;GetConstructor( aVtypes );\n   aVector1 = myDTctor-&gt;Invoke( aVargs1 );\n   aVector2 = myDTctor-&gt;Invoke( aVargs2 );\n   array&lt;Object^&gt;^passMe = gcnew array&lt;Object^&gt;(1);\n   passMe[ 0 ] = dynamic_cast&lt;Object^&gt;(aVector2);\n   Console::WriteLine( &quot;(10, 10, 10) . (20, 20, 20) = {0}&quot;, IVType-&gt;InvokeMember( &quot;DotProduct&quot;, BindingFlags::InvokeMethod, nullptr, aVector1, passMe ) );\n}\n\n// +++ OUTPUT +++\n// ---\n// (10, 10, 10) . (20, 20, 20) = 600\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Reflection.Emit ILGenerator Example#1\">Imports System\nImports System.Threading\nImports System.Reflection\nImports System.Reflection.Emit\n\n _\n\n\nClass TestILGenerator\n   \n   \n   Public Shared Function DynamicDotProductGen() As Type\n      \n      Dim ivType As Type = Nothing\n      Dim ctorParams() As Type = {GetType(Integer), GetType(Integer), GetType(Integer)}\n      \n      Dim myDomain As AppDomain = Thread.GetDomain()\n      Dim myAsmName As New AssemblyName()\n      myAsmName.Name = &quot;IntVectorAsm&quot;\n      \n      Dim myAsmBuilder As AssemblyBuilder = myDomain.DefineDynamicAssembly( _\n\t\t\t\t\t    myAsmName, _\n\t\t\t\t\t    AssemblyBuilderAccess.RunAndSave)\n      \n      Dim IntVectorModule As ModuleBuilder = myAsmBuilder.DefineDynamicModule( _\n\t\t\t\t\t     &quot;IntVectorModule&quot;, _\n\t\t\t\t\t     &quot;Vector.dll&quot;)\n      \n      Dim ivTypeBld As TypeBuilder = IntVectorModule.DefineType(&quot;IntVector&quot;, TypeAttributes.Public)\n      \n      Dim xField As FieldBuilder = ivTypeBld.DefineField(&quot;x&quot;, _\n\t\t\t\t\t\t         GetType(Integer), _\n\t\t\t\t\t\t         FieldAttributes.Private)\n      Dim yField As FieldBuilder = ivTypeBld.DefineField(&quot;y&quot;, _ \n\t\t\t\t\t\t         GetType(Integer), _\n\t\t\t\t\t\t         FieldAttributes.Private)\n      Dim zField As FieldBuilder = ivTypeBld.DefineField(&quot;z&quot;, _\n\t\t\t\t\t\t         GetType(Integer), _\n\t\t\t\t\t\t         FieldAttributes.Private)\n      \n      \n      Dim objType As Type = Type.GetType(&quot;System.Object&quot;)\n      Dim objCtor As ConstructorInfo = objType.GetConstructor(New Type() {})\n      \n      Dim ivCtor As ConstructorBuilder = ivTypeBld.DefineConstructor( _\n\t\t\t\t\t MethodAttributes.Public, _\n\t\t\t\t\t CallingConventions.Standard, _\n\t\t\t\t\t ctorParams)\n      Dim ctorIL As ILGenerator = ivCtor.GetILGenerator()\n      ctorIL.Emit(OpCodes.Ldarg_0)\n      ctorIL.Emit(OpCodes.Call, objCtor)\n      ctorIL.Emit(OpCodes.Ldarg_0)\n      ctorIL.Emit(OpCodes.Ldarg_1)\n      ctorIL.Emit(OpCodes.Stfld, xField)\n      ctorIL.Emit(OpCodes.Ldarg_0)\n      ctorIL.Emit(OpCodes.Ldarg_2)\n      ctorIL.Emit(OpCodes.Stfld, yField)\n      ctorIL.Emit(OpCodes.Ldarg_0)\n      ctorIL.Emit(OpCodes.Ldarg_3)\n      ctorIL.Emit(OpCodes.Stfld, zField)\n      ctorIL.Emit(OpCodes.Ret)\n     \n\n      &#39; Now, you&#39;ll construct the method find the dot product of two vectors. First,\n      &#39; let&#39;s define the parameters that will be accepted by the method. In this case,\n      &#39; it&#39;s an IntVector itself!\n\n      Dim dpParams() As Type = {ivTypeBld}\n      \n      &#39; Here, you create a MethodBuilder containing the\n      &#39; name, the attributes (public, static, private, and so on),\n      &#39; the return type (int, in this case), and a array of Type\n      &#39; indicating the type of each parameter. Since the sole parameter\n      &#39; is a IntVector, the very class you&#39;re creating, you will\n      &#39; pass in the TypeBuilder (which is derived from Type) instead of \n      &#39; a Type object for IntVector, avoiding an exception. \n      &#39; -- This method would be declared in VB.NET as:\n      &#39;    Public Function DotProduct(IntVector aVector) As Integer\n\n      Dim dotProductMthd As MethodBuilder = ivTypeBld.DefineMethod(&quot;DotProduct&quot;, _\n\t\t\t\t\t    MethodAttributes.Public, GetType(Integer), _\n                                            dpParams)\n      \n      &#39; A ILGenerator can now be spawned, attached to the MethodBuilder.\n      Dim mthdIL As ILGenerator = dotProductMthd.GetILGenerator()\n      \n      &#39; Here&#39;s the body of our function, in MSIL form. We&#39;re going to find the\n      &#39; &quot;dot product&quot; of the current vector instance with the passed vector \n      &#39; instance. For reference purposes, the equation is:\n      &#39; (x1 * x2) + (y1 * y2) + (z1 * z2) = the dot product\n      &#39; First, you&#39;ll load the reference to the current instance &quot;this&quot;\n      &#39; stored in argument 0 (ldarg.0) onto the stack. Ldfld, the subsequent\n      &#39; instruction, will pop the reference off the stack and look up the\n      &#39; field &quot;x&quot;, specified by the FieldInfo token &quot;xField&quot;.\n      mthdIL.Emit(OpCodes.Ldarg_0)\n      mthdIL.Emit(OpCodes.Ldfld, xField)\n      \n      &#39; That completed, the value stored at field &quot;x&quot; is now atop the stack.\n      &#39; Now, you&#39;ll do the same for the object reference we passed as a\n      &#39; parameter, stored in argument 1 (ldarg.1). After Ldfld executed,\n      &#39; you&#39;ll have the value stored in field &quot;x&quot; for the passed instance\n      &#39; atop the stack.\n      mthdIL.Emit(OpCodes.Ldarg_1)\n      mthdIL.Emit(OpCodes.Ldfld, xField)\n      \n      &#39; There will now be two values atop the stack - the &quot;x&quot; value for the\n      &#39; current vector instance, and the &quot;x&quot; value for the passed instance.\n      &#39; You&#39;ll now multiply them, and push the result onto the evaluation stack.\n      mthdIL.Emit(OpCodes.Mul_Ovf_Un)\n      \n      &#39; Now, repeat this for the &quot;y&quot; fields of both vectors.\n      mthdIL.Emit(OpCodes.Ldarg_0)\n      mthdIL.Emit(OpCodes.Ldfld, yField)\n      mthdIL.Emit(OpCodes.Ldarg_1)\n      mthdIL.Emit(OpCodes.Ldfld, yField)\n      mthdIL.Emit(OpCodes.Mul_Ovf_Un)\n      \n      &#39; At this time, the results of both multiplications should be atop\n      &#39; the stack. You&#39;ll now add them and push the result onto the stack.\n      mthdIL.Emit(OpCodes.Add_Ovf_Un)\n      \n      &#39; Multiply both &quot;z&quot; field and push the result onto the stack.\n      mthdIL.Emit(OpCodes.Ldarg_0)\n      mthdIL.Emit(OpCodes.Ldfld, zField)\n      mthdIL.Emit(OpCodes.Ldarg_1)\n      mthdIL.Emit(OpCodes.Ldfld, zField)\n      mthdIL.Emit(OpCodes.Mul_Ovf_Un)\n      \n      &#39; Finally, add the result of multiplying the &quot;z&quot; fields with the\n      &#39; result of the earlier addition, and push the result - the dot product -\n      &#39; onto the stack.\n      mthdIL.Emit(OpCodes.Add_Ovf_Un)\n      \n      &#39; The &quot;ret&quot; opcode will pop the last value from the stack and return it\n      &#39; to the calling method. You&#39;re all done!\n      mthdIL.Emit(OpCodes.Ret)\n      \n      \n      ivType = ivTypeBld.CreateType()\n      \n      Return ivType\n   End Function &#39;DynamicDotProductGen\n    \n   \n   Public Shared Sub Main()\n      \n      Dim IVType As Type = Nothing\n      Dim aVector1 As Object = Nothing\n      Dim aVector2 As Object = Nothing\n      Dim aVtypes() As Type = {GetType(Integer), GetType(Integer), GetType(Integer)}\n      Dim aVargs1() As Object = {10, 10, 10}\n      Dim aVargs2() As Object = {20, 20, 20}\n      \n      &#39; Call the  method to build our dynamic class.\n      IVType = DynamicDotProductGen()\n      \n      \n      Dim myDTctor As ConstructorInfo = IVType.GetConstructor(aVtypes)\n      aVector1 = myDTctor.Invoke(aVargs1)\n      aVector2 = myDTctor.Invoke(aVargs2)\n      \n      Console.WriteLine(&quot;---&quot;)\n      Dim passMe(0) As Object\n      passMe(0) = CType(aVector2, Object)\n      \n      Console.WriteLine(&quot;(10, 10, 10) . (20, 20, 20) = {0}&quot;, _\n                        IVType.InvokeMember(&quot;DotProduct&quot;, BindingFlags.InvokeMethod, _\n                        Nothing, aVector1, passMe))\n   End Sub &#39;Main\nEnd Class &#39;TestILGenerator\n\n\n\n&#39; +++ OUTPUT +++\n&#39; ---\n&#39; (10, 10, 10) . (20, 20, 20) = 600 \n\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Reflection.Emit ILGenerator Example#1\">\nusing System;\nusing System.Threading;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\n\nclass TestILGenerator {\n \n  \tpublic static Type DynamicDotProductGen() {\n\t  \n\t   Type ivType = null;\n\t   Type[] ctorParams = new Type[] { typeof(int),\n\t\t               \t\t    typeof(int),\n\t\t\t\t\t    typeof(int)};\n \t\n\t   AppDomain myDomain = Thread.GetDomain();\n\t   AssemblyName myAsmName = new AssemblyName();\n\t   myAsmName.Name = &quot;IntVectorAsm&quot;;\n\t\n\t   AssemblyBuilder myAsmBuilder = myDomain.DefineDynamicAssembly(\n\t\t\t\t\t  myAsmName, \n\t\t\t\t\t  AssemblyBuilderAccess.RunAndSave);\n\n   \t   ModuleBuilder IntVectorModule = myAsmBuilder.DefineDynamicModule(&quot;IntVectorModule&quot;,\n\t\t\t\t\t\t\t\t\t    &quot;Vector.dll&quot;);\n\n\t   TypeBuilder ivTypeBld = IntVectorModule.DefineType(&quot;IntVector&quot;,\n\t\t\t\t\t\t              TypeAttributes.Public);\n\n\t   FieldBuilder xField = ivTypeBld.DefineField(&quot;x&quot;, typeof(int),\n                                                       FieldAttributes.Private);\n\t   FieldBuilder yField = ivTypeBld.DefineField(&quot;y&quot;, typeof(int), \n                                                       FieldAttributes.Private);\n\t   FieldBuilder zField = ivTypeBld.DefineField(&quot;z&quot;, typeof(int),\n                                                       FieldAttributes.Private);\n\n\n           Type objType = Type.GetType(&quot;System.Object&quot;); \n           ConstructorInfo objCtor = objType.GetConstructor(new Type[0]);\n\n\t   ConstructorBuilder ivCtor = ivTypeBld.DefineConstructor(\n\t\t\t\t\t  MethodAttributes.Public,\n\t\t\t\t\t  CallingConventions.Standard,\n\t\t\t\t\t  ctorParams);\n\t   ILGenerator ctorIL = ivCtor.GetILGenerator();\n           ctorIL.Emit(OpCodes.Ldarg_0);\n           ctorIL.Emit(OpCodes.Call, objCtor);\n           ctorIL.Emit(OpCodes.Ldarg_0);\n           ctorIL.Emit(OpCodes.Ldarg_1);\n           ctorIL.Emit(OpCodes.Stfld, xField); \n           ctorIL.Emit(OpCodes.Ldarg_0);\n           ctorIL.Emit(OpCodes.Ldarg_2);\n           ctorIL.Emit(OpCodes.Stfld, yField); \n           ctorIL.Emit(OpCodes.Ldarg_0);\n           ctorIL.Emit(OpCodes.Ldarg_3);\n           ctorIL.Emit(OpCodes.Stfld, zField); \n\t   ctorIL.Emit(OpCodes.Ret); \n\n\n\t   // This method will find the dot product of the stored vector\n\t   // with another.\n\n\t   Type[] dpParams = new Type[] { ivTypeBld };\n\n           // Here, you create a MethodBuilder containing the\n\t   // name, the attributes (public, static, private, and so on),\n\t   // the return type (int, in this case), and a array of Type\n\t   // indicating the type of each parameter. Since the sole parameter\n\t   // is a IntVector, the very class you&#39;re creating, you will\n\t   // pass in the TypeBuilder (which is derived from Type) instead of \n\t   // a Type object for IntVector, avoiding an exception. \n\n\t   // -- This method would be declared in C# as:\n\t   //    public int DotProduct(IntVector aVector)\n\n           MethodBuilder dotProductMthd = ivTypeBld.DefineMethod(\n\t    \t\t                  &quot;DotProduct&quot;, \n\t\t\t\t          MethodAttributes.Public,\n                                          typeof(int), \n                                          dpParams);\n\n\t   // A ILGenerator can now be spawned, attached to the MethodBuilder.\n\n\t   ILGenerator mthdIL = dotProductMthd.GetILGenerator();\n\t   \n \t   // Here&#39;s the body of our function, in MSIL form. We&#39;re going to find the\n\t   // &quot;dot product&quot; of the current vector instance with the passed vector \n\t   // instance. For reference purposes, the equation is:\n\t   // (x1 * x2) + (y1 * y2) + (z1 * z2) = the dot product\n\n\t   // First, you&#39;ll load the reference to the current instance &quot;this&quot;\n\t   // stored in argument 0 (ldarg.0) onto the stack. Ldfld, the subsequent\n\t   // instruction, will pop the reference off the stack and look up the\n\t   // field &quot;x&quot;, specified by the FieldInfo token &quot;xField&quot;.\n\n\t   mthdIL.Emit(OpCodes.Ldarg_0);\n\t   mthdIL.Emit(OpCodes.Ldfld, xField);\n\n\t   // That completed, the value stored at field &quot;x&quot; is now atop the stack.\n\t   // Now, you&#39;ll do the same for the object reference we passed as a\n\t   // parameter, stored in argument 1 (ldarg.1). After Ldfld executed,\n\t   // you&#39;ll have the value stored in field &quot;x&quot; for the passed instance\n\t   // atop the stack.\n\n\t   mthdIL.Emit(OpCodes.Ldarg_1);\n\t   mthdIL.Emit(OpCodes.Ldfld, xField);\n\n           // There will now be two values atop the stack - the &quot;x&quot; value for the\n\t   // current vector instance, and the &quot;x&quot; value for the passed instance.\n\t   // You&#39;ll now multiply them, and push the result onto the evaluation stack.\n\n\t   mthdIL.Emit(OpCodes.Mul_Ovf_Un);\n\n\t   // Now, repeat this for the &quot;y&quot; fields of both vectors.\n\n\t   mthdIL.Emit(OpCodes.Ldarg_0);\n\t   mthdIL.Emit(OpCodes.Ldfld, yField);\n\t   mthdIL.Emit(OpCodes.Ldarg_1);\n\t   mthdIL.Emit(OpCodes.Ldfld, yField);\n\t   mthdIL.Emit(OpCodes.Mul_Ovf_Un);\n\n\t   // At this time, the results of both multiplications should be atop\n\t   // the stack. You&#39;ll now add them and push the result onto the stack.\n\n\t   mthdIL.Emit(OpCodes.Add_Ovf_Un);\n\n\t   // Multiply both &quot;z&quot; field and push the result onto the stack.\n\t   mthdIL.Emit(OpCodes.Ldarg_0);\n\t   mthdIL.Emit(OpCodes.Ldfld, zField);\n\t   mthdIL.Emit(OpCodes.Ldarg_1);\n\t   mthdIL.Emit(OpCodes.Ldfld, zField);\n\t   mthdIL.Emit(OpCodes.Mul_Ovf_Un);\n\n\t   // Finally, add the result of multiplying the &quot;z&quot; fields with the\n\t   // result of the earlier addition, and push the result - the dot product -\n\t   // onto the stack.\n\t   mthdIL.Emit(OpCodes.Add_Ovf_Un);\n\n\t   // The &quot;ret&quot; opcode will pop the last value from the stack and return it\n\t   // to the calling method. You&#39;re all done!\n\n\t   mthdIL.Emit(OpCodes.Ret);\n\n\n \t   ivType = ivTypeBld.CreateType();\n\n\t   return ivType;\n\n \t}\n\n\tpublic static void Main() {\n\t\n\t   Type IVType = null;\n           object aVector1 = null;\n           object aVector2 = null;\n\t   Type[] aVtypes = new Type[] {typeof(int), typeof(int), typeof(int)};\n           object[] aVargs1 = new object[] {10, 10, 10};\n           object[] aVargs2 = new object[] {20, 20, 20};\n\t\n\t   // Call the  method to build our dynamic class.\n\n\t   IVType = DynamicDotProductGen();\n\n           Console.WriteLine(&quot;---&quot;);\n\n\t   ConstructorInfo myDTctor = IVType.GetConstructor(aVtypes);\n\t   aVector1 = myDTctor.Invoke(aVargs1);\n\t   aVector2 = myDTctor.Invoke(aVargs2);\n\n\t   object[] passMe = new object[1];\n           passMe[0] = (object)aVector2; \n\n\t   Console.WriteLine(&quot;(10, 10, 10) . (20, 20, 20) = {0}&quot;,\n\t\t\t     IVType.InvokeMember(&quot;DotProduct&quot;,\n\t\t\t\t\t\t  BindingFlags.InvokeMethod,\n\t\t\t\t\t\t  null,\n\t\t\t\t\t\t  aVector1,\n\t\t\t\t\t\t  passMe));\n\n\t    \n\n\t   // +++ OUTPUT +++\n\t   // ---\n\t   // (10, 10, 10) . (20, 20, 20) = 600 \n\t    \n\t}\n    \n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_GetMethodImplementationFlags\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_GetMethodImplementationFlags_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetMethodImplementationFlags()</div>        \r\n          </div>\r\n    \r\n            <p>Returns the implementation flags for the method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodimplattributes\" data-linktype=\"relative-path\">MethodImplAttributes</a></div>\r\n                  </div>\r\n                  <p>Returns the implementation flags for the method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_GetModule\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_GetModule_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetModule()</div>        \r\n          </div>\r\n    \r\n            <p>Returns a reference to the module that contains this method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.Module GetModule ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.module\" data-linktype=\"relative-path\">Module</a></div>\r\n                  </div>\r\n                  <p>Returns a reference to the module that contains this method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The sample code below illustrates the usage of the <code>GetModule</code> method to retrieve information about a dynamically-generated module.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Reflection.Emit.MethodBuilder.GetModule#1\">\tModuleBuilder myModBuilder = myAsmBuilder.DefineDynamicModule(&quot;MathFunctions&quot;);\n\n\tTypeBuilder myTypeBuilder = myModBuilder.DefineType(&quot;MyMathFunctions&quot;,\n\t\t\t\t\tTypeAttributes.Public);\n\n\tMethodBuilder myMthdBuilder = myTypeBuilder.DefineMethod(&quot;Adder&quot;,\n\t\t\t\t\tMethodAttributes.Public,\n\t\t\t\t\ttypeof(int),\n\t\t\t\t\tnew Type[] { typeof(int),\n\t\t\t\t\t\t     typeof(int) });\n\n\t// Create body via ILGenerator here ...\n\n\tType myNewType = myTypeBuilder.CreateType();\n\n\tModule myModule = myMthdBuilder.GetModule();\n\n \tType[] myModTypes = myModule.GetTypes();\n\tConsole.WriteLine(&quot;Module: {0}&quot;, myModule.Name);\n\tConsole.WriteLine(&quot;------- with path {0}&quot;, myModule.FullyQualifiedName);\n\tConsole.WriteLine(&quot;------- in assembly {0}&quot;, myModule.Assembly.FullName);\n\tforeach (Type myModType in myModTypes)\n        {\n\t\tConsole.WriteLine(&quot;------- has type {0}&quot;, myModType.FullName);\n\t}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Reflection.Emit.MethodBuilder.GetModule#1\">\n      Dim myModBuilder As ModuleBuilder = myAsmBuilder.DefineDynamicModule(&quot;MathFunctions&quot;)\n      \n      Dim myTypeBuilder As TypeBuilder = myModBuilder.DefineType(&quot;MyMathFunctions&quot;, _\n\t\t\t\t\t\t\t\tTypeAttributes.Public)\n      \n      Dim myMthdBuilder As MethodBuilder = myTypeBuilder.DefineMethod(&quot;Adder&quot;, _\n\t\t\t\t\tMethodAttributes.Public, GetType(Integer), _\n\t\t\t\t\tNew Type() {GetType(Integer), GetType(Integer)})\n      \n      &#39; Create body via ILGenerator here ...\n\n      Dim myNewType As Type = myTypeBuilder.CreateType()\n      \n      Dim myModule As [Module] = myMthdBuilder.GetModule()\n      \n      Dim myModTypes As Type() = myModule.GetTypes()\n      Console.WriteLine(&quot;Module: {0}&quot;, myModule.Name)\n      Console.WriteLine(&quot;------- with path {0}&quot;, myModule.FullyQualifiedName)\n      Console.WriteLine(&quot;------- in assembly {0}&quot;, myModule.Assembly.FullName)\n      Dim myModType As Type\n      For Each myModType In  myModTypes\n         Console.WriteLine(&quot;------- has type {0}&quot;, myModType.FullName)\n      Next myModType\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Reflection.Emit.MethodBuilder.GetModule#1\">      ModuleBuilder^ myModBuilder = myAsmBuilder-&gt;DefineDynamicModule( &quot;MathFunctions&quot; );\n      TypeBuilder^ myTypeBuilder = myModBuilder-&gt;DefineType( &quot;MyMathFunctions&quot;, TypeAttributes::Public );\n      array&lt;Type^&gt;^temp0 = {int::typeid,int::typeid};\n      MethodBuilder^ myMthdBuilder = myTypeBuilder-&gt;DefineMethod( &quot;Adder&quot;, MethodAttributes::Public, int::typeid, temp0 );\n      \n      // Create body via ILGenerator here ...\n      Type^ myNewType = myTypeBuilder-&gt;CreateType();\n      Module^ myModule = myMthdBuilder-&gt;GetModule();\n      array&lt;Type^&gt;^myModTypes = myModule-&gt;GetTypes();\n      Console::WriteLine( &quot;Module: {0}&quot;, myModule-&gt;Name );\n      Console::WriteLine( &quot;------- with path {0}&quot;, myModule-&gt;FullyQualifiedName );\n      Console::WriteLine( &quot;------- in assembly {0}&quot;, myModule-&gt;Assembly-&gt;FullName );\n      System::Collections::IEnumerator^ myEnum = myModTypes-&gt;GetEnumerator();\n      while ( myEnum-&gt;MoveNext() )\n      {\n         Type^ myModType = safe_cast&lt;Type^&gt;(myEnum-&gt;Current);\n         Console::WriteLine( &quot;------- has type {0}&quot;, myModType-&gt;FullName );\n      }\n   }\n\n};\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_GetParameters\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_GetParameters_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetParameters()</div>        \r\n          </div>\r\n    \r\n            <p>Returns the parameters of this method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override System.Reflection.ParameterInfo[] GetParameters ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.parameterinfo\" data-linktype=\"relative-path\">ParameterInfo</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <code>ParameterInfo</code> objects that represent the parameters of the method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>This method is not currently supported. Retrieve the method using <span class=\"xref\">stem.Type.GetMethod*</span> and call <code>GetParameters</code> on the returned <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The code sample below illustrates the use of <code>GetParameters</code> to discover information on the parameters passed to a dynamically-generated method.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Reflection.Emit.MethodBuilder.GetParameters Example#1\">      TypeBuilder^ myType1 = myModBuilder-&gt;DefineType( &quot;MyMathFunctions&quot;, TypeAttributes::Public );\n      array&lt;Type^&gt;^temp0 = {Type::GetType( &quot;System.Int32&amp;&quot; ),int::typeid};\n      MethodBuilder^ myMthdBuilder = myType1-&gt;DefineMethod( &quot;AddToRefValue&quot;, MethodAttributes::Public, void::typeid, temp0 );\n      ParameterBuilder^ myParam1 = myMthdBuilder-&gt;DefineParameter( 1, ParameterAttributes::Out, &quot;thePool&quot; );\n      ParameterBuilder^ myParam2 = myMthdBuilder-&gt;DefineParameter( 2, ParameterAttributes::In, &quot;addMeToPool&quot; );\n      \n      // Create body via ILGenerator here, and complete the type.\n      array&lt;ParameterInfo^&gt;^myParams = myMthdBuilder-&gt;GetParameters();\n      Console::WriteLine( &quot;Method: {0}&quot;, myMthdBuilder-&gt;Name );\n\n      for each (ParameterInfo^ myParam in myParams)\n      {\n         Console::WriteLine(&quot;------- Parameter: {0} {1} at pos {2}, with attribute {3}&quot;, \n            myParam-&gt;ParameterType, myParam-&gt;Name, myParam-&gt;Position,\n                  myParam-&gt;Attributes.ToString());\n      }\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Reflection.Emit.MethodBuilder.GetParameters Example#1\">      Dim myType1 As TypeBuilder = myModBuilder.DefineType(&quot;MyMathFunctions&quot;, _\n\t\t\t\t\t\t\tTypeAttributes.Public)\n      \n      Dim myMthdBuilder As MethodBuilder = myType1.DefineMethod(&quot;AddToRefValue&quot;, _\n\t\t\t\tMethodAttributes.Public, Nothing, _\n\t\t\t\tNew Type() {Type.GetType(&quot;System.Int32&amp;&quot;), GetType(Integer)})\n\n      Dim myParam1 As ParameterBuilder = myMthdBuilder.DefineParameter(1, _\n\t\t\t\t\t\tParameterAttributes.Out, &quot;thePool&quot;)\n\n      Dim myParam2 As ParameterBuilder = myMthdBuilder.DefineParameter(2, _\n\t\t\t\t\t\tParameterAttributes.In, &quot;addMeToPool&quot;)\n      \n      &#39; Create body via ILGenerator here, and complete the type.\n\n      Dim myParams As ParameterInfo() = myMthdBuilder.GetParameters()\n      \n      Console.WriteLine(&quot;Method: {0}&quot;, myMthdBuilder.Name)\n      \n      Dim myParam As ParameterInfo\n      For Each myParam In  myParams\n         Console.WriteLine(&quot;------- Parameter: {0} {1} at pos {2}, with attribute {3}&quot;, _\n\t\t\t\tmyParam.ParameterType, myParam.Name, myParam.Position, _\n\t\t\t\tmyParam.Attributes.ToString())\n      Next myParam\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Reflection.Emit.MethodBuilder.GetParameters Example#1\">\n\tTypeBuilder myType1 = myModBuilder.DefineType(&quot;MyMathFunctions&quot;,\n\t\t\t\t\tTypeAttributes.Public);\n\n\tMethodBuilder myMthdBuilder = myType1.DefineMethod(&quot;AddToRefValue&quot;,\n\t\t\t\t\tMethodAttributes.Public,\n\t\t\t\t\ttypeof(void),\n\t\t\t\t\tnew Type[] { Type.GetType(&quot;System.Int32&amp;&quot;),\n\t\t\t\t\t\t     typeof(int) });\n\tParameterBuilder myParam1 = myMthdBuilder.DefineParameter(1,\n\t\t\t\t\tParameterAttributes.Out,\n\t\t\t\t\t&quot;thePool&quot;);\n\tParameterBuilder myParam2 = myMthdBuilder.DefineParameter(2,\n\t\t\t\t\tParameterAttributes.In,\n\t\t\t\t\t&quot;addMeToPool&quot;);\n\n\t// Create body via ILGenerator here, and complete the type.\n\n\tParameterInfo[] myParams = myMthdBuilder.GetParameters();\n\n\tConsole.WriteLine(&quot;Method: {0}&quot;, myMthdBuilder.Name);\n\n\tforeach (ParameterInfo myParam in myParams)\n        {\n\t   Console.WriteLine(&quot;------- Parameter: {0} {1} at pos {2}, with attribute {3}&quot;, \n\t\t\t     myParam.ParameterType, myParam.Name, myParam.Position,\n\t\t\t     myParam.Attributes.ToString());\n\n        }\n\t\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_GetToken\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_GetToken_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetToken()</div>        \r\n          </div>\r\n    \r\n            <p>Returns the <code>MethodToken</code> that represents the token for this method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.Emit.MethodToken GetToken ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.methodtoken\" data-linktype=\"relative-path\">MethodToken</a></div>\r\n                  </div>\r\n                  <p>Returns the <code>MethodToken</code> of this method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_Invoke_System_Object_System_Reflection_BindingFlags_System_Reflection_Binder_System_Object___System_Globalization_CultureInfo_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_Invoke_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Invoke(Object,BindingFlags,Binder,Object[],CultureInfo)</div>        \r\n          </div>\r\n    \r\n            <p>Dynamically invokes the method reflected by this instance on the given object, passing along the specified parameters, and under the constraints of the given binder.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>obj</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object on which to invoke the specified method. If the method is static, this parameter is ignored.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>invokeAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>This must be a bit flag from <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> : <code>InvokeMethod</code>, <code>NonPublic</code>, and so on.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>binder</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of MemberInfo objects via reflection. If binder is <code>null</code>, the default binder is used. For more details, see <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>parameters</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An argument list. This is an array of arguments with the same number, order, and type as the parameters of the method to be invoked. If there are no parameters this should be <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>culture</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.globalization.cultureinfo\" data-linktype=\"relative-path\">CultureInfo</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An instance of <a class=\"xref\" href=\"system.globalization.cultureinfo\" data-linktype=\"relative-path\">CultureInfo</a> used to govern the coercion of types. If this is null, the <a class=\"xref\" href=\"system.globalization.cultureinfo\" data-linktype=\"relative-path\">CultureInfo</a> for the current thread is used. (Note that this is necessary to, for example, convert a <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a> that represents 1000 to a <a class=\"xref\" href=\"system.double\" data-linktype=\"relative-path\">Double</a> value, since 1000 is represented differently by different cultures.)</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></div>\r\n                  </div>\r\n                  <p>Returns an object containing the return value of the invoked method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>This method is not currently supported. Retrieve the method using <span class=\"xref\">stem.Type.GetMethod*</span> and call <span class=\"xref\">stem.Type.InvokeMember*</span> on the returned <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the method is static, the <code>obj</code> parameter is ignored. For non-static methods, <code>obj</code> should be an instance of a class that inherits or declares the method and must be the same type as this class. If the method has no parameters, the value of <code>parameters</code> should be <code>null</code>. Otherwise the number, type, and order of elements in the parameters array should be identical to the number, type, and order of parameters for the method reflected by this instance.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Access restrictions are ignored for fully-trusted code. That is, private constructors, methods, fields, and properties can be accessed and invoked using Reflection whenever the code is fully-trusted.</p>\n</div>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_IsDefined_System_Type_System_Boolean_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_IsDefined_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsDefined(Type,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Checks if the specified custom attribute type is defined.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override bool IsDefined (Type attributeType, bool inherit);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>attributeType</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The custom attribute type.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>inherit</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Specifies whether to search this member&#39;s inheritance chain to find the custom attributes.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the specified custom attribute type is defined; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>This method is not currently supported. Retrieve the method using <span class=\"xref\">stem.Type.GetMethod*</span> and call <span class=\"xref\">stem.Reflection.MemberInfo.IsDefined*</span> on the returned <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_MakeGenericMethod_System_Type___\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_MakeGenericMethod_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">MakeGenericMethod(Type[])</div>        \r\n          </div>\r\n    \r\n            <p>Returns a generic method constructed from the current generic method definition using the specified generic type arguments.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override System.Reflection.MethodInfo MakeGenericMethod (Type[] typeArguments);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>typeArguments</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects that represent the type arguments for the generic method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">System.Reflection.MethodInfo</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> representing the generic method constructed from the current generic method definition using the specified generic type arguments.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>When you are emitting dynamic code, you might need to emit a call to a method constructed from the generic method definition represented by a <a class=\"xref\" href=\"system.reflection.emit.methodbuilder\" data-linktype=\"relative-path\">MethodBuilder</a>, before the enclosing type has been completed. You can use the MakeGenericMethod method to create a <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> for such a constructed method, and use the <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> in the emitted call.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example creates a constructed method from an incomplete generic method definition in an incomplete type.  </p>\n<p> The example creates a transient assembly and module with a single type, adds a method <code>M</code>, and makes the method generic by adding a type parameter T using the <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_DefineGenericParameters_\" data-linktype=\"relative-path\">DefineGenericParameters</a> method. The type parameter is used as the type of the method&#39;s parameter, and also as its return type. The generic method definition is not given a body, and the enclosing type is not completed. The MakeGenericMethod method is then used to make the constructed method <code>M&lt;String&gt;</code> (<code>M(Of String)</code> in Visual Basic). The example code has no output, because the subclass of <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> returned by the MakeGenericMethod method does not allow reflection over its parameters.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> For another code example that uses MakeGenericMethod, see <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_DefineGenericParameters_\" data-linktype=\"relative-path\">DefineGenericParameters</a>. MakeGenericMethod is also used extensively when emitting code that uses generic types. See <a href=\"../Topic/How%20to:%20Define%20a%20Generic%20Method%20with%20Reflection%20Emit.md\" data-linktype=\"relative-path\">How to: Define a Generic Method with Reflection Emit</a>.  </p>\n</div>\n<pre><code class=\"lang-cs\" name=\"MethodBuilder.MakeGenericMethod#1\">using System;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\nclass Example\n{\n    public static void Main()\n    {\n        // Define a transient dynamic assembly (only to run, not\n        // to save) with one module and a type &quot;Test&quot;.\n        // \n        AssemblyName aName = new AssemblyName(&quot;MyDynamic&quot;);\n        AssemblyBuilder ab = \n            AppDomain.CurrentDomain.DefineDynamicAssembly(\n                aName, \n                AssemblyBuilderAccess.Run);\n        ModuleBuilder mb = ab.DefineDynamicModule(aName.Name);\n        TypeBuilder tb = mb.DefineType(&quot;Test&quot;);\n\n        // Add a public static method &quot;M&quot; to Test, and make it a\n        // generic method with one type parameter named &quot;T&quot;).\n        //\n        MethodBuilder meb = tb.DefineMethod(&quot;M&quot;, \n            MethodAttributes.Public | MethodAttributes.Static);\n        GenericTypeParameterBuilder[] typeParams = \n            meb.DefineGenericParameters(new string[] { &quot;T&quot; });\n\n        // Give the method one parameter, of type T, and a \n        // return type of T.\n        meb.SetParameters(typeParams);\n        meb.SetReturnType(typeParams[0]);\n\n        // Create a MethodInfo for M&lt;string&gt;, which can be used in\n        // emitted code. This is possible even though the method\n        // does not yet have a body, and the enclosing type is not\n        // created.\n        MethodInfo mi = meb.MakeGenericMethod(typeof(string));\n        // Note that this is actually a subclass of MethodInfo, \n        // which has rather limited capabilities -- for\n        // example, you cannot reflect on its parameters.\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"MethodBuilder.MakeGenericMethod#1\">Imports System\nImports System.Reflection\nImports System.Reflection.Emit\n\nClass Example\n\n    Public Shared Sub Main()\n    \n        &#39; Define a transient dynamic assembly (only to run, not\n        &#39; to save) with one module and a type &quot;Test&quot;.\n        &#39; \n        Dim aName As AssemblyName = New AssemblyName(&quot;MyDynamic&quot;)\n        Dim ab As AssemblyBuilder = _\n            AppDomain.CurrentDomain.DefineDynamicAssembly( _\n                aName, _\n                AssemblyBuilderAccess.Run)\n        Dim mb As ModuleBuilder = ab.DefineDynamicModule(aName.Name)\n        Dim tb As TypeBuilder = mb.DefineType(&quot;Test&quot;)\n\n        &#39; Add a Public Shared method &quot;M&quot; to Test, and make it a\n        &#39; generic method with one type parameter named &quot;T&quot;).\n        &#39;\n        Dim meb As MethodBuilder = tb.DefineMethod(&quot;M&quot;, _\n            MethodAttributes.Public Or MethodAttributes.Static)\n        Dim typeParams() As GenericTypeParameterBuilder = _\n            meb.DefineGenericParameters(New String() { &quot;T&quot; })\n\n        &#39; Give the method one parameter, of type T, and a \n        &#39; return type of T.\n        meb.SetParameters(typeParams)\n        meb.SetReturnType(typeParams(0))\n\n        &#39; Create a MethodInfo for M(Of String), which can be used \n        &#39; in emitted code. This is possible even though the method\n        &#39; does not yet have a body, and the enclosing type is not\n        &#39; created.\n        Dim mi As MethodInfo = _\n            meb.MakeGenericMethod(GetType(String))\n        &#39; Note that this is actually a subclass of MethodInfo, \n        &#39; which has rather limited capabilities -- for\n        &#39; example, you cannot reflect on its parameters.\n    End Sub\nEnd Class\n</code></pre><pre><code class=\"lang-cpp\" name=\"MethodBuilder.MakeGenericMethod#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Reflection::Emit;\n\nvoid main()\n{\n    // Define a transient dynamic assembly (only to run, not\n    // to save) with one module and a type &quot;Test&quot;.\n    // \n    AssemblyName^ aName = gcnew AssemblyName(&quot;MyDynamic&quot;);\n    AssemblyBuilder^ ab = \n        AppDomain::CurrentDomain-&gt;DefineDynamicAssembly(\n            aName, \n            AssemblyBuilderAccess::Run);\n    ModuleBuilder^ mb = ab-&gt;DefineDynamicModule(aName-&gt;Name);\n    TypeBuilder^ tb = mb-&gt;DefineType(&quot;Test&quot;);\n\n    // Add a public static method &quot;M&quot; to Test, and make it a\n    // generic method with one type parameter named &quot;T&quot;).\n    //\n    MethodBuilder^ meb = tb-&gt;DefineMethod(&quot;M&quot;, \n        MethodAttributes::Public | MethodAttributes::Static);\n    array&lt;GenericTypeParameterBuilder^&gt;^ typeParams = \n        meb-&gt;DefineGenericParameters(gcnew array&lt;String^&gt; { &quot;T&quot; });\n\n    // Give the method one parameter, of type T, and a \n    // return type of T.\n    meb-&gt;SetParameters(typeParams);\n    meb-&gt;SetReturnType(typeParams[0]);\n\n    // Create a MethodInfo for M&lt;string&gt;, which can be used in\n    // emitted code. This is possible even though the method\n    // does not yet have a body, and the enclosing type is not\n    // created.\n    MethodInfo^ mi = meb-&gt;MakeGenericMethod(String::typeid);\n    // Note that this is actually a subclass of MethodInfo, \n    // which has rather limited capabilities -- for\n    // example, you cannot reflect on its parameters.\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_SetCustomAttribute_System_Reflection_Emit_CustomAttributeBuilder_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_SetCustomAttribute_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">SetCustomAttribute(CustomAttributeBuilder)</div>        \r\n          </div>\r\n    \r\n            <p>Sets a custom attribute using a custom attribute builder.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void SetCustomAttribute (System.Reflection.Emit.CustomAttributeBuilder customBuilder);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>customBuilder</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.customattributebuilder\" data-linktype=\"relative-path\">CustomAttributeBuilder</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An instance of a helper class to describe the custom attribute.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>customBuilder</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>For the current method, the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethod*</span> property is <code>true</code>, but the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition*</span> property is <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_SetCustomAttribute_\" data-linktype=\"relative-path\">SetCustomAttribute</a> method can interact with the <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_SetImplementationFlags_\" data-linktype=\"relative-path\">SetImplementationFlags</a> method when the two methods are used in combination. See the Remarks section of the <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_SetImplementationFlags_\" data-linktype=\"relative-path\">SetImplementationFlags</a> method for details.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_SetCustomAttribute_System_Reflection_ConstructorInfo_System_Byte___\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_SetCustomAttribute_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">SetCustomAttribute(ConstructorInfo,Byte[])</div>        \r\n          </div>\r\n    \r\n            <p>Sets a custom attribute using a specified custom attribute blob.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void SetCustomAttribute (System.Reflection.ConstructorInfo con, byte[] binaryAttribute);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>con</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The constructor for the custom attribute.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>binaryAttribute</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.byte\" data-linktype=\"relative-path\">Byte</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A byte blob representing the attributes.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>con</code> or <code>binaryAttribute</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>For the current method, the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethod*</span> property is <code>true</code>, but the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition*</span> property is <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>For details on how to format <code>binaryAttribute</code>, see the Common Language Infrastructure (CLI) documentation, especially &quot;Partition II: Metadata Definition and Semantics&quot;. The documentation is available online; see <a href=\"http://go.microsoft.com/fwlink/?LinkID=99212\" data-linktype=\"external\">ECMA C# and Common Language Infrastructure Standards</a> on MSDN and <a href=\"http://go.microsoft.com/fwlink/?LinkID=65552\" data-linktype=\"external\">Standard ECMA-335 - Common Language Infrastructure (CLI)</a> on the Ecma International Web site.  </p>\n<p> The <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_SetCustomAttribute_\" data-linktype=\"relative-path\">SetCustomAttribute</a> method can interact with the <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_SetImplementationFlags_\" data-linktype=\"relative-path\">SetImplementationFlags</a> method when the two methods are used in combination. See the Remarks section of the <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_SetImplementationFlags_\" data-linktype=\"relative-path\">SetImplementationFlags</a> method for details.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_SetImplementationFlags_System_Reflection_MethodImplAttributes_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_SetImplementationFlags_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">SetImplementationFlags(MethodImplAttributes)</div>        \r\n          </div>\r\n    \r\n            <p>Sets the implementation flags for this method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void SetImplementationFlags (System.Reflection.MethodImplAttributes attributes);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>attributes</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodimplattributes\" data-linktype=\"relative-path\">MethodImplAttributes</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The implementation flags to set.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The containing type was previously created using <span class=\"xref\">stem.Reflection.Emit.TypeBuilder.CreateType*</span>.  </p>\n<p> -or-  </p>\n<p> For the current method, the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethod*</span> property is <code>true</code>, but the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition*</span> property is <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>When you use the SetImplementationFlags method in combination with the <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_SetCustomAttribute_\" data-linktype=\"relative-path\">SetCustomAttribute</a> method, be aware of potential interactions. For example, using the <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_SetCustomAttribute_\" data-linktype=\"relative-path\">SetCustomAttribute</a> method to add the <a class=\"xref\" href=\"system.runtime.interopservices.dllimportattribute\" data-linktype=\"relative-path\">DllImportAttribute</a> attribute also sets the <a class=\"xref\" href=\"system.reflection.methodimplattributes\" data-linktype=\"relative-path\">System.Reflection.MethodImplAttributes</a> flag. If you subsequently call the SetImplementationFlags method, the <a class=\"xref\" href=\"system.reflection.methodimplattributes\" data-linktype=\"relative-path\">MethodImplAttributes</a> flag is overwritten. There are two ways to avoid this:  </p>\n<ul>\n<li><p>Call the SetImplementationFlags method before you call the <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_SetCustomAttribute_\" data-linktype=\"relative-path\">SetCustomAttribute</a> method. The <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_SetCustomAttribute_\" data-linktype=\"relative-path\">SetCustomAttribute</a> method always respects existing method implementation flags.  </p>\n</li>\n<li><p>When you set implementation flags, call the <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_GetMethodImplementationFlags_\" data-linktype=\"relative-path\">GetMethodImplementationFlags</a> method to retrieve the existing flags, use bitwise OR to add your flag, and then call the SetImplementationFlags method.</p>\n</li>\n</ul>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The code sample below illustrates the contextual use of the <code>SetImplementationFlags</code> method to describe the implementation of MSIL in a method body.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1\">      array&lt;Type^&gt;^ temp0 = { int::typeid, int::typeid };\n      MethodBuilder^ myMthdBuilder = myTypeBuilder-&gt;DefineMethod( &quot;MyMethod&quot;,\n                                     MethodAttributes::Public,\n                                     CallingConventions::HasThis,\n                                     int::typeid,\n                                     temp0 );\n      \n      // Specifies that the dynamic method declared above has a an MSIL implementation,\n      // is managed, synchronized (single-threaded) through the body, and that it\n      // cannot be inlined.\n\n      myMthdBuilder-&gt;SetImplementationFlags( (MethodImplAttributes)(\n                                              MethodImplAttributes::IL |\n                                              MethodImplAttributes::Managed |\n                                              MethodImplAttributes::Synchronized |\n                                              MethodImplAttributes::NoInlining) );\n      \n      // Create an ILGenerator for the MethodBuilder and emit MSIL here ...\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1\">\tMethodBuilder myMthdBuilder = myTypeBuilder.DefineMethod(&quot;MyMethod&quot;,\n\t\t\t\t\t\tMethodAttributes.Public,\n\t\t\t\t\t\tCallingConventions.HasThis,\n\t\t\t\t\t\ttypeof(int),\n\t\t\t\t\t\tnew Type[] { typeof(int),\n\t\t\t\t\t\t\t     typeof(int) });\t\n\n\t// Specifies that the dynamic method declared above has a an MSIL implementation,\n        // is managed, synchronized (single-threaded) through the body, and that it \n\t// cannot be inlined.\n \n\tmyMthdBuilder.SetImplementationFlags(MethodImplAttributes.IL |\n\t\t\t\t\t     MethodImplAttributes.Managed |\n\t\t\t\t\t     MethodImplAttributes.Synchronized |\n\t\t\t\t\t     MethodImplAttributes.NoInlining);\n\n\t// Create an ILGenerator for the MethodBuilder and emit MSIL here ...\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Reflection.Emit.MethodBuilder.SetImplementationFlags Example#1\">      Dim myMthdBuilder As MethodBuilder = myTypeBuilder.DefineMethod(&quot;MyMethod&quot;, _\n\t\t\t\t\t   MethodAttributes.Public, _\n\t\t\t\t\t   CallingConventions.HasThis, _\n\t\t\t\t\t   GetType(Integer), _\n\t\t\t\t\t   New Type() {GetType(Integer), GetType(Integer)})\n      \n      &#39; Specifies that the dynamic method declared above has a an MSIL implementation,\n      &#39; is managed, synchronized (single-threaded) through the body, and that it \n      &#39; cannot be inlined.\n\n      myMthdBuilder.SetImplementationFlags((MethodImplAttributes.IL Or _\n\t\t\t\t\t    MethodImplAttributes.Managed Or _\n\t\t\t\t\t    MethodImplAttributes.Synchronized Or _\n\t\t\t\t\t    MethodImplAttributes.NoInlining))\n\n      &#39; Create an ILGenerator for the MethodBuilder and emit MSIL here ...\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_SetMarshal_System_Reflection_Emit_UnmanagedMarshal_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_SetMarshal_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">SetMarshal(UnmanagedMarshal)</div>        \r\n          </div>\r\n    \r\n            <p>Sets marshaling information for the return type of this method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void SetMarshal (System.Reflection.Emit.UnmanagedMarshal unmanagedMarshal);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>unmanagedMarshal</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.unmanagedmarshal\" data-linktype=\"relative-path\">UnmanagedMarshal</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Marshaling information for the return type of this method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The containing type was previously created using <span class=\"xref\">stem.Reflection.Emit.TypeBuilder.CreateType*</span>.  </p>\n<p> -or-  </p>\n<p> For the current method, the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethod*</span> property is <code>true</code>, but the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition*</span> property is <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The code sample below illustrates the contextual usage of the <code>SetMarshal</code> method to marshal the results of a method call as a different type.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Reflection.Emit.MethodBuilder.SetMarshal Example#1\">      array&lt;Type^&gt;^ temp0 = { String::typeid };\n      MethodBuilder^ myMethod = myDynamicType-&gt;DefineMethod( &quot;MyMethodReturnsMarshal&quot;,\n                                MethodAttributes::Public,\n                                UInt32::typeid,\n                                temp0 );\n      \n      // We want the return value of our dynamic method to be marshalled as\n      // an 64-bit (8-Byte) signed integer, instead of the default 32-bit\n      // unsigned int as specified above. The UnmanagedMarshal class can perform\n      // the type conversion.\n\n      UnmanagedMarshal^ marshalMeAsI8 = UnmanagedMarshal::DefineUnmanagedMarshal(\n                                        System::Runtime::InteropServices::UnmanagedType::I8 );\n\n      myMethod-&gt;SetMarshal( marshalMeAsI8 );\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Reflection.Emit.MethodBuilder.SetMarshal Example#1\">\n\tMethodBuilder myMethod = myDynamicType.DefineMethod(&quot;MyMethodReturnsMarshal&quot;,\n\t\t\t\t\t\tMethodAttributes.Public,\n\t\t\t\t\t\ttypeof(uint),\n\t\t\t\t\t\tnew Type[] { typeof(string) });\n\n\t// We want the return value of our dynamic method to be marshalled as \n\t// an 64-bit (8-byte) signed integer, instead of the default 32-bit\n   \t// unsigned int as specified above. The UnmanagedMarshal class can perform\n\t// the type conversion.\n\n\tUnmanagedMarshal marshalMeAsI8 = UnmanagedMarshal.DefineUnmanagedMarshal(\n\t\t\t\t         System.Runtime.InteropServices.UnmanagedType.I8);\t\n\n\tmyMethod.SetMarshal(marshalMeAsI8);\t\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Reflection.Emit.MethodBuilder.SetMarshal Example#1\">      Dim myMethod As MethodBuilder = myDynamicType.DefineMethod(&quot;MyMethodReturnsMarshal&quot;, _\n\t\t\t\t\tMethodAttributes.Public, GetType(System.UInt32), _\n\t\t\t\t\tNew Type() {GetType(String)}) \n      \n      &#39; We want the return value of our dynamic method to be marshalled as \n      &#39; an 64-bit (8-byte) signed integer, instead of the default 32-bit\n      &#39; unsigned int as specified above. The UnmanagedMarshal class can perform\n      &#39; the type conversion.\n\n      Dim marshalMeAsI8 As UnmanagedMarshal = UnmanagedMarshal.DefineUnmanagedMarshal( _\n\t\t\t\t\t      System.Runtime.InteropServices.UnmanagedType.I8)\n      \n      myMethod.SetMarshal(marshalMeAsI8)\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_SetMethodBody_System_Byte___System_Int32_System_Byte___System_Collections_Generic_IEnumerable_System_Reflection_Emit_ExceptionHandler__System_Collections_Generic_IEnumerable_System_Int32__\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_SetMethodBody_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">SetMethodBody(Byte[],Int32,Byte[],IEnumerable&lt;ExceptionHandler&gt;,IEnumerable&lt;Int32&gt;)</div>        \r\n          </div>\r\n    \r\n            <p>Creates the body of the method by using a specified byte array of Microsoft intermediate language (MSIL) instructions.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void SetMethodBody (byte[] il, int maxStack, byte[] localSignature, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.ExceptionHandler&gt; exceptionHandlers, System.Collections.Generic.IEnumerable&lt;int&gt; tokenFixups);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>il</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.byte\" data-linktype=\"relative-path\">Byte</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array that contains valid MSIL instructions.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>maxStack</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The maximum stack evaluation depth.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>localSignature</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.byte\" data-linktype=\"relative-path\">Byte</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of bytes that contain the serialized local variable structure. Specify <code>null</code> if the method has no local variables.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>exceptionHandlers</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable</a>&lt;<a class=\"xref\" href=\"system.reflection.emit.exceptionhandler\" data-linktype=\"relative-path\">ExceptionHandler</a>&gt;</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A collection that contains the exception handlers for the method. Specify <code>null</code> if the method has no exception handlers.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>tokenFixups</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable</a>&lt;<a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a>&gt;</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A collection of values that represent offsets in <code>il</code>, each of which specifies the beginning of a token that may be modified. Specify <code>null</code> if the method has no tokens that have to be modified.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>il</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p><code>maxStack</code> is negative.  </p>\n<p> -or-  </p>\n<p> One of <code>exceptionHandlers</code> specifies an offset outside of <code>il</code>.  </p>\n<p> -or-  </p>\n<p> One of <code>tokenFixups</code> specifies an offset that is outside the <code>il</code> array.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The containing type was previously created using the <span class=\"xref\">stem.Reflection.Emit.TypeBuilder.CreateType*</span> method.  </p>\n<p> -or-  </p>\n<p> This method was called previously on this <a class=\"xref\" href=\"system.reflection.emit.methodbuilder\" data-linktype=\"relative-path\">MethodBuilder</a> object.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_SetParameters_System_Type___\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_SetParameters_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">SetParameters(Type[])</div>        \r\n          </div>\r\n    \r\n            <p>Sets the number and types of parameters for a method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void SetParameters (Type[] parameterTypes);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>parameterTypes</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects representing the parameter types.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The current method is generic, but is not a generic method definition. That is, the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethod*</span> property is <code>true</code>, but the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition*</span> property is <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the number and types of the parameters are known when the method is defined, they can be set using any overload of the <a class=\"xref\" href=\"system.reflection.emit.typebuilder#System_Reflection_Emit_TypeBuilder_DefineMethod_\" data-linktype=\"relative-path\">DefineMethod</a> method that accepts an array of parameter types. However, a generic method can have parameters whose types are specified by one or more of its own generic type parameters, which cannot be defined until after the method has been defined. Use this method to set the parameter types in that case.  </p>\n<p> If the return type has optional or required custom modifiers, such as <a class=\"xref\" href=\"system.runtime.compilerservices.isconst\" data-linktype=\"relative-path\">IsConst</a>, use the [SetSignature(Type, Type[], Type[], Type[], Type[][], Type[]&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29&gt; method overload.  </p>\n<p> Calling this method replaces any parameter types that were set using the <a class=\"xref\" href=\"system.reflection.emit.typebuilder#System_Reflection_Emit_TypeBuilder_DefineMethod_\" data-linktype=\"relative-path\">DefineMethod</a> method.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example uses the <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_DefineGenericParameters_\" data-linktype=\"relative-path\">DefineGenericParameters</a> method to make a method generic. The SetParameters method is used to give the method one parameter, whose type will be specified by the first generic type parameter. The <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_SetReturnType_\" data-linktype=\"relative-path\">SetReturnType</a> method is used to give the method a return type, specified by the second generic type parameter.  </p>\n<p> This code is part of a larger example provided for the <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_DefineGenericParameters_\" data-linktype=\"relative-path\">DefineGenericParameters</a> method.  </p>\n<pre><code class=\"lang-cs\" name=\"GenericMethodBuilder#3\">        // Defining generic parameters for the method makes it a\n        // generic method. By convention, type parameters are \n        // single alphabetic characters. T and U are used here.\n        //\n        string[] typeParamNames = {&quot;T&quot;, &quot;U&quot;};\n        GenericTypeParameterBuilder[] typeParameters = \n            demoMethod.DefineGenericParameters(typeParamNames);\n\n        // The second type parameter is constrained to be a \n        // reference type.\n        typeParameters[1].SetGenericParameterAttributes( \n            GenericParameterAttributes.ReferenceTypeConstraint);\n</code></pre><pre><code class=\"lang-cpp\" name=\"GenericMethodBuilder#3\">    // Defining generic parameters for the method makes it a\n    // generic method. By convention, type parameters are\n    // single alphabetic characters. T and U are used here.\n    //\n    array&lt;String^&gt;^ genericTypeNames = {&quot;T&quot;, &quot;U&quot;};\n    array&lt;GenericTypeParameterBuilder^&gt;^ genericTypes =\n        sampleMethodBuilder-&gt;DefineGenericParameters(\n        genericTypeNames);\n</code></pre><pre><code class=\"lang-vb\" name=\"GenericMethodBuilder#3\">        &#39; Defining generic parameters for the method makes it a\n        &#39; generic method. By convention, type parameters are \n        &#39; single alphabetic characters. T and U are used here.\n        &#39;\n        Dim typeParamNames() As String = {&quot;T&quot;, &quot;U&quot;}\n        Dim typeParameters() As GenericTypeParameterBuilder = _\n            demoMethod.DefineGenericParameters(typeParamNames)\n\n        &#39; The second type parameter is constrained to be a \n        &#39; reference type.\n        typeParameters(1).SetGenericParameterAttributes( _\n            GenericParameterAttributes.ReferenceTypeConstraint)\n</code></pre><pre><code class=\"lang-cs\" name=\"GenericMethodBuilder#5\">        // Set parameter types for the method. The method takes\n        // one parameter, and its type is specified by the first\n        // type parameter, T.\n        Type[] parms = {typeParameters[0]};\n        demoMethod.SetParameters(parms);\n\n        // Set the return type for the method. The return type is\n        // specified by the second type parameter, U.\n        demoMethod.SetReturnType(typeParameters[1]);\n</code></pre><pre><code class=\"lang-cpp\" name=\"GenericMethodBuilder#5\">    // Set parameter types for the method. The method takes\n    // one parameter, and its type is specified by the first\n    // type parameter, T.\n    array&lt;Type^&gt;^ parameterTypes = {genericTypes[0]};\n    sampleMethodBuilder-&gt;SetParameters(parameterTypes);\n\n    // Set the return type for the method. The return type is\n    // specified by the second type parameter, U.\n    sampleMethodBuilder-&gt;SetReturnType(genericTypes[1]);\n</code></pre><pre><code class=\"lang-vb\" name=\"GenericMethodBuilder#5\">        &#39; Set parameter types for the method. The method takes\n        &#39; one parameter, and its type is specified by the first\n        &#39; type parameter, T.\n        Dim params() As Type = {typeParameters(0)}\n        demoMethod.SetParameters(params)\n\n        &#39; Set the return type for the method. The return type is\n        &#39; specified by the second type parameter, U.\n        demoMethod.SetReturnType(typeParameters(1))\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_SetReturnType_System_Type_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_SetReturnType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">SetReturnType(Type)</div>        \r\n          </div>\r\n    \r\n            <p>Sets the return type of the method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void SetReturnType (Type returnType);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>returnType</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents the return type of the method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The current method is generic, but is not a generic method definition. That is, the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethod*</span> property is <code>true</code>, but the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition*</span> property is <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Use this method to set the return type of a generic method, when the return type is specified by one of the generic type parameters of the method. If the return type has optional or required custom modifiers, such as <a class=\"xref\" href=\"system.runtime.compilerservices.isconst\" data-linktype=\"relative-path\">IsConst</a>, use the [SetSignature(Type, Type[], Type[], Type[], Type[][], Type[]&lt;xref:System.Reflection.Emit.MethodBuilder.SetSignature%28System.Type%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%2CSystem.Type%5B%5D%5B%5D%2CSystem.Type%5B%5D%5B%5D%29&gt; method overload.  </p>\n<p> Calling this method replaces a return type established using the <a class=\"xref\" href=\"system.reflection.emit.typebuilder#System_Reflection_Emit_TypeBuilder_DefineMethod_\" data-linktype=\"relative-path\">DefineMethod</a> method.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example uses the <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_DefineGenericParameters_\" data-linktype=\"relative-path\">DefineGenericParameters</a> method to make a method generic. The <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_SetParameters_\" data-linktype=\"relative-path\">SetParameters</a> method is used to give the method one parameter, whose type will be specified by the first generic type parameter. The SetReturnType method is used to give the method a return type, specified by the second generic type parameter.  </p>\n<p> This code is part of a larger example provided for the <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_DefineGenericParameters_\" data-linktype=\"relative-path\">DefineGenericParameters</a> method.  </p>\n<pre><code class=\"lang-cs\" name=\"GenericMethodBuilder#3\">        // Defining generic parameters for the method makes it a\n        // generic method. By convention, type parameters are \n        // single alphabetic characters. T and U are used here.\n        //\n        string[] typeParamNames = {&quot;T&quot;, &quot;U&quot;};\n        GenericTypeParameterBuilder[] typeParameters = \n            demoMethod.DefineGenericParameters(typeParamNames);\n\n        // The second type parameter is constrained to be a \n        // reference type.\n        typeParameters[1].SetGenericParameterAttributes( \n            GenericParameterAttributes.ReferenceTypeConstraint);\n</code></pre><pre><code class=\"lang-cpp\" name=\"GenericMethodBuilder#3\">    // Defining generic parameters for the method makes it a\n    // generic method. By convention, type parameters are\n    // single alphabetic characters. T and U are used here.\n    //\n    array&lt;String^&gt;^ genericTypeNames = {&quot;T&quot;, &quot;U&quot;};\n    array&lt;GenericTypeParameterBuilder^&gt;^ genericTypes =\n        sampleMethodBuilder-&gt;DefineGenericParameters(\n        genericTypeNames);\n</code></pre><pre><code class=\"lang-vb\" name=\"GenericMethodBuilder#3\">        &#39; Defining generic parameters for the method makes it a\n        &#39; generic method. By convention, type parameters are \n        &#39; single alphabetic characters. T and U are used here.\n        &#39;\n        Dim typeParamNames() As String = {&quot;T&quot;, &quot;U&quot;}\n        Dim typeParameters() As GenericTypeParameterBuilder = _\n            demoMethod.DefineGenericParameters(typeParamNames)\n\n        &#39; The second type parameter is constrained to be a \n        &#39; reference type.\n        typeParameters(1).SetGenericParameterAttributes( _\n            GenericParameterAttributes.ReferenceTypeConstraint)\n</code></pre><pre><code class=\"lang-cs\" name=\"GenericMethodBuilder#5\">        // Set parameter types for the method. The method takes\n        // one parameter, and its type is specified by the first\n        // type parameter, T.\n        Type[] parms = {typeParameters[0]};\n        demoMethod.SetParameters(parms);\n\n        // Set the return type for the method. The return type is\n        // specified by the second type parameter, U.\n        demoMethod.SetReturnType(typeParameters[1]);\n</code></pre><pre><code class=\"lang-cpp\" name=\"GenericMethodBuilder#5\">    // Set parameter types for the method. The method takes\n    // one parameter, and its type is specified by the first\n    // type parameter, T.\n    array&lt;Type^&gt;^ parameterTypes = {genericTypes[0]};\n    sampleMethodBuilder-&gt;SetParameters(parameterTypes);\n\n    // Set the return type for the method. The return type is\n    // specified by the second type parameter, U.\n    sampleMethodBuilder-&gt;SetReturnType(genericTypes[1]);\n</code></pre><pre><code class=\"lang-vb\" name=\"GenericMethodBuilder#5\">        &#39; Set parameter types for the method. The method takes\n        &#39; one parameter, and its type is specified by the first\n        &#39; type parameter, T.\n        Dim params() As Type = {typeParameters(0)}\n        demoMethod.SetParameters(params)\n\n        &#39; Set the return type for the method. The return type is\n        &#39; specified by the second type parameter, U.\n        demoMethod.SetReturnType(typeParameters(1))\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_SetSignature_System_Type_System_Type___System_Type___System_Type___System_Type_____System_Type_____\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_SetSignature_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">SetSignature(Type,Type[],Type[],Type[],Type[][],Type[][])</div>        \r\n          </div>\r\n    \r\n            <p>Sets the method signature, including the return type, the parameter types, and the required and optional custom modifiers of the return type and parameter types.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void SetSignature (Type returnType, Type[] returnTypeRequiredCustomModifiers, Type[] returnTypeOptionalCustomModifiers, Type[] parameterTypes, Type[][] parameterTypeRequiredCustomModifiers, Type[][] parameterTypeOptionalCustomModifiers);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>returnType</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The return type of the method.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>returnTypeRequiredCustomModifiers</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of types representing the required custom modifiers, such as <a class=\"xref\" href=\"system.runtime.compilerservices.isconst\" data-linktype=\"relative-path\">IsConst</a>, for the return type of the method. If the return type has no required custom modifiers, specify <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>returnTypeOptionalCustomModifiers</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of types representing the optional custom modifiers, such as <a class=\"xref\" href=\"system.runtime.compilerservices.isconst\" data-linktype=\"relative-path\">IsConst</a>, for the return type of the method. If the return type has no optional custom modifiers, specify <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>parameterTypes</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The types of the parameters of the method.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>parameterTypeRequiredCustomModifiers</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[][]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of arrays of types. Each array of types represents the required custom modifiers for the corresponding parameter, such as <a class=\"xref\" href=\"system.runtime.compilerservices.isconst\" data-linktype=\"relative-path\">IsConst</a>. If a particular parameter has no required custom modifiers, specify <code>null</code> instead of an array of types. If none of the parameters have required custom modifiers, specify <code>null</code> instead of an array of arrays.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>parameterTypeOptionalCustomModifiers</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[][]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of arrays of types. Each array of types represents the optional custom modifiers for the corresponding parameter, such as <a class=\"xref\" href=\"system.runtime.compilerservices.isconst\" data-linktype=\"relative-path\">IsConst</a>. If a particular parameter has no optional custom modifiers, specify <code>null</code> instead of an array of types. If none of the parameters have optional custom modifiers, specify <code>null</code> instead of an array of arrays.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The current method is generic, but is not a generic method definition. That is, the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethod*</span> property is <code>true</code>, but the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition*</span> property is <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the return type and the number and types of the parameters are known when the method is defined, they can be established using any overload of the <a class=\"xref\" href=\"system.reflection.emit.typebuilder#System_Reflection_Emit_TypeBuilder_DefineMethod_\" data-linktype=\"relative-path\">DefineMethod</a> method that accepts an array of parameter types. However, a generic method can have parameters whose types are specified by one or more of its own generic type parameters, which cannot be defined until after the method has been defined. Use this method to set the parameter types in that case.  </p>\n<p> If neither the return type nor the parameter types have optional or required custom modifiers, such as <a class=\"xref\" href=\"microsoft.visualc.isconstmodifier\" data-linktype=\"relative-path\">IsConstModifier</a>, you can use the <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_SetReturnType_\" data-linktype=\"relative-path\">SetReturnType</a> and <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_SetParameters_\" data-linktype=\"relative-path\">SetParameters</a> methods.  </p>\n<p> Calling this method replaces the parameters and return type established using the <a class=\"xref\" href=\"system.reflection.emit.typebuilder#System_Reflection_Emit_TypeBuilder_DefineMethod_\" data-linktype=\"relative-path\">DefineMethod</a> method.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example contains source code for a generic class named Sample that has a type parameter <code>T</code>. The class has a field named <code>Field</code>, of type <code>T</code>, and a generic method <code>GM</code> with its own type parameter, <code>U</code>. Method <code>GM</code> creates an instance of Sample, substituting its own type parameter <code>U</code> for the type parameter of Sample, and stores its input parameter in <code>Field</code>. This source code is compiled but not used; you can view it with the <a href=\"../Topic/Ildasm.exe%20(IL%20Disassembler).md\" data-linktype=\"relative-path\">Ildasm.exe (IL Disassembler)</a>, and compare it to the code emitted by class <code>Example</code>.  </p>\n<p> The code in class <code>Example</code> demonstrates the use of the SetSignature method in emitting generic code. The <code>Main</code> method of class <code>Example</code> creates a dynamic assembly containing a class named <code>Sample</code>, and uses the <a class=\"xref\" href=\"system.reflection.emit.typebuilder#System_Reflection_Emit_TypeBuilder_DefineGenericParameters_\" data-linktype=\"relative-path\">DefineGenericParameters</a> method to make it generic by adding a type parameter named <code>T</code>. A default constructor and a field named <code>Field</code>, of type <code>T</code>, are added to class <code>Sample</code>. A method <code>GM</code> is added, and turned into a generic method using the <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_DefineGenericParameters_\" data-linktype=\"relative-path\">DefineGenericParameters</a> method. The type parameter of <code>GM</code> is named <code>U</code>. Once the type parameter is defined, the signature of <code>GM</code> is added, using the SetSignature method. There is no return type, and no required or custom modifiers, so all the parameters of this method are <code>null</code> except <code>parameterTypes</code>, which sets the type of the only parameter of the method; this is set to the method&#39;s type parameter, <code>U</code>. The body of the method creates an instance of the constructed type <code>Sample&lt;U&gt;</code> (<code>Sample(Of U)</code> in Visual Basic), assigns the method&#39;s parameter to <code>Field</code>, and then prints the value of <code>Field</code>. A dummy type is defined, to hold the entry point method <code>Main</code>. In the body of <code>Main</code>, the static <code>GM</code> method is invoked on the constructed generic type <code>Sample&lt;int&gt;</code> (<code>Sample(Of Integer)</code> in Visual Basic), with type <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a> substituted for <code>U</code>. The <a class=\"xref\" href=\"system.reflection.emit.typebuilder#System_Reflection_Emit_TypeBuilder_GetMethod_\" data-linktype=\"relative-path\">GetMethod</a> method is used to create a <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> for the static <code>GM</code> method of the constructed generic type <code>Sample&lt;U&gt;</code>, and the <a class=\"xref\" href=\"system.reflection.methodinfo#System_Reflection_MethodInfo_MakeGenericMethod_\" data-linktype=\"relative-path\">MakeGenericMethod</a> method is then used to create a <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> that can emitted in a method call.  </p>\n<p> When the code example is run, it saves the emitted assembly as TypeBuilderGetFieldExample.exe. You can run TypeBuilderGetFieldExample.exe, and you can use the <a href=\"../Topic/Ildasm.exe%20(IL%20Disassembler).md\" data-linktype=\"relative-path\">Ildasm.exe (IL Disassembler)</a> to compare the emitted code with the code for the <code>Sample</code> class that is compiled into the code example itself.  </p>\n<pre><code class=\"lang-cs\" name=\"TypeBuilder.GetField_Generic#1\">using System;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\n// Compare the MSIL in this class to the MSIL\n// generated by the Reflection.Emit code in class\n// Example.\npublic class Sample&lt;T&gt;\n{\n  public T Field;\n  public static void GM&lt;U&gt;(U val)\n  {\n    Sample&lt;U&gt; s = new Sample&lt;U&gt;();\n    s.Field = val;\n    Console.WriteLine(s.Field);\n  }\n}\n\npublic class Example\n{\n    public static void Main()\n    {\n        AppDomain myDomain = AppDomain.CurrentDomain;\n        AssemblyName myAsmName = \n            new AssemblyName(&quot;TypeBuilderGetFieldExample&quot;);\n        AssemblyBuilder myAssembly = myDomain.DefineDynamicAssembly(\n            myAsmName, AssemblyBuilderAccess.Save);\n        ModuleBuilder myModule = myAssembly.DefineDynamicModule(\n            myAsmName.Name, \n            myAsmName.Name + &quot;.exe&quot;);\n\n        // Define the sample type.\n        TypeBuilder myType = myModule.DefineType(&quot;Sample&quot;, \n            TypeAttributes.Class | TypeAttributes.Public);\n\n        // Add a type parameter, making the type generic.\n        string[] typeParamNames = {&quot;T&quot;};  \n        GenericTypeParameterBuilder[] typeParams = \n            myType.DefineGenericParameters(typeParamNames);\n\n        // Define a default constructor. Normally it would \n        // not be necessary to define the default constructor,\n        // but in this case it is needed for the call to\n        // TypeBuilder.GetConstructor, which gets the default\n        // constructor for the generic type constructed from \n        // Sample&lt;T&gt;, in the generic method GM&lt;U&gt;.\n        ConstructorBuilder ctor = myType.DefineDefaultConstructor(\n            MethodAttributes.PrivateScope | MethodAttributes.Public |\n            MethodAttributes.HideBySig | MethodAttributes.SpecialName |\n            MethodAttributes.RTSpecialName);\n\n        // Add a field of type T, with the name Field.\n        FieldBuilder myField = myType.DefineField(&quot;Field&quot;, \n            typeParams[0],\n            FieldAttributes.Public);\n\n        // Add a method and make it generic, with a type \n        // parameter named U. Note how similar this is to \n        // the way Sample is turned into a generic type. The\n        // method has no signature, because the type of its\n        // only parameter is U, which is not yet defined.\n        MethodBuilder genMethod = myType.DefineMethod(&quot;GM&quot;, \n            MethodAttributes.Public | MethodAttributes.Static);\n        string[] methodParamNames = {&quot;U&quot;};\n        GenericTypeParameterBuilder[] methodParams = \n            genMethod.DefineGenericParameters(methodParamNames);\n        \n        // Now add a signature for genMethod, specifying U\n        // as the type of the parameter. There is no return value\n        // and no custom modifiers.\n        genMethod.SetSignature(null, null, null, \n            new Type[] { methodParams[0] }, null, null);\n\n        // Emit a method body for the generic method.\n        ILGenerator ilg = genMethod.GetILGenerator();\n        // Construct the type Sample&lt;U&gt; using MakeGenericType.\n        Type SampleOfU = myType.MakeGenericType( methodParams[0] );\n        // Create a local variable to store the instance of\n        // Sample&lt;U&gt;.\n        ilg.DeclareLocal(SampleOfU);\n        // Call the default constructor. Note that it is \n        // necessary to have the default constructor for the\n        // constructed generic type Sample&lt;U&gt;; use the \n        // TypeBuilder.GetConstructor method to obtain this \n        // constructor.\n        ConstructorInfo ctorOfU = TypeBuilder.GetConstructor(\n            SampleOfU, ctor);\n        ilg.Emit(OpCodes.Newobj, ctorOfU);\n        // Store the instance in the local variable; load it\n        // again, and load the parameter of genMethod.\n        ilg.Emit(OpCodes.Stloc_0); \n        ilg.Emit(OpCodes.Ldloc_0); \n        ilg.Emit(OpCodes.Ldarg_0);\n        // In order to store the value in the field of the\n        // instance of Sample&lt;U&gt;, it is necessary to have \n        // a FieldInfo representing the field of the \n        // constructed type. Use TypeBuilder.GetField to \n        // obtain this FieldInfo.\n        FieldInfo FieldOfU = TypeBuilder.GetField(\n            SampleOfU, myField);\n        // Store the value in the field. \n        ilg.Emit(OpCodes.Stfld, FieldOfU);\n        // Load the instance, load the field value, box it\n        // (specifying the type of the type parameter, U), and\n        // print it.\n        ilg.Emit(OpCodes.Ldloc_0);\n        ilg.Emit(OpCodes.Ldfld, FieldOfU);\n        ilg.Emit(OpCodes.Box, methodParams[0]);\n        MethodInfo writeLineObj = \n            typeof(Console).GetMethod(&quot;WriteLine&quot;, \n                new Type[] { typeof(object) });\n        ilg.EmitCall(OpCodes.Call, writeLineObj, null);\n        ilg.Emit(OpCodes.Ret);\n\n        // Emit an entry point method; this must be in a\n        // non-generic type.\n        TypeBuilder dummy = myModule.DefineType(&quot;Dummy&quot;, \n            TypeAttributes.Class | TypeAttributes.NotPublic);\n        MethodBuilder entryPoint = dummy.DefineMethod(&quot;Main&quot;, \n            MethodAttributes.Public | MethodAttributes.Static,\n            null, null);\n        ilg = entryPoint.GetILGenerator();\n        // In order to call the static generic method GM, it is\n        // necessary to create a constructed type from the \n        // generic type definition for Sample. This can be any\n        // constructed type; in this case Sample&lt;int&gt; is used.\n        Type SampleOfInt = \n            myType.MakeGenericType( typeof(int) );\n        // Next get a MethodInfo representing the static generic\n        // method GM on type Sample&lt;int&gt;.\n        MethodInfo SampleOfIntGM = TypeBuilder.GetMethod(SampleOfInt, \n            genMethod);\n        // Next get a MethodInfo for GM&lt;string&gt;, which is the \n        // instantiation of GM that Main calls.\n        MethodInfo GMOfString = \n            SampleOfIntGM.MakeGenericMethod( typeof(string) );\n        // Finally, emit the call. Push a string onto\n        // the stack, as the argument for the generic method.\n        ilg.Emit(OpCodes.Ldstr, &quot;Hello, world!&quot;);\n        ilg.EmitCall(OpCodes.Call, GMOfString, null);\n        ilg.Emit(OpCodes.Ret);\n\n        myType.CreateType();\n        dummy.CreateType();\n        myAssembly.SetEntryPoint(entryPoint);\n        myAssembly.Save(myAsmName.Name + &quot;.exe&quot;);\n\n        Console.WriteLine(myAsmName.Name + &quot;.exe has been saved.&quot;);\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"TypeBuilder.GetField_Generic#1\">Imports System\nImports System.Reflection\nImports System.Reflection.Emit\n\n&#39; Compare the MSIL in this class to the MSIL\n&#39; generated by the Reflection.Emit code in class\n&#39; Example.\nPublic Class Sample(Of T)\n    Public Field As T\n    Public Shared Sub GM(Of U)(ByVal val As U)\n        Dim s As New Sample(Of U)\n        s.Field = val\n        Console.WriteLine(s.Field)\n    \n    End Sub\nEnd Class \n\nPublic Class Example\n    \n    Public Shared Sub Main() \n        Dim myDomain As AppDomain = AppDomain.CurrentDomain\n        Dim myAsmName As New AssemblyName(&quot;TypeBuilderGetFieldExample&quot;)\n        Dim myAssembly As AssemblyBuilder = _\n            myDomain.DefineDynamicAssembly(myAsmName, _\n                AssemblyBuilderAccess.Save)\n        Dim myModule As ModuleBuilder = _\n            myAssembly.DefineDynamicModule(myAsmName.Name, _\n                myAsmName.Name &amp; &quot;.exe&quot;)\n        \n        &#39; Define the sample type.\n        Dim myType As TypeBuilder = myModule.DefineType( _\n            &quot;Sample&quot;, _\n            TypeAttributes.Class Or TypeAttributes.Public)\n        \n        &#39; Add a type parameter, making the type generic.\n        Dim typeParamNames() As String = { &quot;T&quot; }\n        Dim typeParams As GenericTypeParameterBuilder() = _\n            myType.DefineGenericParameters(typeParamNames)\n        \n        &#39; Define a default constructor. Normally it would \n        &#39; not be necessary to define the default constructor,\n        &#39; but in this case it is needed for the call to\n        &#39; TypeBuilder.GetConstructor, which gets the default\n        &#39; constructor for the generic type constructed from \n        &#39; Sample(Of T), in the generic method GM(Of U).\n        Dim ctor As ConstructorBuilder = _\n            myType.DefineDefaultConstructor( _\n                MethodAttributes.PrivateScope Or MethodAttributes.Public _\n                Or MethodAttributes.HideBySig Or MethodAttributes.SpecialName _\n                Or MethodAttributes.RTSpecialName)\n        \n        &#39; Add a field of type T, with the name Field.\n        Dim myField As FieldBuilder = myType.DefineField( _\n            &quot;Field&quot;, typeParams(0), FieldAttributes.Public)\n        \n        &#39; Add a method and make it generic, with a type \n        &#39; parameter named U. Note how similar this is to \n        &#39; the way Sample is turned into a generic type. The\n        &#39; method has no signature, because the type of its\n        &#39; only parameter is U, which is not yet defined.\n        Dim genMethod As MethodBuilder = _\n            myType.DefineMethod(&quot;GM&quot;, _\n                MethodAttributes.Public Or MethodAttributes.Static)\n        Dim methodParamNames() As String = { &quot;U&quot; }\n        Dim methodParams As GenericTypeParameterBuilder() = _\n            genMethod.DefineGenericParameters(methodParamNames)\n\n        &#39; Now add a signature for genMethod, specifying U\n        &#39; as the type of the parameter. There is no return value\n        &#39; and no custom modifiers.\n        genMethod.SetSignature(Nothing, Nothing, Nothing, _\n            New Type() { methodParams(0) }, Nothing, Nothing)\n        \n        &#39; Emit a method body for the generic method.\n        Dim ilg As ILGenerator = genMethod.GetILGenerator()\n        &#39; Construct the type Sample(Of U) using MakeGenericType.\n        Dim SampleOfU As Type = _\n            myType.MakeGenericType(methodParams(0))\n        &#39; Create a local variable to store the instance of\n        &#39; Sample(Of U).\n        ilg.DeclareLocal(SampleOfU)\n        &#39; Call the default constructor. Note that it is \n        &#39; necessary to have the default constructor for the\n        &#39; constructed generic type Sample(Of U); use the \n        &#39; TypeBuilder.GetConstructor method to obtain this \n        &#39; constructor.\n        Dim ctorOfU As ConstructorInfo = _\n            TypeBuilder.GetConstructor(SampleOfU, ctor)\n        ilg.Emit(OpCodes.Newobj, ctorOfU)\n        &#39; Store the instance in the local variable; load it\n        &#39; again, and load the parameter of genMethod.\n        ilg.Emit(OpCodes.Stloc_0)\n        ilg.Emit(OpCodes.Ldloc_0)\n        ilg.Emit(OpCodes.Ldarg_0)\n        &#39; In order to store the value in the field of the\n        &#39; instance of Sample(Of U), it is necessary to have \n        &#39; a FieldInfo representing the field of the \n        &#39; constructed type. Use TypeBuilder.GetField to \n        &#39; obtain this FieldInfo.\n        Dim FieldOfU As FieldInfo = _\n            TypeBuilder.GetField(SampleOfU, myField)\n        &#39; Store the value in the field. \n        ilg.Emit(OpCodes.Stfld, FieldOfU)\n        &#39; Load the instance, load the field value, box it\n        &#39; (specifying the type of the type parameter, U), \n        &#39; and print it.\n        ilg.Emit(OpCodes.Ldloc_0)\n        ilg.Emit(OpCodes.Ldfld, FieldOfU)\n        ilg.Emit(OpCodes.Box, methodParams(0))\n        Dim writeLineObj As MethodInfo = _\n            GetType(Console).GetMethod(&quot;WriteLine&quot;, _\n                New Type() {GetType(Object)})\n        ilg.EmitCall(OpCodes.Call, writeLineObj, Nothing)\n        ilg.Emit(OpCodes.Ret)\n        \n        &#39; Emit an entry point method; this must be in a\n        &#39; non-generic type.\n        Dim dummy As TypeBuilder = _\n            myModule.DefineType(&quot;Dummy&quot;, _\n                TypeAttributes.Class Or TypeAttributes.NotPublic)\n        Dim entryPoint As MethodBuilder = _\n            dummy.DefineMethod(&quot;Main&quot;, _\n                MethodAttributes.Public Or MethodAttributes.Static, _\n                Nothing, Nothing)\n        ilg = entryPoint.GetILGenerator()\n        &#39; In order to call the static generic method GM, it is\n        &#39; necessary to create a constructed type from the \n        &#39; generic type definition for Sample. This can be ANY\n        &#39; constructed type; in this case Sample(Of Integer)\n        &#39; is used.\n        Dim SampleOfInt As Type = _\n            myType.MakeGenericType(GetType(Integer))\n        &#39; Next get a MethodInfo representing the static generic\n        &#39; method GM on type Sample(Of Integer).\n        Dim SampleOfIntGM As MethodInfo = _\n            TypeBuilder.GetMethod(SampleOfInt, genMethod)\n        &#39; Next get a MethodInfo for GM(Of String), which is the \n        &#39; instantiation of generic method GM that is called\n        &#39; by Sub Main.\n        Dim GMOfString As MethodInfo = _\n            SampleOfIntGM.MakeGenericMethod(GetType(String))\n        &#39; Finally, emit the call. Push a string onto\n        &#39; the stack, as the argument for the generic method.\n        ilg.Emit(OpCodes.Ldstr, &quot;Hello, world!&quot;)\n        ilg.EmitCall(OpCodes.Call, GMOfString, Nothing)\n        ilg.Emit(OpCodes.Ret)\n        \n        myType.CreateType()\n        dummy.CreateType()\n        myAssembly.SetEntryPoint(entryPoint)\n        myAssembly.Save(myAsmName.Name &amp; &quot;.exe&quot;)\n        \n        Console.WriteLine(myAsmName.Name &amp; &quot;.exe has been saved.&quot;)\n    \n    End Sub \nEnd Class \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_SetSymCustomAttribute_System_String_System_Byte___\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_SetSymCustomAttribute_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">SetSymCustomAttribute(String,Byte[])</div>        \r\n          </div>\r\n    \r\n            <p>Set a symbolic custom attribute using a blob.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void SetSymCustomAttribute (string name, byte[] data);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of the symbolic custom attribute.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>data</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.byte\" data-linktype=\"relative-path\">Byte</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The byte blob that represents the value of the symbolic custom attribute.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The containing type was previously created using <span class=\"xref\">stem.Reflection.Emit.TypeBuilder.CreateType*</span>.  </p>\n<p> -or-  </p>\n<p> The module that contains this method is not a debug module.  </p>\n<p> -or-  </p>\n<p> For the current method, the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethod*</span> property is <code>true</code>, but the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition*</span> property is <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Unlike the metadata custom attribute, this custom attribute is associated with a symbol writer.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The code sample below illustrates the contextual usage of the <code>SetSymCustomAttribute</code> method to set the byte values for the name and key of a custom attribute attached to a method.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1\">      array&lt;Type^&gt;^ temp0 = { String::typeid };\n      MethodBuilder^ myMethod = myDynamicType-&gt;DefineMethod( &quot;MyMethod&quot;,\n                                MethodAttributes::Public,\n                                int::typeid,\n                                temp0 );\n      \n      // A 128-bit key in hex form, represented as a Byte array.\n      array&lt;Byte&gt;^ keyVal = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n                              0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xFF, 0xFF};\n\n      System::Text::ASCIIEncoding^ encoder = gcnew System::Text::ASCIIEncoding;\n      array&lt;Byte&gt;^ symFullName = encoder-&gt;GetBytes( &quot;My Dynamic Method&quot; );\n\n      myMethod-&gt;SetSymCustomAttribute( &quot;SymID&quot;, keyVal );\n      myMethod-&gt;SetSymCustomAttribute( &quot;SymFullName&quot;, symFullName );\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1\">\n\tMethodBuilder myMethod = myDynamicType.DefineMethod(&quot;MyMethod&quot;,\n\t\t\t\t\t\tMethodAttributes.Public,\n\t\t\t\t\t\ttypeof(int),\n\t\t\t\t\t\tnew Type[] { typeof(string) });\n\n\t// A 128-bit key in hex form, represented as a byte array.\n\tbyte[] keyVal = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n\t\t\t  0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0xFF, 0xFF };\t\n\n\tSystem.Text.ASCIIEncoding encoder = new System.Text.ASCIIEncoding();\n\tbyte[] symFullName = encoder.GetBytes(&quot;My Dynamic Method&quot;);\n\n\tmyMethod.SetSymCustomAttribute(&quot;SymID&quot;, keyVal);\n\tmyMethod.SetSymCustomAttribute(&quot;SymFullName&quot;, symFullName);\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute Example#1\">      Dim myMethod As MethodBuilder = myDynamicType.DefineMethod(&quot;MyMethod&quot;, _\n\t\t\t\t\t MethodAttributes.Public, GetType(Integer), _\n\t\t\t\t\t New Type() {GetType(String)})\n      \n      &#39; A 128-bit key in hex form, represented as a byte array.\n      Dim keyVal As Byte() =  {&amp;H0, &amp;H0, &amp;H0, &amp;H0, &amp;H0, &amp;H0, &amp;H0, &amp;H0, _\n\t\t\t       &amp;H0, &amp;H0, &amp;H0, &amp;H0, &amp;H0, &amp;H60, &amp;HFF, &amp;HFF}\n      \n      Dim encoder As New System.Text.ASCIIEncoding()\n      Dim symFullName As Byte() = encoder.GetBytes(&quot;My Dynamic Method&quot;)\n      \n      myMethod.SetSymCustomAttribute(&quot;SymID&quot;, keyVal)\n      myMethod.SetSymCustomAttribute(&quot;SymFullName&quot;, symFullName)\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_ToString\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_ToString_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ToString()</div>        \r\n          </div>\r\n    \r\n            <p>Returns this <code>MethodBuilder</code> instance as a string.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override string ToString ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </div>\r\n                  <p>Returns a string containing the name, attributes, method signature, exceptions, and local signature of this method followed by the current Microsoft intermediate language (MSIL) stream.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"eii\">\r\n        <h2>Explicit Interface Implementations\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_System_Runtime_InteropServices__MethodBuilder_GetIDsOfNames_System_Guid__System_IntPtr_System_UInt32_System_UInt32_System_IntPtr_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_System_Runtime_InteropServices__MethodBuilder_GetIDsOfNames_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_MethodBuilder.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)</div>        \r\n          </div>\r\n    \r\n            <p>Maps a set of names to a corresponding set of dispatch identifiers.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">void _MethodBuilder.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>riid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.guid\" data-linktype=\"relative-path\">Guid</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Reserved for future use. Must be IID_NULL.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>rgszNames</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Passed-in array of names to be mapped.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>cNames</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Count of the names to be mapped.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>lcid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The locale context in which to interpret the names.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>rgDispId</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Caller-allocated array that receives the IDs corresponding to the names.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notimplementedexception\" data-linktype=\"relative-path\">NotImplementedException</a></div>\r\n                  </div>\r\n                  <p>Late-bound access using the COM <code>IDispatch</code> interface is not supported.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <code>IDispatch::GetIDsOfNames</code>, see the MSDN Library.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_System_Runtime_InteropServices__MethodBuilder_GetTypeInfo_System_UInt32_System_UInt32_System_IntPtr_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_System_Runtime_InteropServices__MethodBuilder_GetTypeInfo_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_MethodBuilder.GetTypeInfo(UInt32,UInt32,IntPtr)</div>        \r\n          </div>\r\n    \r\n            <p>Retrieves the type information for an object, which can then be used to get the type information for an interface.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">void _MethodBuilder.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>iTInfo</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The type information to return.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>lcid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The locale identifier for the type information.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>ppTInfo</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Receives a pointer to the requested type information object.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notimplementedexception\" data-linktype=\"relative-path\">NotImplementedException</a></div>\r\n                  </div>\r\n                  <p>Late-bound access using the COM <code>IDispatch</code> interface is not supported.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <code>IDispatch::GetTypeInfo</code>, see the MSDN Library.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_System_Runtime_InteropServices__MethodBuilder_GetTypeInfoCount_System_UInt32__\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_System_Runtime_InteropServices__MethodBuilder_GetTypeInfoCount_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_MethodBuilder.GetTypeInfoCount(UInt32)</div>        \r\n          </div>\r\n    \r\n            <p>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">void _MethodBuilder.GetTypeInfoCount (out uint pcTInfo);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>pcTInfo</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Points to a location that receives the number of type information interfaces provided by the object.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notimplementedexception\" data-linktype=\"relative-path\">NotImplementedException</a></div>\r\n                  </div>\r\n                  <p>Late-bound access using the COM <code>IDispatch</code> interface is not supported.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <code>IDispatch::GetTypeInfoCount</code>, see the MSDN Library.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_MethodBuilder_System_Runtime_InteropServices__MethodBuilder_Invoke_System_UInt32_System_Guid__System_UInt32_System_Int16_System_IntPtr_System_IntPtr_System_IntPtr_System_IntPtr_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_MethodBuilder_System_Runtime_InteropServices__MethodBuilder_Invoke_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_MethodBuilder.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)</div>        \r\n          </div>\r\n    \r\n            <p>Provides access to properties and methods exposed by an object.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">void _MethodBuilder.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>dispIdMember</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Identifies the member.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>riid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.guid\" data-linktype=\"relative-path\">Guid</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Reserved for future use. Must be IID_NULL.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>lcid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The locale context in which to interpret arguments.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>wFlags</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int16\" data-linktype=\"relative-path\">Int16</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Flags describing the context of the call.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>pDispParams</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Pointer to a structure containing an array of arguments, an array of argument DispIDs for named arguments, and counts for the number of elements in the arrays.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>pVarResult</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Pointer to the location where the result is to be stored.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>pExcepInfo</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Pointer to a structure that contains exception information.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>puArgErr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The index of the first argument that has an error.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notimplementedexception\" data-linktype=\"relative-path\">NotImplementedException</a></div>\r\n                  </div>\r\n                  <p>Late-bound access using the COM <code>IDispatch</code> interface is not supported.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <code>IDispatch::Invoke</code>, see the MSDN Library.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n","outputRootRelativePath":"./","pageMetadata":"<meta name=\"breadcrumb_path\" content=\"breadcrumb/toc.json\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"fulldocset\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.fulldocset\">\r\n<meta name=\"ref_skeleton_gitcommit\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Reflection.Emit.MethodBuilder.yml\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Reflection.Emit.MethodBuilder.yml\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.Attributes\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.CallingConvention\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.ContainsGenericParameters\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.CreateMethodBody\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.DeclaringType\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.DefineGenericParameters\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.DefineParameter\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.Equals\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.GetBaseDefinition\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.GetCustomAttributes\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.GetGenericArguments\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.GetHashCode\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.GetILGenerator\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.GetModule\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.GetParameters\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.GetToken\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.InitLocals\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.Invoke\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.IsDefined\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.IsGenericMethod\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.IsSecurityCritical\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.IsSecurityTransparent\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.MakeGenericMethod\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.MethodHandle\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.Module\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.Name\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.ReflectedType\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.ReturnParameter\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.ReturnType\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.SetCustomAttribute\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.SetImplementationFlags\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.SetMarshal\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.SetMethodBody\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.SetParameters\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.SetReturnType\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.SetSignature\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.Signature\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder._MethodBuilder.GetIDsOfNames\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder._MethodBuilder.GetTypeInfo\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder._MethodBuilder.GetTypeInfoCount\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder._MethodBuilder.Invoke\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.MethodBuilder.ToString\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-01 01:37 AM\">\r\n<meta name=\"document_id\" content=\"8ab79867-54a8-b3a4-02ba-14c783850760\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Defines and represents a method (or constructor) on a dynamic class.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/System.Reflection.Emit/toc.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Reflection.Emit.MethodBuilder\">\r\n","rawMetadata":{"breadcrumb_path":"breadcrumb/toc.json","search.ms_sitename":"Docs","search.ms_docsetname":"fulldocset","version":null,"_op_canonicalUrlPrefix":"https://ppe.docs.microsoft.com/en-us/fulldotnet/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":true,"depot_name":"MSDN.fulldocset","_op_gitRefSkeletonCommitHistory":[{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"use plugin in master","commit_sha":"501959ac03e19ac52a27aa4c6bbeb980f8b11c8c","commit_date":"2017-03-01 09:31:20 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"fix pointer ref","commit_sha":"76befb0e7f7b41839ec719047e5b39a5981298f3","commit_date":"2017-02-28 15:47:23 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"switch from platform to version","commit_sha":"78cdacb5ca782478af490a6b30c3a2cb2b6b873e","commit_date":"2017-02-28 15:09:51 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"update platforms","commit_sha":"39ad5a8919a59afc93a79ac4bd8e07c3b471b37a","commit_date":"2017-02-28 10:38:59 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"checkin yml","commit_sha":"da161b792852497df7140d7768cee2eccd9cb43f","commit_date":"2017-02-28 09:36:15 +0800"}],"ref_skeleton_gitcommit":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Reflection.Emit.MethodBuilder.yml","original_ref_skeleton_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Reflection.Emit.MethodBuilder.yml","open_to_public_contributors":true,"api_name":["System.Reflection.Emit.MethodBuilder","System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity","System.Reflection.Emit.MethodBuilder.Attributes","System.Reflection.Emit.MethodBuilder.CallingConvention","System.Reflection.Emit.MethodBuilder.ContainsGenericParameters","System.Reflection.Emit.MethodBuilder.CreateMethodBody","System.Reflection.Emit.MethodBuilder.DeclaringType","System.Reflection.Emit.MethodBuilder.DefineGenericParameters","System.Reflection.Emit.MethodBuilder.DefineParameter","System.Reflection.Emit.MethodBuilder.Equals","System.Reflection.Emit.MethodBuilder.GetBaseDefinition","System.Reflection.Emit.MethodBuilder.GetCustomAttributes","System.Reflection.Emit.MethodBuilder.GetGenericArguments","System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition","System.Reflection.Emit.MethodBuilder.GetHashCode","System.Reflection.Emit.MethodBuilder.GetILGenerator","System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags","System.Reflection.Emit.MethodBuilder.GetModule","System.Reflection.Emit.MethodBuilder.GetParameters","System.Reflection.Emit.MethodBuilder.GetToken","System.Reflection.Emit.MethodBuilder.InitLocals","System.Reflection.Emit.MethodBuilder.Invoke","System.Reflection.Emit.MethodBuilder.IsDefined","System.Reflection.Emit.MethodBuilder.IsGenericMethod","System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition","System.Reflection.Emit.MethodBuilder.IsSecurityCritical","System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical","System.Reflection.Emit.MethodBuilder.IsSecurityTransparent","System.Reflection.Emit.MethodBuilder.MakeGenericMethod","System.Reflection.Emit.MethodBuilder.MethodHandle","System.Reflection.Emit.MethodBuilder.Module","System.Reflection.Emit.MethodBuilder.Name","System.Reflection.Emit.MethodBuilder.ReflectedType","System.Reflection.Emit.MethodBuilder.ReturnParameter","System.Reflection.Emit.MethodBuilder.ReturnType","System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes","System.Reflection.Emit.MethodBuilder.SetCustomAttribute","System.Reflection.Emit.MethodBuilder.SetImplementationFlags","System.Reflection.Emit.MethodBuilder.SetMarshal","System.Reflection.Emit.MethodBuilder.SetMethodBody","System.Reflection.Emit.MethodBuilder.SetParameters","System.Reflection.Emit.MethodBuilder.SetReturnType","System.Reflection.Emit.MethodBuilder.SetSignature","System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute","System.Reflection.Emit.MethodBuilder.Signature","System.Reflection.Emit.MethodBuilder._MethodBuilder.GetIDsOfNames","System.Reflection.Emit.MethodBuilder._MethodBuilder.GetTypeInfo","System.Reflection.Emit.MethodBuilder._MethodBuilder.GetTypeInfoCount","System.Reflection.Emit.MethodBuilder._MethodBuilder.Invoke","System.Reflection.Emit.MethodBuilder.ToString"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Reflection.Emit.MethodBuilder","System::Reflection::Emit::MethodBuilder","System.Reflection.Emit.MethodBuilder.AddDeclarativeSecurity","System::Reflection::Emit::MethodBuilder::AddDeclarativeSecurity","System.Reflection.Emit.MethodBuilder.Attributes","System::Reflection::Emit::MethodBuilder::Attributes","System.Reflection.Emit.MethodBuilder.CallingConvention","System::Reflection::Emit::MethodBuilder::CallingConvention","System.Reflection.Emit.MethodBuilder.ContainsGenericParameters","System::Reflection::Emit::MethodBuilder::ContainsGenericParameters","System.Reflection.Emit.MethodBuilder.CreateMethodBody","System::Reflection::Emit::MethodBuilder::CreateMethodBody","System.Reflection.Emit.MethodBuilder.DeclaringType","System::Reflection::Emit::MethodBuilder::DeclaringType","System.Reflection.Emit.MethodBuilder.DefineGenericParameters","System::Reflection::Emit::MethodBuilder::DefineGenericParameters","System.Reflection.Emit.MethodBuilder.DefineParameter","System::Reflection::Emit::MethodBuilder::DefineParameter","System.Reflection.Emit.MethodBuilder.Equals","System::Reflection::Emit::MethodBuilder::Equals","System.Reflection.Emit.MethodBuilder.GetBaseDefinition","System::Reflection::Emit::MethodBuilder::GetBaseDefinition","System.Reflection.Emit.MethodBuilder.GetCustomAttributes","System::Reflection::Emit::MethodBuilder::GetCustomAttributes","System.Reflection.Emit.MethodBuilder.GetGenericArguments","System::Reflection::Emit::MethodBuilder::GetGenericArguments","System.Reflection.Emit.MethodBuilder.GetGenericMethodDefinition","System::Reflection::Emit::MethodBuilder::GetGenericMethodDefinition","System.Reflection.Emit.MethodBuilder.GetHashCode","System::Reflection::Emit::MethodBuilder::GetHashCode","System.Reflection.Emit.MethodBuilder.GetILGenerator","System::Reflection::Emit::MethodBuilder::GetILGenerator","System.Reflection.Emit.MethodBuilder.GetMethodImplementationFlags","System::Reflection::Emit::MethodBuilder::GetMethodImplementationFlags","System.Reflection.Emit.MethodBuilder.GetModule","System::Reflection::Emit::MethodBuilder::GetModule","System.Reflection.Emit.MethodBuilder.GetParameters","System::Reflection::Emit::MethodBuilder::GetParameters","System.Reflection.Emit.MethodBuilder.GetToken","System::Reflection::Emit::MethodBuilder::GetToken","System.Reflection.Emit.MethodBuilder.InitLocals","System::Reflection::Emit::MethodBuilder::InitLocals","System.Reflection.Emit.MethodBuilder.Invoke","System::Reflection::Emit::MethodBuilder::Invoke","System.Reflection.Emit.MethodBuilder.IsDefined","System::Reflection::Emit::MethodBuilder::IsDefined","System.Reflection.Emit.MethodBuilder.IsGenericMethod","System::Reflection::Emit::MethodBuilder::IsGenericMethod","System.Reflection.Emit.MethodBuilder.IsGenericMethodDefinition","System::Reflection::Emit::MethodBuilder::IsGenericMethodDefinition","System.Reflection.Emit.MethodBuilder.IsSecurityCritical","System::Reflection::Emit::MethodBuilder::IsSecurityCritical","System.Reflection.Emit.MethodBuilder.IsSecuritySafeCritical","System::Reflection::Emit::MethodBuilder::IsSecuritySafeCritical","System.Reflection.Emit.MethodBuilder.IsSecurityTransparent","System::Reflection::Emit::MethodBuilder::IsSecurityTransparent","System.Reflection.Emit.MethodBuilder.MakeGenericMethod","System::Reflection::Emit::MethodBuilder::MakeGenericMethod","System.Reflection.Emit.MethodBuilder.MethodHandle","System::Reflection::Emit::MethodBuilder::MethodHandle","System.Reflection.Emit.MethodBuilder.Module","System::Reflection::Emit::MethodBuilder::Module","System.Reflection.Emit.MethodBuilder.Name","System::Reflection::Emit::MethodBuilder::Name","System.Reflection.Emit.MethodBuilder.ReflectedType","System::Reflection::Emit::MethodBuilder::ReflectedType","System.Reflection.Emit.MethodBuilder.ReturnParameter","System::Reflection::Emit::MethodBuilder::ReturnParameter","System.Reflection.Emit.MethodBuilder.ReturnType","System::Reflection::Emit::MethodBuilder::ReturnType","System.Reflection.Emit.MethodBuilder.ReturnTypeCustomAttributes","System::Reflection::Emit::MethodBuilder::ReturnTypeCustomAttributes","System.Reflection.Emit.MethodBuilder.SetCustomAttribute","System::Reflection::Emit::MethodBuilder::SetCustomAttribute","System.Reflection.Emit.MethodBuilder.SetImplementationFlags","System::Reflection::Emit::MethodBuilder::SetImplementationFlags","System.Reflection.Emit.MethodBuilder.SetMarshal","System::Reflection::Emit::MethodBuilder::SetMarshal","System.Reflection.Emit.MethodBuilder.SetMethodBody","System::Reflection::Emit::MethodBuilder::SetMethodBody","System.Reflection.Emit.MethodBuilder.SetParameters","System::Reflection::Emit::MethodBuilder::SetParameters","System.Reflection.Emit.MethodBuilder.SetReturnType","System::Reflection::Emit::MethodBuilder::SetReturnType","System.Reflection.Emit.MethodBuilder.SetSignature","System::Reflection::Emit::MethodBuilder::SetSignature","System.Reflection.Emit.MethodBuilder.SetSymCustomAttribute","System::Reflection::Emit::MethodBuilder::SetSymCustomAttribute","System.Reflection.Emit.MethodBuilder.Signature","System::Reflection::Emit::MethodBuilder::Signature","System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames","System::Reflection::Emit::MethodBuilder::System#Runtime#InteropServices#_MethodBuilder#GetIDsOfNames","System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo","System::Reflection::Emit::MethodBuilder::System#Runtime#InteropServices#_MethodBuilder#GetTypeInfo","System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount","System::Reflection::Emit::MethodBuilder::System#Runtime#InteropServices#_MethodBuilder#GetTypeInfoCount","System.Reflection.Emit.MethodBuilder.System#Runtime#InteropServices#_MethodBuilder#Invoke","System::Reflection::Emit::MethodBuilder::System#Runtime#InteropServices#_MethodBuilder#Invoke","System.Reflection.Emit.MethodBuilder.ToString","System::Reflection::Emit::MethodBuilder::ToString"],"dev_langs":["csharp"],"updated_at":"2017-03-01 01:37 AM","document_id":"8ab79867-54a8-b3a4-02ba-14c783850760","content_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/xml/System.Reflection.Emit/MethodBuilder.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"MethodBuilder class | Microsoft Docs","_op_ogTitle":"MethodBuilder class","description":"Defines and represents a method (or constructor) on a dynamic class.\n","toc_asset_id":"_splitted/System.Reflection.Emit/toc.json","toc_rel":"_splitted/System.Reflection.Emit/toc.json","source_url":"","ms.assetid":"System.Reflection.Emit.MethodBuilder","canonical_url":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.reflection.emit.methodbuilder","_op_canonicalUrl":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.reflection.emit.methodbuilder","fileRelativePath":"System.Reflection.Emit.MethodBuilder.html"},"themesRelativePathToOutputRoot":"_themes/"}