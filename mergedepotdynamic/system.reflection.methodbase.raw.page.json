{"content":"    \r\n    <h1 id=\"System_Reflection_MethodBase\">\r\n      <span class=\"lang-csharp\">MethodBase</span>\r\n        Class\r\n    </h1>\r\n    \r\n    \r\n    <nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n      <h3>In this Article</h3>\r\n    </nav><div class=\"summary\">\r\n    \t<p>Provides information about methods and constructors.</p>\n\r\n    </div><h2>Syntax</h2>\r\n    \r\n    \t<h3>Declaration</h3>\r\n    \t<pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]\n[System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodBase))]\n[System.Runtime.InteropServices.ComVisible(true)]\npublic abstract class MethodBase : System.Reflection.MemberInfo, System.Runtime.InteropServices._MethodBase</code></pre>\r\n    \r\n    \r\n    \r\n    <h3>Inheritance Hierarchy</h3>\r\n    <ul class=\"inheritance\">\r\n        <li class=\"l0\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>\r\n          </div>\r\n        </li>\r\n        <li class=\"l1\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">System.Reflection.MemberInfo</a>\r\n          </div>\r\n        </li>\r\n      <li class=\"l2\">\r\n        <div class=\"xref\">\r\n          <div class=\"lang-csharp\">MethodBase</div>\r\n        </div>\r\n      </li>\r\n    </ul>\r\n    \r\n      <div class=\"referencebox inheritedMembers\">\r\n        <h3>Inherited Members</h3>\r\n        <h4></h4>\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_CustomAttributes\" data-linktype=\"relative-path\">CustomAttributes</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_DeclaringType\" data-linktype=\"relative-path\">DeclaringType</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_GetCustomAttributes_System_Boolean_\" data-linktype=\"relative-path\">GetCustomAttributes(Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_GetCustomAttributes_System_Type_System_Boolean_\" data-linktype=\"relative-path\">GetCustomAttributes(Type,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_GetCustomAttributesData\" data-linktype=\"relative-path\">GetCustomAttributesData()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_IsDefined_System_Type_System_Boolean_\" data-linktype=\"relative-path\">IsDefined(Type,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_MemberType\" data-linktype=\"relative-path\">MemberType</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_MetadataToken\" data-linktype=\"relative-path\">MetadataToken</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_Module\" data-linktype=\"relative-path\">Module</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_Name\" data-linktype=\"relative-path\">Name</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_op_Equality_System_Reflection_MemberInfo_System_Reflection_MemberInfo_\" data-linktype=\"relative-path\">op_Equality(MemberInfo,MemberInfo)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_op_Inequality_System_Reflection_MemberInfo_System_Reflection_MemberInfo_\" data-linktype=\"relative-path\">op_Inequality(MemberInfo,MemberInfo)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_ReflectedType\" data-linktype=\"relative-path\">ReflectedType</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_System_Runtime_InteropServices__MemberInfo_GetIDsOfNames_System_Guid__System_IntPtr_System_UInt32_System_UInt32_System_IntPtr_\" data-linktype=\"relative-path\">_MemberInfo.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_System_Runtime_InteropServices__MemberInfo_GetType\" data-linktype=\"relative-path\">_MemberInfo.GetType()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_System_Runtime_InteropServices__MemberInfo_GetTypeInfo_System_UInt32_System_UInt32_System_IntPtr_\" data-linktype=\"relative-path\">_MemberInfo.GetTypeInfo(UInt32,UInt32,IntPtr)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_System_Runtime_InteropServices__MemberInfo_GetTypeInfoCount_System_UInt32__\" data-linktype=\"relative-path\">_MemberInfo.GetTypeInfoCount(UInt32)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_System_Runtime_InteropServices__MemberInfo_Invoke_System_UInt32_System_Guid__System_UInt32_System_Int16_System_IntPtr_System_IntPtr_System_IntPtr_System_IntPtr_\" data-linktype=\"relative-path\">_MemberInfo.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)</a>\r\n          </div>\r\n          \r\n      </div>\r\n    \r\n    \r\n      <h2>Remarks</h2>\r\n      <p><code>MethodBase</code> is the base class of <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> and <a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a>.</p>\n\r\n    \r\n    \r\n    <h2>Constructors\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase__ctor\" data-linktype=\"self-bookmark\">MethodBase()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> class.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Properties\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_Attributes\" data-linktype=\"self-bookmark\">Attributes</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the attributes associated with this method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_CallingConvention\" data-linktype=\"self-bookmark\">CallingConvention</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating the calling conventions for this method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_ContainsGenericParameters\" data-linktype=\"self-bookmark\">ContainsGenericParameters</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the generic method contains unassigned generic type parameters.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_IsAbstract\" data-linktype=\"self-bookmark\">IsAbstract</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the method is abstract.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_IsAssembly\" data-linktype=\"self-bookmark\">IsAssembly</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the potential visibility of this method or constructor is described by <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a>; that is, the method or constructor is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_IsConstructor\" data-linktype=\"self-bookmark\">IsConstructor</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the method is a constructor.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_IsFamily\" data-linktype=\"self-bookmark\">IsFamily</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the visibility of this method or constructor is described by <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a>; that is, the method or constructor is visible only within its class and derived classes.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_IsFamilyAndAssembly\" data-linktype=\"self-bookmark\">IsFamilyAndAssembly</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the visibility of this method or constructor is described by <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a>; that is, the method or constructor can be called by derived classes, but only if they are in the same assembly.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_IsFamilyOrAssembly\" data-linktype=\"self-bookmark\">IsFamilyOrAssembly</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the potential visibility of this method or constructor is described by <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a>; that is, the method or constructor can be called by derived classes wherever they are, and by classes in the same assembly.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_IsFinal\" data-linktype=\"self-bookmark\">IsFinal</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether this method is <code>final</code>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_IsGenericMethod\" data-linktype=\"self-bookmark\">IsGenericMethod</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the method is generic.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_IsGenericMethodDefinition\" data-linktype=\"self-bookmark\">IsGenericMethodDefinition</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the method is a generic method definition.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_IsHideBySig\" data-linktype=\"self-bookmark\">IsHideBySig</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether only a member of the same kind with exactly the same signature is hidden in the derived class.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_IsPrivate\" data-linktype=\"self-bookmark\">IsPrivate</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether this member is private.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_IsPublic\" data-linktype=\"self-bookmark\">IsPublic</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether this is a public method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_IsSecurityCritical\" data-linktype=\"self-bookmark\">IsSecurityCritical</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value that indicates whether the current method or constructor is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_IsSecuritySafeCritical\" data-linktype=\"self-bookmark\">IsSecuritySafeCritical</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value that indicates whether the current method or constructor is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_IsSecurityTransparent\" data-linktype=\"self-bookmark\">IsSecurityTransparent</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value that indicates whether the current method or constructor is transparent at the current trust level, and therefore cannot perform critical operations.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_IsSpecialName\" data-linktype=\"self-bookmark\">IsSpecialName</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether this method has a special name.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_IsStatic\" data-linktype=\"self-bookmark\">IsStatic</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the method is <code>static</code>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_IsVirtual\" data-linktype=\"self-bookmark\">IsVirtual</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the method is <code>virtual</code>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_MethodHandle\" data-linktype=\"self-bookmark\">MethodHandle</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a handle to the internal metadata representation of a method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_MethodImplementationFlags\" data-linktype=\"self-bookmark\">MethodImplementationFlags</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the <a class=\"xref\" href=\"system.reflection.methodimplattributes\" data-linktype=\"relative-path\">MethodImplAttributes</a> flags that specify the attributes of a method implementation.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Methods\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_Equals_System_Object_\" data-linktype=\"self-bookmark\">Equals(Object)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns a value that indicates whether this instance is equal to a specified object.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_GetCurrentMethod\" data-linktype=\"self-bookmark\">GetCurrentMethod()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns a <code>MethodBase</code> object representing the currently executing method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_GetGenericArguments\" data-linktype=\"self-bookmark\">GetGenericArguments()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns an array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_GetHashCode\" data-linktype=\"self-bookmark\">GetHashCode()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns the hash code for this instance.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_GetMethodBody\" data-linktype=\"self-bookmark\">GetMethodBody()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, gets a <a class=\"xref\" href=\"system.reflection.methodbody\" data-linktype=\"relative-path\">MethodBody</a> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_GetMethodFromHandle_System_RuntimeMethodHandle_\" data-linktype=\"self-bookmark\">GetMethodFromHandle(RuntimeMethodHandle)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets method information by using the method&#39;s internal metadata representation (handle).</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_GetMethodFromHandle_System_RuntimeMethodHandle_System_RuntimeTypeHandle_\" data-linktype=\"self-bookmark\">GetMethodFromHandle(RuntimeMethodHandle,RuntimeTypeHandle)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> object for the constructor or method represented by the specified handle, for the specified generic type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_GetMethodImplementationFlags\" data-linktype=\"self-bookmark\">GetMethodImplementationFlags()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, returns the <a class=\"xref\" href=\"system.reflection.methodimplattributes\" data-linktype=\"relative-path\">MethodImplAttributes</a> flags.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_GetParameters\" data-linktype=\"self-bookmark\">GetParameters()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, gets the parameters of the specified method or constructor.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_Invoke_System_Object_System_Object___\" data-linktype=\"self-bookmark\">Invoke(Object,Object[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Invokes the method or constructor represented by the current instance, using the specified parameters.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_Invoke_System_Object_System_Reflection_BindingFlags_System_Reflection_Binder_System_Object___System_Globalization_CultureInfo_\" data-linktype=\"self-bookmark\">Invoke(Object,BindingFlags,Binder,Object[],CultureInfo)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, invokes the reflected method or constructor with the given parameters.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Operators\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_op_Equality_System_Reflection_MethodBase_System_Reflection_MethodBase_\" data-linktype=\"self-bookmark\">op_Equality(MethodBase,MethodBase)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Indicates whether two <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> objects are equal.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_op_Inequality_System_Reflection_MethodBase_System_Reflection_MethodBase_\" data-linktype=\"self-bookmark\">op_Inequality(MethodBase,MethodBase)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Indicates whether two <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> objects are not equal.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Explicit Interface Implementations\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_GetIDsOfNames_System_Guid__System_IntPtr_System_UInt32_System_UInt32_System_IntPtr_\" data-linktype=\"self-bookmark\">_MethodBase.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Maps a set of names to a corresponding set of dispatch identifiers.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_GetType\" data-linktype=\"self-bookmark\">_MethodBase.GetType()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.GetType*</span>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_GetTypeInfo_System_UInt32_System_UInt32_System_IntPtr_\" data-linktype=\"self-bookmark\">_MethodBase.GetTypeInfo(UInt32,UInt32,IntPtr)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Retrieves the type information for an object, which can then be used to get the type information for an interface.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_GetTypeInfoCount_System_UInt32__\" data-linktype=\"self-bookmark\">_MethodBase.GetTypeInfoCount(UInt32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_Invoke_System_UInt32_System_Guid__System_UInt32_System_Int16_System_IntPtr_System_IntPtr_System_IntPtr_System_IntPtr_\" data-linktype=\"self-bookmark\">_MethodBase.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Provides access to properties and methods exposed by an object.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsAbstract\" data-linktype=\"self-bookmark\">_MethodBase.IsAbstract</a></div>\r\n          </td>\r\n            <td>\r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsAbstract*</span>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsAssembly\" data-linktype=\"self-bookmark\">_MethodBase.IsAssembly</a></div>\r\n          </td>\r\n            <td>\r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsAssembly*</span>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsConstructor\" data-linktype=\"self-bookmark\">_MethodBase.IsConstructor</a></div>\r\n          </td>\r\n            <td>\r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsConstructor*</span>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsFamily\" data-linktype=\"self-bookmark\">_MethodBase.IsFamily</a></div>\r\n          </td>\r\n            <td>\r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsFamily*</span>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsFamilyAndAssembly\" data-linktype=\"self-bookmark\">_MethodBase.IsFamilyAndAssembly</a></div>\r\n          </td>\r\n            <td>\r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly*</span>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsFamilyOrAssembly\" data-linktype=\"self-bookmark\">_MethodBase.IsFamilyOrAssembly</a></div>\r\n          </td>\r\n            <td>\r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly*</span>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsFinal\" data-linktype=\"self-bookmark\">_MethodBase.IsFinal</a></div>\r\n          </td>\r\n            <td>\r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsFinal*</span>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsHideBySig\" data-linktype=\"self-bookmark\">_MethodBase.IsHideBySig</a></div>\r\n          </td>\r\n            <td>\r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsHideBySig*</span>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsPrivate\" data-linktype=\"self-bookmark\">_MethodBase.IsPrivate</a></div>\r\n          </td>\r\n            <td>\r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsPrivate*</span>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsPublic\" data-linktype=\"self-bookmark\">_MethodBase.IsPublic</a></div>\r\n          </td>\r\n            <td>\r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsPublic*</span>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsSpecialName\" data-linktype=\"self-bookmark\">_MethodBase.IsSpecialName</a></div>\r\n          </td>\r\n            <td>\r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsSpecialName*</span>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsStatic\" data-linktype=\"self-bookmark\">_MethodBase.IsStatic</a></div>\r\n          </td>\r\n            <td>\r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsStatic*</span>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsVirtual\" data-linktype=\"self-bookmark\">_MethodBase.IsVirtual</a></div>\r\n          </td>\r\n            <td>\r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsVirtual*</span>.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"constructors\">\r\n        <h2>Constructors\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase__ctor\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase__ctor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">MethodBase()</div>        \r\n          </div>\r\n    \r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> class.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected MethodBase ();</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"properties\">\r\n        <h2>Properties\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_Attributes\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_Attributes_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Attributes</div>        \r\n          </div>\r\n    \r\n            <p>Gets the attributes associated with this method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract System.Reflection.MethodAttributes Attributes { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a></div>\r\n                  </div>\r\n                  <p>One of the <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a> values.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>All members have a set of attributes, which are defined in relation to the specific type of member.  </p>\n<p> To get the <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a>, first get the type. From the type, get the method. From the method, get the <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example displays the attributes of the user-defined method Mymethod.  </p>\n<pre><code class=\"lang-cs\" name=\"Classic MethodBase.Attributes Example#1\">\nusing System;\nusing System.Reflection;\n \nclass AttributesSample\n{\n    public void Mymethod (int int1m, out string str2m, ref string str3m)\n    {\n        str2m = &quot;in Mymethod&quot;;\n    }\n \n    public static int Main(string[] args)\n    {      \n        Console.WriteLine (&quot;Reflection.MethodBase.Attributes Sample&quot;);\n       \n        // Get the type.\n        Type MyType = Type.GetType(&quot;AttributesSample&quot;);\n \n        // Get the method Mymethod on the type.\n        MethodBase Mymethodbase = MyType.GetMethod(&quot;Mymethod&quot;);\n \n        // Display the method name.\n        Console.WriteLine(&quot;Mymethodbase = &quot; + Mymethodbase);\n \n        // Get the MethodAttribute enumerated value.\n        MethodAttributes Myattributes = Mymethodbase.Attributes;\n \n        // Display the flags that are set.\n        PrintAttributes(typeof(System.Reflection.MethodAttributes), (int) Myattributes);\n        return 0;\n    }\n \n \n    public static void PrintAttributes(Type attribType, int iAttribValue)\n    {\n        if (!attribType.IsEnum)\n        { \n            Console.WriteLine(&quot;This type is not an enum.&quot;); \n            return; \n        }\n \n        FieldInfo[] fields = attribType.GetFields(BindingFlags.Public | BindingFlags.Static);\n        for (int i = 0; i &lt; fields.Length; i++)\n        {\n            int fieldvalue = (Int32)fields[i].GetValue(null);\n            if ((fieldvalue &amp; iAttribValue) == fieldvalue)\n            {\n                Console.WriteLine(fields[i].Name);\n            }\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Classic MethodBase.Attributes Example#1\">Imports System\nImports System.Reflection\nImports Microsoft.VisualBasic\n\nClass AttributesSample\n\n    Public Sub Mymethod(ByVal int1m As Integer, ByRef str2m As String, ByRef str3m As String)\n        str2m = &quot;in Mymethod&quot;\n    End Sub &#39;Mymethod\n\n    Public Shared Function Main(ByVal args() As String) As Integer\n        Console.WriteLine(&quot;Reflection.MethodBase.Attributes Sample&quot;)\n\n        &#39; Get the type.\n        Dim MyType As Type = Type.GetType(&quot;AttributesSample&quot;)\n\n        &#39; Get the method Mymethod on the type.\n        Dim Mymethodbase As MethodBase = MyType.GetMethod(&quot;Mymethod&quot;)\n\n        &#39; Display the method name.\n        Console.WriteLine(&quot;Mymethodbase = {0}.&quot;, Mymethodbase)\n\n        &#39; Get the MethodAttribute enumerated value.\n        Dim Myattributes As MethodAttributes = Mymethodbase.Attributes\n\n        &#39; Display the flags that are set.\n        PrintAttributes(GetType(System.Reflection.MethodAttributes), CInt(Myattributes))\n        Return 0\n    End Function &#39;Main\n\n    Public Shared Sub PrintAttributes(ByVal attribType As Type, ByVal iAttribValue As Integer)\n        If Not attribType.IsEnum Then\n            Console.WriteLine(&quot;This type is not an enum.&quot;)\n            Return\n        End If\n        Dim fields As FieldInfo() = attribType.GetFields((BindingFlags.Public Or BindingFlags.Static))\n        Dim i As Integer\n        For i = 0 To fields.Length - 1\n            Dim fieldvalue As Integer = CType(fields(i).GetValue(Nothing), Int32)\n            If (fieldvalue And iAttribValue) = fieldvalue Then\n                Console.WriteLine(fields(i).Name)\n            End If\n        Next i\n    End Sub &#39;PrintAttributes\nEnd Class &#39;AttributesSample\n</code></pre><pre><code class=\"lang-cpp\" name=\"Classic MethodBase.Attributes Example#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Runtime::InteropServices;\npublic ref class AttributesSample\n{\npublic:\n   void Mymethod( int int1m, [Out]interior_ptr&lt;String^&gt; str2m, interior_ptr&lt;String^&gt; str3m )\n   {\n       *str2m = &quot;in Mymethod&quot;;\n   }\n};\n\nvoid PrintAttributes( Type^ attribType, int iAttribValue )\n{\n   if (  !attribType-&gt;IsEnum )\n   {\n      Console::WriteLine( &quot;This type is not an enum.&quot; );\n      return;\n   }\n\n   array&lt;FieldInfo^&gt;^fields = attribType-&gt;GetFields( static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Static) );\n   for ( int i = 0; i &lt; fields-&gt;Length; i++ )\n   {\n      int fieldvalue = safe_cast&lt;Int32&gt;(fields[ i ]-&gt;GetValue( nullptr ));\n      if ( (fieldvalue &amp; iAttribValue) == fieldvalue )\n      {\n         Console::WriteLine( fields[ i ]-&gt;Name );\n      }\n   }\n}\n\nint main()\n{\n   Console::WriteLine( &quot;Reflection.MethodBase.Attributes Sample&quot; );\n\n   // Get the type.\n   Type^ MyType = Type::GetType( &quot;AttributesSample&quot; );\n\n   // Get the method Mymethod on the type.\n   MethodBase^ Mymethodbase = MyType-&gt;GetMethod( &quot;Mymethod&quot; );\n\n   // Display the method name.\n   Console::WriteLine( &quot;Mymethodbase = {0}&quot;, Mymethodbase );\n\n   // Get the MethodAttribute enumerated value.\n   MethodAttributes Myattributes = Mymethodbase-&gt;Attributes;\n\n   // Display the flags that are set.\n   PrintAttributes( System::Reflection::MethodAttributes::typeid, (int)Myattributes );\n   return 0;\n}\n</code></pre><p> This code produces the following output:  </p>\n<p> Reflection.MethodBase.Attributes Sample  </p>\n<p> Mymethodbase = Void Mymethod(Int32, System.String ByRef, System.String ByRef)  </p>\n<p> PrivateScope  </p>\n<p> FamANDAssem  </p>\n<p> Family  </p>\n<p> Public  </p>\n<p> HideBySig  </p>\n<p> ReuseSlot</p>\n\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_CallingConvention\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_CallingConvention_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">CallingConvention</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating the calling conventions for this method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual System.Reflection.CallingConventions CallingConvention { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.callingconventions\" data-linktype=\"relative-path\">CallingConventions</a></div>\r\n                  </div>\r\n                  <p>The <a class=\"xref\" href=\"system.reflection.callingconventions\" data-linktype=\"relative-path\">CallingConventions</a> for this method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_ContainsGenericParameters\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_ContainsGenericParameters_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ContainsGenericParameters</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the generic method contains unassigned generic type parameters.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool ContainsGenericParameters { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the current <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> object represents a generic method that contains unassigned generic type parameters; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A generic method can be invoked only if there are no generic type definitions or open constructed types in the type arguments of the method itself or in any enclosing types. Because types can be arbitrarily complex, making this recursive determination is difficult. For convenience, and to reduce the chance of error, the ContainsGenericParameters property provides a standard way to distinguish between closed constructed methods, which can be invoked, and open constructed methods, which cannot. If the ContainsGenericParameters property returns <code>true</code>, the method cannot be invoked.  </p>\n<p> The ContainsGenericParameters property searches recursively for type parameters. For example, it returns <code>true</code> for any method in an open type <code>A&lt;T&gt;</code> (<code>A(Of T)</code> in Visual Basic), even though the method itself is not generic. Contrast this with the behavior of the <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsGenericMethod_\" data-linktype=\"relative-path\">IsGenericMethod</a> property, which returns <code>false</code> for such a method.  </p>\n<p> Similarly, the ContainsGenericParameters property parameter returns <code>true</code> for any constructor in an open type, even though constructors cannot have type parameters of their own.  </p>\n<p> For a list of the invariant conditions for terms specific to generic methods, see the &lt;xref:System.Reflection.MethodInfo.IsGenericMethod%2A?displayProperty=fullName&gt; property. For a list of the invariant conditions for other terms used in generic reflection, see the <a class=\"xref\" href=\"system.type#System_Type_IsGenericType_\" data-linktype=\"relative-path\">IsGenericType</a> property.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_IsAbstract\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_IsAbstract_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsAbstract</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the method is abstract.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsAbstract { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the method is abstract; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>An abstract member is declared on a base class and has no implementation supplied.  </p>\n<p> To get the <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a>, first get the type. From the type, get the method. From the method, get the <code>MethodBase</code>. If the <code>MethodBase</code> or constructor is other than public, it is protected and cannot be readily accessed. To access a non-public method, set the <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> mask to <code>NonPublic</code> in <code>GetMethod</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example determines whether specified the method is abstract and displays the result.  </p>\n<pre><code class=\"lang-cpp\" name=\"Classic MethodBase.IsAbstract Example#1\">using namespace System;\nusing namespace System::Reflection;\nint main()\n{\n   Console::WriteLine( &quot;<br>Reflection.MethodBase&quot; );\n   \n   // Get the types.\n   Type^ MyType1 = Type::GetType( &quot;System.Runtime.Serialization.Formatter&quot; );\n   Type^ MyType2 = Type::GetType( &quot;System.Reflection.MethodBase&quot; );\n   \n   // Get and display the methods.\n   MethodBase^ Mymethodbase1 = MyType1-&gt;GetMethod( &quot;WriteInt32&quot;, static_cast&lt;BindingFlags&gt;(BindingFlags::NonPublic | BindingFlags::Instance) );\n   MethodBase^ Mymethodbase2 = MyType2-&gt;GetMethod( &quot;GetCurrentMethod&quot;, static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Static) );\n   Console::Write( &quot;<br>Mymethodbase = {0}&quot;, Mymethodbase1 );\n   if ( Mymethodbase1-&gt;IsAbstract )\n      Console::Write( &quot;<br>Mymethodbase is an abstract method.&quot; );\n   else\n      Console::Write( &quot;<br>Mymethodbase is not an abstract method.&quot; );\n\n   Console::Write( &quot;<br><br>Mymethodbase = {0}&quot;, Mymethodbase2 );\n   if ( Mymethodbase2-&gt;IsAbstract )\n      Console::Write( &quot;<br>Mymethodbase is an abstract method.&quot; );\n   else\n      Console::Write( &quot;<br>Mymethodbase is not an abstract method.&quot; );\n\n   return 0;\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Classic MethodBase.IsAbstract Example#1\">using System;\nusing System.Reflection;\n// using System.Windows.Forms;\n\nclass methodbase\n{\n    public static int Main(string[] args)\n    {      \n        Console.WriteLine (&quot;<br>Reflection.MethodBase&quot;);\n        \n        // Get the types.\n        Type MyType1 = Type.GetType(&quot;System.Runtime.Serialization.Formatter&quot;);       \n        Type MyType2 = Type.GetType(&quot;System.Reflection.MethodBase&quot;);\n \n        // Get and display the methods.\n        MethodBase Mymethodbase1 = \n            MyType1.GetMethod(&quot;WriteInt32&quot;, BindingFlags.NonPublic|BindingFlags.Instance);\n\n        MethodBase Mymethodbase2 = \n            MyType2.GetMethod(&quot;GetCurrentMethod&quot;, BindingFlags.Public|BindingFlags.Static);\n \n        Console.Write(&quot;<br>Mymethodbase = &quot; + Mymethodbase1.ToString());\n        if (Mymethodbase1.IsAbstract)\n            Console.Write (&quot;<br>Mymethodbase is an abstract method.&quot;);\n        else\n            Console.Write (&quot;<br>Mymethodbase is not an abstract method.&quot;);\n \n        Console.Write(&quot;<br><br>Mymethodbase = &quot; + Mymethodbase2.ToString());\n        if (Mymethodbase2.IsAbstract)\n            Console.Write (&quot;<br>Mymethodbase is an abstract method.&quot;);\n        else\n            Console.Write (&quot;<br>Mymethodbase is not an abstract method.&quot;);\n       \n        return 0;\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Classic MethodBase.IsAbstract Example#1\">Imports System\nImports System.Reflection\nImports Microsoft.VisualBasic\n\nClass methodbase1\n\n    Public Shared Function Main() As Integer\n        Console.WriteLine(&quot;Reflection.MethodBase&quot;)\n        Console.WriteLine()\n        &#39; Get the types.\n        Dim MyType1 As Type = _\n           Type.GetType(&quot;System.Runtime.Serialization.Formatter&quot;)\n        Dim MyType2 As Type = _\n           Type.GetType(&quot;System.Reflection.MethodBase&quot;)\n\n        &#39; Get and display the methods\n        Dim Mymethodbase1 As MethodBase = _\n           MyType1.GetMethod(&quot;WriteInt32&quot;, BindingFlags.NonPublic Or BindingFlags.Instance)\n        Dim Mymethodbase2 As MethodBase = _\n           MyType2.GetMethod(&quot;GetCurrentMethod&quot;, BindingFlags.Public Or BindingFlags.Static)\n\n        Console.WriteLine(&quot;Mymethodbase = {0}&quot;, Mymethodbase1.ToString())\n        If Mymethodbase1.IsAbstract Then\n            Console.WriteLine(ControlChars.CrLf &amp; &quot;Mymethodbase is an abstract method.&quot;)\n        Else\n            Console.WriteLine(ControlChars.CrLf &amp; &quot;Mymethodbase is not an abstract method.&quot;)\n        End If\n        Console.Write(&quot;Mymethodbase = {0}&quot;, Mymethodbase2.ToString())\n        If Mymethodbase2.IsAbstract Then\n            Console.WriteLine(ControlChars.CrLf &amp; &quot;Mymethodbase is an abstract method.&quot;)\n        Else\n            Console.WriteLine(ControlChars.CrLf &amp; &quot;Mymethodbase is not an abstract method.&quot;)\n        End If\n        Return 0\n    End Function\n\nEnd Class\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_IsAssembly\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_IsAssembly_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsAssembly</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the potential visibility of this method or constructor is described by <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a>; that is, the method or constructor is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsAssembly { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the visibility of this method or constructor is exactly described by <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a>; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The actual visibility of a method is limited by the visibility of its type. The IsAssembly property might be <code>true</code> for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.  </p>\n<p> The visibility of a method or constructor is exactly described by <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">System.Reflection.MethodAttributes</a> if the only visibility modifier is <code>internal</code> (<code>Friend</code> in Visual Basic). This property is <code>false</code> for methods that are <code>protected internal</code> in C# (<code>Protected Friend</code> in Visual Basic, <code>protected public</code> in C++); use the <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsFamilyOrAssembly_\" data-linktype=\"relative-path\">IsFamilyOrAssembly</a> property to identify such methods.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example defines methods with varying levels of visibility, and displays the values of their IsAssembly, <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsFamily_\" data-linktype=\"relative-path\">IsFamily</a>, <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsFamilyOrAssembly_\" data-linktype=\"relative-path\">IsFamilyOrAssembly</a>, and <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsFamilyAndAssembly_\" data-linktype=\"relative-path\">IsFamilyAndAssembly</a> properties.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The Visual Basic and C# languages cannot define methods with <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">System.Reflection.MethodAttributes</a> visibility; that access level appears only in the C++ example.  </p>\n</div>\n<pre><code class=\"lang-vb\" name=\"Classic MethodBase.IsAssembly Example#1\">Imports System\nImports System.Reflection\n\nPublic class Example\n\n    Public Sub m_Public() \n    End Sub\n    Friend Sub m_Friend() \n    End Sub\n    Protected Sub m_Protected() \n    End Sub\n    Protected Friend Sub m_Protected_Friend() \n    End Sub\n\n    Public Shared Sub Main()\n    \n        Console.WriteLine(vbCrLf &amp; _\n            &quot;{0,-30}{1,-18}{2}&quot;, &quot;&quot;, &quot;IsAssembly&quot;, &quot;IsFamilyOrAssembly&quot;) \n        Console.WriteLine(&quot;{0,-21}{1,-18}{2,-18}{3}&quot; &amp; vbCrLf, _\n            &quot;&quot;, &quot;IsPublic&quot;, &quot;IsFamily&quot;, &quot;IsFamilyAndAssembly&quot;)\n   \n        For Each m As MethodBase In GetType(Example).GetMethods( _\n            BindingFlags.Instance Or BindingFlags.NonPublic Or BindingFlags.Public)\n        \n            If Left(m.Name, 1) = &quot;m&quot;\n            \n                Console.WriteLine(&quot;{0,-21}{1,-9}{2,-9}{3,-9}{4,-9}{5,-9}&quot;, _\n                    m.Name, _\n                    m.IsPublic, _\n                    m.IsAssembly, _\n                    m.IsFamily, _\n                    m.IsFamilyOrAssembly, _\n                    m.IsFamilyAndAssembly _\n                )\n            End If\n        Next\n    End Sub\nEnd Class\n\n&#39; This code example produces output similar to the following:\n&#39;\n&#39;                              IsAssembly        IsFamilyOrAssembly\n&#39;                     IsPublic          IsFamily          IsFamilyAndAssembly\n&#39;\n&#39;m_Public             True     False    False    False    False\n&#39;m_Friend             False    True     False    False    False\n&#39;m_Protected          False    False    True     False    False\n&#39;m_Protected_Friend   False    False    False    True     False\n</code></pre><pre><code class=\"lang-cpp\" name=\"Classic MethodBase.IsAssembly Example#1\">using namespace System;\nusing namespace System::Reflection;\n\npublic ref class Example\n{\npublic:\n    void m_public() {};\ninternal:\n    void m_internal() {};\nprotected:\n    void m_protected() {};\nprotected public:\n    void m_protected_public() {};\nprotected private:\n    void m_protected_private() {};\n};\n\nvoid main()\n{\n    Console::WriteLine(&quot;<br>{0,-30}{1,-18}{2}&quot;, &quot;&quot;, &quot;IsAssembly&quot;, &quot;IsFamilyOrAssembly&quot;); \n    Console::WriteLine(&quot;{0,-21}{1,-18}{2,-18}{3}<br>&quot;, \n        &quot;&quot;, &quot;IsPublic&quot;, &quot;IsFamily&quot;, &quot;IsFamilyAndAssembly&quot;);\n\n    for each (MethodBase^ m in Example::typeid-&gt;GetMethods(\n        BindingFlags::Instance | BindingFlags::NonPublic | BindingFlags::Public))\n    {\n        if (m-&gt;Name-&gt;Substring(0, 1) == &quot;m&quot;)\n        {\n            Console::WriteLine(&quot;{0,-21}{1,-9}{2,-9}{3,-9}{4,-9}{5,-9}&quot;, \n                m-&gt;Name,\n                m-&gt;IsPublic,\n                m-&gt;IsAssembly,\n                m-&gt;IsFamily,\n                m-&gt;IsFamilyOrAssembly,\n                m-&gt;IsFamilyAndAssembly\n            );\n        }\n    }\n}\n\n/* This code example produces output similar to the following:\n\n                              IsAssembly        IsFamilyOrAssembly\n                     IsPublic          IsFamily          IsFamilyAndAssembly\n\nm_public             True     False    False    False    False\nm_internal           False    True     False    False    False\nm_protected          False    False    True     False    False\nm_protected_public   False    False    False    True     False\nm_protected_private  False    False    False    False    True\n */\n</code></pre><pre><code class=\"lang-cs\" name=\"Classic MethodBase.IsAssembly Example#1\">using System;\nusing System.Reflection;\n\npublic class Example\n{\n    public void m_public() {}\n    internal void m_internal() {}\n    protected void m_protected() {}\n    protected internal void m_protected_public() {}\n\n    public static void Main()\n    {\n        Console.WriteLine(&quot;<br>{0,-30}{1,-18}{2}&quot;, &quot;&quot;, &quot;IsAssembly&quot;, &quot;IsFamilyOrAssembly&quot;); \n        Console.WriteLine(&quot;{0,-21}{1,-18}{2,-18}{3}<br>&quot;, \n            &quot;&quot;, &quot;IsPublic&quot;, &quot;IsFamily&quot;, &quot;IsFamilyAndAssembly&quot;);\n   \n        foreach (MethodBase m in typeof(Example).GetMethods(\n            BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public))\n        {\n            if (m.Name.Substring(0, 1) == &quot;m&quot;)\n            {\n                Console.WriteLine(&quot;{0,-21}{1,-9}{2,-9}{3,-9}{4,-9}{5,-9}&quot;, \n                    m.Name,\n                    m.IsPublic,\n                    m.IsAssembly,\n                    m.IsFamily,\n                    m.IsFamilyOrAssembly,\n                    m.IsFamilyAndAssembly\n                );\n            }\n        }\n    }\n}\n\n/* This code example produces output similar to the following:\n\n                              IsAssembly        IsFamilyOrAssembly\n                     IsPublic          IsFamily          IsFamilyAndAssembly\n\nm_public             True     False    False    False    False\nm_internal           False    True     False    False    False\nm_protected          False    False    True     False    False\nm_protected_public   False    False    False    True     False\n */\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_IsConstructor\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_IsConstructor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsConstructor</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the method is a constructor.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsConstructor { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if this method is a constructor represented by a <a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a> object (see note in Remarks about <a class=\"xref\" href=\"system.reflection.emit.constructorbuilder\" data-linktype=\"relative-path\">ConstructorBuilder</a> objects); otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <div class=\"NOTE\"><h5>Note</h5><p> The IsConstructor property returns <code>false</code> for a <a class=\"xref\" href=\"system.reflection.emit.constructorbuilder\" data-linktype=\"relative-path\">ConstructorBuilder</a> object in a dynamic type, unless the <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">System.Reflection.MethodAttributes</a> flag was included in the <code>attributes</code> parameter when the constructor was defined. Omitting the <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a> flag does not affect the correctness of the emitted constructor.</p>\n</div>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_IsFamily\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_IsFamily_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsFamily</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the visibility of this method or constructor is described by <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a>; that is, the method or constructor is visible only within its class and derived classes.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsFamily { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if access to this method or constructor is exactly described by <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a>; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The visibility of a method or constructor is exactly described by <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">System.Reflection.MethodAttributes</a> if the only visibility modifier is <code>protected</code>. This property is <code>false</code> for methods that are <code>protected internal</code> in C# (<code>Protected Friend</code> in Visual Basic, <code>protected public</code> in C++); use the <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsFamilyOrAssembly_\" data-linktype=\"relative-path\">IsFamilyOrAssembly</a> property to identify such methods.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example defines methods with varying levels of visibility, and displays the values of their <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsAssembly_\" data-linktype=\"relative-path\">IsAssembly</a>, IsFamily, <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsFamilyOrAssembly_\" data-linktype=\"relative-path\">IsFamilyOrAssembly</a>, and <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsFamilyAndAssembly_\" data-linktype=\"relative-path\">IsFamilyAndAssembly</a> properties.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The Visual Basic and C# languages cannot define methods with <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">System.Reflection.MethodAttributes</a> visibility; that access level appears only in the C++ example.  </p>\n</div>\n<pre><code class=\"lang-vb\" name=\"Classic MethodBase.IsAssembly Example#1\">Imports System\nImports System.Reflection\n\nPublic class Example\n\n    Public Sub m_Public() \n    End Sub\n    Friend Sub m_Friend() \n    End Sub\n    Protected Sub m_Protected() \n    End Sub\n    Protected Friend Sub m_Protected_Friend() \n    End Sub\n\n    Public Shared Sub Main()\n    \n        Console.WriteLine(vbCrLf &amp; _\n            &quot;{0,-30}{1,-18}{2}&quot;, &quot;&quot;, &quot;IsAssembly&quot;, &quot;IsFamilyOrAssembly&quot;) \n        Console.WriteLine(&quot;{0,-21}{1,-18}{2,-18}{3}&quot; &amp; vbCrLf, _\n            &quot;&quot;, &quot;IsPublic&quot;, &quot;IsFamily&quot;, &quot;IsFamilyAndAssembly&quot;)\n   \n        For Each m As MethodBase In GetType(Example).GetMethods( _\n            BindingFlags.Instance Or BindingFlags.NonPublic Or BindingFlags.Public)\n        \n            If Left(m.Name, 1) = &quot;m&quot;\n            \n                Console.WriteLine(&quot;{0,-21}{1,-9}{2,-9}{3,-9}{4,-9}{5,-9}&quot;, _\n                    m.Name, _\n                    m.IsPublic, _\n                    m.IsAssembly, _\n                    m.IsFamily, _\n                    m.IsFamilyOrAssembly, _\n                    m.IsFamilyAndAssembly _\n                )\n            End If\n        Next\n    End Sub\nEnd Class\n\n&#39; This code example produces output similar to the following:\n&#39;\n&#39;                              IsAssembly        IsFamilyOrAssembly\n&#39;                     IsPublic          IsFamily          IsFamilyAndAssembly\n&#39;\n&#39;m_Public             True     False    False    False    False\n&#39;m_Friend             False    True     False    False    False\n&#39;m_Protected          False    False    True     False    False\n&#39;m_Protected_Friend   False    False    False    True     False\n</code></pre><pre><code class=\"lang-cpp\" name=\"Classic MethodBase.IsAssembly Example#1\">using namespace System;\nusing namespace System::Reflection;\n\npublic ref class Example\n{\npublic:\n    void m_public() {};\ninternal:\n    void m_internal() {};\nprotected:\n    void m_protected() {};\nprotected public:\n    void m_protected_public() {};\nprotected private:\n    void m_protected_private() {};\n};\n\nvoid main()\n{\n    Console::WriteLine(&quot;<br>{0,-30}{1,-18}{2}&quot;, &quot;&quot;, &quot;IsAssembly&quot;, &quot;IsFamilyOrAssembly&quot;); \n    Console::WriteLine(&quot;{0,-21}{1,-18}{2,-18}{3}<br>&quot;, \n        &quot;&quot;, &quot;IsPublic&quot;, &quot;IsFamily&quot;, &quot;IsFamilyAndAssembly&quot;);\n\n    for each (MethodBase^ m in Example::typeid-&gt;GetMethods(\n        BindingFlags::Instance | BindingFlags::NonPublic | BindingFlags::Public))\n    {\n        if (m-&gt;Name-&gt;Substring(0, 1) == &quot;m&quot;)\n        {\n            Console::WriteLine(&quot;{0,-21}{1,-9}{2,-9}{3,-9}{4,-9}{5,-9}&quot;, \n                m-&gt;Name,\n                m-&gt;IsPublic,\n                m-&gt;IsAssembly,\n                m-&gt;IsFamily,\n                m-&gt;IsFamilyOrAssembly,\n                m-&gt;IsFamilyAndAssembly\n            );\n        }\n    }\n}\n\n/* This code example produces output similar to the following:\n\n                              IsAssembly        IsFamilyOrAssembly\n                     IsPublic          IsFamily          IsFamilyAndAssembly\n\nm_public             True     False    False    False    False\nm_internal           False    True     False    False    False\nm_protected          False    False    True     False    False\nm_protected_public   False    False    False    True     False\nm_protected_private  False    False    False    False    True\n */\n</code></pre><pre><code class=\"lang-cs\" name=\"Classic MethodBase.IsAssembly Example#1\">using System;\nusing System.Reflection;\n\npublic class Example\n{\n    public void m_public() {}\n    internal void m_internal() {}\n    protected void m_protected() {}\n    protected internal void m_protected_public() {}\n\n    public static void Main()\n    {\n        Console.WriteLine(&quot;<br>{0,-30}{1,-18}{2}&quot;, &quot;&quot;, &quot;IsAssembly&quot;, &quot;IsFamilyOrAssembly&quot;); \n        Console.WriteLine(&quot;{0,-21}{1,-18}{2,-18}{3}<br>&quot;, \n            &quot;&quot;, &quot;IsPublic&quot;, &quot;IsFamily&quot;, &quot;IsFamilyAndAssembly&quot;);\n   \n        foreach (MethodBase m in typeof(Example).GetMethods(\n            BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public))\n        {\n            if (m.Name.Substring(0, 1) == &quot;m&quot;)\n            {\n                Console.WriteLine(&quot;{0,-21}{1,-9}{2,-9}{3,-9}{4,-9}{5,-9}&quot;, \n                    m.Name,\n                    m.IsPublic,\n                    m.IsAssembly,\n                    m.IsFamily,\n                    m.IsFamilyOrAssembly,\n                    m.IsFamilyAndAssembly\n                );\n            }\n        }\n    }\n}\n\n/* This code example produces output similar to the following:\n\n                              IsAssembly        IsFamilyOrAssembly\n                     IsPublic          IsFamily          IsFamilyAndAssembly\n\nm_public             True     False    False    False    False\nm_internal           False    True     False    False    False\nm_protected          False    False    True     False    False\nm_protected_public   False    False    False    True     False\n */\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_IsFamilyAndAssembly\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_IsFamilyAndAssembly_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsFamilyAndAssembly</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the visibility of this method or constructor is described by <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a>; that is, the method or constructor can be called by derived classes, but only if they are in the same assembly.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsFamilyAndAssembly { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if access to this method or constructor is exactly described by <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a>; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The visibility of a method or constructor is exactly described by <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">System.Reflection.MethodAttributes</a> if the visibility modifier is <code>protected private</code> in C++. Methods with this visibility cannot be defined in Visual Basic or C#.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example defines methods with varying levels of visibility, and displays the values of their <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsAssembly_\" data-linktype=\"relative-path\">IsAssembly</a>, <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsFamily_\" data-linktype=\"relative-path\">IsFamily</a>, <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsFamilyOrAssembly_\" data-linktype=\"relative-path\">IsFamilyOrAssembly</a>, and IsFamilyAndAssembly properties.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The Visual Basic and C# languages cannot define methods with <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">System.Reflection.MethodAttributes</a> visibility; that access level appears only in the C++ example.  </p>\n</div>\n<pre><code class=\"lang-vb\" name=\"Classic MethodBase.IsAssembly Example#1\">Imports System\nImports System.Reflection\n\nPublic class Example\n\n    Public Sub m_Public() \n    End Sub\n    Friend Sub m_Friend() \n    End Sub\n    Protected Sub m_Protected() \n    End Sub\n    Protected Friend Sub m_Protected_Friend() \n    End Sub\n\n    Public Shared Sub Main()\n    \n        Console.WriteLine(vbCrLf &amp; _\n            &quot;{0,-30}{1,-18}{2}&quot;, &quot;&quot;, &quot;IsAssembly&quot;, &quot;IsFamilyOrAssembly&quot;) \n        Console.WriteLine(&quot;{0,-21}{1,-18}{2,-18}{3}&quot; &amp; vbCrLf, _\n            &quot;&quot;, &quot;IsPublic&quot;, &quot;IsFamily&quot;, &quot;IsFamilyAndAssembly&quot;)\n   \n        For Each m As MethodBase In GetType(Example).GetMethods( _\n            BindingFlags.Instance Or BindingFlags.NonPublic Or BindingFlags.Public)\n        \n            If Left(m.Name, 1) = &quot;m&quot;\n            \n                Console.WriteLine(&quot;{0,-21}{1,-9}{2,-9}{3,-9}{4,-9}{5,-9}&quot;, _\n                    m.Name, _\n                    m.IsPublic, _\n                    m.IsAssembly, _\n                    m.IsFamily, _\n                    m.IsFamilyOrAssembly, _\n                    m.IsFamilyAndAssembly _\n                )\n            End If\n        Next\n    End Sub\nEnd Class\n\n&#39; This code example produces output similar to the following:\n&#39;\n&#39;                              IsAssembly        IsFamilyOrAssembly\n&#39;                     IsPublic          IsFamily          IsFamilyAndAssembly\n&#39;\n&#39;m_Public             True     False    False    False    False\n&#39;m_Friend             False    True     False    False    False\n&#39;m_Protected          False    False    True     False    False\n&#39;m_Protected_Friend   False    False    False    True     False\n</code></pre><pre><code class=\"lang-cpp\" name=\"Classic MethodBase.IsAssembly Example#1\">using namespace System;\nusing namespace System::Reflection;\n\npublic ref class Example\n{\npublic:\n    void m_public() {};\ninternal:\n    void m_internal() {};\nprotected:\n    void m_protected() {};\nprotected public:\n    void m_protected_public() {};\nprotected private:\n    void m_protected_private() {};\n};\n\nvoid main()\n{\n    Console::WriteLine(&quot;<br>{0,-30}{1,-18}{2}&quot;, &quot;&quot;, &quot;IsAssembly&quot;, &quot;IsFamilyOrAssembly&quot;); \n    Console::WriteLine(&quot;{0,-21}{1,-18}{2,-18}{3}<br>&quot;, \n        &quot;&quot;, &quot;IsPublic&quot;, &quot;IsFamily&quot;, &quot;IsFamilyAndAssembly&quot;);\n\n    for each (MethodBase^ m in Example::typeid-&gt;GetMethods(\n        BindingFlags::Instance | BindingFlags::NonPublic | BindingFlags::Public))\n    {\n        if (m-&gt;Name-&gt;Substring(0, 1) == &quot;m&quot;)\n        {\n            Console::WriteLine(&quot;{0,-21}{1,-9}{2,-9}{3,-9}{4,-9}{5,-9}&quot;, \n                m-&gt;Name,\n                m-&gt;IsPublic,\n                m-&gt;IsAssembly,\n                m-&gt;IsFamily,\n                m-&gt;IsFamilyOrAssembly,\n                m-&gt;IsFamilyAndAssembly\n            );\n        }\n    }\n}\n\n/* This code example produces output similar to the following:\n\n                              IsAssembly        IsFamilyOrAssembly\n                     IsPublic          IsFamily          IsFamilyAndAssembly\n\nm_public             True     False    False    False    False\nm_internal           False    True     False    False    False\nm_protected          False    False    True     False    False\nm_protected_public   False    False    False    True     False\nm_protected_private  False    False    False    False    True\n */\n</code></pre><pre><code class=\"lang-cs\" name=\"Classic MethodBase.IsAssembly Example#1\">using System;\nusing System.Reflection;\n\npublic class Example\n{\n    public void m_public() {}\n    internal void m_internal() {}\n    protected void m_protected() {}\n    protected internal void m_protected_public() {}\n\n    public static void Main()\n    {\n        Console.WriteLine(&quot;<br>{0,-30}{1,-18}{2}&quot;, &quot;&quot;, &quot;IsAssembly&quot;, &quot;IsFamilyOrAssembly&quot;); \n        Console.WriteLine(&quot;{0,-21}{1,-18}{2,-18}{3}<br>&quot;, \n            &quot;&quot;, &quot;IsPublic&quot;, &quot;IsFamily&quot;, &quot;IsFamilyAndAssembly&quot;);\n   \n        foreach (MethodBase m in typeof(Example).GetMethods(\n            BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public))\n        {\n            if (m.Name.Substring(0, 1) == &quot;m&quot;)\n            {\n                Console.WriteLine(&quot;{0,-21}{1,-9}{2,-9}{3,-9}{4,-9}{5,-9}&quot;, \n                    m.Name,\n                    m.IsPublic,\n                    m.IsAssembly,\n                    m.IsFamily,\n                    m.IsFamilyOrAssembly,\n                    m.IsFamilyAndAssembly\n                );\n            }\n        }\n    }\n}\n\n/* This code example produces output similar to the following:\n\n                              IsAssembly        IsFamilyOrAssembly\n                     IsPublic          IsFamily          IsFamilyAndAssembly\n\nm_public             True     False    False    False    False\nm_internal           False    True     False    False    False\nm_protected          False    False    True     False    False\nm_protected_public   False    False    False    True     False\n */\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_IsFamilyOrAssembly\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_IsFamilyOrAssembly_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsFamilyOrAssembly</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the potential visibility of this method or constructor is described by <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a>; that is, the method or constructor can be called by derived classes wherever they are, and by classes in the same assembly.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsFamilyOrAssembly { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if access to this method or constructor is exactly described by <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a>; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If a type member has <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">System.Reflection.MethodAttributes</a>visibility, it can be called from any member in a derived class or any member in the same assembly, but not from any other type.  </p>\n<p> The actual visibility of a method is limited by the visibility of its type. The IsFamilyOrAssembly property might be <code>true</code> for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.  </p>\n<p> The visibility of a method or constructor is exactly described by <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">System.Reflection.MethodAttributes</a> if the visibility modifier is <code>protected internal</code> in C# (<code>Protected Friend</code> in Visual Basic, <code>protected public</code> in C++).</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example defines methods with varying levels of visibility, and displays the values of their <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsAssembly_\" data-linktype=\"relative-path\">IsAssembly</a>, <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsFamily_\" data-linktype=\"relative-path\">IsFamily</a>, IsFamilyOrAssembly, and <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsFamilyAndAssembly_\" data-linktype=\"relative-path\">IsFamilyAndAssembly</a> properties.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The Visual Basic and C# languages cannot define methods with <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">System.Reflection.MethodAttributes</a> visibility; that access level appears only in the C++ example.  </p>\n</div>\n<pre><code class=\"lang-vb\" name=\"Classic MethodBase.IsAssembly Example#1\">Imports System\nImports System.Reflection\n\nPublic class Example\n\n    Public Sub m_Public() \n    End Sub\n    Friend Sub m_Friend() \n    End Sub\n    Protected Sub m_Protected() \n    End Sub\n    Protected Friend Sub m_Protected_Friend() \n    End Sub\n\n    Public Shared Sub Main()\n    \n        Console.WriteLine(vbCrLf &amp; _\n            &quot;{0,-30}{1,-18}{2}&quot;, &quot;&quot;, &quot;IsAssembly&quot;, &quot;IsFamilyOrAssembly&quot;) \n        Console.WriteLine(&quot;{0,-21}{1,-18}{2,-18}{3}&quot; &amp; vbCrLf, _\n            &quot;&quot;, &quot;IsPublic&quot;, &quot;IsFamily&quot;, &quot;IsFamilyAndAssembly&quot;)\n   \n        For Each m As MethodBase In GetType(Example).GetMethods( _\n            BindingFlags.Instance Or BindingFlags.NonPublic Or BindingFlags.Public)\n        \n            If Left(m.Name, 1) = &quot;m&quot;\n            \n                Console.WriteLine(&quot;{0,-21}{1,-9}{2,-9}{3,-9}{4,-9}{5,-9}&quot;, _\n                    m.Name, _\n                    m.IsPublic, _\n                    m.IsAssembly, _\n                    m.IsFamily, _\n                    m.IsFamilyOrAssembly, _\n                    m.IsFamilyAndAssembly _\n                )\n            End If\n        Next\n    End Sub\nEnd Class\n\n&#39; This code example produces output similar to the following:\n&#39;\n&#39;                              IsAssembly        IsFamilyOrAssembly\n&#39;                     IsPublic          IsFamily          IsFamilyAndAssembly\n&#39;\n&#39;m_Public             True     False    False    False    False\n&#39;m_Friend             False    True     False    False    False\n&#39;m_Protected          False    False    True     False    False\n&#39;m_Protected_Friend   False    False    False    True     False\n</code></pre><pre><code class=\"lang-cpp\" name=\"Classic MethodBase.IsAssembly Example#1\">using namespace System;\nusing namespace System::Reflection;\n\npublic ref class Example\n{\npublic:\n    void m_public() {};\ninternal:\n    void m_internal() {};\nprotected:\n    void m_protected() {};\nprotected public:\n    void m_protected_public() {};\nprotected private:\n    void m_protected_private() {};\n};\n\nvoid main()\n{\n    Console::WriteLine(&quot;<br>{0,-30}{1,-18}{2}&quot;, &quot;&quot;, &quot;IsAssembly&quot;, &quot;IsFamilyOrAssembly&quot;); \n    Console::WriteLine(&quot;{0,-21}{1,-18}{2,-18}{3}<br>&quot;, \n        &quot;&quot;, &quot;IsPublic&quot;, &quot;IsFamily&quot;, &quot;IsFamilyAndAssembly&quot;);\n\n    for each (MethodBase^ m in Example::typeid-&gt;GetMethods(\n        BindingFlags::Instance | BindingFlags::NonPublic | BindingFlags::Public))\n    {\n        if (m-&gt;Name-&gt;Substring(0, 1) == &quot;m&quot;)\n        {\n            Console::WriteLine(&quot;{0,-21}{1,-9}{2,-9}{3,-9}{4,-9}{5,-9}&quot;, \n                m-&gt;Name,\n                m-&gt;IsPublic,\n                m-&gt;IsAssembly,\n                m-&gt;IsFamily,\n                m-&gt;IsFamilyOrAssembly,\n                m-&gt;IsFamilyAndAssembly\n            );\n        }\n    }\n}\n\n/* This code example produces output similar to the following:\n\n                              IsAssembly        IsFamilyOrAssembly\n                     IsPublic          IsFamily          IsFamilyAndAssembly\n\nm_public             True     False    False    False    False\nm_internal           False    True     False    False    False\nm_protected          False    False    True     False    False\nm_protected_public   False    False    False    True     False\nm_protected_private  False    False    False    False    True\n */\n</code></pre><pre><code class=\"lang-cs\" name=\"Classic MethodBase.IsAssembly Example#1\">using System;\nusing System.Reflection;\n\npublic class Example\n{\n    public void m_public() {}\n    internal void m_internal() {}\n    protected void m_protected() {}\n    protected internal void m_protected_public() {}\n\n    public static void Main()\n    {\n        Console.WriteLine(&quot;<br>{0,-30}{1,-18}{2}&quot;, &quot;&quot;, &quot;IsAssembly&quot;, &quot;IsFamilyOrAssembly&quot;); \n        Console.WriteLine(&quot;{0,-21}{1,-18}{2,-18}{3}<br>&quot;, \n            &quot;&quot;, &quot;IsPublic&quot;, &quot;IsFamily&quot;, &quot;IsFamilyAndAssembly&quot;);\n   \n        foreach (MethodBase m in typeof(Example).GetMethods(\n            BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public))\n        {\n            if (m.Name.Substring(0, 1) == &quot;m&quot;)\n            {\n                Console.WriteLine(&quot;{0,-21}{1,-9}{2,-9}{3,-9}{4,-9}{5,-9}&quot;, \n                    m.Name,\n                    m.IsPublic,\n                    m.IsAssembly,\n                    m.IsFamily,\n                    m.IsFamilyOrAssembly,\n                    m.IsFamilyAndAssembly\n                );\n            }\n        }\n    }\n}\n\n/* This code example produces output similar to the following:\n\n                              IsAssembly        IsFamilyOrAssembly\n                     IsPublic          IsFamily          IsFamilyAndAssembly\n\nm_public             True     False    False    False    False\nm_internal           False    True     False    False    False\nm_protected          False    False    True     False    False\nm_protected_public   False    False    False    True     False\n */\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_IsFinal\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_IsFinal_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsFinal</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether this method is <code>final</code>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsFinal { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if this method is <code>final</code>; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>To determine if a method is overridable, it is not sufficient to check that <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsVirtual_\" data-linktype=\"relative-path\">IsVirtual</a> is <code>true</code>. For a method to be overridable, <code>IsVirtual</code> must be <code>true</code> and <code>IsFinal</code> must be <code>false</code>. For example, a method might be non-virtual, but it implements an interface method. The common language runtime requires that all methods that implement interface members must be marked as <code>virtual</code>; therefore, the compiler marks the method <code>virtual final</code>. So there are cases where a method is marked as <code>virtual</code> but is still not overridable.  </p>\n<p> To establish with certainty whether a method is overridable, use code such as this:  </p>\n<p> <code>if (MethodInfo.IsVirtual &amp;&amp; !MethodInfo.IsFinal)</code>  </p>\n<p> If <code>IsVirtual</code> is <code>false</code> or <code>IsFinal</code> is <code>true</code>, then the method cannot be overridden.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example displays <code>false</code> for <code>IsFinal</code>, which might lead you to think that MyMethod is overridable. The code prints <code>false</code> even though MyMethod is not marked <code>virtual</code> and thus cannot be overridden.  </p>\n<pre><code class=\"lang-cs\" name=\"Classic MethodBase.IsVirtual Example#1\">using System;\nusing System.Reflection;\n \npublic class MyClass \n{\n    public void MyMethod() \n    {\n    }\n    public static void Main() \n    {\n        MethodBase m = typeof(MyClass).GetMethod(&quot;MyMethod&quot;);\n        Console.WriteLine(&quot;The IsFinal property value of MyMethod is {0}.&quot;, m.IsFinal);\n        Console.WriteLine(&quot;The IsVirtual property value of MyMethod is {0}.&quot;, m.IsVirtual);\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"Classic MethodBase.IsVirtual Example#1\">using namespace System;\nusing namespace System::Reflection;\n\npublic ref class MyClass\n{\npublic:\n   void MyMethod(){}\n};\n\nint main()\n{\n   MethodBase^ m = MyClass::typeid-&gt;GetMethod( &quot;MyMethod&quot; );\n   Console::WriteLine( &quot;The IsFinal property value of MyMethod is {0}.&quot;, m-&gt;IsFinal );\n   Console::WriteLine( &quot;The IsVirtual property value of MyMethod is {0}.&quot;, m-&gt;IsVirtual );\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Classic MethodBase.IsVirtual Example#1\">Imports System\nImports System.Reflection\nImports Microsoft.VisualBasic\n\nPublic Class MyClass1\n    \n    Public Sub MyMethod()\n    End Sub\n    \n    Public Shared Sub Main()\n        Dim m As MethodBase = GetType(MyClass1).GetMethod(&quot;MyMethod&quot;)\n        Console.WriteLine(&quot;The IsFinal property value of MyMethod is {0}.&quot;, m.IsFinal)\n        Console.WriteLine(&quot;The IsVirtual property value of MyMethod is {0}.&quot;, m.IsVirtual)\n    End Sub\nEnd Class\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_IsGenericMethod\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_IsGenericMethod_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsGenericMethod</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the method is generic.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool IsGenericMethod { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the current <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> represents a generic method; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Use the IsGenericMethod property to determine whether the current <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> object represents a generic method. Use the <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_ContainsGenericParameters_\" data-linktype=\"relative-path\">ContainsGenericParameters</a> property to determine whether the current <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> object represents an open constructed method or a closed constructed method.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Generics are not supported by default; this property returns <code>false</code> if not overridden in a derived class. Generic constructors are not supported in the .NET Framework version 2.0, so this property returns <code>false</code> if the current instance is of type <a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a>.  </p>\n</div>\n<p> For a list of the invariant conditions for terms specific to generic methods, see the &lt;xref:System.Reflection.MethodInfo.IsGenericMethod%2A?displayProperty=fullName&gt; property. For a list of the invariant conditions for other terms used in generic reflection, see the <a class=\"xref\" href=\"system.type#System_Type_IsGenericType_\" data-linktype=\"relative-path\">IsGenericType</a> property.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_IsGenericMethodDefinition\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_IsGenericMethodDefinition_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsGenericMethodDefinition</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the method is a generic method definition.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool IsGenericMethodDefinition { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the current <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> object represents the definition of a generic method; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the current <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> represents a generic method definition, then:  </p>\n<ul>\n<li><p>The IsGenericMethodDefinition property is <code>true</code>.  </p>\n</li>\n<li><p>For each <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object in the array returned by the <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_GetGenericArguments_\" data-linktype=\"relative-path\">GetGenericArguments</a> method:  </p>\n<ul>\n<li><p>The <a class=\"xref\" href=\"system.type#System_Type_IsGenericParameter_\" data-linktype=\"relative-path\">IsGenericParameter</a> property is <code>true</code>.  </p>\n</li>\n<li><p>The <a class=\"xref\" href=\"system.type#System_Type_DeclaringMethod_\" data-linktype=\"relative-path\">DeclaringMethod</a> property returns the current instance.  </p>\n</li>\n<li><p>The <a class=\"xref\" href=\"system.type#System_Type_GenericParameterPosition_\" data-linktype=\"relative-path\">GenericParameterPosition</a> property is the same as the position of the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object in the array.  </p>\n</li>\n</ul>\n</li>\n</ul>\n<div class=\"NOTE\"><h5>Note</h5><p> Generics are not supported by default; this property returns <code>false</code> if not overridden in a derived class. Generic constructors are not supported in the .NET Framework version 2.0, so this property returns <code>false</code> if the current instance is of type <a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a>.  </p>\n</div>\n<p> For a list of the invariant conditions for terms specific to generic methods, see the &lt;xref:System.Reflection.MethodInfo.IsGenericMethod%2A?displayProperty=fullName&gt; property. For a list of the invariant conditions for other terms used in generic reflection, see the <a class=\"xref\" href=\"system.type#System_Type_IsGenericType_\" data-linktype=\"relative-path\">IsGenericType</a> property.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_IsHideBySig\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_IsHideBySig_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsHideBySig</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether only a member of the same kind with exactly the same signature is hidden in the derived class.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsHideBySig { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the member is hidden by signature; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>When a member in a derived class is declared with the C# <code>new</code> modifier or the Visual Basic <code>Shadows</code> modifier, it can hide a member of the same name in the base class. C# hides base class members by signature. That is, if the base class member has multiple overloads, the only one that is hidden is the one that has the identical signature. By contrast, Visual Basic hides all the base class overloads. Thus, IsHideBySig returns <code>false</code> on a member declared with the Visual Basic <code>Shadows</code> modifier, and <code>true</code> on a member declared with the C# <code>new</code> modifier.  </p>\n<div class=\"WARNING\"><h5>Warning</h5><p> This property does not determine whether a method has the <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a> attribute. A method that is declared with either the <code>new</code> or the <code>Shadows</code> modifier will have the <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a> attribute, but only methods declared with <code>new</code> (that is, only C# methods) will have the IsHideBySig property set to <code>true</code>.  To determine whether a method has the <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a> attribute, use code similar to the following: <code>if ((myMethodInfo.Attributes &amp; MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)</code> in C# or <code>If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot</code> in Visual Basic. Note, however, that although all methods declared with <code>new</code> or <code>Shadows</code> have the <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a> attribute, not all methods that have the <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a> attribute are declared with <code>new</code> or <code>Shadows</code>.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example contains a base class with an overloaded method, and a derived class that hides one of the overloads. In the Visual Basic version of the code example, the IsHideBySig property returns <code>false</code> for the member in the derived class. In the C# version of the code sample, the property returns <code>true</code> for the member in the derived class.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Reflection.MethodBase.IsHideBySig#1\">using namespace System;\nusing namespace System::Reflection;\n\n// The base class Parent contains an overloaded method PrintCall.\n//\npublic ref class Parent\n{\npublic:\n    virtual void PrintCall()\n    {\n        Console::WriteLine(&quot;Parent&#39;s PrintCall()&quot;);\n    }\npublic:\n    virtual void PrintCall(int x)\n    {\n        Console::WriteLine(&quot;Parent&#39;s PrintCall({0})&quot;, x);\n    }\n};\n\n// The derived class Child hides one overload of the inherited \n// method PrintCall.\n//\npublic ref class Child : public Parent\n{\npublic:\n    void PrintCall(int i) new\n    {\n        Console::WriteLine(&quot;Child&#39;s PrintCall({0})&quot;, i);\n    }\n};\n\nint main()\n{\n    Child^ childInstance = gcnew Child();\n\n    // In C#, the method in the derived class hides by name and by\n    // signature, so the overload in the derived class hides only one\n    // of the overloads in the base class.\n    //\n    Console::WriteLine(&quot;------ List the overloads of PrintCall in the &quot; +\n        &quot;derived class Child ------&quot;);\n    Type^ t = childInstance-&gt;GetType();\n    for each(MethodInfo^ minfo in t-&gt;GetMethods())\n    {\n        if (minfo-&gt;Name == &quot;PrintCall&quot;)\n        {\n            Console::WriteLine(&quot;Overload of PrintCall: {0}&quot; +\n                &quot; IsHideBySig = {1}, DeclaringType = {2}&quot;, \n                minfo, minfo-&gt;IsHideBySig, minfo-&gt;DeclaringType);\n        }\n    }\n\n    // The method PrintCall in the derived class hides one overload of the \n    // method in Parent.  Contrast this with Visual Basic, which hides by\n    // name instead of by name and signature.  In Visual Basic, the\n    // parameterless overload of PrintCall would be unavailable from Child.\n    //\n    Console::WriteLine(\n        &quot;------ Call the overloads of PrintCall available in Child ------&quot;);\n    childInstance-&gt;PrintCall();\n    childInstance-&gt;PrintCall(42);\n\n    // If Child is cast to the base type Parent, both overloads of the \n    // shadowed method can be called.\n    //\n    Console::WriteLine(\n        &quot;------ Call the shadowed overloads of PrintCall ------&quot;);\n    Parent^ parentInstance = childInstance;\n    parentInstance-&gt;PrintCall();\n    parentInstance-&gt;PrintCall(42);\n}\n\n/* This code example produces the following output:\n\n------ List the overloads of PrintCall in the derived class Child ------\nOverload of PrintCall: Void PrintCall(Int32) IsHideBySig = True, DeclaringType = Child\nOverload of PrintCall: Void PrintCall() IsHideBySig = True, DeclaringType = Parent\nOverload of PrintCall: Void PrintCall(Int32) IsHideBySig = True, DeclaringType = Parent\n------ Call the overloads of PrintCall available in Child ------\nParent&#39;s PrintCall()\nChild&#39;s PrintCall(42)\n------ Call the shadowed overloads of PrintCall ------\nParent&#39;s PrintCall()\nParent&#39;s PrintCall(42)\n\n*/\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Reflection.MethodBase.IsHideBySig#1\">using System;\nusing System.Reflection;\n\n// The base class B contains an overloaded method M.\n//\npublic class B\n{\n    public virtual void M()\n    {\n        Console.WriteLine(&quot;B&#39;s M()&quot;);\n    }\n    public virtual void M(int x)\n    {\n        Console.WriteLine(&quot;B&#39;s M({0})&quot;, x);\n    }\n}\n\n// The derived class D hides one overload of the inherited \n// method M.\n//\npublic class D:\n    B\n{\n    new public void M(int i)\n    {\n        Console.WriteLine(&quot;D&#39;s M({0})&quot;, i);\n    }\n}\n\npublic class Test\n{\n    public static void Main()\n    {\n        D dinst = new D();\n        // In C#, the method in the derived class hides by name and by\n        // signature, so the overload in the derived class hides only one\n        // of the overloads in the base class.\n        //\n        Console.WriteLine(&quot;------ List the overloads of M in the derived class D ------&quot;);\n        Type t = dinst.GetType();\n        foreach( MethodInfo minfo in t.GetMethods() )\n        {\n            if (minfo.Name==&quot;M&quot;) {Console.WriteLine(&quot;Overload of M: {0}  IsHideBySig = {1}, DeclaringType = {2}&quot;, minfo, minfo.IsHideBySig, minfo.DeclaringType);}\n        }\n\n        // The method M in the derived class hides one overload of the \n        // method in B.  Contrast this with Visual Basic, which hides by\n        // name instead of by name and signature.  In Visual Basic, the\n        // parameterless overload of M would be unavailable from D.\n        //\n        Console.WriteLine(&quot;------ Call the overloads of M available in D ------&quot;);\n        dinst.M();\n        dinst.M(42);\n        \n        // If D is cast to the base type B, both overloads of the \n        // shadowed method can be called.\n        //\n        Console.WriteLine(&quot;------ Call the shadowed overloads of M ------&quot;);\n        B binst = dinst;\n        binst.M();\n        binst.M(42);\n    } //Main\n} //Test\n\n/* This code example produces the following output:\n\n------ List the overloads of M in the derived class D ------\nOverload of M: Void M(Int32)  IsHideBySig = True, DeclaringType = B\nOverload of M: Void M()  IsHideBySig = True, DeclaringType = B\nOverload of M: Void M(Int32)  IsHideBySig = True, DeclaringType = D\n------ Call the overloads of M available in D ------\nB&#39;s M()\nD&#39;s M(42)\n------ Call the shadowed overloads of M ------\nB&#39;s M()\nB&#39;s M(42)\n*/\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Reflection.MethodBase.IsHideBySig#1\">Imports System\nImports System.Reflection\n\n&#39; The base class B contains an overloaded method M.\n&#39;\nPublic Class B\n    Public Overridable Sub M()\n        Console.WriteLine(&quot;B&#39;s M()&quot;)\n    End Sub\n    Public Overridable Sub M(ByVal x As Integer)\n        Console.WriteLine(&quot;B&#39;s M({0})&quot;, x)\n    End Sub\nEnd Class\n\n&#39; The derived class D hides the inherited method M.\n&#39;\nPublic Class D\n    Inherits B\n    Shadows Public Sub M(ByVal i As Integer)\n        Console.WriteLine(&quot;D&#39;s M({0})&quot;, i)\n    End Sub\nEnd Class\n\nPublic Class Test\n    Public Shared Sub Main()\n        Dim dinst As New D()\n        &#39; In Visual Basic, the method in the derived class hides by\n        &#39; name, rather than by signature.  Thus, although a list of all the \n        &#39; overloads of M shows three overloads, only one can be called from\n        &#39; class D.  \n        &#39;\n        Console.WriteLine(&quot;------ List the overloads of M in the derived class D ------&quot;)\n        Dim t As Type = dinst.GetType()\n        For Each minfo As MethodInfo In t.GetMethods()\n            If minfo.Name = &quot;M&quot; Then Console.WriteLine( _\n                &quot;Overload of M: {0}  IsHideBySig = {1}, DeclaringType = {2}&quot;, _\n                minfo, minfo.IsHideBySig, minfo.DeclaringType)\n        Next\n\n        &#39; The method M in the derived class hides the method in B.\n        &#39;\n        Console.WriteLine(&quot;------ Call the overloads of M available in D ------&quot;)\n        &#39; The following line causes a compile error, because both overloads\n        &#39; in the base class are hidden.  Contrast this with C#, where only \n        &#39; one of the overloads of B would be hidden.\n        &#39;dinst.M()\n        dinst.M(42)\n        \n        &#39; If D is cast to the base type B, both overloads of the \n        &#39; shadowed method can be called.\n        &#39;\n        Console.WriteLine(&quot;------ Call the shadowed overloads of M ------&quot;)\n        Dim binst As B = dinst\n        binst.M()\n        binst.M(42)         \n    End Sub &#39;Main\nEnd Class &#39;Test\n\n&#39; This code example produces the following output:\n&#39; ------ List the overloads of M in the derived class D ------\n&#39; Overload of M: Void M(Int32)  IsHideBySig = False, DeclaringType = B\n&#39; Overload of M: Void M()  IsHideBySig = False, DeclaringType = B\n&#39; Overload of M: Void M(Int32)  IsHideBySig = False, DeclaringType = D\n&#39; ------ Call the overloads of M available in D ------\n&#39; D&#39;s M(42)\n&#39; ------ Call the shadowed overloads of M ------\n&#39; B&#39;s M()\n&#39; B&#39;s M(42)\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_IsPrivate\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_IsPrivate_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsPrivate</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether this member is private.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsPrivate { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if access to this method is restricted to other members of the class itself; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If a type member has <code>Private</code> level visibility, it can be called from any member in the same class and no others.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_IsPublic\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_IsPublic_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsPublic</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether this is a public method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsPublic { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if this method is public; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>To get the <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a>, first get the type. From the type, get the method. From the method, get the <code>MethodBase</code>. If the <code>MethodBase</code> or constructor is other than public, it is protected and cannot be readily accessed. To access a non-public method, set the <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> mask to <code>NonPublic</code> in <code>GetMethod</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses the IsPublic property to display a message that indicates whether the specified method is public.  </p>\n<pre><code class=\"lang-vb\" name=\"Classic MethodBase.IsPublic Example#1\">Class methodbase1\n    \n    Public Shared Function Main() As Integer\n    \n        Console.WriteLine(ControlChars.Cr + &quot;Reflection.MethodBase&quot;)\n        \n        &#39;Get the MethodBase of a method.\n        \n        &#39;Get the type\n        Dim MyType As Type = Type.GetType(&quot;System.MulticastDelegate&quot;)\n        \n        &#39;Get and display the method\n        Dim Mymethodbase As MethodBase = _\n           MyType.GetMethod(&quot;RemoveImpl&quot;, BindingFlags.NonPublic)\n        \n        Console.Write(ControlChars.Cr _\n           + &quot;Mymethodbase = &quot; + Mymethodbase.ToString())\n        \n        Dim Myispublic As Boolean = Mymethodbase.IsPublic\n        If Myispublic Then\n            Console.Write(ControlChars.Cr _\n               + &quot;Mymethodbase is a public method&quot;)\n        Else\n            Console.Write(ControlChars.Cr _\n               + &quot;Mymethodbase is not a public method&quot;)\n        End If \n        Return 0\n    End Function\nEnd Class\n\n&#39; Produces the following output\n&#39; \n&#39; Reflection.MethodBase\n&#39; Mymethodbase = System.Delegate RemoveImpl (System.Delegate)\n&#39; Mymethodbase is not a public method \n</code></pre><pre><code class=\"lang-cpp\" name=\"Classic MethodBase.IsPublic Example#1\">int main()\n{\n   Console::WriteLine( &quot;<br>Reflection.MethodBase&quot; );\n   \n   //Get the MethodBase of a method.\n   //Get the type\n   Type^ MyType = Type::GetType( &quot;System.MulticastDelegate&quot; );\n   \n   //Get and display the method\n   MethodBase^ Mymethodbase = MyType-&gt;GetMethod( &quot;RemoveImpl&quot;, static_cast&lt;BindingFlags&gt;(BindingFlags::NonPublic | BindingFlags::Instance) );\n   Console::Write( &quot;<br>Mymethodbase = {0}&quot;, Mymethodbase );\n   bool Myispublic = Mymethodbase-&gt;IsPublic;\n   if ( Myispublic )\n      Console::Write( &quot;<br>Mymethodbase is a public method&quot; );\n   else\n      Console::Write( &quot;<br>Mymethodbase is not a public method&quot; );\n\n   return 0;\n}\n\n/*\nProduces the following output\n\nReflection.MethodBase\nMymethodbase = System.Delegate RemoveImpl (System.Delegate)\nMymethodbase is not a public method\n*/\n</code></pre><pre><code class=\"lang-cs\" name=\"Classic MethodBase.IsPublic Example#1\"> class methodbase\n {\n    public static int Main(string[] args)\n    {     \n \n       Console.WriteLine(&quot;<br>Reflection.MethodBase&quot;);\n       \n       //Get the MethodBase of a method.\n  \n       //Get the type\n       Type MyType = Type.GetType(&quot;System.MulticastDelegate&quot;);\n  \n       //Get and display the method\n       MethodBase Mymethodbase =\n          MyType.GetMethod(&quot;RemoveImpl&quot;,BindingFlags.NonPublic);\n  \n       Console.Write(&quot;<br>Mymethodbase = &quot; + Mymethodbase);\n  \n       bool Myispublic = Mymethodbase.IsPublic;\n       if (Myispublic)\n          Console.Write (&quot;<br>Mymethodbase is a public method&quot;);\n       else\n          Console.Write (&quot;<br>Mymethodbase is not a public method&quot;);\n       \n       return 0;\n    }\n }\n /*\n Produces the following output\n \n Reflection.MethodBase\n Mymethodbase = System.Delegate RemoveImpl (System.Delegate)\n Mymethodbase is not a public method\n */\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_IsSecurityCritical\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_IsSecurityCritical_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsSecurityCritical</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value that indicates whether the current method or constructor is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool IsSecurityCritical { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the current method or constructor is security-critical or security-safe-critical at the current trust level; <code>false</code> if it is transparent.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The IsSecurityCritical, <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsSecuritySafeCritical_\" data-linktype=\"relative-path\">IsSecuritySafeCritical</a>, and <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsSecurityTransparent_\" data-linktype=\"relative-path\">IsSecurityTransparent</a> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR). The combinations of these properties are shown in the following table:  </p>\n<table>\n<thead>\n<tr>\n<th>Security level</th>\n<th>IsSecurityCritical</th>\n<th>IsSecuritySafeCritical</th>\n<th>IsSecurityTransparent</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Critical</td>\n<td><code>true</code></td>\n<td><code>false</code></td>\n<td><code>false</code></td>\n</tr>\n<tr>\n<td>Safe critical</td>\n<td><code>true</code></td>\n<td><code>true</code></td>\n<td><code>false</code></td>\n</tr>\n<tr>\n<td>Transparent</td>\n<td><code>false</code></td>\n<td><code>false</code></td>\n<td><code>true</code></td>\n</tr>\n</tbody>\n</table>\n<p> Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime&#39;s rules.  </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_IsFullyTrusted_\" data-linktype=\"relative-path\">IsFullyTrusted</a> and <a class=\"xref\" href=\"system.appdomain#System_AppDomain_IsFullyTrusted_\" data-linktype=\"relative-path\">IsFullyTrusted</a> properties.  </p>\n</div>\n<p> For more information about reflection and transparency, see <a href=\"../Topic/Security%20Considerations%20for%20Reflection.md\" data-linktype=\"relative-path\">Security Considerations for Reflection</a>. For information about transparency, see <a href=\"../Topic/Security%20Changes%20in%20the%20.NET%20Framework.md\" data-linktype=\"relative-path\">Security Changes</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_IsSecuritySafeCritical\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_IsSecuritySafeCritical_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsSecuritySafeCritical</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value that indicates whether the current method or constructor is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool IsSecuritySafeCritical { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the method or constructor is security-safe-critical at the current trust level; <code>false</code> if it is security-critical or transparent.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsSecurityCritical_\" data-linktype=\"relative-path\">IsSecurityCritical</a>, IsSecuritySafeCritical, and <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsSecurityTransparent_\" data-linktype=\"relative-path\">IsSecurityTransparent</a> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR). The combinations of these properties are shown in the following table:  </p>\n<table>\n<thead>\n<tr>\n<th>Security level</th>\n<th>IsSecurityCritical</th>\n<th>IsSecuritySafeCritical</th>\n<th>IsSecurityTransparent</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Critical</td>\n<td><code>true</code></td>\n<td><code>false</code></td>\n<td><code>false</code></td>\n</tr>\n<tr>\n<td>Safe critical</td>\n<td><code>true</code></td>\n<td><code>true</code></td>\n<td><code>false</code></td>\n</tr>\n<tr>\n<td>Transparent</td>\n<td><code>false</code></td>\n<td><code>false</code></td>\n<td><code>true</code></td>\n</tr>\n</tbody>\n</table>\n<p> Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime&#39;s rules.  </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_IsFullyTrusted_\" data-linktype=\"relative-path\">IsFullyTrusted</a> and <a class=\"xref\" href=\"system.appdomain#System_AppDomain_IsFullyTrusted_\" data-linktype=\"relative-path\">IsFullyTrusted</a> properties.  </p>\n</div>\n<p> For more information about reflection and transparency, see <a href=\"../Topic/Security%20Considerations%20for%20Reflection.md\" data-linktype=\"relative-path\">Security Considerations for Reflection</a>. For information about transparency, see <a href=\"../Topic/Security%20Changes%20in%20the%20.NET%20Framework.md\" data-linktype=\"relative-path\">Security Changes</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_IsSecurityTransparent\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_IsSecurityTransparent_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsSecurityTransparent</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value that indicates whether the current method or constructor is transparent at the current trust level, and therefore cannot perform critical operations.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool IsSecurityTransparent { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the method or constructor is security-transparent at the current trust level; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If this property returns <code>true</code>, the <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsSecurityCritical_\" data-linktype=\"relative-path\">IsSecurityCritical</a> and <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsSecuritySafeCritical_\" data-linktype=\"relative-path\">IsSecuritySafeCritical</a> properties return <code>false</code>.  </p>\n<p> The <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsSecurityCritical_\" data-linktype=\"relative-path\">IsSecurityCritical</a>, <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsSecuritySafeCritical_\" data-linktype=\"relative-path\">IsSecuritySafeCritical</a>, and IsSecurityTransparent properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR). Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime&#39;s rules.  </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_IsFullyTrusted_\" data-linktype=\"relative-path\">IsFullyTrusted</a> and <a class=\"xref\" href=\"system.appdomain#System_AppDomain_IsFullyTrusted_\" data-linktype=\"relative-path\">IsFullyTrusted</a> properties.  </p>\n</div>\n<p> For more information about reflection and transparency, see <a href=\"../Topic/Security%20Considerations%20for%20Reflection.md\" data-linktype=\"relative-path\">Security Considerations for Reflection</a>. For information about transparency, see <a href=\"../Topic/Security%20Changes%20in%20the%20.NET%20Framework.md\" data-linktype=\"relative-path\">Security Changes</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_IsSpecialName\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_IsSpecialName_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsSpecialName</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether this method has a special name.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsSpecialName { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if this method has a special name; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a> bit is set to flag members that are treated in a special way by some compilers (such as property accessors and operator overloading methods).</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>This example shows a use of IsSpecialName to filter internal or private members out of a list.  </p>\n<pre><code class=\"lang-cpp\" name=\"Classic Type.IsSpecialName Example#1\">using namespace System;\nusing namespace System::IO;\nusing namespace System::Reflection;\nusing namespace System::Text;\npublic ref class Sample\n{\nprotected:\n   bool ShowMethods;\n   StreamWriter^ myWriter;\n\nprivate:\n   void DumpMethods( Type^ aType )\n   {\n      if (  !ShowMethods )\n            return;\n\n      array&lt;MethodInfo^&gt;^mInfo = aType-&gt;GetMethods();\n      myWriter-&gt;WriteLine( &quot;Methods&quot; );\n      bool found = false;\n      if ( mInfo-&gt;Length != 0 )\n      {\n         for ( int i = 0; i &lt; mInfo-&gt;Length; i++ )\n         {\n            \n            // Only display methods declared in this type. Also \n            // filter out any methods with special names, because these\n            // cannot be generally called by the user. That is, their \n            // functionality is usually exposed in other ways, for example,\n            // property get/set methods are exposed as properties.\n            if ( mInfo[ i ]-&gt;DeclaringType == aType &amp;&amp;  !mInfo[ i ]-&gt;IsSpecialName )\n            {\n               found = true;\n               StringBuilder^ modifiers = gcnew StringBuilder;\n               if ( mInfo[ i ]-&gt;IsStatic )\n               {\n                  modifiers-&gt;Append( &quot;static &quot; );\n               }\n               if ( mInfo[ i ]-&gt;IsPublic )\n               {\n                  modifiers-&gt;Append( &quot;public &quot; );\n               }\n               if ( mInfo[ i ]-&gt;IsFamily )\n               {\n                  modifiers-&gt;Append( &quot;protected &quot; );\n               }\n               if ( mInfo[ i ]-&gt;IsAssembly )\n               {\n                  modifiers-&gt;Append( &quot;internal &quot; );\n               }\n               if ( mInfo[ i ]-&gt;IsPrivate )\n               {\n                  modifiers-&gt;Append( &quot;private &quot; );\n               }\n               myWriter-&gt;WriteLine( &quot;{0} {1}&quot;, modifiers, mInfo[ i ] );\n            }\n\n         }\n      }\n\n      if (  !found )\n      {\n         myWriter-&gt;WriteLine( &quot;(none)&quot; );\n      }\n   }\n\n};\n</code></pre><pre><code class=\"lang-cs\" name=\"Classic Type.IsSpecialName Example#1\">using System;\nusing System.IO;\nusing System.Reflection;\nusing System.Text;\n\npublic class Sample\n{\n    protected bool ShowMethods;\n    protected StreamWriter myWriter;\n \n    private void DumpMethods(Type aType)\n    {\n        if (!ShowMethods)\n            return;\n        MethodInfo[] mInfo = aType.GetMethods();\n        myWriter.WriteLine(&quot;Methods&quot;); \n        bool found = false;            \n        if (mInfo.Length != 0)\n        {\n            for (int i=0; i &lt; mInfo.Length; i++)\n            {\n                // Only display methods declared in this type. Also \n                // filter out any methods with special names, because these\n                // cannot be generally called by the user. That is, their \n                // functionality is usually exposed in other ways, for example,\n                // property get/set methods are exposed as properties.\n                if (mInfo[i].DeclaringType == aType &amp;&amp; !mInfo[i].IsSpecialName)\n                {        \n                    found = true;\n                    StringBuilder modifiers = new StringBuilder();\n                    if (mInfo[i].IsStatic)   {modifiers.Append(&quot;static &quot;);}     \n                    if (mInfo[i].IsPublic)   {modifiers.Append(&quot;public &quot;);}     \n                    if (mInfo[i].IsFamily)   {modifiers.Append(&quot;protected &quot;);}     \n                    if (mInfo[i].IsAssembly) {modifiers.Append(&quot;internal &quot;);}     \n                    if (mInfo[i].IsPrivate)  {modifiers.Append(&quot;private &quot;);}     \n                    myWriter.WriteLine(&quot;{0} {1}&quot;, modifiers, mInfo[i]);\n                }\n            }                      \n        }                    \n        if (!found)\n        {\n            myWriter.WriteLine(&quot;(none)&quot;);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Classic Type.IsSpecialName Example#1\">Imports System\nImports System.IO\nImports System.Reflection\nImports System.Text\nPublic Class Sample\n    Protected ShowMethods As Boolean\n    Protected myWriter As StreamWriter\n    Private Sub DumpMethods(ByVal aType As Type)\n        If Not ShowMethods Then\n            Return\n        End If\n        Dim mInfo As MethodInfo() = aType.GetMethods()\n        myWriter.WriteLine(&quot;Methods&quot;)\n        Dim found As Boolean = False\n        If mInfo.Length &lt;&gt; 0 Then\n            Dim i As Integer\n            For i = 0 To mInfo.Length - 1\n                &#39; Only display methods declared in this type. Also \n                &#39; filter out any methods with special names, because these\n                &#39; cannot be generally called by the user. That is, their \n                &#39; functionality is usually exposed in other ways, for example,\n                &#39; property get/set methods are exposed as properties.\n                If mInfo(i).DeclaringType Is aType _\n                   And Not mInfo(i).IsSpecialName Then\n                    found = True\n                    Dim modifiers As New StringBuilder()\n                    If mInfo(i).IsStatic Then\n                        modifiers.Append(&quot;static &quot;)\n                    End If\n                    If mInfo(i).IsPublic Then\n                        modifiers.Append(&quot;public &quot;)\n                    End If\n                    If mInfo(i).IsFamily Then\n                        modifiers.Append(&quot;protected &quot;)\n                    End If\n                    If mInfo(i).IsAssembly Then\n                        modifiers.Append(&quot;internal &quot;)\n                    End If\n                    If mInfo(i).IsPrivate Then\n                        modifiers.Append(&quot;private &quot;)\n                    End If\n                    myWriter.WriteLine(&quot;{0} {1}&quot;, modifiers, mInfo(i))\n                End If\n            Next i\n        End If\n        If Not found Then\n            myWriter.WriteLine(&quot;(none)&quot;)\n        End If\n    End Sub\nEnd Class\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_IsStatic\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_IsStatic_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsStatic</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the method is <code>static</code>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsStatic { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if this method is <code>static</code>; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A static member cannot implicitly reference instance data in a class.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_IsVirtual\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_IsVirtual_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsVirtual</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the method is <code>virtual</code>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsVirtual { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if this method is <code>virtual</code>; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A virtual member may reference instance data in a class and must be referenced through an instance of the class.  </p>\n<p> To determine if a method is overridable, it is not sufficient to check that <code>IsVirtual</code> is <code>true</code>. For a method to be overridable, <code>IsVirtual</code> must be <code>true</code> and <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_IsFinal_\" data-linktype=\"relative-path\">IsFinal</a> must be <code>false</code>. For example, a method might be non-virtual, but it implements an interface method. The common language runtime requires that all methods that implement interface members must be marked as <code>virtual</code>; therefore, the compiler marks the method <code>virtual final</code>. So there are cases where a method is marked as <code>virtual</code> but is still not overridable.  </p>\n<p> To establish with certainty whether a method is overridable, use code such as this:  </p>\n<pre><code class=\"lang-c#\">if (MethodInfo.IsVirtual &amp;&amp; !MethodInfo.IsFinal)  \n</code></pre><pre><code class=\"lang-vb\">If MethodInfo.IsVirtual AndAlso Not MethodInfo.IsFinal Then  \n</code></pre><p> If <code>IsVirtual</code> is <code>false</code> or <code>IsFinal</code> is <code>true</code>, then the method cannot be overridden.  </p>\n<p> You can determine whether the current method overrides a method in a base class by calling the <a class=\"xref\" href=\"system.reflection.methodinfo#System_Reflection_MethodInfo_GetBaseDefinition_\" data-linktype=\"relative-path\">GetBaseDefinition</a> method. The following example implements an <code>IsOverride</code> method that does this.  </p>\n<pre><code class=\"lang-cs\" name=\"system.reflection.methodinfo.getbasedefinition#2\">using System;\nusing System.Reflection;\n\npublic class ReflectionUtilities\n{   \n   public static bool IsOverride(MethodInfo method)\n   {\n      return ! method.Equals(method.GetBaseDefinition());\n   }\n}\n\npublic class Example\n{\n   public static void Main()\n   {\n      MethodInfo equals = typeof(Int32).GetMethod(&quot;Equals&quot;, \n                                        new Type[] { typeof(Object) } );\n      Console.WriteLine(&quot;{0}.{1} is inherited: {2}&quot;, \n                        equals.ReflectedType.Name, equals.Name,\n                        ReflectionUtilities.IsOverride(equals));\n      \n      equals = typeof(Object).GetMethod(&quot;Equals&quot;, \n                                        new Type[] { typeof(Object) } );\n      Console.WriteLine(&quot;{0}.{1} is inherited: {2}&quot;, \n                        equals.ReflectedType.Name, equals.Name,\n                        ReflectionUtilities.IsOverride(equals));\n   }\n}\n// The example displays the following output:\n//       Int32.Equals is inherited: True\n//       Object.Equals is inherited: False\n</code></pre><pre><code class=\"lang-vb\" name=\"system.reflection.methodinfo.getbasedefinition#2\">Imports System.Reflection\n\nPublic Class ReflectionUtilities\n   Public Shared Function IsOverride(method As MethodInfo) As Boolean\n      Return Not method.Equals(method.GetBaseDefinition())\n   End Function\nEnd Class\n\nModule Example\n   Public Sub Main()\n      Dim equals As MethodInfo = GetType(Int32).GetMethod(&quot;Equals&quot;, \n                                         { GetType(Object) } )\n      Console.WriteLine(&quot;{0}.{1} is inherited: {2}&quot;, \n                        equals.ReflectedType.Name, equals.Name,\n                        ReflectionUtilities.IsOverride(equals))\n      \n      equals = GetType(Object).GetMethod(&quot;Equals&quot;, { GetType(Object) } )\n      Console.WriteLine(&quot;{0}.{1} is inherited: {2}&quot;, \n                        equals.ReflectedType.Name, equals.Name,\n                        ReflectionUtilities.IsOverride(equals))\n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       Int32.Equals is inherited: True\n&#39;       Object.Equals is inherited: False\n</code></pre>\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example displays <code>false</code> for <code>IsFinal</code>, which might lead you to think that <code>MyMethod</code> is overridable. The code prints <code>false</code> even though <code>MyMethod</code> is not marked <code>virtual</code> and thus cannot be overridden.  </p>\n<pre><code class=\"lang-cs\" name=\"Classic MethodBase.IsVirtual Example#1\">using System;\nusing System.Reflection;\n \npublic class MyClass \n{\n    public void MyMethod() \n    {\n    }\n    public static void Main() \n    {\n        MethodBase m = typeof(MyClass).GetMethod(&quot;MyMethod&quot;);\n        Console.WriteLine(&quot;The IsFinal property value of MyMethod is {0}.&quot;, m.IsFinal);\n        Console.WriteLine(&quot;The IsVirtual property value of MyMethod is {0}.&quot;, m.IsVirtual);\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"Classic MethodBase.IsVirtual Example#1\">using namespace System;\nusing namespace System::Reflection;\n\npublic ref class MyClass\n{\npublic:\n   void MyMethod(){}\n};\n\nint main()\n{\n   MethodBase^ m = MyClass::typeid-&gt;GetMethod( &quot;MyMethod&quot; );\n   Console::WriteLine( &quot;The IsFinal property value of MyMethod is {0}.&quot;, m-&gt;IsFinal );\n   Console::WriteLine( &quot;The IsVirtual property value of MyMethod is {0}.&quot;, m-&gt;IsVirtual );\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Classic MethodBase.IsVirtual Example#1\">Imports System\nImports System.Reflection\nImports Microsoft.VisualBasic\n\nPublic Class MyClass1\n    \n    Public Sub MyMethod()\n    End Sub\n    \n    Public Shared Sub Main()\n        Dim m As MethodBase = GetType(MyClass1).GetMethod(&quot;MyMethod&quot;)\n        Console.WriteLine(&quot;The IsFinal property value of MyMethod is {0}.&quot;, m.IsFinal)\n        Console.WriteLine(&quot;The IsVirtual property value of MyMethod is {0}.&quot;, m.IsVirtual)\n    End Sub\nEnd Class\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_MethodHandle\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_MethodHandle_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">MethodHandle</div>        \r\n          </div>\r\n    \r\n            <p>Gets a handle to the internal metadata representation of a method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract RuntimeMethodHandle MethodHandle { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtimemethodhandle\" data-linktype=\"relative-path\">RuntimeMethodHandle</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"system.runtimemethodhandle\" data-linktype=\"relative-path\">RuntimeMethodHandle</a> object.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The handles are valid only in the application domain in which they were obtained.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_MethodImplementationFlags\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_MethodImplementationFlags_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">MethodImplementationFlags</div>        \r\n          </div>\r\n    \r\n            <p>Gets the <a class=\"xref\" href=\"system.reflection.methodimplattributes\" data-linktype=\"relative-path\">MethodImplAttributes</a> flags that specify the attributes of a method implementation.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual System.Reflection.MethodImplAttributes MethodImplementationFlags { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodimplattributes\" data-linktype=\"relative-path\">MethodImplAttributes</a></div>\r\n                  </div>\r\n                  <p>The method implementation flags.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>See the <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_GetMethodImplementationFlags_\" data-linktype=\"relative-path\">GetMethodImplementationFlags</a> method for more information.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"methods\">\r\n        <h2>Methods\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_Equals_System_Object_\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_Equals_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Equals(Object)</div>        \r\n          </div>\r\n    \r\n            <p>Returns a value that indicates whether this instance is equal to a specified object.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override bool Equals (object obj);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>obj</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An object to compare with this instance, or <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if <code>obj</code> equals the type and value of this instance; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_GetCurrentMethod\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_GetCurrentMethod_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetCurrentMethod()</div>        \r\n          </div>\r\n    \r\n            <p>Returns a <code>MethodBase</code> object representing the currently executing method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Reflection.MethodBase GetCurrentMethod ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a></div>\r\n                  </div>\r\n                  <p>GetCurrentMethod is a static method that is called from within an executing method and that returns information about that method.  </p>\n<p> A <code>MethodBase</code> object representing the currently executing method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.targetexception\" data-linktype=\"relative-path\">TargetException</a></div>\r\n                  </div>\r\n                  <p>This member was invoked with a late-binding mechanism.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the currently executing method is defined on a generic type, the <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> that is returned by GetCurrentMethod is obtained from the generic type definition (that is, &lt;xref:System.Reflection.MethodInfo.ContainsGenericParameters%2A?displayProperty=fullName&gt; returns <code>true</code>). Therefore, it does not reflect the type arguments that were used when the method was called. For example, if a method <code>M()</code> is defined on a generic type <code>C&lt;T&gt;</code> (<code>C(Of T)</code> in Visual Basic), and GetCurrentMethod is called from <code>C&lt;string&gt;.M()</code>, then GetCurrentMethod returns <code>C&lt;T&gt;.M()</code> (<code>C(Of T).M()</code> in Visual Basic).  </p>\n<p> If the currently executing method is a generic method, GetCurrentMethod returns the generic method definition. If the generic method is defined on a generic type, the <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> is obtained from the generic type definition.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example defines two types. The first is a non-generic class, <code>TestClass</code>, includes a constructor, a method named <code>GetValue</code>, and a read-write property named <code>GetValue</code>. The second is a generic class named <code>TestClass&lt;T&gt;</code> that includes a constructor, a <code>GetValue</code> method, and a generic method, <code>ConvertValue&lt;Y&gt;</code>. Each constructor, method, and property accessor includes a call to the GetCurrentMethod method.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Reflection.MethodBase.GetCurrentMethod#1\">using System;\nusing System.Reflection;\n\npublic class Example\n{\n   public static void Main()\n   {\n      var t = new TestClass();  \n      Console.WriteLine(t.GetValue());\n      t.Value = 10;\n      Console.WriteLine(t.Value);\n      Console.WriteLine();\n      \n      var tg =new Test&lt;int&gt;(200);\n      Console.WriteLine(tg.GetValue());\n      var b = tg.ConvertValue&lt;Byte&gt;();\n      Console.WriteLine(&quot;{0} -&gt; {1} ({2})&quot;, tg.GetValue().GetType().Name,\n                        b, b.GetType().Name);\n   }\n}        \n\npublic class TestClass\n{\n   private Nullable&lt;int&gt; _value;\n   \n   public TestClass()\n   {\n      MethodBase m = MethodBase.GetCurrentMethod();\n      Console.WriteLine(&quot;Executing {0}.{1}&quot;, \n                        m.ReflectedType.Name, m.Name);\n   }\n   \n   public TestClass(int value)\n   {\n      MethodBase m = MethodBase.GetCurrentMethod();\n      Console.WriteLine(&quot;Executing {0}.{1}&quot;, \n                        m.ReflectedType.Name, m.Name);\n      _value = value;\n   }\n   \n   public int Value\n   {  \n      get {\n         MethodBase m = MethodBase.GetCurrentMethod();\n         Console.WriteLine(&quot;Executing {0}.{1}&quot;, \n                           m.ReflectedType.Name, m.Name);\n         return _value.GetValueOrDefault();\n      }\n      set {\n         MethodBase m = MethodBase.GetCurrentMethod();\n         Console.WriteLine(&quot;Executing {0}.{1}&quot;, \n                           m.ReflectedType.Name, m.Name);\n         _value = value;\n      }\n   }\n   \n   public int GetValue()\n   {\n      MethodBase m = MethodBase.GetCurrentMethod();\n      Console.WriteLine(&quot;Executing {0}.{1}&quot;, \n                        m.ReflectedType.Name, m.Name);\n      return this.Value;\n   }\n}\n\npublic class Test&lt;T&gt;\n{\n   private T value;\n   \n   public Test(T value)\n   {\n      MethodBase m = MethodBase.GetCurrentMethod();\n      Console.WriteLine(&quot;Executing {0}.{1}&quot;, \n                        m.ReflectedType.Name, m.Name);\n      this.value = value;\n   }\n   \n   public T GetValue()\n   {\n      MethodBase m = MethodBase.GetCurrentMethod();\n      Console.WriteLine(&quot;Executing {0}.{1}&quot;, \n                        m.ReflectedType.Name, m.Name);\n      return value;\n   }\n   \n   public Y ConvertValue&lt;Y&gt;() \n   {\n      MethodBase m = MethodBase.GetCurrentMethod();\n      Console.WriteLine(&quot;Executing {0}.{1}&quot;, \n                        m.ReflectedType.Name, m.Name);\n      Console.Write(&quot;      Generic method: {0}, definition: {1}, Args: &quot;, \n                        m.IsGenericMethod, m.IsGenericMethodDefinition);\n      if (m.IsGenericMethod) {\n         foreach (var arg in m.GetGenericArguments())\n            Console.Write(&quot;{0} &quot;, arg.Name);\n      }\n      Console.WriteLine();\n      try {\n         return (Y) Convert.ChangeType(value, typeof(Y));\n      }\n      catch (OverflowException) {\n         throw; \n      }   \n      catch (InvalidCastException) {\n         throw;\n      }   \n   }   \n}\n// The example displays the following output:\n//       Executing TestClass..ctor\n//       Executing TestClass.GetValue\n//       Executing TestClass.get_Value\n//       0\n//       Executing TestClass.set_Value\n//       Executing TestClass.get_Value\n//       10\n//       \n//       Executing Test`1..ctor\n//       Executing Test`1.GetValue\n//       200\n//       Executing Test`1.ConvertValue\n//             Generic method: True, definition: True, Args: Y\n//       Executing Test`1.GetValue\n//       Int32 -&gt; 200 (Byte)\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Reflection.MethodBase.GetCurrentMethod#1\">Imports System.Reflection\n\nModule Example\n   Public Sub Main()\n      Dim t As New TestClass()  \n      Console.WriteLine(t.GetValue())\n      t.Value = 10\n      Console.WriteLine(t.Value)\n      Console.WriteLine()\n      \n      Dim tg As New Test(Of Integer)(200)\n      Console.WriteLine(tg.GetValue())\n      Dim b = tg.ConvertValue(Of Byte)()\n      Console.WriteLine(&quot;{0} -&gt; {1} ({2})&quot;, tg.GetValue().GetType().Name,\n                        b, b.GetType().Name)\n                                            \n                                             \n   End Sub\nEnd Module\n\nPublic Class TestClass\n   Private _value As Nullable(Of Integer)\n   \n   Public Sub New()\n      Dim m As MethodBase = MethodBase.GetCurrentMethod()\n      Console.WriteLine(&quot;   Executing {0}.{1}&quot;, \n                        m.ReflectedType.Name, m.Name)\n   End Sub\n   \n   Public Sub New(value As Integer)\n      Dim m As MethodBase = MethodBase.GetCurrentMethod()\n      Console.WriteLine(&quot;   Executing {0}.{1}&quot;, \n                        m.ReflectedType.Name, m.Name)\n      _value = value\n   End Sub\n   \n   Public Property Value As Integer\n      Get\n         Dim m As MethodBase = MethodBase.GetCurrentMethod()\n         Console.WriteLine(&quot;   Executing {0}.{1}&quot;, \n                           m.ReflectedType.Name, m.Name)\n         Return _value.GetValueOrDefault()\n      End Get\n      Set\n         Dim m As MethodBase = MethodBase.GetCurrentMethod()\n         Console.WriteLine(&quot;   Executing {0}.{1}&quot;, \n                           m.ReflectedType.Name, m.Name)\n         _value = value\n      End Set\n   End Property\n   \n   Public Function GetValue() As Integer\n      Dim m As MethodBase = MethodBase.GetCurrentMethod()\n      Console.WriteLine(&quot;   Executing {0}.{1}&quot;, \n                        m.ReflectedType.Name, m.Name)\n      Return Me.Value\n   End Function\nEnd Class\n\nPublic Class Test(Of T)\n   Private value As T\n   \n   Public Sub New(value As T)\n      Dim m As MethodBase = MethodBase.GetCurrentMethod()\n      Console.WriteLine(&quot;   Executing {0}.{1}&quot;, \n                        m.ReflectedType.Name, m.Name)\n      Me.value = value\n   End Sub\n   \n   Public Function GetValue() As T\n      Dim m As MethodBase = MethodBase.GetCurrentMethod()\n      Console.WriteLine(&quot;   Executing {0}.{1}&quot;, \n                        m.ReflectedType.Name, m.Name)\n      Return value\n   End Function\n   \n   Public Function ConvertValue(Of Y)() As Y\n      Dim m As MethodBase = MethodBase.GetCurrentMethod()\n      Console.WriteLine(&quot;   Executing {0}.{1}&quot;, \n                        m.ReflectedType.Name, m.Name)\n      Console.Write(&quot;      Generic method: {0}, definition: {1}, Args: &quot;, \n                        m.IsGenericMethod, m.IsGenericMethodDefinition)\n      If m.IsGenericMethod Then\n         For Each arg In m.GetGenericArguments()\n            Console.Write(&quot;{0} &quot;, arg.Name)\n         Next\n      End If\n      Console.WriteLine()\n      Try\n         Return CType(Convert.ChangeType(value, GetType(Y)), Y)\n      Catch e As OverflowException\n         Throw \n      Catch e As InvalidCastException\n         Throw\n      End Try   \n   End Function   \nEnd Class\n&#39; The example displays the following output:\n&#39;       Executing TestClass..ctor\n&#39;       Executing TestClass.GetValue\n&#39;       Executing TestClass.get_Value\n&#39;       0\n&#39;       Executing TestClass.set_Value\n&#39;       Executing TestClass.get_Value\n&#39;       10\n&#39;       \n&#39;       Executing Test`1..ctor\n&#39;       Executing Test`1.GetValue\n&#39;       200\n&#39;       Executing Test`1.ConvertValue\n&#39;             Generic method: True, definition: True, Args: Y\n&#39;       Executing Test`1.GetValue\n&#39;       Int32 -&gt; 200 (Byte)\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_GetGenericArguments\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_GetGenericArguments_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetGenericArguments()</div>        \r\n          </div>\r\n    \r\n            <p>Returns an array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual Type[] GetGenericArguments ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects that represent the type arguments of a generic method or the type parameters of a generic method definition. Returns an empty array if the current method is not a generic method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The current object is a <a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a>. Generic constructors are not supported in the .NET Framework version 2.0. This exception is the default behavior if this method is not overridden in a derived class.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.  </p>\n<ul>\n<li><p>If the current method is a closed constructed method (that is, the <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_ContainsGenericParameters_\" data-linktype=\"relative-path\">ContainsGenericParameters</a> property returns <code>false</code>), the array returned by the GetGenericArguments method contains the types that have been assigned to the generic type parameters of the generic method definition.  </p>\n</li>\n<li><p>If the current method is a generic method definition, the array contains the type parameters.  </p>\n</li>\n<li><p>If the current method is an open constructed method (that is, the <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_ContainsGenericParameters_\" data-linktype=\"relative-path\">ContainsGenericParameters</a> property returns <code>true</code>) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters. Use the <a class=\"xref\" href=\"system.type#System_Type_IsGenericParameter_\" data-linktype=\"relative-path\">IsGenericParameter</a> property to tell them apart. For a demonstration of this scenario, see the code example provided for the <a class=\"xref\" href=\"system.reflection.methodbase#System_Reflection_MethodBase_ContainsGenericParameters_\" data-linktype=\"relative-path\">ContainsGenericParameters</a> property.  </p>\n<p>Generic constructors are not supported in the .NET Framework version 2.0. This property throws <a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a> if not overridden in a derived class, so an exception is thrown if the current instance is of type <a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a>.  </p>\n<p>For a list of the invariant conditions for terms specific to generic methods, see the &lt;xref:System.Reflection.MethodInfo.IsGenericMethod%2A?displayProperty=fullName&gt; property. For a list of the invariant conditions for other terms used in generic reflection, see the <a class=\"xref\" href=\"system.type#System_Type_IsGenericType_\" data-linktype=\"relative-path\">IsGenericType</a> property.</p>\n</li>\n</ul>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_GetHashCode\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_GetHashCode_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetHashCode()</div>        \r\n          </div>\r\n    \r\n            <p>Returns the hash code for this instance.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override int GetHashCode ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </div>\r\n                  <p>A 32-bit signed integer hash code.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_GetMethodBody\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_GetMethodBody_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetMethodBody()</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, gets a <a class=\"xref\" href=\"system.reflection.methodbody\" data-linktype=\"relative-path\">MethodBody</a> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual System.Reflection.MethodBody GetMethodBody ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodbody\" data-linktype=\"relative-path\">MethodBody</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"system.reflection.methodbody\" data-linktype=\"relative-path\">MethodBody</a> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>This method is invalid unless overridden in a derived class.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>You do not have to override the GetMethodBody in order to use it. You can call the GetMethodBody method on <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> and <a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a> objects, because the method is overridden in the runtime versions of these classes. For example, the runtime version of the <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> class derives from the <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> class, which in turn derives from the <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> class.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example defines a test method named <code>MethodBodyExample</code> and displays its local variable information and exception-handling clauses. The GetMethodBody method is used to obtain a <a class=\"xref\" href=\"system.reflection.methodbody\" data-linktype=\"relative-path\">MethodBody</a> object for the test method.  </p>\n<p> The <a class=\"xref\" href=\"system.reflection.methodbody#System_Reflection_MethodBody_LocalVariables_\" data-linktype=\"relative-path\">LocalVariables</a> property is used to obtain a list of <a class=\"xref\" href=\"system.reflection.localvariableinfo\" data-linktype=\"relative-path\">LocalVariableInfo</a> objects and display their types and index order. The <a class=\"xref\" href=\"system.reflection.methodbody#System_Reflection_MethodBody_ExceptionHandlingClauses_\" data-linktype=\"relative-path\">ExceptionHandlingClauses</a> property is used to obtain a list of exception-handling clauses.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Not all computer languages can generate <a class=\"xref\" href=\"system.reflection.exceptionhandlingclauseoptions\" data-linktype=\"relative-path\">System.Reflection.ExceptionHandlingClauseOptions</a> clauses. The Visual Basic example shows a filter clause, using a Visual Basic <code>When</code> expression, which is omitted from the examples for other languages.  </p>\n</div>\n<pre><code class=\"lang-cpp\" name=\"MethodBody#1\">#using &lt;System.dll&gt;\n\nusing namespace System;\nusing namespace System::Reflection;\n\npublic ref class Example\n{\n    // The Main method contains code to analyze this method, using\n    // the properties and methods of the MethodBody class.\npublic:\n    void MethodBodyExample(Object^ arg)\n    {\n        // Define some local variables. In addition to these variables,\n        // the local variable list includes the variables scoped to \n        // the catch clauses.\n        int var1 = 42;\n        String^ var2 = &quot;Forty-two&quot;;\n\n        try\n        {\n            // Depending on the input value, throw an ArgumentException or \n            // an ArgumentNullException to test the Catch clauses.\n            if (arg == nullptr)\n            {\n                throw gcnew ArgumentNullException(&quot;The argument cannot &quot; +\n                    &quot;be null.&quot;);\n            }\n            if (arg-&gt;GetType() == String::typeid)\n            {\n                throw gcnew ArgumentException(&quot;The argument cannot &quot; + \n                    &quot;be a string.&quot;);\n            }        \n        }\n\n        // There is no Filter clause in this code example. See the Visual \n        // Basic code for an example of a Filter clause.\n\n        // This catch clause handles the ArgumentException class, and\n        // any other class derived from Exception.\n        catch (ArgumentException^ ex)\n        {\n            Console::WriteLine(&quot;Ordinary exception-handling clause caught:&quot; +\n                &quot; {0}&quot;, ex-&gt;GetType());\n        }        \n        finally\n        {\n            var1 = 3033;\n            var2 = &quot;Another string.&quot;;\n        }\n    }\n};\n\nint main()\n{ \n    // Get method body information.\n    MethodInfo^ mi = \n        Example::typeid-&gt;GetMethod(&quot;MethodBodyExample&quot;);\n\n    MethodBody^ mb = mi-&gt;GetMethodBody();\n    Console::WriteLine(&quot;\\r<br>Method: {0}&quot;, mi);\n\n    // Display the general information included in the \n    // MethodBody object.\n    Console::WriteLine(&quot;    Local variables are initialized: {0}&quot;, \n        mb-&gt;InitLocals);\n    Console::WriteLine(&quot;    Maximum number of items on the operand &quot; +\n        &quot;stack: {0}&quot;, mb-&gt;MaxStackSize);\n\n    // Display information about the local variables in the\n    // method body.\n    Console::WriteLine();\n    for each (LocalVariableInfo^ lvi in mb-&gt;LocalVariables)\n    {\n        Console::WriteLine(&quot;Local variable: {0}&quot;, lvi);\n    }\n\n    // Display exception handling clauses.\n    Console::WriteLine();\n    for each(ExceptionHandlingClause^ exhc in mb-&gt;ExceptionHandlingClauses)\n    {\n        Console::WriteLine(exhc-&gt;Flags.ToString());\n\n        // The FilterOffset property is meaningful only for Filter\n        // clauses. The CatchType property is not meaningful for \n        // Filter or Finally clauses. \n        switch(exhc-&gt;Flags)\n        {\n        case ExceptionHandlingClauseOptions::Filter:\n            Console::WriteLine(&quot;        Filter Offset: {0}&quot;, \n                exhc-&gt;FilterOffset);\n            break;\n        case ExceptionHandlingClauseOptions::Finally:\n            break;\n        default:\n            Console::WriteLine(&quot;    Type of exception: {0}&quot;, \n                exhc-&gt;CatchType);\n            break;\n        }\n\n        Console::WriteLine(&quot;       Handler Length: {0}&quot;,\n            exhc-&gt;HandlerLength);\n        Console::WriteLine(&quot;       Handler Offset: {0}&quot;, \n            exhc-&gt;HandlerOffset);\n        Console::WriteLine(&quot;     Try Block Length: {0}&quot;, exhc-&gt;TryLength);\n        Console::WriteLine(&quot;     Try Block Offset: {0}&quot;, exhc-&gt;TryOffset);\n    }\n}\n\n//This code example produces output similar to the following:\n//\n//Method: Void MethodBodyExample(System.Object)\n//    Local variables are initialized: False\n//    Maximum number of items on the operand stack: 4\n//\n//Local variable: System.ArgumentException (0)\n//Local variable: System.String (1)\n//Local variable: System.Int32 (2)\n//Clause\n//    Type of exception: System.ArgumentException\n//       Handler Length: 29\n//       Handler Offset: 78\n//     Try Block Length: 65\n//     Try Block Offset: 13\n//Finally\n//       Handler Length: 13\n//       Handler Offset: 113\n//     Try Block Length: 100\n//     Try Block Offset: 13\n</code></pre><pre><code class=\"lang-vb\" name=\"MethodBody#1\">Imports System\nImports System.Reflection\n\nPublic Class Example\n\n    Public Shared Sub Main()\n\n        &#39; Demonstrate the effect of the Visual Basic When keyword, which\n        &#39; generates a Filter clause in the Try block.\n        Dim e As New Example()\n        Console.WriteLine()\n        e.MethodBodyExample(&quot;String argument&quot;)\n        e.MethodBodyExample(Nothing)\n\n        &#39; Get method body information.\n        Dim mi As MethodInfo = _\n            GetType(Example).GetMethod(&quot;MethodBodyExample&quot;)\n        Dim mb As MethodBody = mi.GetMethodBody()\n        Console.WriteLine(vbCrLf &amp; &quot;Method: {0}&quot;, mi)\n\n        &#39; Display the general information included in the \n        &#39; MethodBody object.\n        Console.WriteLine(&quot;    Local variables are initialized: {0}&quot;, _\n            mb.InitLocals)\n        Console.WriteLine(&quot;    Maximum number of items on the operand stack: {0}&quot;, _\n            mb.MaxStackSize)\n\n        &#39; Display information about the local variables in the\n        &#39; method body.\n        Console.WriteLine()\n        For Each lvi As LocalVariableInfo In mb.LocalVariables\n            Console.WriteLine(&quot;Local variable: {0}&quot;, lvi)\n        Next\n\n        &#39; Display exception handling clauses.\n        Console.WriteLine()\n        For Each ehc As ExceptionHandlingClause In mb.ExceptionHandlingClauses\n            Console.WriteLine(ehc.Flags.ToString())\n\n            &#39; The FilterOffset property is meaningful only for Filter\n            &#39; clauses. The CatchType property is not meaningful for \n            &#39; Filter or Finally clauses. \n            Select Case ehc.Flags\n                Case ExceptionHandlingClauseOptions.Filter\n                    Console.WriteLine(&quot;        Filter Offset: {0}&quot;, _\n                        ehc.FilterOffset)\n                Case ExceptionHandlingClauseOptions.Finally\n                Case Else\n                    Console.WriteLine(&quot;    Type of exception: {0}&quot;, _\n                        ehc.CatchType)\n            End Select\n\n            Console.WriteLine(&quot;       Handler Length: {0}&quot;, ehc.HandlerLength)\n            Console.WriteLine(&quot;       Handler Offset: {0}&quot;, ehc.HandlerOffset)\n            Console.WriteLine(&quot;     Try Block Length: {0}&quot;, ehc.TryLength)\n            Console.WriteLine(&quot;     Try Block Offset: {0}&quot;, ehc.TryOffset)\n        Next\n    End Sub\n\n    &#39; This test method is executed at the beginning of Main, to show\n    &#39; how the Filter clause works. The Filter clause is generated by \n    &#39; a Visual Basic When expression. If arg is Nothing, this method\n    &#39; throws ArgumentNullException, which is caught by the filter\n    &#39; clause. If arg is a string, the method throws ArgumentException,\n    &#39; which does not match the filter clause.\n    &#39;\n    &#39; Sub Main also contains code to analyze this method, using \n    &#39; the properties and methods of the MethodBody class.\n    Public Sub MethodBodyExample(ByVal arg As Object)\n\n        &#39; Define some local variables. In addition to these variables,\n        &#39; the local variable list includes the variables scoped to \n        &#39; the catch clauses.\n        Dim var1 As Integer = 42\n        Dim var2 As String = &quot;Forty-two&quot;\n\n        Try\n            &#39; Depending on the input value, throw an ArgumentException or \n            &#39; an ArgumentNullException to test the Catch clauses.\n            &#39;\n            If arg Is Nothing Then\n                Throw New ArgumentNullException(&quot;The argument cannot be Nothing.&quot;)\n            End If\n            If arg.GetType() Is GetType(String) Then\n                Throw New ArgumentException(&quot;The argument cannot be a string.&quot;)\n            End If\n        \n        &#39; The When expression makes this a filter clause. The expression \n        &#39; selects only exceptions that derive from the ArgumentException\n        &#39; class. Other exceptions, including ArgumentException itself, \n        &#39; are not handled by this filter clause.\n        Catch ex As ArgumentException _\n            When ex.GetType().IsSubclassOf(GetType(ArgumentException))\n\n            Console.WriteLine(&quot;Filter clause caught: {0}&quot;, ex.GetType())\n        \n        &#39; This catch clause handles the ArgumentException class, and\n        &#39; any other class derived from Exception.\n        Catch ex As Exception\n            Console.WriteLine(&quot;Ordinary exception-handling clause caught: {0}&quot;, _\n                ex.GetType())\n\n        Finally\n            var1 = 3033\n            var2 = &quot;Another string.&quot;\n        End Try\n    End Sub\nEnd Class\n\n&#39; This code example produces output similar to the following:\n&#39;\n&#39;Ordinary exception-handling clause caught: System.ArgumentException\n&#39;Filter clause caught: System.ArgumentNullException\n&#39;\n&#39;Method: Void MethodBodyExample(System.Object)\n&#39;    Local variables are initialized: True\n&#39;    Maximum number of items on the operand stack: 3\n&#39;\n&#39;Local variable: System.Int32 (0)\n&#39;Local variable: System.String (1)\n&#39;Local variable: System.ArgumentException (2)\n&#39;Local variable: System.Exception (3)\n&#39;\n&#39;Filter\n&#39;        Filter Offset: 0\n&#39;       Handler Length: 19\n&#39;       Handler Offset: 99\n&#39;     Try Block Length: 45\n&#39;     Try Block Offset: 9\n&#39;Clause\n&#39;    Type of exception: System.Exception\n&#39;       Handler Length: 25\n&#39;       Handler Offset: 118\n&#39;     Try Block Length: 45\n&#39;     Try Block Offset: 9\n&#39;Finally\n&#39;       Handler Length: 13\n&#39;       Handler Offset: 153\n&#39;     Try Block Length: 144\n&#39;     Try Block Offset: 9\n</code></pre><pre><code class=\"lang-cs\" name=\"MethodBody#1\">using System;\nusing System.Reflection;\n\npublic class Example\n{\n    public static void Main()\n    {\n        // Get method body information.\n        MethodInfo mi = typeof(Example).GetMethod(&quot;MethodBodyExample&quot;);\n        MethodBody mb = mi.GetMethodBody();\n        Console.WriteLine(&quot;\\r<br>Method: {0}&quot;, mi);\n\n        // Display the general information included in the \n        // MethodBody object.\n        Console.WriteLine(&quot;    Local variables are initialized: {0}&quot;, \n            mb.InitLocals);\n        Console.WriteLine(&quot;    Maximum number of items on the operand stack: {0}&quot;, \n            mb.MaxStackSize);\n\n        // Display information about the local variables in the\n        // method body.\n        Console.WriteLine();\n        foreach (LocalVariableInfo lvi in mb.LocalVariables)\n        {\n            Console.WriteLine(&quot;Local variable: {0}&quot;, lvi);\n        }\n\n        // Display exception handling clauses.\n        Console.WriteLine();\n        foreach (ExceptionHandlingClause ehc in mb.ExceptionHandlingClauses)\n        {\n            Console.WriteLine(ehc.Flags.ToString());\n\n            // The FilterOffset property is meaningful only for Filter\n            // clauses. The CatchType property is not meaningful for \n            // Filter or Finally clauses. \n            switch (ehc.Flags)\n            {\n                case ExceptionHandlingClauseOptions.Filter:\n                    Console.WriteLine(&quot;        Filter Offset: {0}&quot;, \n                        ehc.FilterOffset);\n                    break;\n                case ExceptionHandlingClauseOptions.Finally:\n                    break;\n                default:\n                    Console.WriteLine(&quot;    Type of exception: {0}&quot;, \n                        ehc.CatchType);\n                    break;\n            }\n\n            Console.WriteLine(&quot;       Handler Length: {0}&quot;, ehc.HandlerLength);\n            Console.WriteLine(&quot;       Handler Offset: {0}&quot;, ehc.HandlerOffset);\n            Console.WriteLine(&quot;     Try Block Length: {0}&quot;, ehc.TryLength);\n            Console.WriteLine(&quot;     Try Block Offset: {0}&quot;, ehc.TryOffset);\n        }\n    }\n\n    // The Main method contains code to analyze this method, using\n    // the properties and methods of the MethodBody class.\n    public void MethodBodyExample(object arg)\n    {\n        // Define some local variables. In addition to these variables,\n        // the local variable list includes the variables scoped to \n        // the catch clauses.\n        int var1 = 42;\n        string var2 = &quot;Forty-two&quot;;\n\n        try\n        {\n            // Depending on the input value, throw an ArgumentException or \n            // an ArgumentNullException to test the Catch clauses.\n            if (arg == null)\n            {\n                throw new ArgumentNullException(&quot;The argument cannot be null.&quot;);\n            }\n            if (arg.GetType() == typeof(string))\n            {\n                throw new ArgumentException(&quot;The argument cannot be a string.&quot;);\n            }        \n        }\n\n        // There is no Filter clause in this code example. See the Visual \n        // Basic code for an example of a Filter clause.\n\n        // This catch clause handles the ArgumentException class, and\n        // any other class derived from Exception.\n        catch(Exception ex)\n        {\n            Console.WriteLine(&quot;Ordinary exception-handling clause caught: {0}&quot;, \n                ex.GetType());\n        }        \n        finally\n        {\n            var1 = 3033;\n            var2 = &quot;Another string.&quot;;\n        }\n    }\n}\n\n// This code example produces output similar to the following:\n//\n//Method: Void MethodBodyExample(System.Object)\n//    Local variables are initialized: True\n//    Maximum number of items on the operand stack: 2\n//\n//Local variable: System.Int32 (0)\n//Local variable: System.String (1)\n//Local variable: System.Exception (2)\n//Local variable: System.Boolean (3)\n//\n//Clause\n//    Type of exception: System.Exception\n//       Handler Length: 21\n//       Handler Offset: 70\n//     Try Block Length: 61\n//     Try Block Offset: 9\n//Finally\n//       Handler Length: 14\n//       Handler Offset: 94\n//     Try Block Length: 85\n//     Try Block Offset: 9\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_GetMethodFromHandle_System_RuntimeMethodHandle_\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_GetMethodFromHandle_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetMethodFromHandle(RuntimeMethodHandle)</div>        \r\n          </div>\r\n    \r\n            <p>Gets method information by using the method&#39;s internal metadata representation (handle).</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>handle</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtimemethodhandle\" data-linktype=\"relative-path\">RuntimeMethodHandle</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The method&#39;s handle.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a></div>\r\n                  </div>\r\n                  <p>A <code>MethodBase</code> containing information about the method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>handle</code> is invalid.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Handles are valid only in the application domain in which they were obtained.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_GetMethodFromHandle_System_RuntimeMethodHandle_System_RuntimeTypeHandle_\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_GetMethodFromHandle_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetMethodFromHandle(RuntimeMethodHandle,RuntimeTypeHandle)</div>        \r\n          </div>\r\n    \r\n            <p>Gets a <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> object for the constructor or method represented by the specified handle, for the specified generic type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Reflection.MethodBase GetMethodFromHandle (RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>handle</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtimemethodhandle\" data-linktype=\"relative-path\">RuntimeMethodHandle</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A handle to the internal metadata representation of a constructor or method.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>declaringType</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtimetypehandle\" data-linktype=\"relative-path\">RuntimeTypeHandle</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A handle to the generic type that defines the constructor or method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> object representing the method or constructor specified by <code>handle</code>, in the generic type specified by <code>declaringType</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>handle</code> is invalid.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Handles are valid only in the application domain in which they were obtained.  </p>\n<p> A <a class=\"xref\" href=\"system.runtimemethodhandle\" data-linktype=\"relative-path\">RuntimeMethodHandle</a> structure for a constructor or method of a generic type can represent different <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> objects, depending on the types specified for the type parameters of the generic type. For example, if <code>class G&lt;T&gt;</code> (<code>class G(Of T)</code> in Visual Basic, <code>generic &lt;T&gt; ref class G</code> in C++) has a method that returns type <code>T</code>, the <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> object for that method in a constructed class such as <code>G&lt;int&gt;</code> is different from the <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> object for that method in the generic type definition.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_GetMethodImplementationFlags\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_GetMethodImplementationFlags_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetMethodImplementationFlags()</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, returns the <a class=\"xref\" href=\"system.reflection.methodimplattributes\" data-linktype=\"relative-path\">MethodImplAttributes</a> flags.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract System.Reflection.MethodImplAttributes GetMethodImplementationFlags ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodimplattributes\" data-linktype=\"relative-path\">MethodImplAttributes</a></div>\r\n                  </div>\r\n                  <p>The <code>MethodImplAttributes</code> flags.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example defines a constructor in a dynamic assembly and then uses the GetMethodImplementationFlags method to display the method implementation flags that are set by default.  </p>\n<pre><code class=\"lang-cs\" name=\"ConstructorBuilder_GetModule_4#3\">\n      MethodBuilder myMethodBuilder = null;\n      AppDomain myCurrentDomain = AppDomain.CurrentDomain;\n      // Create assembly in current CurrentDomain.\n      AssemblyName myAssemblyName = new AssemblyName();\n      myAssemblyName.Name = &quot;TempAssembly&quot;;\n      // Create a dynamic assembly.\n      myAssemblyBuilder = myCurrentDomain.DefineDynamicAssembly\n                                    (myAssemblyName, AssemblyBuilderAccess.Run);\n      // Create a dynamic module in the assembly.\n      myModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;TempModule&quot;);\n      // Create a type in the module.\n      TypeBuilder myTypeBuilder = myModuleBuilder.DefineType(&quot;TempClass&quot;,TypeAttributes.Public);\n      FieldBuilder myGreetingField = myTypeBuilder.DefineField(&quot;Greeting&quot;,\n         typeof(String), FieldAttributes.Public);\n      Type[] myConstructorArgs = { typeof(String) };\n      // Define a constructor of the dynamic class.\n      ConstructorBuilder myConstructorBuilder = myTypeBuilder.DefineConstructor(\n         MethodAttributes.Public, CallingConventions.Standard, myConstructorArgs);\n      // Get a reference to the module that contains this constructor.\n      Module myModule = myConstructorBuilder.GetModule();\n      Console.WriteLine(&quot;Module Name : &quot; + myModule.Name);\n      // Get the &#39;MethodToken&#39; that represents the token for this constructor.\n      MethodToken myMethodToken = myConstructorBuilder.GetToken();\n      Console.WriteLine(&quot;Constructor Token is : &quot; + myMethodToken.Token);\n      // Get the method implementation flags for this constructor.\n      MethodImplAttributes myMethodImplAttributes = myConstructorBuilder.GetMethodImplementationFlags();\n      Console.WriteLine(&quot;MethodImplAttributes : &quot;  + myMethodImplAttributes);\n</code></pre><pre><code class=\"lang-cpp\" name=\"ConstructorBuilder_GetModule_4#3\">\n      MethodBuilder^ myMethodBuilder = nullptr;\n      AppDomain^ myCurrentDomain = AppDomain::CurrentDomain;\n      // Create assembly in current CurrentDomain.\n      AssemblyName^ myAssemblyName = gcnew AssemblyName;\n      myAssemblyName-&gt;Name = &quot;TempAssembly&quot;;\n      // Create a dynamic assembly.\n      myAssemblyBuilder = myCurrentDomain-&gt;DefineDynamicAssembly( myAssemblyName, AssemblyBuilderAccess::Run );\n      // Create a dynamic module in the assembly.\n      myModuleBuilder = myAssemblyBuilder-&gt;DefineDynamicModule( &quot;TempModule&quot; );\n      // Create a type in the module.\n      TypeBuilder^ myTypeBuilder = myModuleBuilder-&gt;DefineType( &quot;TempClass&quot;, TypeAttributes::Public );\n      FieldBuilder^ myGreetingField = myTypeBuilder-&gt;DefineField( &quot;Greeting&quot;,\n         String::typeid, FieldAttributes::Public );\n      array&lt;Type^&gt;^myConstructorArgs = {String::typeid};\n      // Define a constructor of the dynamic class.\n      ConstructorBuilder^ myConstructorBuilder = myTypeBuilder-&gt;DefineConstructor(\n         MethodAttributes::Public, CallingConventions::Standard, myConstructorArgs );\n      // Get a reference to the module that contains this constructor.\n      Module^ myModule = myConstructorBuilder-&gt;GetModule();\n      Console::WriteLine( &quot;Module Name : {0}&quot;, myModule-&gt;Name );\n      // Get the &#39;MethodToken&#39; that represents the token for this constructor.\n      MethodToken myMethodToken = myConstructorBuilder-&gt;GetToken();\n      Console::WriteLine( &quot;Constructor Token is : {0}&quot;, myMethodToken.Token );\n      // Get the method implementation flags for this constructor.\n      MethodImplAttributes myMethodImplAttributes = myConstructorBuilder-&gt;GetMethodImplementationFlags();\n      Console::WriteLine( &quot;MethodImplAttributes : {0}&quot;, myMethodImplAttributes );\n</code></pre><pre><code class=\"lang-vb\" name=\"ConstructorBuilder_GetModule_4#3\">      Dim myMethodBuilder As MethodBuilder = Nothing\n      Dim myCurrentDomain As AppDomain = AppDomain.CurrentDomain\n      &#39; Create assembly in current CurrentDomain.\n      Dim myAssemblyName As New AssemblyName()\n      myAssemblyName.Name = &quot;TempAssembly&quot;\n      &#39; Create a dynamic assembly.\n      myAssemblyBuilder = _ \n                myCurrentDomain.DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.Run)\n      &#39; Create a dynamic module in the assembly.\n      myModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;TempModule&quot;)\n      &#39; Create a type in the module.\n      Dim myTypeBuilder As TypeBuilder = _ \n                   myModuleBuilder.DefineType(&quot;TempClass&quot;, TypeAttributes.Public)\n      Dim myGreetingField As FieldBuilder = _ \n               myTypeBuilder.DefineField(&quot;Greeting&quot;, GetType(String), FieldAttributes.Public)\n       Dim myConstructorArgs As Type() = {GetType(String)}\n      &#39; Define a constructor of the dynamic class.\n      Dim myConstructorBuilder As ConstructorBuilder = _ \n          myTypeBuilder.DefineConstructor(MethodAttributes.Public, CallingConventions.Standard, _ \n                                          myConstructorArgs)\n      &#39; Get a reference to the module that contains this constructor.\n      Dim myModule As [Module] = myConstructorBuilder.GetModule()\n      Console.WriteLine(&quot;Module Name : &quot; + myModule.Name)\n      &#39; Get the &#39;MethodToken&#39; that represents the token for this constructor.\n      Dim myMethodToken As MethodToken = myConstructorBuilder.GetToken()\n      Console.WriteLine(&quot;Constructor Token is : &quot; + myMethodToken.Token.ToString())\n      &#39; Get the method implementation flags for this constructor.\n      Dim myMethodImplAttributes As MethodImplAttributes = _\n          myConstructorBuilder.GetMethodImplementationFlags()\n      Console.WriteLine(&quot;MethodImplAttributes : &quot; + myMethodImplAttributes.ToString())\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_GetParameters\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_GetParameters_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetParameters()</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, gets the parameters of the specified method or constructor.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract System.Reflection.ParameterInfo[] GetParameters ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.parameterinfo\" data-linktype=\"relative-path\">ParameterInfo</a>[]</div>\r\n                  </div>\r\n                  <p>An array of type <code>ParameterInfo</code> containing information that matches the signature of the method (or constructor) reflected by this <code>MethodBase</code> instance.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses the GetParameters method to retrieve the parameters of the <code>Invoke</code> method of a delegate.  </p>\n<p> The example defines a delegate named <code>MyDelegate</code> and an event named <code>ev</code> of type <code>MyDelegate</code>. The code in the <code>Main</code> method discovers the event signature by getting the delegate type of the event, getting the <code>Invoke</code> method of the delegate type, and then retrieving and displaying the parameters.  </p>\n<pre><code class=\"lang-cs\" name=\"eventarg#1\">// The following example uses instances of classes in \n// the System.Reflection namespace to discover an event argument type.\nusing System;\nusing System.Reflection;\n\npublic delegate void MyDelegate(int i);\npublic class MainClass \n{\n    public event MyDelegate ev;\n\n    public static void Main() \n    {\n        Type delegateType = typeof(MainClass).GetEvent(&quot;ev&quot;).EventHandlerType;\n        MethodInfo invoke = delegateType.GetMethod(&quot;Invoke&quot;);\n        ParameterInfo[] pars = invoke.GetParameters();\n        foreach (ParameterInfo p in pars) \n        {\n            Console.WriteLine(p.ParameterType);\n        }\n    }\n}\n// The example displays the following output:\n//       System.Int32\n</code></pre><pre><code class=\"lang-cpp\" name=\"eventarg#1\">// The following example uses instances of classes in\n// the System::Reflection namespace to discover an event argument type.\nusing namespace System;\nusing namespace System::Reflection;\n\npublic delegate void MyDelegate( int i );\npublic ref class MainClass\n{\npublic:\n   event MyDelegate^ ev;\n};\n\nint main()\n{\n   Type^ delegateType = MainClass::typeid-&gt;GetEvent( &quot;ev&quot; )-&gt;EventHandlerType;\n   MethodInfo^ invoke = delegateType-&gt;GetMethod( &quot;Invoke&quot; );\n   array&lt;ParameterInfo^&gt;^pars = invoke-&gt;GetParameters();\n   System::Collections::IEnumerator^ myEnum = pars-&gt;GetEnumerator();\n   while ( myEnum-&gt;MoveNext() )\n   {\n      ParameterInfo^ p = safe_cast&lt;ParameterInfo^&gt;(myEnum-&gt;Current);\n      Console::WriteLine( p-&gt;ParameterType );\n   }\n}\n// The example displays the following output:\n//       System.Int32\n</code></pre><pre><code class=\"lang-vb\" name=\"eventarg#1\">Imports System.Reflection\n\nPublic Delegate Sub MyDelegate(ByVal i As Integer)\n\nPublic Class MainClass\n    Public Event ev As MyDelegate\n\n    Public Shared Sub Main()\n        Dim delegateType As Type = GetType(MainClass).GetEvent(&quot;ev&quot;).EventHandlerType\n        Dim invoke As MethodInfo = delegateType.GetMethod(&quot;Invoke&quot;)\n        Dim pars As ParameterInfo() = invoke.GetParameters()\n        For Each p As ParameterInfo In pars\n            Console.WriteLine(p.ParameterType)\n        Next \n    End Sub \nEnd Class \n&#39; The example displays the following output:\n&#39;     System.Int32\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_Invoke_System_Object_System_Object___\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_Invoke_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Invoke(Object,Object[])</div>        \r\n          </div>\r\n    \r\n            <p>Invokes the method or constructor represented by the current instance, using the specified parameters.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public object Invoke (object obj, object[] parameters);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>obj</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object on which to invoke the method or constructor. If a method is static, this argument is ignored. If a constructor is static, this argument must be <code>null</code> or an instance of the class that defines the constructor.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>parameters</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An argument list for the invoked method or constructor. This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked. If there are no parameters, <code>parameters</code> should be <code>null</code>.  </p>\n<p> If the method or constructor represented by this instance takes a <code>ref</code> parameter (<code>ByRef</code> in Visual Basic), no special attribute is required for that parameter in order to invoke the method or constructor using this function. Any object in this array that is not explicitly initialized with a value will contain the default value for that object type. For reference-type elements, this value is <code>null</code>. For value-type elements, this value is 0, 0.0, or <code>false</code>, depending on the specific element type.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></div>\r\n                  </div>\r\n                  <p>An object containing the return value of the invoked method, or <code>null</code> in the case of a constructor.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.targetexception\" data-linktype=\"relative-path\">TargetException</a></div>\r\n                  </div>\r\n                  <div class=\"alert NOTE\"><br> In the <a href=\"http://go.microsoft.com/fwlink/?LinkID=247912\" data-linktype=\"external\">.NET for Windows Store apps</a> or the <a href=\"../Topic/Cross-Platform%20Development%20with%20the%20Portable%20Class%20Library.md\" data-linktype=\"relative-path\">Portable Class Library</a>, catch <a class=\"xref\" href=\"system.exception\" data-linktype=\"relative-path\">Exception</a> instead.<br>\n</div>  \n\n<p> The <code>obj</code> parameter is <code>null</code> and the method is not static.  </p>\n<p> -or-  </p>\n<p> The method is not declared or inherited by the class of <code>obj</code>.  </p>\n<p> -or-  </p>\n<p> A static constructor is invoked, and <code>obj</code> is neither <code>null</code> nor an instance of the class that declared the constructor.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p>The elements of the <code>parameters</code>array do not match the signature of the method or constructor reflected by this instance.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.targetinvocationexception\" data-linktype=\"relative-path\">TargetInvocationException</a></div>\r\n                  </div>\r\n                  <p>The invoked method or constructor throws an exception.  </p>\n<p> -or-  </p>\n<p> The current instance is a <a class=\"xref\" href=\"system.reflection.emit.dynamicmethod\" data-linktype=\"relative-path\">DynamicMethod</a> that contains unverifiable code. See the &quot;Verification&quot; section in Remarks for <a class=\"xref\" href=\"system.reflection.emit.dynamicmethod\" data-linktype=\"relative-path\">DynamicMethod</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.targetparametercountexception\" data-linktype=\"relative-path\">TargetParameterCountException</a></div>\r\n                  </div>\r\n                  <p>The <code>parameters</code> array does not have the correct number of arguments.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.methodaccessexception\" data-linktype=\"relative-path\">MethodAccessException</a></div>\r\n                  </div>\r\n                  <div class=\"alert NOTE\"><br> In the <a href=\"http://go.microsoft.com/fwlink/?LinkID=247912\" data-linktype=\"external\">.NET for Windows Store apps</a> or the <a href=\"../Topic/Cross-Platform%20Development%20with%20the%20Portable%20Class%20Library.md\" data-linktype=\"relative-path\">Portable Class Library</a>, catch the base class exception, <a class=\"xref\" href=\"system.memberaccessexception\" data-linktype=\"relative-path\">MemberAccessException</a>, instead.<br>\n</div>  \n\n<p> The caller does not have permission to execute the method or constructor that is represented by the current instance.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The type that declares the method is an open generic type. That is, the <span class=\"xref\">stem.Type.ContainsGenericParameters*</span> property returns <code>true</code> for the declaring type.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The current instance is a <a class=\"xref\" href=\"system.reflection.emit.methodbuilder\" data-linktype=\"relative-path\">MethodBuilder</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This is a convenience method that calls the [Invoke(Object, BindingFlags, Binder, Object&lt;xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29&gt; method overload, passing <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> for <code>invokeAttr</code> and <code>null</code> for <code>binder</code> and <code>culture</code>.  </p>\n<p> If the invoked method throws an exception, the <a class=\"xref\" href=\"system.exception#System_Exception_GetBaseException_\" data-linktype=\"relative-path\">GetBaseException</a> method returns the exception.  </p>\n<p> To invoke a static method using its <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> object, pass <code>null</code> for <code>obj</code>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> If this method overload is used to invoke an instance constructor, the object supplied for <code>obj</code> is reinitialized; that is, all instance initializers are executed. The return value is <code>null</code>. If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed. The return value is <code>null</code>.  </p>\n</div>\n<div class=\"NOTE\"><h5>Note</h5><p> Starting with the .NET Framework 2.0 Service Pack 1, this method can be used to access non-public members if the caller has been granted <a class=\"xref\" href=\"system.security.permissions.reflectionpermission\" data-linktype=\"relative-path\">ReflectionPermission</a> with the <a class=\"xref\" href=\"system.security.permissions.reflectionpermissionflag\" data-linktype=\"relative-path\">System.Security.Permissions.ReflectionPermissionFlag</a> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof. (See <a href=\"../Topic/Security%20Considerations%20for%20Reflection.md\" data-linktype=\"relative-path\">Security Considerations for Reflection</a>.)  </p>\n<p> To use this functionality, your application should target the  .NET Framework 3.5  or later.  </p>\n</div>\n<p> If a parameter of the current method is a value type, and the corresponding argument in <code>parameters</code> is <code>null</code>, the runtime passes a zero-initialized instance of the value type.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates dynamic method lookup using reflection. Note that you cannot use the <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> object from the base class to invoke the overridden method in the derived class, because late binding cannot resolve overrides.  </p>\n<pre><code class=\"lang-cpp\" name=\"Classic MethodBase.Invoke1 Example#1\">using namespace System;\nusing namespace System::Reflection;\n\npublic ref class MagicClass\n{\nprivate:\n    int magicBaseValue;\n\npublic:\n    MagicClass()\n    {\n        magicBaseValue = 9;\n    }\n\n    int ItsMagic(int preMagic)\n    {\n        return preMagic * magicBaseValue;\n    }\n};\n\npublic ref class TestMethodInfo\n{\npublic:\n    static void Main()\n    {\n        // Get the constructor and create an instance of MagicClass\n\n        Type^ magicType = Type::GetType(&quot;MagicClass&quot;);\n        ConstructorInfo^ magicConstructor = magicType-&gt;GetConstructor(Type::EmptyTypes);\n        Object^ magicClassObject = magicConstructor-&gt;Invoke(gcnew array&lt;Object^&gt;(0));\n\n        // Get the ItsMagic method and invoke with a parameter value of 100\n\n        MethodInfo^ magicMethod = magicType-&gt;GetMethod(&quot;ItsMagic&quot;);\n        Object^ magicValue = magicMethod-&gt;Invoke(magicClassObject, gcnew array&lt;Object^&gt;(1){100});\n\n        Console::WriteLine(&quot;MethodInfo.Invoke() Example<br>&quot;);\n        Console::WriteLine(&quot;MagicClass.ItsMagic() returned: {0}&quot;, magicValue);\n    }\n};\n\nint main()\n{\n    TestMethodInfo::Main();\n}\n\n// The example program gives the following output:\n//\n// MethodInfo.Invoke() Example\n//\n// MagicClass.ItsMagic() returned: 900\n</code></pre><pre><code class=\"lang-cs\" name=\"Classic MethodBase.Invoke1 Example#1\">using System;\nusing System.Reflection;\n\npublic class MagicClass\n{\n    private int magicBaseValue;\n\n    public MagicClass()\n    {\n        magicBaseValue = 9;\n    }\n    \n    public int ItsMagic(int preMagic)\n    {\n        return preMagic * magicBaseValue;\n    }\n}\n\npublic class TestMethodInfo\n{\n    public static void Main()\n    {\n        // Get the constructor and create an instance of MagicClass\n\n        Type magicType = Type.GetType(&quot;MagicClass&quot;);\n        ConstructorInfo magicConstructor = magicType.GetConstructor(Type.EmptyTypes);\n        object magicClassObject = magicConstructor.Invoke(new object[]{});\n\n        // Get the ItsMagic method and invoke with a parameter value of 100\n\n        MethodInfo magicMethod = magicType.GetMethod(&quot;ItsMagic&quot;);\n        object magicValue = magicMethod.Invoke(magicClassObject, new object[]{100});\n\n        Console.WriteLine(&quot;MethodInfo.Invoke() Example<br>&quot;);\n        Console.WriteLine(&quot;MagicClass.ItsMagic() returned: {0}&quot;, magicValue);\n    }\n}\n\n// The example program gives the following output:\n//\n// MethodInfo.Invoke() Example\n//\n// MagicClass.ItsMagic() returned: 900\n</code></pre><pre><code class=\"lang-vb\" name=\"Classic MethodBase.Invoke1 Example#1\">Imports System\nImports System.Reflection\n\nPublic Class MagicClass\n    Private magicBaseValue As Integer\n\n    Public Sub New()\n        magicBaseValue = 9\n    End Sub\n\n    Public Function ItsMagic(preMagic As Integer) As Integer\n        Return preMagic * magicBaseValue\n    End Function\nEnd Class\n\nPublic Class TestMethodInfo\n    Public Shared Sub Main()\n        &#39; Get the constructor and create an instance of MagicClass\n\n        Dim magicType As Type = Type.GetType(&quot;MagicClass&quot;)\n        Dim magicConstructor As ConstructorInfo = magicType.GetConstructor(Type.EmptyTypes)\n        Dim magicClassObject As Object = magicConstructor.Invoke(New Object(){})\n\n        &#39; Get the ItsMagic method and invoke with a parameter value of 100\n\n        Dim magicMethod As MethodInfo = magicType.GetMethod(&quot;ItsMagic&quot;)\n        Dim magicValue As Object = magicMethod.Invoke(magicClassObject, New Object(){100})\n\n        Console.WriteLine(&quot;MethodInfo.Invoke() Example&quot; + vbNewLine)\n        Console.WriteLine(&quot;MagicClass.ItsMagic() returned: {0}&quot;, magicValue)\n    End Sub\nEnd Class\n\n&#39; The example program gives the following output:\n&#39;\n&#39; MethodInfo.Invoke() Example\n&#39;\n&#39; MagicClass.ItsMagic() returned: 900\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_Invoke_System_Object_System_Reflection_BindingFlags_System_Reflection_Binder_System_Object___System_Globalization_CultureInfo_\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_Invoke_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Invoke(Object,BindingFlags,Binder,Object[],CultureInfo)</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, invokes the reflected method or constructor with the given parameters.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract object Invoke (object obj, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object[] parameters, System.Globalization.CultureInfo culture);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>obj</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object on which to invoke the method or constructor. If a method is static, this argument is ignored. If a constructor is static, this argument must be <code>null</code> or an instance of the class that defines the constructor.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>invokeAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask that is a combination of 0 or more bit flags from <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a>. If <code>binder</code> is <code>null</code>, this parameter is assigned the value <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a>; thus, whatever you pass in is ignored.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>binder</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <code>MemberInfo</code> objects via reflection. If <code>binder</code> is <code>null</code>, the default binder is used.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>parameters</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An argument list for the invoked method or constructor. This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked. If there are no parameters, this should be <code>null</code>.  </p>\n<p> If the method or constructor represented by this instance takes a ByRef parameter, there is no special attribute required for that parameter in order to invoke the method or constructor using this function. Any object in this array that is not explicitly initialized with a value will contain the default value for that object type. For reference-type elements, this value is <code>null</code>. For value-type elements, this value is 0, 0.0, or <code>false</code>, depending on the specific element type.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>culture</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.globalization.cultureinfo\" data-linktype=\"relative-path\">CultureInfo</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An instance of <code>CultureInfo</code> used to govern the coercion of types. If this is <code>null</code>, the <code>CultureInfo</code> for the current thread is used. (This is necessary to convert a <code>String</code> that represents 1000 to a <code>Double</code> value, for example, since 1000 is represented differently by different cultures.)</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></div>\r\n                  </div>\r\n                  <p>An <code>Object</code> containing the return value of the invoked method, or <code>null</code> in the case of a constructor, or <code>null</code> if the method&#39;s return type is <code>void</code>. Before calling the method or constructor, <code>Invoke</code> checks to see if the user has access permission and verifies that the parameters are valid.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.targetexception\" data-linktype=\"relative-path\">TargetException</a></div>\r\n                  </div>\r\n                  <p>The <code>obj</code> parameter is <code>null</code> and the method is not static.  </p>\n<p> -or-  </p>\n<p> The method is not declared or inherited by the class of <code>obj</code>.  </p>\n<p> -or-  </p>\n<p> A static constructor is invoked, and <code>obj</code> is neither <code>null</code> nor an instance of the class that declared the constructor.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p>The type of the <code>parameters</code> parameter does not match the signature of the method or constructor reflected by this instance.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.targetparametercountexception\" data-linktype=\"relative-path\">TargetParameterCountException</a></div>\r\n                  </div>\r\n                  <p>The <code>parameters</code> array does not have the correct number of arguments.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.targetinvocationexception\" data-linktype=\"relative-path\">TargetInvocationException</a></div>\r\n                  </div>\r\n                  <p>The invoked method or constructor throws an exception.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.methodaccessexception\" data-linktype=\"relative-path\">MethodAccessException</a></div>\r\n                  </div>\r\n                  <p>The caller does not have permission to execute the method or constructor that is represented by the current instance.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The type that declares the method is an open generic type. That is, the <span class=\"xref\">stem.Type.ContainsGenericParameters*</span> property returns <code>true</code> for the declaring type.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Dynamically invokes the method reflected by this instance on <code>obj</code>, and passes along the specified parameters. If the method is static, the <code>obj</code> parameter is ignored. For non-static methods, <code>obj</code> should be an instance of a class that inherits or declares the method and must be the same type as this class. If the method has no parameters, the value of <code>parameters</code> should be <code>null</code>. Otherwise, the number, type, and order of elements in <code>parameters</code> should be identical to the number, type, and order of parameters for the method reflected by this instance.  </p>\n<p> You may not omit optional parameters in calls to <code>Invoke</code>. To invoke a method omitting optional parameters, you should call <code>Type.InvokeMember</code> instead.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> If this method overload is used to invoke an instance constructor, the object supplied for <code>obj</code> is reinitialized; that is, all instance initializers are executed. The return value is <code>null</code>. If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed. The return value is <code>null</code>.  </p>\n</div>\n<p> For pass-by-value primitive parameters, normal widening is performed (Int16 -&gt; Int32, for example). For pass-by-value reference parameters, normal reference widening is allowed (derived class to base class, and base class to interface type). However, for pass-by-reference primitive parameters, the types must match exactly. For pass-by-reference reference parameters, the normal widening still applies.  </p>\n<p> For example, if the method reflected by this instance is declared as <code>public boolean Compare(String a, String b)</code>, then <code>parameters</code> should be an array of <code>Objects</code> with length 2 such that <code>parameters[0] = new Object(&quot;SomeString1&quot;) and parameters[1] = new Object(&quot;SomeString2&quot;)</code>.  </p>\n<p> If a parameter of the current method is a value type, and the corresponding argument in <code>parameters</code> is <code>null</code>, the runtime passes a zero-initialized instance of the value type.  </p>\n<p> Reflection uses dynamic method lookup when invoking virtual methods. For example, suppose that class B inherits from class A and both implement a virtual method named M. Now suppose that you have a <code>MethodInfo</code> object that represents M on class A. If you use the <code>Invoke</code> method to invoke M on an object of type B, then reflection will use the implementation given by class B. Even if the object of type B is cast to A, the implementation given by class B is used (see code sample below).  </p>\n<p> On the other hand, if the method is non-virtual, then reflection will use the implementation given by the type from which the <code>MethodInfo</code> was obtained, regardless of the type of the object passed as the target.  </p>\n<p> Access restrictions are ignored for fully trusted code. That is, private constructors, methods, fields, and properties can be accessed and invoked via reflection whenever the code is fully trusted.  </p>\n<p> If the invoked method throws an exception, <code>TargetInvocationException.GetException</code> returns the exception. This implementation throws a <code>NotSupportedException</code>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Starting with the .NET Framework 2.0 Service Pack 1, this method can be used to access non-public members if the caller has been granted <a class=\"xref\" href=\"system.security.permissions.reflectionpermission\" data-linktype=\"relative-path\">ReflectionPermission</a> with the <a class=\"xref\" href=\"system.security.permissions.reflectionpermissionflag\" data-linktype=\"relative-path\">System.Security.Permissions.ReflectionPermissionFlag</a> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof. (See <a href=\"../Topic/Security%20Considerations%20for%20Reflection.md\" data-linktype=\"relative-path\">Security Considerations for Reflection</a>.)  </p>\n<p> To use this functionality, your application should target the  .NET Framework 3.5  or later.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example demonstrates all members of the <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">System.Reflection.Binder</a> class using an overload of <a class=\"xref\" href=\"system.type#System_Type_InvokeMember_\" data-linktype=\"relative-path\">InvokeMember</a>. The private method <code>CanConvertFrom</code> finds compatible types for a given type. For another example of invoking members in a custom binding scenario, see <a href=\"../Topic/Dynamically%20Loading%20and%20Using%20Types.md\" data-linktype=\"relative-path\">Dynamically Loading and Using Types</a>.  </p>\n<pre><code class=\"lang-cpp\" name=\"Binder_1#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Globalization;\nusing namespace System::Runtime::InteropServices;\npublic ref class MyBinder: public Binder\n{\npublic:\n   MyBinder()\n      : Binder()\n   {}\n\nprivate:\n   ref class BinderState\n   {\n   public:\n      array&lt;Object^&gt;^args;\n   };\n\npublic:\n   virtual FieldInfo^ BindToField( BindingFlags bindingAttr, array&lt;FieldInfo^&gt;^match, Object^ value, CultureInfo^ culture ) override\n   {\n      if ( match == nullptr )\n            throw gcnew ArgumentNullException( &quot;match&quot; );\n\n      // Get a field for which the value parameter can be converted to the specified field type.\n      for ( int i = 0; i &lt; match-&gt;Length; i++ )\n         if ( ChangeType( value, match[ i ]-&gt;FieldType, culture ) != nullptr )\n                  return match[ i ];\n\n      return nullptr;\n   }\n\n   virtual MethodBase^ BindToMethod( BindingFlags bindingAttr, array&lt;MethodBase^&gt;^match, array&lt;Object^&gt;^%args, array&lt;ParameterModifier&gt;^ modifiers, CultureInfo^ culture, array&lt;String^&gt;^names, [Out]Object^% state ) override\n   {\n      // Store the arguments to the method in a state Object*.\n      BinderState^ myBinderState = gcnew BinderState;\n      array&lt;Object^&gt;^arguments = gcnew array&lt;Object^&gt;(args-&gt;Length);\n      args-&gt;CopyTo( arguments, 0 );\n      myBinderState-&gt;args = arguments;\n      state = myBinderState;\n      if ( match == nullptr )\n            throw gcnew ArgumentNullException;\n\n      // Find a method that has the same parameters as those of the args parameter.\n      for ( int i = 0; i &lt; match-&gt;Length; i++ )\n      {\n         // Count the number of parameters that match.\n         int count = 0;\n         array&lt;ParameterInfo^&gt;^parameters = match[ i ]-&gt;GetParameters();\n\n         // Go on to the next method if the number of parameters do not match.\n         if ( args-&gt;Length != parameters-&gt;Length )\n                  continue;\n\n         // Match each of the parameters that the user expects the method to have.\n         for ( int j = 0; j &lt; args-&gt;Length; j++ )\n         {\n            // If the names parameter is not 0, then reorder args.\n            if ( names != nullptr )\n            {\n               if ( names-&gt;Length != args-&gt;Length )\n                              throw gcnew ArgumentException( &quot;names and args must have the same number of elements.&quot; );\n\n               for ( int k = 0; k &lt; names-&gt;Length; k++ )\n                  if ( String::Compare( parameters[ j ]-&gt;Name, names[ k ] ) == 0 )\n                                    args[ j ] = myBinderState-&gt;args[ k ];\n            }\n\n            // Determine whether the types specified by the user can be converted to the parameter type.\n            if ( ChangeType( args[ j ], parameters[ j ]-&gt;ParameterType, culture ) != nullptr )\n                        count += 1;\n            else\n                        break;\n         }\n         if ( count == args-&gt;Length )\n                  return match[ i ];\n      }\n      return nullptr;\n   }\n\n   virtual Object^ ChangeType( Object^ value, Type^ myChangeType, CultureInfo^ culture ) override\n   {\n      // Determine whether the value parameter can be converted to a value of type myType.\n      if ( CanConvertFrom( value-&gt;GetType(), myChangeType ) )\n         // Return the converted Object*.\n         return Convert::ChangeType( value, myChangeType ); \n      else\n         return nullptr;\n   }\n\n   virtual void ReorderArgumentArray( array&lt;Object^&gt;^%args, Object^ state ) override\n   {\n      // Return the args that had been reordered by BindToMethod.\n      (safe_cast&lt;BinderState^&gt;(state))-&gt;args-&gt;CopyTo( args, 0 );\n   }\n\n   virtual MethodBase^ SelectMethod( BindingFlags bindingAttr, array&lt;MethodBase^&gt;^match, array&lt;Type^&gt;^types, array&lt;ParameterModifier&gt;^ modifiers ) override\n   {\n      if ( match == nullptr )\n            throw gcnew ArgumentNullException( &quot;match&quot; );\n\n      for ( int i = 0; i &lt; match-&gt;Length; i++ )\n      {\n         // Count the number of parameters that match.\n         int count = 0;\n         array&lt;ParameterInfo^&gt;^parameters = match[ i ]-&gt;GetParameters();\n\n         // Go on to the next method if the number of parameters do not match.\n         if ( types-&gt;Length != parameters-&gt;Length )\n                  continue;\n\n         // Match each of the parameters that the user expects the method to have.\n         for ( int j = 0; j &lt; types-&gt;Length; j++ )\n         {\n            // Determine whether the types specified by the user can be converted to parameter type.\n            if ( CanConvertFrom( types[ j ], parameters[ j ]-&gt;ParameterType ) )\n                        count += 1;\n            else\n                        break;\n         }\n         // Determine whether the method has been found.\n         if ( count == types-&gt;Length )\n                  return match[ i ];\n      }\n      return nullptr;\n   }\n\n   virtual PropertyInfo^ SelectProperty( BindingFlags bindingAttr, array&lt;PropertyInfo^&gt;^match, Type^ returnType, array&lt;Type^&gt;^indexes, array&lt;ParameterModifier&gt;^ modifiers ) override\n   {\n      if ( match == nullptr )\n            throw gcnew ArgumentNullException( &quot;match&quot; );\n\n      for ( int i = 0; i &lt; match-&gt;Length; i++ )\n      {\n         // Count the number of indexes that match.\n         int count = 0;\n         array&lt;ParameterInfo^&gt;^parameters = match[ i ]-&gt;GetIndexParameters();\n\n         // Go on to the next property if the number of indexes do not match.\n         if ( indexes-&gt;Length != parameters-&gt;Length )\n                  continue;\n\n         // Match each of the indexes that the user expects the property to have.\n         for ( int j = 0; j &lt; indexes-&gt;Length; j++ )\n            // Determine whether the types specified by the user can be converted to index type.\n            if ( CanConvertFrom( indexes[ j ], parameters[ j ]-&gt;ParameterType ) )\n                        count += 1;\n            else\n                        break;\n\n         // Determine whether the property has been found.\n         if ( count == indexes-&gt;Length )\n         {\n            // Determine whether the return type can be converted to the properties type.\n            if ( CanConvertFrom( returnType, match[ i ]-&gt;PropertyType ) )\n                  return match[ i ];\n            else\n                  continue;\n         }\n      }\n      return nullptr;\n   }\n\nprivate:\n\n   // Determines whether type1 can be converted to type2. Check only for primitive types.\n   bool CanConvertFrom( Type^ type1, Type^ type2 )\n   {\n      if ( type1-&gt;IsPrimitive &amp;&amp; type2-&gt;IsPrimitive )\n      {\n         TypeCode typeCode1 = Type::GetTypeCode( type1 );\n         TypeCode typeCode2 = Type::GetTypeCode( type2 );\n\n         // If both type1 and type2 have the same type, return true.\n         if ( typeCode1 == typeCode2 )\n                  return true;\n\n         // Possible conversions from Char follow.\n         if ( typeCode1 == TypeCode::Char )\n         {\n            switch ( typeCode2 )\n            {\n               case TypeCode::UInt16:\n                  return true;\n\n               case TypeCode::UInt32:\n                  return true;\n\n               case TypeCode::Int32:\n                  return true;\n\n               case TypeCode::UInt64:\n                  return true;\n\n               case TypeCode::Int64:\n                  return true;\n\n               case TypeCode::Single:\n                  return true;\n\n               case TypeCode::Double:\n                  return true;\n\n               default:\n                  return false;\n            }\n         }\n\n         // Possible conversions from Byte follow.\n         if ( typeCode1 == TypeCode::Byte )\n         {\n            switch ( typeCode2 )\n            {\n               case TypeCode::Char:\n                  return true;\n\n               case TypeCode::UInt16:\n                  return true;\n\n               case TypeCode::Int16:\n                  return true;\n\n               case TypeCode::UInt32:\n                  return true;\n\n               case TypeCode::Int32:\n                  return true;\n\n               case TypeCode::UInt64:\n                  return true;\n\n               case TypeCode::Int64:\n                  return true;\n\n               case TypeCode::Single:\n                  return true;\n\n               case TypeCode::Double:\n                  return true;\n\n               default:\n                  return false;\n            }\n         }\n\n         // Possible conversions from SByte follow.\n         if ( typeCode1 == TypeCode::SByte )\n         {\n            switch ( typeCode2 )\n            {\n               case TypeCode::Int16:\n                  return true;\n\n               case TypeCode::Int32:\n                  return true;\n\n               case TypeCode::Int64:\n                  return true;\n\n               case TypeCode::Single:\n                  return true;\n\n               case TypeCode::Double:\n                  return true;\n\n               default:\n                  return false;\n            }\n         }\n\n         // Possible conversions from UInt16 follow.\n         if ( typeCode1 == TypeCode::UInt16 )\n         {\n            switch ( typeCode2 )\n            {\n               case TypeCode::UInt32:\n                  return true;\n\n               case TypeCode::Int32:\n                  return true;\n\n               case TypeCode::UInt64:\n                  return true;\n\n               case TypeCode::Int64:\n                  return true;\n\n               case TypeCode::Single:\n                  return true;\n\n               case TypeCode::Double:\n                  return true;\n\n               default:\n                  return false;\n            }\n         }\n\n         // Possible conversions from Int16 follow.\n         if ( typeCode1 == TypeCode::Int16 )\n         {\n            switch ( typeCode2 )\n            {\n               case TypeCode::Int32:\n                  return true;\n\n               case TypeCode::Int64:\n                  return true;\n\n               case TypeCode::Single:\n                  return true;\n\n               case TypeCode::Double:\n                  return true;\n\n               default:\n                  return false;\n            }\n         }\n\n         // Possible conversions from UInt32 follow.\n         if ( typeCode1 == TypeCode::UInt32 )\n         {\n            switch ( typeCode2 )\n            {\n               case TypeCode::UInt64:\n                  return true;\n\n               case TypeCode::Int64:\n                  return true;\n\n               case TypeCode::Single:\n                  return true;\n\n               case TypeCode::Double:\n                  return true;\n\n               default:\n                  return false;\n            }\n         }\n\n         // Possible conversions from Int32 follow.\n         if ( typeCode1 == TypeCode::Int32 )\n         {\n            switch ( typeCode2 )\n            {\n               case TypeCode::Int64:\n                  return true;\n\n               case TypeCode::Single:\n                  return true;\n\n               case TypeCode::Double:\n                  return true;\n\n               default:\n                  return false;\n            }\n         }\n\n         // Possible conversions from UInt64 follow.\n         if ( typeCode1 == TypeCode::UInt64 )\n         {\n            switch ( typeCode2 )\n            {\n               case TypeCode::Single:\n                  return true;\n\n               case TypeCode::Double:\n                  return true;\n\n               default:\n                  return false;\n            }\n         }\n\n         // Possible conversions from Int64 follow.\n         if ( typeCode1 == TypeCode::Int64 )\n         {\n            switch ( typeCode2 )\n            {\n               case TypeCode::Single:\n                  return true;\n\n               case TypeCode::Double:\n                  return true;\n\n               default:\n                  return false;\n            }\n         }\n\n         // Possible conversions from Single follow.\n         if ( typeCode1 == TypeCode::Single )\n         {\n            switch ( typeCode2 )\n            {\n               case TypeCode::Double:\n                  return true;\n\n               default:\n                  return false;\n            }\n         }\n      }\n\n      return false;\n   }\n\n};\n\npublic ref class MyClass1\n{\npublic:\n   short myFieldB;\n   int myFieldA;\n   void MyMethod( long i, char k )\n   {\n      Console::WriteLine( &quot;<br>This is MyMethod(long i, char k)&quot; );\n   }\n\n   void MyMethod( long i, long j )\n   {\n      Console::WriteLine( &quot;<br>This is MyMethod(long i, long j)&quot; );\n   }\n};\n\nint main()\n{\n   // Get the type of MyClass1.\n   Type^ myType = MyClass1::typeid;\n\n   // Get the instance of MyClass1.\n   MyClass1^ myInstance = gcnew MyClass1;\n   Console::WriteLine( &quot;<br>Displaying the results of using the MyBinder binder.<br>&quot; );\n\n   // Get the method information for MyMethod.\n   array&lt;Type^&gt;^types = {short::typeid,short::typeid};\n   MethodInfo^ myMethod = myType-&gt;GetMethod( &quot;MyMethod&quot;, static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Instance), gcnew MyBinder, types, nullptr );\n   Console::WriteLine( myMethod );\n\n   // Invoke MyMethod.\n   array&lt;Object^&gt;^obj = {32,32};\n   myMethod-&gt;Invoke( myInstance, BindingFlags::InvokeMethod, gcnew MyBinder, obj, CultureInfo::CurrentCulture );\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Binder_1#1\">Imports System\nImports System.Reflection\nImports System.Globalization\nImports Microsoft.VisualBasic\n\nPublic Class MyBinder\n    Inherits Binder\n    Public Sub New()\n        MyBase.new()\n    End Sub &#39;New\n    Private Class BinderState\n        Public args() As Object\n    End Class &#39;BinderState\n\n    Public Overrides Function BindToField(ByVal bindingAttr As BindingFlags, ByVal match() As FieldInfo, ByVal value As Object, ByVal culture As CultureInfo) As FieldInfo\n        If match Is Nothing Then\n            Throw New ArgumentNullException(&quot;match&quot;)\n        End If\n        &#39; Get a field for which the value parameter can be converted to the specified field type.\n        Dim i As Integer\n        For i = 0 To match.Length - 1\n            If Not (ChangeType(value, match(i).FieldType, culture) Is Nothing) Then\n                Return match(i)\n            End If\n        Next i\n        Return Nothing\n    End Function &#39;BindToField\n\n    Public Overrides Function BindToMethod(ByVal bindingAttr As BindingFlags, ByVal match() As MethodBase, ByRef args() As Object, ByVal modifiers() As ParameterModifier, ByVal culture As CultureInfo, ByVal names() As String, ByRef state As Object) As MethodBase\n        &#39; Store the arguments to the method in a state object.\n        Dim myBinderState As New BinderState()\n        Dim arguments() As Object = New [Object](args.Length) {}\n        args.CopyTo(arguments, 0)\n        myBinderState.args = arguments\n        state = myBinderState\n\n        If match Is Nothing Then\n            Throw New ArgumentNullException()\n        End If\n        &#39; Find a method that has the same parameters as those of args.\n        Dim i As Integer\n        For i = 0 To match.Length - 1\n            &#39; Count the number of parameters that match.\n            Dim count As Integer = 0\n            Dim parameters As ParameterInfo() = match(i).GetParameters()\n            &#39; Go on to the next method if the number of parameters do not match.\n            If args.Length &lt;&gt; parameters.Length Then\n                GoTo ContinueFori\n            End If\n            &#39; Match each of the parameters that the user expects the method to have.\n            Dim j As Integer\n            For j = 0 To args.Length - 1\n                &#39; If names is not null, then reorder args.\n                If Not (names Is Nothing) Then\n                    If names.Length &lt;&gt; args.Length Then\n                        Throw New ArgumentException(&quot;names and args must have the same number of elements.&quot;)\n                    End If\n                    Dim k As Integer\n                    For k = 0 To names.Length - 1\n                        If String.Compare(parameters(j).Name, names(k).ToString()) = 0 Then\n                            args(j) = myBinderState.args(k)\n                        End If\n                    Next k\n                End If &#39; Determine whether the types specified by the user can be converted to parameter type.\n                If Not (ChangeType(args(j), parameters(j).ParameterType, culture) Is Nothing) Then\n                    count += 1\n                Else\n                    Exit For\n                End If\n            Next j\n            &#39; Determine whether the method has been found.\n            If count = args.Length Then\n                Return match(i)\n            End If\nContinueFori:\n        Next i\n        Return Nothing\n    End Function &#39;BindToMethod\n\n    Public Overrides Function ChangeType(ByVal value As Object, ByVal myChangeType As Type, ByVal culture As CultureInfo) As Object\n        &#39; Determine whether the value parameter can be converted to a value of type myType.\n        If CanConvertFrom(value.GetType(), myChangeType) Then\n            &#39; Return the converted object.\n            Return Convert.ChangeType(value, myChangeType)\n            &#39; Return null.\n        Else\n            Return Nothing\n        End If\n    End Function &#39;ChangeType\n\n    Public Overrides Sub ReorderArgumentArray(ByRef args() As Object, ByVal state As Object)\n        &#39;Redimension the array to hold the state values.\n        ReDim args(CType(state, BinderState).args.Length)\n        &#39; Return the args that had been reordered by BindToMethod.\n        CType(state, BinderState).args.CopyTo(args, 0)\n    End Sub &#39;ReorderArgumentArray\n\n    Public Overrides Function SelectMethod(ByVal bindingAttr As BindingFlags, ByVal match() As MethodBase, ByVal types() As Type, ByVal modifiers() As ParameterModifier) As MethodBase\n        If match Is Nothing Then\n            Throw New ArgumentNullException(&quot;match&quot;)\n        End If\n        Dim i As Integer\n        For i = 0 To match.Length - 1\n            &#39; Count the number of parameters that match.\n            Dim count As Integer = 0\n            Dim parameters As ParameterInfo() = match(i).GetParameters()\n            &#39; Go on to the next method if the number of parameters do not match.\n            If types.Length &lt;&gt; parameters.Length Then\n                GoTo ContinueFori\n            End If\n            &#39; Match each of the parameters that the user expects the method to have.\n            Dim j As Integer\n            For j = 0 To types.Length - 1\n                &#39; Determine whether the types specified by the user can be converted to parameter type.\n                If CanConvertFrom(types(j), parameters(j).ParameterType) Then\n                    count += 1\n                Else\n                    Exit For\n                End If\n            Next j &#39; Determine whether the method has been found.\n            If count = types.Length Then\n                Return match(i)\n            End If\nContinueFori:\n        Next i\n        Return Nothing\n    End Function &#39;SelectMethod\n    Public Overrides Function SelectProperty(ByVal bindingAttr As BindingFlags, ByVal match() As PropertyInfo, ByVal returnType As Type, ByVal indexes() As Type, ByVal modifiers() As ParameterModifier) As PropertyInfo\n        If match Is Nothing Then\n            Throw New ArgumentNullException(&quot;match&quot;)\n        End If\n        Dim i As Integer\n        For i = 0 To match.Length - 1\n            &#39; Count the number of indexes that match.\n            Dim count As Integer = 0\n            Dim parameters As ParameterInfo() = match(i).GetIndexParameters()\n\n            &#39; Go on to the next property if the number of indexes do not match.\n            If indexes.Length &lt;&gt; parameters.Length Then\n                GoTo ContinueFori\n            End If\n            &#39; Match each of the indexes that the user expects the property to have.\n            Dim j As Integer\n            For j = 0 To indexes.Length - 1\n                &#39; Determine whether the types specified by the user can be converted to index type.\n                If CanConvertFrom(indexes(j), parameters(j).ParameterType) Then\n                    count += 1\n                Else\n                    Exit For\n                End If\n            Next j &#39; Determine whether the property has been found.\n            If count = indexes.Length Then\n                &#39; Determine whether the return type can be converted to the properties type.\n                If CanConvertFrom(returnType, match(i).PropertyType) Then\n                    Return match(i)\n                Else\n                    GoTo ContinueFori\n                End If\n            End If\nContinueFori:\n        Next i\n        Return Nothing\n    End Function &#39;SelectProperty\n\n    &#39; Determine whether type1 can be converted to type2. Check only for primitive types.\n    Private Function CanConvertFrom(ByVal type1 As Type, ByVal type2 As Type) As Boolean\n        If type1.IsPrimitive And type2.IsPrimitive Then\n            Dim typeCode1 As TypeCode = Type.GetTypeCode(type1)\n            Dim typeCode2 As TypeCode = Type.GetTypeCode(type2)\n            &#39; If both type1 and type2 have same type, return true.\n            If typeCode1 = typeCode2 Then\n                Return True\n            End If &#39; Possible conversions from Char follow.\n            If typeCode1 = TypeCode.Char Then\n                Select Case typeCode2\n                    Case TypeCode.UInt16\n                        Return True\n                    Case TypeCode.UInt32\n                        Return True\n                    Case TypeCode.Int32\n                        Return True\n                    Case TypeCode.UInt64\n                        Return True\n                    Case TypeCode.Int64\n                        Return True\n                    Case TypeCode.Single\n                        Return True\n                    Case TypeCode.Double\n                        Return True\n                    Case Else\n                        Return False\n                End Select\n            End If &#39; Possible conversions from Byte follow.\n            If typeCode1 = TypeCode.Byte Then\n                Select Case typeCode2\n                    Case TypeCode.Char\n                        Return True\n                    Case TypeCode.UInt16\n                        Return True\n                    Case TypeCode.Int16\n                        Return True\n                    Case TypeCode.UInt32\n                        Return True\n                    Case TypeCode.Int32\n                        Return True\n                    Case TypeCode.UInt64\n                        Return True\n                    Case TypeCode.Int64\n                        Return True\n                    Case TypeCode.Single\n                        Return True\n                    Case TypeCode.Double\n                        Return True\n                    Case Else\n                        Return False\n                End Select\n            End If &#39; Possible conversions from SByte follow.\n            If typeCode1 = TypeCode.SByte Then\n                Select Case typeCode2\n                    Case TypeCode.Int16\n                        Return True\n                    Case TypeCode.Int32\n                        Return True\n                    Case TypeCode.Int64\n                        Return True\n                    Case TypeCode.Single\n                        Return True\n                    Case TypeCode.Double\n                        Return True\n                    Case Else\n                        Return False\n                End Select\n            End If &#39; Possible conversions from UInt16 follow.\n            If typeCode1 = TypeCode.UInt16 Then\n                Select Case typeCode2\n                    Case TypeCode.UInt32\n                        Return True\n                    Case TypeCode.Int32\n                        Return True\n                    Case TypeCode.UInt64\n                        Return True\n                    Case TypeCode.Int64\n                        Return True\n                    Case TypeCode.Single\n                        Return True\n                    Case TypeCode.Double\n                        Return True\n                    Case Else\n                        Return False\n                End Select\n            End If &#39; Possible conversions from Int16 follow.\n            If typeCode1 = TypeCode.Int16 Then\n                Select Case typeCode2\n                    Case TypeCode.Int32\n                        Return True\n                    Case TypeCode.Int64\n                        Return True\n                    Case TypeCode.Single\n                        Return True\n                    Case TypeCode.Double\n                        Return True\n                    Case Else\n                        Return False\n                End Select\n            End If &#39; Possible conversions from UInt32 follow.\n            If typeCode1 = TypeCode.UInt32 Then\n                Select Case typeCode2\n                    Case TypeCode.UInt64\n                        Return True\n                    Case TypeCode.Int64\n                        Return True\n                    Case TypeCode.Single\n                        Return True\n                    Case TypeCode.Double\n                        Return True\n                    Case Else\n                        Return False\n                End Select\n            End If &#39; Possible conversions from Int32 follow.\n            If typeCode1 = TypeCode.Int32 Then\n                Select Case typeCode2\n                    Case TypeCode.Int64\n                        Return True\n                    Case TypeCode.Single\n                        Return True\n                    Case TypeCode.Double\n                        Return True\n                    Case Else\n                        Return False\n                End Select\n            End If &#39; Possible conversions from UInt64 follow.\n            If typeCode1 = TypeCode.UInt64 Then\n                Select Case typeCode2\n                    Case TypeCode.Single\n                        Return True\n                    Case TypeCode.Double\n                        Return True\n                    Case Else\n                        Return False\n                End Select\n            End If &#39; Possible conversions from Int64 follow.\n            If typeCode1 = TypeCode.Int64 Then\n                Select Case typeCode2\n                    Case TypeCode.Single\n                        Return True\n                    Case TypeCode.Double\n                        Return True\n                    Case Else\n                        Return False\n                End Select\n            End If &#39; Possible conversions from Single follow.\n            If typeCode1 = TypeCode.Single Then\n                Select Case typeCode2\n                    Case TypeCode.Double\n                        Return True\n                    Case Else\n                        Return False\n                End Select\n            End If\n        End If\n        Return False\n    End Function &#39;CanConvertFrom\nEnd Class &#39;MyBinder\n\n\nPublic Class MyClass1\n    Public myFieldB As Short\n    Public myFieldA As Integer\n\n    Public Overloads Sub MyMethod(ByVal i As Long, ByVal k As Char)\n        Console.WriteLine(ControlChars.NewLine &amp; &quot;This is MyMethod(long i, char k).&quot;)\n    End Sub &#39;MyMethod\n\n    Public Overloads Sub MyMethod(ByVal i As Long, ByVal j As Long)\n        Console.WriteLine(ControlChars.NewLine &amp; &quot;This is MyMethod(long i, long j).&quot;)\n    End Sub &#39;MyMethod\nEnd Class &#39;MyClass1\n\n\nPublic Class Binder_Example\n    Public Shared Sub Main()\n        &#39; Get the type of MyClass1.\n        Dim myType As Type = GetType(MyClass1)\n        &#39; Get the instance of MyClass1.\n        Dim myInstance As New MyClass1()\n        Console.WriteLine(ControlChars.Cr &amp; &quot;Displaying the results of using the MyBinder binder.&quot;)\n        Console.WriteLine()\n        &#39; Get the method information for MyMethod.\n        Dim myMethod As MethodInfo = myType.GetMethod(&quot;MyMethod&quot;, BindingFlags.Public Or BindingFlags.Instance, New MyBinder(), New Type() {GetType(Short), GetType(Short)}, Nothing)\n        Console.WriteLine(MyMethod)\n        &#39; Invoke MyMethod.\n        myMethod.Invoke(myInstance, BindingFlags.InvokeMethod, New MyBinder(), New [Object]() {CInt(32), CInt(32)}, CultureInfo.CurrentCulture)\n    End Sub &#39;Main\nEnd Class &#39;Binder_Example\n</code></pre><pre><code class=\"lang-cs\" name=\"Binder_1#1\">using System;\nusing System.Reflection;\nusing System.Globalization;\n\npublic class MyBinder : Binder \n{\n    public MyBinder() : base()\n    {\n    }\n    private class BinderState\n    {\n        public object[] args;\n    }\n    public override FieldInfo BindToField(\n        BindingFlags bindingAttr,\n        FieldInfo[] match,\n        object value,\n        CultureInfo culture\n        )\n    {\n        if(match == null)\n            throw new ArgumentNullException(&quot;match&quot;);\n        // Get a field for which the value parameter can be converted to the specified field type.\n        for(int i = 0; i &lt; match.Length; i++)\n            if(ChangeType(value, match[i].FieldType, culture) != null)\n                return match[i];\n        return null;\n    }\n    public override MethodBase BindToMethod(\n        BindingFlags bindingAttr,\n        MethodBase[] match,\n        ref object[] args,\n        ParameterModifier[] modifiers,\n        CultureInfo culture,\n        string[] names,\n        out object state\n        )\n    {\n        // Store the arguments to the method in a state object.\n        BinderState myBinderState = new BinderState();\n        object[] arguments = new Object[args.Length];\n        args.CopyTo(arguments, 0);\n        myBinderState.args = arguments;\n        state = myBinderState;\n        if(match == null)\n            throw new ArgumentNullException();\n        // Find a method that has the same parameters as those of the args parameter.\n        for(int i = 0; i &lt; match.Length; i++)\n        {\n            // Count the number of parameters that match.\n            int count = 0;\n            ParameterInfo[] parameters = match[i].GetParameters();\n            // Go on to the next method if the number of parameters do not match.\n            if(args.Length != parameters.Length)\n                continue;\n            // Match each of the parameters that the user expects the method to have.\n            for(int j = 0; j &lt; args.Length; j++)\n            {\n                // If the names parameter is not null, then reorder args.\n                if(names != null)\n                {\n                    if(names.Length != args.Length)\n                        throw new ArgumentException(&quot;names and args must have the same number of elements.&quot;);\n                    for(int k = 0; k &lt; names.Length; k++)\n                        if(String.Compare(parameters[j].Name, names[k].ToString()) == 0)\n                            args[j] = myBinderState.args[k];\n                }\n                // Determine whether the types specified by the user can be converted to the parameter type.\n                if(ChangeType(args[j], parameters[j].ParameterType, culture) != null)\n                    count += 1;\n                else\n                    break;\n            }\n            // Determine whether the method has been found.\n            if(count == args.Length)\n                return match[i];\n        }\n        return null;\n    }\n    public override object ChangeType(\n        object value,\n        Type myChangeType,\n        CultureInfo culture\n        )\n    {\n        // Determine whether the value parameter can be converted to a value of type myType.\n        if(CanConvertFrom(value.GetType(), myChangeType))\n            // Return the converted object.\n            return Convert.ChangeType(value, myChangeType);\n        else\n            // Return null.\n            return null;\n    }\n    public override void ReorderArgumentArray(\n        ref object[] args,\n        object state\n        )\n    {\n        // Return the args that had been reordered by BindToMethod.\n        ((BinderState)state).args.CopyTo(args, 0);\n    }\n    public override MethodBase SelectMethod(\n        BindingFlags bindingAttr,\n        MethodBase[] match,\n        Type[] types,\n        ParameterModifier[] modifiers\n        )\n    {\n        if(match == null)\n            throw new ArgumentNullException(&quot;match&quot;);\n        for(int i = 0; i &lt; match.Length; i++)\n        {\n            // Count the number of parameters that match.\n            int count = 0; \n            ParameterInfo[] parameters = match[i].GetParameters();\n            // Go on to the next method if the number of parameters do not match.\n            if(types.Length != parameters.Length)\n                continue;\n            // Match each of the parameters that the user expects the method to have.\n            for(int j = 0; j &lt; types.Length; j++)\n                // Determine whether the types specified by the user can be converted to parameter type.\n                if(CanConvertFrom(types[j], parameters[j].ParameterType))\n                    count += 1;\n                else\n                    break;\n            // Determine whether the method has been found.\n            if(count == types.Length)\n                return match[i];\n        }\n        return null;\n    }\n    public override PropertyInfo SelectProperty(\n        BindingFlags bindingAttr,\n        PropertyInfo[] match,\n        Type returnType,\n        Type[] indexes,\n        ParameterModifier[] modifiers\n        )\n    {\n        if(match == null)\n            throw new ArgumentNullException(&quot;match&quot;);\n        for(int i = 0; i &lt; match.Length; i++)\n        {\n            // Count the number of indexes that match.\n            int count = 0;\n            ParameterInfo[] parameters = match[i].GetIndexParameters();\n            // Go on to the next property if the number of indexes do not match.\n            if(indexes.Length != parameters.Length)\n                continue;\n            // Match each of the indexes that the user expects the property to have.\n            for(int j = 0; j &lt; indexes.Length; j++)\n                // Determine whether the types specified by the user can be converted to index type.\n                if(CanConvertFrom(indexes[j], parameters[j].ParameterType))\n                    count += 1;\n                else\n                    break;\n            // Determine whether the property has been found.\n            if(count == indexes.Length)\n                // Determine whether the return type can be converted to the properties type.\n                if(CanConvertFrom(returnType, match[i].PropertyType))\n                    return match[i];\n                else\n                    continue;\n        }\n        return null;\n    }\n    // Determines whether type1 can be converted to type2. Check only for primitive types.\n    private bool CanConvertFrom(Type type1, Type type2)\n    {\n        if(type1.IsPrimitive &amp;&amp; type2.IsPrimitive)\n        {\n            TypeCode typeCode1 = Type.GetTypeCode(type1);\n            TypeCode typeCode2 = Type.GetTypeCode(type2);\n            // If both type1 and type2 have the same type, return true.\n            if(typeCode1 == typeCode2)\n                return true;\n            // Possible conversions from Char follow.\n            if(typeCode1 == TypeCode.Char)\n                switch(typeCode2)\n                {\n                    case TypeCode.UInt16 : return true;\n                    case TypeCode.UInt32 : return true;\n                    case TypeCode.Int32  : return true;\n                    case TypeCode.UInt64 : return true;\n                    case TypeCode.Int64  : return true;\n                    case TypeCode.Single : return true;\n                    case TypeCode.Double : return true;\n                    default              : return false;\n                }\n            // Possible conversions from Byte follow.\n            if(typeCode1 == TypeCode.Byte)\n                switch(typeCode2)\n                {\n                    case TypeCode.Char   : return true;\n                    case TypeCode.UInt16 : return true;\n                    case TypeCode.Int16  : return true;\n                    case TypeCode.UInt32 : return true;\n                    case TypeCode.Int32  : return true;\n                    case TypeCode.UInt64 : return true;\n                    case TypeCode.Int64  : return true;\n                    case TypeCode.Single : return true;\n                    case TypeCode.Double : return true;\n                    default              : return false;\n                }\n            // Possible conversions from SByte follow.\n            if(typeCode1 == TypeCode.SByte)\n                switch(typeCode2)\n                {\n                    case TypeCode.Int16  : return true;\n                    case TypeCode.Int32  : return true;\n                    case TypeCode.Int64  : return true;\n                    case TypeCode.Single : return true;\n                    case TypeCode.Double : return true;\n                    default              : return false;\n                }\n            // Possible conversions from UInt16 follow.\n            if(typeCode1 == TypeCode.UInt16)\n                switch(typeCode2)\n                {\n                    case TypeCode.UInt32 : return true;\n                    case TypeCode.Int32  : return true;\n                    case TypeCode.UInt64 : return true;\n                    case TypeCode.Int64  : return true;\n                    case TypeCode.Single : return true;\n                    case TypeCode.Double : return true;\n                    default              : return false;\n                }\n            // Possible conversions from Int16 follow.\n            if(typeCode1 == TypeCode.Int16)\n                switch(typeCode2)\n                {\n                    case TypeCode.Int32  : return true;\n                    case TypeCode.Int64  : return true;\n                    case TypeCode.Single : return true;\n                    case TypeCode.Double : return true;\n                    default              : return false;\n                }\n            // Possible conversions from UInt32 follow.\n            if(typeCode1 == TypeCode.UInt32)\n                switch(typeCode2)\n                {\n                    case TypeCode.UInt64 : return true;\n                    case TypeCode.Int64  : return true;\n                    case TypeCode.Single : return true;\n                    case TypeCode.Double : return true;\n                    default              : return false;\n                }\n            // Possible conversions from Int32 follow.\n            if(typeCode1 == TypeCode.Int32)\n                switch(typeCode2)\n                {\n                    case TypeCode.Int64  : return true;\n                    case TypeCode.Single : return true;\n                    case TypeCode.Double : return true;\n                    default              : return false;\n                }\n            // Possible conversions from UInt64 follow.\n            if(typeCode1 == TypeCode.UInt64)\n                switch(typeCode2)\n                {\n                    case TypeCode.Single : return true;\n                    case TypeCode.Double : return true;\n                    default              : return false;\n                }\n            // Possible conversions from Int64 follow.\n            if(typeCode1 == TypeCode.Int64)\n                switch(typeCode2)\n                {\n                    case TypeCode.Single : return true;\n                    case TypeCode.Double : return true;\n                    default              : return false;\n                }\n            // Possible conversions from Single follow.\n            if(typeCode1 == TypeCode.Single)\n                switch(typeCode2)\n                {\n                    case TypeCode.Double : return true;\n                    default              : return false;\n                }\n        }\n        return false;\n    }\n}\npublic class MyClass1\n{\n    public short myFieldB;\n    public int myFieldA; \n    public void MyMethod(long i, char k)\n    {\n        Console.WriteLine(&quot;<br>This is MyMethod(long i, char k)&quot;);\n    }\n    public void MyMethod(long i, long j)\n    {\n        Console.WriteLine(&quot;<br>This is MyMethod(long i, long j)&quot;);\n    }\n}\npublic class Binder_Example\n{\n    public static void Main()\n    {\n        // Get the type of MyClass1.\n        Type myType = typeof(MyClass1);\n        // Get the instance of MyClass1.\n        MyClass1 myInstance = new MyClass1();\n        Console.WriteLine(&quot;<br>Displaying the results of using the MyBinder binder.<br>&quot;);\n        // Get the method information for MyMethod.\n        MethodInfo myMethod = myType.GetMethod(&quot;MyMethod&quot;, BindingFlags.Public | BindingFlags.Instance,\n            new MyBinder(), new Type[] {typeof(short), typeof(short)}, null);\n        Console.WriteLine(myMethod);\n        // Invoke MyMethod.\n        myMethod.Invoke(myInstance, BindingFlags.InvokeMethod, new MyBinder(), new Object[] {(int)32, (int)32}, CultureInfo.CurrentCulture);\n    }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"operators\">\r\n        <h2>Operators\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_op_Equality_System_Reflection_MethodBase_System_Reflection_MethodBase_\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_op_Equality_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">op_Equality(MethodBase,MethodBase)</div>        \r\n          </div>\r\n    \r\n            <p>Indicates whether two <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> objects are equal.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool op_Equality (System.Reflection.MethodBase left, System.Reflection.MethodBase right);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>left</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The first object to compare.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>right</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The second object to compare.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if <code>left</code> is equal to <code>right</code>; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_op_Inequality_System_Reflection_MethodBase_System_Reflection_MethodBase_\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_op_Inequality_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">op_Inequality(MethodBase,MethodBase)</div>        \r\n          </div>\r\n    \r\n            <p>Indicates whether two <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> objects are not equal.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool op_Inequality (System.Reflection.MethodBase left, System.Reflection.MethodBase right);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>left</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The first object to compare.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>right</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The second object to compare.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if <code>left</code> is not equal to <code>right</code>; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"eii\">\r\n        <h2>Explicit Interface Implementations\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_GetIDsOfNames_System_Guid__System_IntPtr_System_UInt32_System_UInt32_System_IntPtr_\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_GetIDsOfNames_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_MethodBase.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)</div>        \r\n          </div>\r\n    \r\n            <p>Maps a set of names to a corresponding set of dispatch identifiers.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">void _MethodBase.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>riid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.guid\" data-linktype=\"relative-path\">Guid</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Reserved for future use. Must be IID_NULL.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>rgszNames</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Passed-in array of names to be mapped.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>cNames</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Count of the names to be mapped.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>lcid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The locale context in which to interpret the names.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>rgDispId</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Caller-allocated array which receives the IDs corresponding to the names.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notimplementedexception\" data-linktype=\"relative-path\">NotImplementedException</a></div>\r\n                  </div>\r\n                  <p>Late-bound access using the COM <code>IDispatch</code> interface is not supported.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <code>IDispatch::GetIDsOfNames</code>, see the MSDN Library.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_GetType\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_GetType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_MethodBase.GetType()</div>        \r\n          </div>\r\n    \r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.GetType*</span>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">Type _MethodBase.GetType ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.GetType*</span>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This member is an explicit interface member implementation. It can be used only when the <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> instance is cast to an <a class=\"xref\" href=\"system.runtime.interopservices._methodbase\" data-linktype=\"relative-path\">_MethodBase</a> interface.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_GetTypeInfo_System_UInt32_System_UInt32_System_IntPtr_\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_GetTypeInfo_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_MethodBase.GetTypeInfo(UInt32,UInt32,IntPtr)</div>        \r\n          </div>\r\n    \r\n            <p>Retrieves the type information for an object, which can then be used to get the type information for an interface.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">void _MethodBase.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>iTInfo</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The type information to return.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>lcid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The locale identifier for the type information.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>ppTInfo</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Receives a pointer to the requested type information object.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notimplementedexception\" data-linktype=\"relative-path\">NotImplementedException</a></div>\r\n                  </div>\r\n                  <p>Late-bound access using the COM <code>IDispatch</code> interface is not supported.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <code>IDispatch::GetTypeInfo</code>, see the MSDN Library.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_GetTypeInfoCount_System_UInt32__\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_GetTypeInfoCount_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_MethodBase.GetTypeInfoCount(UInt32)</div>        \r\n          </div>\r\n    \r\n            <p>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">void _MethodBase.GetTypeInfoCount (out uint pcTInfo);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>pcTInfo</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Points to a location that receives the number of type information interfaces provided by the object.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notimplementedexception\" data-linktype=\"relative-path\">NotImplementedException</a></div>\r\n                  </div>\r\n                  <p>Late-bound access using the COM <code>IDispatch</code> interface is not supported.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <code>IDispatch::GetTypeInfoCount</code>, see the MSDN Library.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_Invoke_System_UInt32_System_Guid__System_UInt32_System_Int16_System_IntPtr_System_IntPtr_System_IntPtr_System_IntPtr_\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_Invoke_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_MethodBase.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)</div>        \r\n          </div>\r\n    \r\n            <p>Provides access to properties and methods exposed by an object.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">void _MethodBase.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>dispIdMember</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Identifies the member.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>riid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.guid\" data-linktype=\"relative-path\">Guid</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Reserved for future use. Must be IID_NULL.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>lcid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The locale context in which to interpret arguments.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>wFlags</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int16\" data-linktype=\"relative-path\">Int16</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Flags describing the context of the call.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>pDispParams</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>pVarResult</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Pointer to the location where the result is to be stored.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>pExcepInfo</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Pointer to a structure that contains exception information.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>puArgErr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The index of the first argument that has an error.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notimplementedexception\" data-linktype=\"relative-path\">NotImplementedException</a></div>\r\n                  </div>\r\n                  <p>Late-bound access using the COM <code>IDispatch</code> interface is not supported.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <code>IDispatch::Invoke</code>, see the MSDN Library.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsAbstract\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsAbstract_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_MethodBase.IsAbstract</div>        \r\n          </div>\r\n    \r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsAbstract*</span>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">bool System.Runtime.InteropServices._MethodBase.IsAbstract { get; }</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsAbstract*</span>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This member is an explicit interface member implementation. It can be used only when the <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> instance is cast to an <a class=\"xref\" href=\"system.runtime.interopservices._methodbase\" data-linktype=\"relative-path\">_MethodBase</a> interface.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsAssembly\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsAssembly_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_MethodBase.IsAssembly</div>        \r\n          </div>\r\n    \r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsAssembly*</span>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">bool System.Runtime.InteropServices._MethodBase.IsAssembly { get; }</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsAssembly*</span>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This member is an explicit interface member implementation. It can be used only when the <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> instance is cast to an <a class=\"xref\" href=\"system.runtime.interopservices._methodbase\" data-linktype=\"relative-path\">_MethodBase</a> interface.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsConstructor\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsConstructor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_MethodBase.IsConstructor</div>        \r\n          </div>\r\n    \r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsConstructor*</span>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">bool System.Runtime.InteropServices._MethodBase.IsConstructor { get; }</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsConstructor*</span>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This member is an explicit interface member implementation. It can be used only when the <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> instance is cast to an <a class=\"xref\" href=\"system.runtime.interopservices._methodbase\" data-linktype=\"relative-path\">_MethodBase</a> interface.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsFamily\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsFamily_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_MethodBase.IsFamily</div>        \r\n          </div>\r\n    \r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsFamily*</span>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">bool System.Runtime.InteropServices._MethodBase.IsFamily { get; }</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsFamily*</span>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This member is an explicit interface member implementation. It can be used only when the <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> instance is cast to an <a class=\"xref\" href=\"system.runtime.interopservices._methodbase\" data-linktype=\"relative-path\">_MethodBase</a> interface.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsFamilyAndAssembly\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsFamilyAndAssembly_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_MethodBase.IsFamilyAndAssembly</div>        \r\n          </div>\r\n    \r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly*</span>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">bool System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly { get; }</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly*</span>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This member is an explicit interface member implementation. It can be used only when the <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> instance is cast to an <a class=\"xref\" href=\"system.runtime.interopservices._methodbase\" data-linktype=\"relative-path\">_MethodBase</a> interface.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsFamilyOrAssembly\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsFamilyOrAssembly_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_MethodBase.IsFamilyOrAssembly</div>        \r\n          </div>\r\n    \r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly*</span>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">bool System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly { get; }</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly*</span>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This member is an explicit interface member implementation. It can be used only when the <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> instance is cast to an <a class=\"xref\" href=\"system.runtime.interopservices._methodbase\" data-linktype=\"relative-path\">_MethodBase</a> interface.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsFinal\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsFinal_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_MethodBase.IsFinal</div>        \r\n          </div>\r\n    \r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsFinal*</span>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">bool System.Runtime.InteropServices._MethodBase.IsFinal { get; }</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsFinal*</span>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This member is an explicit interface member implementation. It can be used only when the <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> instance is cast to an <a class=\"xref\" href=\"system.runtime.interopservices._methodbase\" data-linktype=\"relative-path\">_MethodBase</a> interface.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsHideBySig\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsHideBySig_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_MethodBase.IsHideBySig</div>        \r\n          </div>\r\n    \r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsHideBySig*</span>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">bool System.Runtime.InteropServices._MethodBase.IsHideBySig { get; }</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsHideBySig*</span>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This member is an explicit interface member implementation. It can be used only when the <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> instance is cast to an <a class=\"xref\" href=\"system.runtime.interopservices._methodbase\" data-linktype=\"relative-path\">_MethodBase</a> interface.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsPrivate\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsPrivate_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_MethodBase.IsPrivate</div>        \r\n          </div>\r\n    \r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsPrivate*</span>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">bool System.Runtime.InteropServices._MethodBase.IsPrivate { get; }</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsPrivate*</span>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This member is an explicit interface member implementation. It can be used only when the <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> instance is cast to an <a class=\"xref\" href=\"system.runtime.interopservices._methodbase\" data-linktype=\"relative-path\">_MethodBase</a> interface.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsPublic\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsPublic_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_MethodBase.IsPublic</div>        \r\n          </div>\r\n    \r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsPublic*</span>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">bool System.Runtime.InteropServices._MethodBase.IsPublic { get; }</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsPublic*</span>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This member is an explicit interface member implementation. It can be used only when the <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> instance is cast to an <a class=\"xref\" href=\"system.runtime.interopservices._methodbase\" data-linktype=\"relative-path\">_MethodBase</a> interface.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsSpecialName\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsSpecialName_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_MethodBase.IsSpecialName</div>        \r\n          </div>\r\n    \r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsSpecialName*</span>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">bool System.Runtime.InteropServices._MethodBase.IsSpecialName { get; }</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsSpecialName*</span>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This member is an explicit interface member implementation. It can be used only when the <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> instance is cast to an <a class=\"xref\" href=\"system.runtime.interopservices._methodbase\" data-linktype=\"relative-path\">_MethodBase</a> interface.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsStatic\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsStatic_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_MethodBase.IsStatic</div>        \r\n          </div>\r\n    \r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsStatic*</span>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">bool System.Runtime.InteropServices._MethodBase.IsStatic { get; }</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsStatic*</span>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This member is an explicit interface member implementation. It can be used only when the <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> instance is cast to an <a class=\"xref\" href=\"system.runtime.interopservices._methodbase\" data-linktype=\"relative-path\">_MethodBase</a> interface.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsVirtual\">\r\n    \r\n            <a id=\"System_Reflection_MethodBase_System_Runtime_InteropServices__MethodBase_IsVirtual_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_MethodBase.IsVirtual</div>        \r\n          </div>\r\n    \r\n            <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsVirtual*</span>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">bool System.Runtime.InteropServices._MethodBase.IsVirtual { get; }</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p>For a description of this member, see <span class=\"xref\">stem.Runtime.InteropServices._MethodBase.IsVirtual*</span>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This member is an explicit interface member implementation. It can be used only when the <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> instance is cast to an <a class=\"xref\" href=\"system.runtime.interopservices._methodbase\" data-linktype=\"relative-path\">_MethodBase</a> interface.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n","outputRootRelativePath":"./","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"breadcrumb_path\" content=\"breadcrumb/toc.json\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"fulldocset\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.fulldocset\">\r\n<meta name=\"ref_skeleton_gitcommit\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Reflection.MethodBase.yml\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Reflection.MethodBase.yml\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase..ctor\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.Attributes\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.CallingConvention\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.ContainsGenericParameters\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.Equals\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.GetCurrentMethod\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.GetGenericArguments\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.GetHashCode\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.GetMethodBody\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.GetMethodFromHandle\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.GetMethodImplementationFlags\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.GetParameters\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.Invoke\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.IsAbstract\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.IsAssembly\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.IsConstructor\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.IsFamily\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.IsFamilyAndAssembly\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.IsFamilyOrAssembly\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.IsFinal\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.IsGenericMethod\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.IsGenericMethodDefinition\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.IsHideBySig\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.IsPrivate\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.IsPublic\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.IsSecurityCritical\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.IsSecuritySafeCritical\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.IsSecurityTransparent\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.IsSpecialName\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.IsStatic\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.IsVirtual\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.MethodHandle\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.MethodImplementationFlags\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.op_Equality\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.op_op_Equality\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.op_Inequality\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase.op_op_Inequality\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase._MethodBase.GetIDsOfNames\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase._MethodBase.GetType\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase._MethodBase.GetTypeInfo\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase._MethodBase.GetTypeInfoCount\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase._MethodBase.Invoke\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase._MethodBase.IsAbstract\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase._MethodBase.IsAssembly\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase._MethodBase.IsConstructor\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase._MethodBase.IsFamily\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase._MethodBase.IsFamilyAndAssembly\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase._MethodBase.IsFamilyOrAssembly\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase._MethodBase.IsFinal\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase._MethodBase.IsHideBySig\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase._MethodBase.IsPrivate\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase._MethodBase.IsPublic\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase._MethodBase.IsSpecialName\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase._MethodBase.IsStatic\">\r\n<meta name=\"APIName\" content=\"System.Reflection.MethodBase._MethodBase.IsVirtual\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-01 01:37 AM\">\r\n<meta name=\"document_id\" content=\"b9cf52d1-efcf-8122-708e-849cfa69a550\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Provides information about methods and constructors.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/System.Reflection/toc.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Reflection.MethodBase\">\r\n","rawMetadata":{"author":"dotnet-bot","breadcrumb_path":"breadcrumb/toc.json","search.ms_sitename":"Docs","search.ms_docsetname":"fulldocset","version":null,"_op_canonicalUrlPrefix":"https://ppe.docs.microsoft.com/en-us/fulldotnet/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":true,"depot_name":"MSDN.fulldocset","_op_gitRefSkeletonCommitHistory":[{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"use plugin in master","commit_sha":"501959ac03e19ac52a27aa4c6bbeb980f8b11c8c","commit_date":"2017-03-01 09:31:20 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"fix pointer ref","commit_sha":"76befb0e7f7b41839ec719047e5b39a5981298f3","commit_date":"2017-02-28 15:47:23 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"switch from platform to version","commit_sha":"78cdacb5ca782478af490a6b30c3a2cb2b6b873e","commit_date":"2017-02-28 15:09:51 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"update platforms","commit_sha":"39ad5a8919a59afc93a79ac4bd8e07c3b471b37a","commit_date":"2017-02-28 10:38:59 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"checkin yml","commit_sha":"da161b792852497df7140d7768cee2eccd9cb43f","commit_date":"2017-02-28 09:36:15 +0800"}],"ref_skeleton_gitcommit":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Reflection.MethodBase.yml","original_ref_skeleton_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Reflection.MethodBase.yml","open_to_public_contributors":true,"api_name":["System.Reflection.MethodBase","System.Reflection.MethodBase..ctor","System.Reflection.MethodBase.Attributes","System.Reflection.MethodBase.CallingConvention","System.Reflection.MethodBase.ContainsGenericParameters","System.Reflection.MethodBase.Equals","System.Reflection.MethodBase.GetCurrentMethod","System.Reflection.MethodBase.GetGenericArguments","System.Reflection.MethodBase.GetHashCode","System.Reflection.MethodBase.GetMethodBody","System.Reflection.MethodBase.GetMethodFromHandle","System.Reflection.MethodBase.GetMethodImplementationFlags","System.Reflection.MethodBase.GetParameters","System.Reflection.MethodBase.Invoke","System.Reflection.MethodBase.IsAbstract","System.Reflection.MethodBase.IsAssembly","System.Reflection.MethodBase.IsConstructor","System.Reflection.MethodBase.IsFamily","System.Reflection.MethodBase.IsFamilyAndAssembly","System.Reflection.MethodBase.IsFamilyOrAssembly","System.Reflection.MethodBase.IsFinal","System.Reflection.MethodBase.IsGenericMethod","System.Reflection.MethodBase.IsGenericMethodDefinition","System.Reflection.MethodBase.IsHideBySig","System.Reflection.MethodBase.IsPrivate","System.Reflection.MethodBase.IsPublic","System.Reflection.MethodBase.IsSecurityCritical","System.Reflection.MethodBase.IsSecuritySafeCritical","System.Reflection.MethodBase.IsSecurityTransparent","System.Reflection.MethodBase.IsSpecialName","System.Reflection.MethodBase.IsStatic","System.Reflection.MethodBase.IsVirtual","System.Reflection.MethodBase.MethodHandle","System.Reflection.MethodBase.MethodImplementationFlags","System.Reflection.MethodBase.op_Equality","System.Reflection.MethodBase.op_op_Equality","System.Reflection.MethodBase.op_Inequality","System.Reflection.MethodBase.op_op_Inequality","System.Reflection.MethodBase._MethodBase.GetIDsOfNames","System.Reflection.MethodBase._MethodBase.GetType","System.Reflection.MethodBase._MethodBase.GetTypeInfo","System.Reflection.MethodBase._MethodBase.GetTypeInfoCount","System.Reflection.MethodBase._MethodBase.Invoke","System.Reflection.MethodBase._MethodBase.IsAbstract","System.Reflection.MethodBase._MethodBase.IsAssembly","System.Reflection.MethodBase._MethodBase.IsConstructor","System.Reflection.MethodBase._MethodBase.IsFamily","System.Reflection.MethodBase._MethodBase.IsFamilyAndAssembly","System.Reflection.MethodBase._MethodBase.IsFamilyOrAssembly","System.Reflection.MethodBase._MethodBase.IsFinal","System.Reflection.MethodBase._MethodBase.IsHideBySig","System.Reflection.MethodBase._MethodBase.IsPrivate","System.Reflection.MethodBase._MethodBase.IsPublic","System.Reflection.MethodBase._MethodBase.IsSpecialName","System.Reflection.MethodBase._MethodBase.IsStatic","System.Reflection.MethodBase._MethodBase.IsVirtual"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Reflection.MethodBase","System::Reflection::MethodBase","System.Reflection.MethodBase.#ctor","System::Reflection::MethodBase::#ctor","System.Reflection.MethodBase.Attributes","System::Reflection::MethodBase::Attributes","System.Reflection.MethodBase.CallingConvention","System::Reflection::MethodBase::CallingConvention","System.Reflection.MethodBase.ContainsGenericParameters","System::Reflection::MethodBase::ContainsGenericParameters","System.Reflection.MethodBase.Equals","System::Reflection::MethodBase::Equals","System.Reflection.MethodBase.GetCurrentMethod","System::Reflection::MethodBase::GetCurrentMethod","System.Reflection.MethodBase.GetGenericArguments","System::Reflection::MethodBase::GetGenericArguments","System.Reflection.MethodBase.GetHashCode","System::Reflection::MethodBase::GetHashCode","System.Reflection.MethodBase.GetMethodBody","System::Reflection::MethodBase::GetMethodBody","System.Reflection.MethodBase.GetMethodFromHandle","System::Reflection::MethodBase::GetMethodFromHandle","System.Reflection.MethodBase.GetMethodImplementationFlags","System::Reflection::MethodBase::GetMethodImplementationFlags","System.Reflection.MethodBase.GetParameters","System::Reflection::MethodBase::GetParameters","System.Reflection.MethodBase.Invoke","System::Reflection::MethodBase::Invoke","System.Reflection.MethodBase.IsAbstract","System::Reflection::MethodBase::IsAbstract","System.Reflection.MethodBase.IsAssembly","System::Reflection::MethodBase::IsAssembly","System.Reflection.MethodBase.IsConstructor","System::Reflection::MethodBase::IsConstructor","System.Reflection.MethodBase.IsFamily","System::Reflection::MethodBase::IsFamily","System.Reflection.MethodBase.IsFamilyAndAssembly","System::Reflection::MethodBase::IsFamilyAndAssembly","System.Reflection.MethodBase.IsFamilyOrAssembly","System::Reflection::MethodBase::IsFamilyOrAssembly","System.Reflection.MethodBase.IsFinal","System::Reflection::MethodBase::IsFinal","System.Reflection.MethodBase.IsGenericMethod","System::Reflection::MethodBase::IsGenericMethod","System.Reflection.MethodBase.IsGenericMethodDefinition","System::Reflection::MethodBase::IsGenericMethodDefinition","System.Reflection.MethodBase.IsHideBySig","System::Reflection::MethodBase::IsHideBySig","System.Reflection.MethodBase.IsPrivate","System::Reflection::MethodBase::IsPrivate","System.Reflection.MethodBase.IsPublic","System::Reflection::MethodBase::IsPublic","System.Reflection.MethodBase.IsSecurityCritical","System::Reflection::MethodBase::IsSecurityCritical","System.Reflection.MethodBase.IsSecuritySafeCritical","System::Reflection::MethodBase::IsSecuritySafeCritical","System.Reflection.MethodBase.IsSecurityTransparent","System::Reflection::MethodBase::IsSecurityTransparent","System.Reflection.MethodBase.IsSpecialName","System::Reflection::MethodBase::IsSpecialName","System.Reflection.MethodBase.IsStatic","System::Reflection::MethodBase::IsStatic","System.Reflection.MethodBase.IsVirtual","System::Reflection::MethodBase::IsVirtual","System.Reflection.MethodBase.MethodHandle","System::Reflection::MethodBase::MethodHandle","System.Reflection.MethodBase.MethodImplementationFlags","System::Reflection::MethodBase::MethodImplementationFlags","System.Reflection.MethodBase.op_Equality","System::Reflection::MethodBase::op_Equality","System.Reflection.MethodBase.op_Inequality","System::Reflection::MethodBase::op_Inequality","System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetIDsOfNames","System::Reflection::MethodBase::System#Runtime#InteropServices#_MethodBase#GetIDsOfNames","System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetType","System::Reflection::MethodBase::System#Runtime#InteropServices#_MethodBase#GetType","System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfo","System::Reflection::MethodBase::System#Runtime#InteropServices#_MethodBase#GetTypeInfo","System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount","System::Reflection::MethodBase::System#Runtime#InteropServices#_MethodBase#GetTypeInfoCount","System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#Invoke","System::Reflection::MethodBase::System#Runtime#InteropServices#_MethodBase#Invoke","System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAbstract","System::Reflection::MethodBase::System#Runtime#InteropServices#_MethodBase#IsAbstract","System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsAssembly","System::Reflection::MethodBase::System#Runtime#InteropServices#_MethodBase#IsAssembly","System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsConstructor","System::Reflection::MethodBase::System#Runtime#InteropServices#_MethodBase#IsConstructor","System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamily","System::Reflection::MethodBase::System#Runtime#InteropServices#_MethodBase#IsFamily","System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly","System::Reflection::MethodBase::System#Runtime#InteropServices#_MethodBase#IsFamilyAndAssembly","System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly","System::Reflection::MethodBase::System#Runtime#InteropServices#_MethodBase#IsFamilyOrAssembly","System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsFinal","System::Reflection::MethodBase::System#Runtime#InteropServices#_MethodBase#IsFinal","System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsHideBySig","System::Reflection::MethodBase::System#Runtime#InteropServices#_MethodBase#IsHideBySig","System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPrivate","System::Reflection::MethodBase::System#Runtime#InteropServices#_MethodBase#IsPrivate","System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsPublic","System::Reflection::MethodBase::System#Runtime#InteropServices#_MethodBase#IsPublic","System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsSpecialName","System::Reflection::MethodBase::System#Runtime#InteropServices#_MethodBase#IsSpecialName","System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsStatic","System::Reflection::MethodBase::System#Runtime#InteropServices#_MethodBase#IsStatic","System.Reflection.MethodBase.System#Runtime#InteropServices#_MethodBase#IsVirtual","System::Reflection::MethodBase::System#Runtime#InteropServices#_MethodBase#IsVirtual"],"dev_langs":["csharp"],"updated_at":"2017-03-01 01:37 AM","document_id":"b9cf52d1-efcf-8122-708e-849cfa69a550","content_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/xml/System.Reflection/MethodBase.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"MethodBase class | Microsoft Docs","_op_ogTitle":"MethodBase class","description":"Provides information about methods and constructors.\n","toc_asset_id":"_splitted/System.Reflection/toc.json","toc_rel":"_splitted/System.Reflection/toc.json","source_url":"","ms.assetid":"System.Reflection.MethodBase","canonical_url":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.reflection.methodbase","_op_canonicalUrl":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.reflection.methodbase","fileRelativePath":"System.Reflection.MethodBase.html"},"themesRelativePathToOutputRoot":"_themes/"}