{"content":"    \r\n    <h1 id=\"System_Type\">\r\n      <span class=\"lang-csharp\">Type</span>\r\n        Class\r\n    </h1>\r\n    \r\n    \r\n    <nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n      <h3>In this Article</h3>\r\n    </nav><div class=\"summary\">\r\n    \t<p>Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.  </p>\n<p> To browse the .NET Framework source code for this type, see the <a href=\"http://referencesource.microsoft.com/#mscorlib/system/type.cs#3d00eeab9feb80f3\" data-linktype=\"external\">Reference Source</a>.</p>\n\r\n    </div><h2>Syntax</h2>\r\n    \r\n    \t<h3>Declaration</h3>\r\n    \t<pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]\n[System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))]\n[System.Runtime.InteropServices.ComVisible(true)]\npublic abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type</code></pre>\r\n    \r\n    \r\n    \r\n    <h3>Inheritance Hierarchy</h3>\r\n    <ul class=\"inheritance\">\r\n        <li class=\"l0\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>\r\n          </div>\r\n        </li>\r\n        <li class=\"l1\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">System.Reflection.MemberInfo</a>\r\n          </div>\r\n        </li>\r\n      <li class=\"l2\">\r\n        <div class=\"xref\">\r\n          <div class=\"lang-csharp\">Type</div>\r\n        </div>\r\n      </li>\r\n    </ul>\r\n    \r\n      <div class=\"referencebox inheritedMembers\">\r\n        <h3>Inherited Members</h3>\r\n        <h4></h4>\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_CustomAttributes\" data-linktype=\"relative-path\">CustomAttributes</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_GetCustomAttributes_System_Boolean_\" data-linktype=\"relative-path\">GetCustomAttributes(Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_GetCustomAttributes_System_Type_System_Boolean_\" data-linktype=\"relative-path\">GetCustomAttributes(Type,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_GetCustomAttributesData\" data-linktype=\"relative-path\">GetCustomAttributesData()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_IsDefined_System_Type_System_Boolean_\" data-linktype=\"relative-path\">IsDefined(Type,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_MetadataToken\" data-linktype=\"relative-path\">MetadataToken</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_Name\" data-linktype=\"relative-path\">Name</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_op_Equality_System_Reflection_MemberInfo_System_Reflection_MemberInfo_\" data-linktype=\"relative-path\">op_Equality(MemberInfo,MemberInfo)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_op_Inequality_System_Reflection_MemberInfo_System_Reflection_MemberInfo_\" data-linktype=\"relative-path\">op_Inequality(MemberInfo,MemberInfo)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_System_Runtime_InteropServices__MemberInfo_GetIDsOfNames_System_Guid__System_IntPtr_System_UInt32_System_UInt32_System_IntPtr_\" data-linktype=\"relative-path\">_MemberInfo.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_System_Runtime_InteropServices__MemberInfo_GetType\" data-linktype=\"relative-path\">_MemberInfo.GetType()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_System_Runtime_InteropServices__MemberInfo_GetTypeInfo_System_UInt32_System_UInt32_System_IntPtr_\" data-linktype=\"relative-path\">_MemberInfo.GetTypeInfo(UInt32,UInt32,IntPtr)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_System_Runtime_InteropServices__MemberInfo_GetTypeInfoCount_System_UInt32__\" data-linktype=\"relative-path\">_MemberInfo.GetTypeInfoCount(UInt32)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_System_Runtime_InteropServices__MemberInfo_Invoke_System_UInt32_System_Guid__System_UInt32_System_Int16_System_IntPtr_System_IntPtr_System_IntPtr_System_IntPtr_\" data-linktype=\"relative-path\">_MemberInfo.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)</a>\r\n          </div>\r\n          \r\n      </div>\r\n    \r\n    \r\n      <h2>Remarks</h2>\r\n      <div class=\"NOTE\"><h5>Note</h5><p> To view the .NET Framework source code for this type, see the <a href=\"http://referencesource.microsoft.com/#mscorlib/system/type.cs#3d00eeab9feb80f3\" data-linktype=\"external\">Reference Source</a>. You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <a href=\"http://referencesource.microsoft.com/\" data-linktype=\"external\">instructions</a>.  </p>\n</div>\n<p> <code>Type</code> is the root of the <a class=\"xref\" href=\"system.reflection\" data-linktype=\"relative-path\">System.Reflection</a> functionality and is the primary way to access metadata. Use the members of Type to get information about a type declaration, about the members of a type (such as the constructors, methods, fields, properties, and events of a class), as well as the module and the assembly in which the class is deployed.  </p>\n<p> No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels. No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation. However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <a class=\"xref\" href=\"system.security.permissions.reflectionpermission\" data-linktype=\"relative-path\">ReflectionPermission</a>. See <a href=\"../Topic/Security%20Considerations%20for%20Reflection.md\" data-linktype=\"relative-path\">Security Considerations for Reflection</a>.  </p>\n<p> <code>Type</code> is an abstract base class that allows multiple implementations. The system will always provide the derived class <code>RuntimeType</code>. In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> In multithreading scenarios, do not lock Type objects in order to synchronize access to <code>static</code> data. Other code, over which you have no control, might also lock your class type. This might result in a deadlock. Instead, synchronize access to static data by locking a private <code>static</code> object.  </p>\n</div>\n<div class=\"NOTE\"><h5>Note</h5><p> A derived class can access protected members of the calling code&#39;s base classes. Also, access is allowed to assembly members of the calling code&#39;s assembly. As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.  </p>\n</div>\n<div class=\"NOTE\"><h5>Note</h5><p> Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.  </p>\n</div>\n<p> In this section:  </p>\n<p> <a href=\"#WhatTypes\" data-linktype=\"self-bookmark\">What types does a Type object represent?</a><br> <a href=\"#Retrieve\" data-linktype=\"self-bookmark\">Retrieving a Type object</a><br> <a href=\"#Equality\" data-linktype=\"self-bookmark\">Comparing type objects for equality</a>  </p>\n<p><a name=\"WhatTypes\"></a>   </p>\n<h2 id=\"what-types-does-a-type-object-represent\">What types does a Type object represent?</h2>\n<p> This class is thread safe; multiple threads can concurrently read from an instance of this type. An instance of the Type class can represent any of the following types:  </p>\n<ul>\n<li><p>Classes  </p>\n</li>\n<li><p>Value types  </p>\n</li>\n<li><p>Arrays  </p>\n</li>\n<li><p>Interfaces  </p>\n</li>\n<li><p>Enumerations  </p>\n</li>\n<li><p>Delegates  </p>\n</li>\n<li><p>Constructed generic types and generic type definitions  </p>\n</li>\n<li><p>Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions  </p>\n</li>\n</ul>\n<p><a name=\"Retrieve\"></a>   </p>\n<h2 id=\"retrieving-a-type-object\">Retrieving a Type object</h2>\n<p> The Type object associated with a particular type can be obtained in the following ways:  </p>\n<ul>\n<li><p>The instance <a class=\"xref\" href=\"system.object#System_Object_GetType_\" data-linktype=\"relative-path\">GetType</a> method returns a Type object that represents the type of an instance. Because all managed types derive from <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>, the <a class=\"xref\" href=\"system.object#System_Object_GetType_\" data-linktype=\"relative-path\">GetType</a> method can be called on an instance of any type.  </p>\n<p> The following example calls the <a class=\"xref\" href=\"system.object#System_Object_GetType_\" data-linktype=\"relative-path\">GetType</a> method to determine the runtime type of each object in an object array.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Type#2\">Module Example\n   Public Sub Main()\n      Dim values() As Object = { &quot;word&quot;, True, 120, 136.34, &quot;a&quot;c }\n      For Each value In values\n         Console.WriteLine(&quot;{0} - type {1}&quot;, value, \n                           value.GetType().Name)\n      Next\n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       word - type String\n&#39;       True - type Boolean\n&#39;       120 - type Int32\n&#39;       136.34 - type Double\n&#39;       a - type Char\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Type#2\">using namespace System;\n\nvoid main()\n{\n   array&lt;Object^&gt;^ values = { &quot;word&quot;, true, 120, 136.34 };\n   for each (Object^ value in values)\n      Console::WriteLine(&quot;{0} - type {1}&quot;, value, \n                        value-&gt;GetType()-&gt;Name);\n}\n// The example displays the following output:\n//       word - type String\n//       True - type Boolean\n//       120 - type Int32\n//       136.34 - type Double\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type#2\">using System;\n\npublic class Example\n{\n   public static void Main()\n   {\n      object[] values = { &quot;word&quot;, true, 120, 136.34, &#39;a&#39; };\n      foreach (var value in values)\n         Console.WriteLine(&quot;{0} - type {1}&quot;, value, \n                           value.GetType().Name);\n   }\n}\n// The example displays the following output:\n//       word - type String\n//       True - type Boolean\n//       120 - type Int32\n//       136.34 - type Double\n//       a - type Char\n</code></pre></li>\n<li><p>The static <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> methods return a Type object that represents a type specified by its fully qualified name.  </p>\n</li>\n<li><p>The <a class=\"xref\" href=\"system.reflection.module#System_Reflection_Module_GetTypes_\" data-linktype=\"relative-path\">GetTypes</a>, <a class=\"xref\" href=\"system.reflection.module#System_Reflection_Module_GetType_\" data-linktype=\"relative-path\">GetType</a>, and <a class=\"xref\" href=\"system.reflection.module#System_Reflection_Module_FindTypes_\" data-linktype=\"relative-path\">FindTypes</a> methods return <code>Type</code> objects that represent the types defined in a module. The first method can be used to obtain an array of Type objects for all the public and private types defined in a module. (You can obtain an instance of <code>Module</code> through the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_GetModule_\" data-linktype=\"relative-path\">GetModule</a> or <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_GetModules_\" data-linktype=\"relative-path\">GetModules</a> method, or through the <a class=\"xref\" href=\"system.type#System_Type_Module_\" data-linktype=\"relative-path\">Module</a> property.)  </p>\n</li>\n<li><p>The <a class=\"xref\" href=\"system.reflection.assembly\" data-linktype=\"relative-path\">System.Reflection.Assembly</a> object contains a number of methods to retrieve the classes defined in an assembly, including <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_GetType_\" data-linktype=\"relative-path\">GetType</a>, <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_GetTypes_\" data-linktype=\"relative-path\">GetTypes</a>, and <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_GetExportedTypes_\" data-linktype=\"relative-path\">GetExportedTypes</a>.  </p>\n</li>\n<li><p>The <a class=\"xref\" href=\"system.type#System_Type_FindInterfaces_\" data-linktype=\"relative-path\">FindInterfaces</a> method returns a filtered list of interface types supported by a type.  </p>\n</li>\n<li><p>The <a class=\"xref\" href=\"system.type#System_Type_GetElementType_\" data-linktype=\"relative-path\">GetElementType</a> method returns a <code>Type</code> object that represents the element.  </p>\n</li>\n<li><p>The <a class=\"xref\" href=\"system.type#System_Type_GetInterfaces_\" data-linktype=\"relative-path\">GetInterfaces</a> and <a class=\"xref\" href=\"system.type#System_Type_GetInterface_\" data-linktype=\"relative-path\">GetInterface</a> methods return Type objects representing the interface types supported by a type.  </p>\n</li>\n<li><p>The <a class=\"xref\" href=\"system.type#System_Type_GetTypeArray_\" data-linktype=\"relative-path\">GetTypeArray</a> method returns an array of Type objects representing the types specified by an arbitrary set of objects. The objects are specified with an array of type <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>.  </p>\n</li>\n<li><p>The <a class=\"xref\" href=\"system.type#System_Type_GetTypeFromProgID_\" data-linktype=\"relative-path\">GetTypeFromProgID</a> and <a class=\"xref\" href=\"system.type#System_Type_GetTypeFromCLSID_\" data-linktype=\"relative-path\">GetTypeFromCLSID</a> methods are provided for COM interoperability. They return a Type object that represents the type specified by a <code>ProgID</code> or <code>CLSID</code>.  </p>\n</li>\n<li><p>The <a class=\"xref\" href=\"system.type#System_Type_GetTypeFromHandle_\" data-linktype=\"relative-path\">GetTypeFromHandle</a> method is provided for interoperability. It returns a <code>Type</code> object that represents the type specified by a class handle.  </p>\n</li>\n<li><p>The C# <code>typeof</code> operator, the C++ <code>typeid</code> operator, and the Visual Basic <code>GetType</code> operator obtain the <code>Type</code> object for a type.  </p>\n</li>\n<li><p>The <a class=\"xref\" href=\"system.type#System_Type_MakeGenericType_\" data-linktype=\"relative-path\">MakeGenericType</a> method returns a Type object representing a constructed generic type, which is an open constructed type if its <a class=\"xref\" href=\"system.type#System_Type_ContainsGenericParameters_\" data-linktype=\"relative-path\">ContainsGenericParameters</a> property returns <code>true</code>, and a closed constructed type otherwise. A generic type can be instantiated only if it is closed.  </p>\n</li>\n<li><p>The <a class=\"xref\" href=\"system.type#System_Type_MakeArrayType_\" data-linktype=\"relative-path\">MakeArrayType</a>, <a class=\"xref\" href=\"system.type#System_Type_MakePointerType_\" data-linktype=\"relative-path\">MakePointerType</a>, and <a class=\"xref\" href=\"system.type#System_Type_MakeByRefType_\" data-linktype=\"relative-path\">MakeByRefType</a> methods return Type objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (<code>ref</code> in C#, <code>ByRef</code> in Visual Basic).  </p>\n</li>\n</ul>\n<p><a name=\"Equality\"></a>   </p>\n<h2 id=\"comparing-type-objects-for-equality\">Comparing type objects for equality</h2>\n<p> A Type object that represents a type is unique; that is, two Type object references refer to the same object if and only if they represent the same type. This allows for comparison of Type objects using reference equality. The following example compares the Type objects that represent a number of integer values to determine whether they are of the same type.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type#3\">using System;\n\npublic class Example\n{\n   public static void Main()\n   {\n      long number1 = 1635429;\n      int number2 = 16203;\n      double number3 = 1639.41;\n      long number4 = 193685412;\n      \n      // Get the type of number1.\n      Type t = number1.GetType();\n      \n      // Compare types of all objects with number1.\n      Console.WriteLine(&quot;Type of number1 and number2 are equal: {0}&quot;,\n                        Object.ReferenceEquals(t, number2.GetType()));\n      Console.WriteLine(&quot;Type of number1 and number3 are equal: {0}&quot;,\n                        Object.ReferenceEquals(t, number3.GetType()));\n      Console.WriteLine(&quot;Type of number1 and number4 are equal: {0}&quot;,\n                        Object.ReferenceEquals(t, number4.GetType()));\n   }\n}\n// The example displays the following output:\n//       Type of number1 and number2 are equal: False\n//       Type of number1 and number3 are equal: False\n//       Type of number1 and number4 are equal: True\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type#3\">Module Example\n   Public Sub Main()\n      Dim number1 As Long = 1635429\n      Dim number2 As Integer = 16203\n      Dim number3 As Double = 1639.41\n      Dim number4 As Long = 193685412\n      \n      &#39; Get the type of number1.\n      Dim t As Type = number1.GetType()\n      \n      &#39; Compare types of all objects with number1.\n      Console.WriteLine(&quot;Type of number1 and number2 are equal: {0}&quot;,\n                        Object.ReferenceEquals(t, number2.GetType()))\n      Console.WriteLine(&quot;Type of number1 and number3 are equal: {0}&quot;,\n                        Object.ReferenceEquals(t, number3.GetType()))\n      Console.WriteLine(&quot;Type of number1 and number4 are equal: {0}&quot;,\n                        Object.ReferenceEquals(t, number4.GetType()))\n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       Type of number1 and number2 are equal: False\n&#39;       Type of number1 and number3 are equal: False\n&#39;       Type of number1 and number4 are equal: True\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Type#3\">using namespace System;\n\nvoid main()\n{\n   Int64 number1 = 1635429;\n   Int32 number2 = 16203;\n   double number3 = 1639.41;\n   Int64 number4 = 193685412;\n   \n   // Get the type of number1.\n   Type^ t = number1.GetType();\n   \n   // Compare types of all objects with number1.\n   Console::WriteLine(&quot;Type of number1 and number2 are equal: {0}&quot;,\n                      Object::ReferenceEquals(t, number2.GetType()));\n   Console::WriteLine(&quot;Type of number1 and number3 are equal: {0}&quot;,\n                      Object::ReferenceEquals(t, number3.GetType()));\n   Console::WriteLine(&quot;Type of number1 and number4 are equal: {0}&quot;,\n                      Object::ReferenceEquals(t, number4.GetType()));\n}\n// The example displays the following output:\n//       Type of number1 and number2 are equal: False\n//       Type of number1 and number3 are equal: False\n//       Type of number1 and number4 are equal: True\n</code></pre>\r\n    \r\n    \r\n    <h2>Constructors\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type__ctor\" data-linktype=\"self-bookmark\">Type()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> class.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Fields\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_Delimiter\" data-linktype=\"self-bookmark\">Delimiter</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Separates names in the namespace of the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>. This field is read-only.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_EmptyTypes\" data-linktype=\"self-bookmark\">EmptyTypes</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Represents an empty array of type <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>. This field is read-only.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_FilterAttribute\" data-linktype=\"self-bookmark\">FilterAttribute</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Represents the member filter used on attributes. This field is read-only.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_FilterName\" data-linktype=\"self-bookmark\">FilterName</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Represents the case-sensitive member filter used on names. This field is read-only.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_FilterNameIgnoreCase\" data-linktype=\"self-bookmark\">FilterNameIgnoreCase</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Represents the case-insensitive member filter used on names. This field is read-only.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_Missing\" data-linktype=\"self-bookmark\">Missing</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Represents a missing value in the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> information. This field is read-only.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Properties\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_Assembly\" data-linktype=\"self-bookmark\">Assembly</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the <a class=\"xref\" href=\"system.reflection.assembly\" data-linktype=\"relative-path\">Assembly</a> in which the type is declared. For generic types, gets the <a class=\"xref\" href=\"system.reflection.assembly\" data-linktype=\"relative-path\">Assembly</a> in which the generic type is defined.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_AssemblyQualifiedName\" data-linktype=\"self-bookmark\">AssemblyQualifiedName</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object was loaded.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_Attributes\" data-linktype=\"self-bookmark\">Attributes</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the attributes associated with the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_BaseType\" data-linktype=\"self-bookmark\">BaseType</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the type from which the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> directly inherits.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_ContainsGenericParameters\" data-linktype=\"self-bookmark\">ContainsGenericParameters</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object has type parameters that have not been replaced by specific types.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_DeclaringMethod\" data-linktype=\"self-bookmark\">DeclaringMethod</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> that represents the declaring method, if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter of a generic method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_DeclaringType\" data-linktype=\"self-bookmark\">DeclaringType</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the type that declares the current nested type or generic type parameter.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_DefaultBinder\" data-linktype=\"self-bookmark\">DefaultBinder</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <span class=\"xref\">stem.Type.InvokeMember*</span>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_FullName\" data-linktype=\"self-bookmark\">FullName</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the fully qualified name of the type, including its namespace but not its assembly.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GenericParameterAttributes\" data-linktype=\"self-bookmark\">GenericParameterAttributes</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a combination of <a class=\"xref\" href=\"system.reflection.genericparameterattributes\" data-linktype=\"relative-path\">GenericParameterAttributes</a> flags that describe the covariance and special constraints of the current generic type parameter.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GenericParameterPosition\" data-linktype=\"self-bookmark\">GenericParameterPosition</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents a type parameter of a generic type or a generic method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GenericTypeArguments\" data-linktype=\"self-bookmark\">GenericTypeArguments</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets an array of the generic type arguments for this type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GUID\" data-linktype=\"self-bookmark\">GUID</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the GUID associated with the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_HasElementType\" data-linktype=\"self-bookmark\">HasElementType</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> encompasses or refers to another type; that is, whether the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is an array, a pointer, or is passed by reference.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsAbstract\" data-linktype=\"self-bookmark\">IsAbstract</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is abstract and must be overridden.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsAnsiClass\" data-linktype=\"self-bookmark\">IsAnsiClass</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the string format attribute <code>AnsiClass</code> is selected for the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsArray\" data-linktype=\"self-bookmark\">IsArray</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value that indicates whether the type is an array.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsAutoClass\" data-linktype=\"self-bookmark\">IsAutoClass</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the string format attribute <code>AutoClass</code> is selected for the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsAutoLayout\" data-linktype=\"self-bookmark\">IsAutoLayout</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsByRef\" data-linktype=\"self-bookmark\">IsByRef</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is passed by reference.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsClass\" data-linktype=\"self-bookmark\">IsClass</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is a class or a delegate; that is, not a value type or interface.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsCOMObject\" data-linktype=\"self-bookmark\">IsCOMObject</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is a COM object.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsConstructedGenericType\" data-linktype=\"self-bookmark\">IsConstructedGenericType</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value that indicates whether this object represents a constructed generic type. You can create instances of a constructed generic type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsContextful\" data-linktype=\"self-bookmark\">IsContextful</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> can be hosted in a context.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsEnum\" data-linktype=\"self-bookmark\">IsEnum</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents an enumeration.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsExplicitLayout\" data-linktype=\"self-bookmark\">IsExplicitLayout</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsGenericParameter\" data-linktype=\"self-bookmark\">IsGenericParameter</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsGenericType\" data-linktype=\"self-bookmark\">IsGenericType</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the current type is a generic type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsGenericTypeDefinition\" data-linktype=\"self-bookmark\">IsGenericTypeDefinition</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a generic type definition, from which other generic types can be constructed.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsImport\" data-linktype=\"self-bookmark\">IsImport</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> has a <a class=\"xref\" href=\"system.runtime.interopservices.comimportattribute\" data-linktype=\"relative-path\">ComImportAttribute</a> attribute applied, indicating that it was imported from a COM type library.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsInterface\" data-linktype=\"self-bookmark\">IsInterface</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is an interface; that is, not a class or a value type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsLayoutSequential\" data-linktype=\"self-bookmark\">IsLayoutSequential</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsMarshalByRef\" data-linktype=\"self-bookmark\">IsMarshalByRef</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is marshaled by reference.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsNested\" data-linktype=\"self-bookmark\">IsNested</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents a type whose definition is nested inside the definition of another type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsNestedAssembly\" data-linktype=\"self-bookmark\">IsNestedAssembly</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is nested and visible only within its own assembly.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsNestedFamANDAssem\" data-linktype=\"self-bookmark\">IsNestedFamANDAssem</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is nested and visible only to classes that belong to both its own family and its own assembly.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsNestedFamily\" data-linktype=\"self-bookmark\">IsNestedFamily</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is nested and visible only within its own family.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsNestedFamORAssem\" data-linktype=\"self-bookmark\">IsNestedFamORAssem</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is nested and visible only to classes that belong to either its own family or to its own assembly.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsNestedPrivate\" data-linktype=\"self-bookmark\">IsNestedPrivate</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is nested and declared private.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsNestedPublic\" data-linktype=\"self-bookmark\">IsNestedPublic</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether a class is nested and declared public.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsNotPublic\" data-linktype=\"self-bookmark\">IsNotPublic</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is not declared public.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsPointer\" data-linktype=\"self-bookmark\">IsPointer</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is a pointer.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsPrimitive\" data-linktype=\"self-bookmark\">IsPrimitive</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is one of the primitive types.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsPublic\" data-linktype=\"self-bookmark\">IsPublic</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is declared public.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsSealed\" data-linktype=\"self-bookmark\">IsSealed</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is declared sealed.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsSecurityCritical\" data-linktype=\"self-bookmark\">IsSecurityCritical</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsSecuritySafeCritical\" data-linktype=\"self-bookmark\">IsSecuritySafeCritical</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsSecurityTransparent\" data-linktype=\"self-bookmark\">IsSecurityTransparent</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsSerializable\" data-linktype=\"self-bookmark\">IsSerializable</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is serializable.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsSpecialName\" data-linktype=\"self-bookmark\">IsSpecialName</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the type has a name that requires special handling.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsUnicodeClass\" data-linktype=\"self-bookmark\">IsUnicodeClass</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the string format attribute <code>UnicodeClass</code> is selected for the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsValueType\" data-linktype=\"self-bookmark\">IsValueType</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is a value type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsVisible\" data-linktype=\"self-bookmark\">IsVisible</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> can be accessed by code outside the assembly.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_MemberType\" data-linktype=\"self-bookmark\">MemberType</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a <a class=\"xref\" href=\"system.reflection.membertypes\" data-linktype=\"relative-path\">MemberTypes</a> value indicating that this member is a type or a nested type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_Module\" data-linktype=\"self-bookmark\">Module</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the module (the DLL) in which the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is defined.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_Namespace\" data-linktype=\"self-bookmark\">Namespace</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the namespace of the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_ReflectedType\" data-linktype=\"self-bookmark\">ReflectedType</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the class object that was used to obtain this member.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_StructLayoutAttribute\" data-linktype=\"self-bookmark\">StructLayoutAttribute</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a <a class=\"xref\" href=\"system.runtime.interopservices.structlayoutattribute\" data-linktype=\"relative-path\">StructLayoutAttribute</a> that describes the layout of the current type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_TypeHandle\" data-linktype=\"self-bookmark\">TypeHandle</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the handle for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_TypeInitializer\" data-linktype=\"self-bookmark\">TypeInitializer</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the initializer for the type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_UnderlyingSystemType\" data-linktype=\"self-bookmark\">UnderlyingSystemType</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Indicates the type provided by the common language runtime that represents this type.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Methods\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_Equals_System_Object_\" data-linktype=\"self-bookmark\">Equals(Object)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Determines if the underlying system type of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object is the same as the underlying system type of the specified <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_Equals_System_Type_\" data-linktype=\"self-bookmark\">Equals(Type)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Determines if the underlying system type of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is the same as the underlying system type of the specified <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_FindInterfaces_System_Reflection_TypeFilter_System_Object_\" data-linktype=\"self-bookmark\">FindInterfaces(TypeFilter,Object)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns an array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects representing a filtered list of interfaces implemented or inherited by the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_FindMembers_System_Reflection_MemberTypes_System_Reflection_BindingFlags_System_Reflection_MemberFilter_System_Object_\" data-linktype=\"self-bookmark\">FindMembers(MemberTypes,BindingFlags,MemberFilter,Object)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns a filtered array of <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a> objects of the specified member type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetArrayRank\" data-linktype=\"self-bookmark\">GetArrayRank()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the number of dimensions in an array.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetAttributeFlagsImpl\" data-linktype=\"self-bookmark\">GetAttributeFlagsImpl()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, implements the <span class=\"xref\">stem.Type.Attributes*</span> property and gets a bitmask indicating the attributes associated with the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetConstructor_System_Type___\" data-linktype=\"self-bookmark\">GetConstructor(Type[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Searches for a public instance constructor whose parameters match the types in the specified array.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetConstructor_System_Reflection_BindingFlags_System_Reflection_Binder_System_Type___System_Reflection_ParameterModifier___\" data-linktype=\"self-bookmark\">GetConstructor(BindingFlags,Binder,Type[],ParameterModifier[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetConstructor_System_Reflection_BindingFlags_System_Reflection_Binder_System_Reflection_CallingConventions_System_Type___System_Reflection_ParameterModifier___\" data-linktype=\"self-bookmark\">GetConstructor(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetConstructorImpl_System_Reflection_BindingFlags_System_Reflection_Binder_System_Reflection_CallingConventions_System_Type___System_Reflection_ParameterModifier___\" data-linktype=\"self-bookmark\">GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetConstructors\" data-linktype=\"self-bookmark\">GetConstructors()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns all the public constructors defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetConstructors_System_Reflection_BindingFlags_\" data-linktype=\"self-bookmark\">GetConstructors(BindingFlags)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, searches for the constructors defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, using the specified <code>BindingFlags</code>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetDefaultMembers\" data-linktype=\"self-bookmark\">GetDefaultMembers()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Searches for the members defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> whose <a class=\"xref\" href=\"system.reflection.defaultmemberattribute\" data-linktype=\"relative-path\">DefaultMemberAttribute</a> is set.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetElementType\" data-linktype=\"self-bookmark\">GetElementType()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, returns the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> of the object encompassed or referred to by the current array, pointer or reference type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetEnumName_System_Object_\" data-linktype=\"self-bookmark\">GetEnumName(Object)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns the name of the constant that has the specified value, for the current enumeration type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetEnumNames\" data-linktype=\"self-bookmark\">GetEnumNames()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns the names of the members of the current enumeration type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetEnumUnderlyingType\" data-linktype=\"self-bookmark\">GetEnumUnderlyingType()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns the underlying type of the current enumeration type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetEnumValues\" data-linktype=\"self-bookmark\">GetEnumValues()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns an array of the values of the constants in the current enumeration type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetEvent_System_String_\" data-linktype=\"self-bookmark\">GetEvent(String)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns the <a class=\"xref\" href=\"system.reflection.eventinfo\" data-linktype=\"relative-path\">EventInfo</a> object representing the specified public event.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetEvent_System_String_System_Reflection_BindingFlags_\" data-linktype=\"self-bookmark\">GetEvent(String,BindingFlags)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, returns the <a class=\"xref\" href=\"system.reflection.eventinfo\" data-linktype=\"relative-path\">EventInfo</a> object representing the specified event, using the specified binding constraints.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetEvents\" data-linktype=\"self-bookmark\">GetEvents()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns all the public events that are declared or inherited by the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetEvents_System_Reflection_BindingFlags_\" data-linktype=\"self-bookmark\">GetEvents(BindingFlags)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, searches for events that are declared or inherited by the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, using the specified binding constraints.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetField_System_String_\" data-linktype=\"self-bookmark\">GetField(String)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Searches for the public field with the specified name.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetField_System_String_System_Reflection_BindingFlags_\" data-linktype=\"self-bookmark\">GetField(String,BindingFlags)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Searches for the specified field, using the specified binding constraints.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetFields\" data-linktype=\"self-bookmark\">GetFields()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns all the public fields of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetFields_System_Reflection_BindingFlags_\" data-linktype=\"self-bookmark\">GetFields(BindingFlags)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, searches for the fields defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, using the specified binding constraints.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetGenericArguments\" data-linktype=\"self-bookmark\">GetGenericArguments()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns an array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetGenericParameterConstraints\" data-linktype=\"self-bookmark\">GetGenericParameterConstraints()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns an array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects that represent the constraints on the current generic type parameter.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetGenericTypeDefinition\" data-linktype=\"self-bookmark\">GetGenericTypeDefinition()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents a generic type definition from which the current generic type can be constructed.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetHashCode\" data-linktype=\"self-bookmark\">GetHashCode()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns the hash code for this instance.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetInterface_System_String_\" data-linktype=\"self-bookmark\">GetInterface(String)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Searches for the interface with the specified name.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetInterface_System_String_System_Boolean_\" data-linktype=\"self-bookmark\">GetInterface(String,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetInterfaceMap_System_Type_\" data-linktype=\"self-bookmark\">GetInterfaceMap(Type)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns an interface mapping for the specified interface type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetInterfaces\" data-linktype=\"self-bookmark\">GetInterfaces()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, gets all the interfaces implemented or inherited by the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetMember_System_String_\" data-linktype=\"self-bookmark\">GetMember(String)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Searches for the public members with the specified name.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetMember_System_String_System_Reflection_BindingFlags_\" data-linktype=\"self-bookmark\">GetMember(String,BindingFlags)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Searches for the specified members, using the specified binding constraints.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetMember_System_String_System_Reflection_MemberTypes_System_Reflection_BindingFlags_\" data-linktype=\"self-bookmark\">GetMember(String,MemberTypes,BindingFlags)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Searches for the specified members of the specified member type, using the specified binding constraints.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetMembers\" data-linktype=\"self-bookmark\">GetMembers()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns all the public members of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetMembers_System_Reflection_BindingFlags_\" data-linktype=\"self-bookmark\">GetMembers(BindingFlags)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, searches for the members defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, using the specified binding constraints.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetMethod_System_String_\" data-linktype=\"self-bookmark\">GetMethod(String)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Searches for the public method with the specified name.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetMethod_System_String_System_Reflection_BindingFlags_\" data-linktype=\"self-bookmark\">GetMethod(String,BindingFlags)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Searches for the specified method, using the specified binding constraints.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetMethod_System_String_System_Type___\" data-linktype=\"self-bookmark\">GetMethod(String,Type[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Searches for the specified public method whose parameters match the specified argument types.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetMethod_System_String_System_Type___System_Reflection_ParameterModifier___\" data-linktype=\"self-bookmark\">GetMethod(String,Type[],ParameterModifier[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Searches for the specified public method whose parameters match the specified argument types and modifiers.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetMethod_System_String_System_Reflection_BindingFlags_System_Reflection_Binder_System_Type___System_Reflection_ParameterModifier___\" data-linktype=\"self-bookmark\">GetMethod(String,BindingFlags,Binder,Type[],ParameterModifier[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetMethod_System_String_System_Reflection_BindingFlags_System_Reflection_Binder_System_Reflection_CallingConventions_System_Type___System_Reflection_ParameterModifier___\" data-linktype=\"self-bookmark\">GetMethod(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetMethodImpl_System_String_System_Reflection_BindingFlags_System_Reflection_Binder_System_Reflection_CallingConventions_System_Type___System_Reflection_ParameterModifier___\" data-linktype=\"self-bookmark\">GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetMethods\" data-linktype=\"self-bookmark\">GetMethods()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns all the public methods of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetMethods_System_Reflection_BindingFlags_\" data-linktype=\"self-bookmark\">GetMethods(BindingFlags)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, searches for the methods defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, using the specified binding constraints.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetNestedType_System_String_\" data-linktype=\"self-bookmark\">GetNestedType(String)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Searches for the public nested type with the specified name.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetNestedType_System_String_System_Reflection_BindingFlags_\" data-linktype=\"self-bookmark\">GetNestedType(String,BindingFlags)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetNestedTypes\" data-linktype=\"self-bookmark\">GetNestedTypes()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns the public types nested in the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetNestedTypes_System_Reflection_BindingFlags_\" data-linktype=\"self-bookmark\">GetNestedTypes(BindingFlags)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, searches for the types nested in the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, using the specified binding constraints.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetProperties\" data-linktype=\"self-bookmark\">GetProperties()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns all the public properties of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetProperties_System_Reflection_BindingFlags_\" data-linktype=\"self-bookmark\">GetProperties(BindingFlags)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, searches for the properties of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, using the specified binding constraints.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetProperty_System_String_\" data-linktype=\"self-bookmark\">GetProperty(String)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Searches for the public property with the specified name.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetProperty_System_String_System_Reflection_BindingFlags_\" data-linktype=\"self-bookmark\">GetProperty(String,BindingFlags)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Searches for the specified property, using the specified binding constraints.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetProperty_System_String_System_Type_\" data-linktype=\"self-bookmark\">GetProperty(String,Type)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Searches for the public property with the specified name and return type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetProperty_System_String_System_Type___\" data-linktype=\"self-bookmark\">GetProperty(String,Type[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Searches for the specified public property whose parameters match the specified argument types.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetProperty_System_String_System_Type_System_Type___\" data-linktype=\"self-bookmark\">GetProperty(String,Type,Type[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Searches for the specified public property whose parameters match the specified argument types.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetProperty_System_String_System_Type_System_Type___System_Reflection_ParameterModifier___\" data-linktype=\"self-bookmark\">GetProperty(String,Type,Type[],ParameterModifier[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Searches for the specified public property whose parameters match the specified argument types and modifiers.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetProperty_System_String_System_Reflection_BindingFlags_System_Reflection_Binder_System_Type_System_Type___System_Reflection_ParameterModifier___\" data-linktype=\"self-bookmark\">GetProperty(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetPropertyImpl_System_String_System_Reflection_BindingFlags_System_Reflection_Binder_System_Type_System_Type___System_Reflection_ParameterModifier___\" data-linktype=\"self-bookmark\">GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetType\" data-linktype=\"self-bookmark\">GetType()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetType_System_String_\" data-linktype=\"self-bookmark\">GetType(String)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> with the specified name, performing a case-sensitive search.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetType_System_String_System_Boolean_\" data-linktype=\"self-bookmark\">GetType(String,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetType_System_String_System_Boolean_System_Boolean_\" data-linktype=\"self-bookmark\">GetType(String,Boolean,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetType_System_String_System_Func_System_Reflection_AssemblyName_System_Reflection_Assembly__System_Func_System_Reflection_Assembly_System_String_System_Boolean_System_Type__\" data-linktype=\"self-bookmark\">GetType(String,Func&lt;AssemblyName,Assembly&gt;,Func&lt;Assembly,String,Boolean,Type&gt;)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetType_System_String_System_Func_System_Reflection_AssemblyName_System_Reflection_Assembly__System_Func_System_Reflection_Assembly_System_String_System_Boolean_System_Type__System_Boolean_\" data-linktype=\"self-bookmark\">GetType(String,Func&lt;AssemblyName,Assembly&gt;,Func&lt;Assembly,String,Boolean,Type&gt;,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetType_System_String_System_Func_System_Reflection_AssemblyName_System_Reflection_Assembly__System_Func_System_Reflection_Assembly_System_String_System_Boolean_System_Type__System_Boolean_System_Boolean_\" data-linktype=\"self-bookmark\">GetType(String,Func&lt;AssemblyName,Assembly&gt;,Func&lt;Assembly,String,Boolean,Type&gt;,Boolean,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetTypeArray_System_Object___\" data-linktype=\"self-bookmark\">GetTypeArray(Object[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the types of the objects in the specified array.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetTypeCode_System_Type_\" data-linktype=\"self-bookmark\">GetTypeCode(Type)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the underlying type code of the specified <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetTypeCodeImpl\" data-linktype=\"self-bookmark\">GetTypeCodeImpl()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns the underlying type code of this <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> instance.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetTypeFromCLSID_System_Guid_\" data-linktype=\"self-bookmark\">GetTypeFromCLSID(Guid)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the type associated with the specified class identifier (CLSID).</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetTypeFromCLSID_System_Guid_System_Boolean_\" data-linktype=\"self-bookmark\">GetTypeFromCLSID(Guid,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetTypeFromCLSID_System_Guid_System_String_\" data-linktype=\"self-bookmark\">GetTypeFromCLSID(Guid,String)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the type associated with the specified class identifier (CLSID) from the specified server.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetTypeFromCLSID_System_Guid_System_String_System_Boolean_\" data-linktype=\"self-bookmark\">GetTypeFromCLSID(Guid,String,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetTypeFromHandle_System_RuntimeTypeHandle_\" data-linktype=\"self-bookmark\">GetTypeFromHandle(RuntimeTypeHandle)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the type referenced by the specified type handle.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetTypeFromProgID_System_String_\" data-linktype=\"self-bookmark\">GetTypeFromProgID(String)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetTypeFromProgID_System_String_System_Boolean_\" data-linktype=\"self-bookmark\">GetTypeFromProgID(String,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetTypeFromProgID_System_String_System_String_\" data-linktype=\"self-bookmark\">GetTypeFromProgID(String,String)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetTypeFromProgID_System_String_System_String_System_Boolean_\" data-linktype=\"self-bookmark\">GetTypeFromProgID(String,String,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_GetTypeHandle_System_Object_\" data-linktype=\"self-bookmark\">GetTypeHandle(Object)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the handle for the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> of a specified object.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_HasElementTypeImpl\" data-linktype=\"self-bookmark\">HasElementTypeImpl()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, implements the <span class=\"xref\">stem.Type.HasElementType*</span> property and determines whether the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> encompasses or refers to another type; that is, whether the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is an array, a pointer, or is passed by reference.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_InvokeMember_System_String_System_Reflection_BindingFlags_System_Reflection_Binder_System_Object_System_Object___\" data-linktype=\"self-bookmark\">InvokeMember(String,BindingFlags,Binder,Object,Object[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Invokes the specified member, using the specified binding constraints and matching the specified argument list.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_InvokeMember_System_String_System_Reflection_BindingFlags_System_Reflection_Binder_System_Object_System_Object___System_Globalization_CultureInfo_\" data-linktype=\"self-bookmark\">InvokeMember(String,BindingFlags,Binder,Object,Object[],CultureInfo)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_InvokeMember_System_String_System_Reflection_BindingFlags_System_Reflection_Binder_System_Object_System_Object___System_Reflection_ParameterModifier___System_Globalization_CultureInfo_System_String___\" data-linktype=\"self-bookmark\">InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsArrayImpl\" data-linktype=\"self-bookmark\">IsArrayImpl()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, implements the <span class=\"xref\">stem.Type.IsArray*</span> property and determines whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is an array.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsAssignableFrom_System_Type_\" data-linktype=\"self-bookmark\">IsAssignableFrom(Type)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Determines whether an instance of a specified type can be assigned to an instance of the current type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsByRefImpl\" data-linktype=\"self-bookmark\">IsByRefImpl()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, implements the <span class=\"xref\">stem.Type.IsByRef*</span> property and determines whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is passed by reference.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsCOMObjectImpl\" data-linktype=\"self-bookmark\">IsCOMObjectImpl()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, implements the <span class=\"xref\">stem.Type.IsCOMObject*</span> property and determines whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is a COM object.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsContextfulImpl\" data-linktype=\"self-bookmark\">IsContextfulImpl()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Implements the <span class=\"xref\">stem.Type.IsContextful*</span> property and determines whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> can be hosted in a context.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsEnumDefined_System_Object_\" data-linktype=\"self-bookmark\">IsEnumDefined(Object)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns a value that indicates whether the specified value exists in the current enumeration type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsEquivalentTo_System_Type_\" data-linktype=\"self-bookmark\">IsEquivalentTo(Type)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Determines whether two COM types have the same identity and are eligible for type equivalence.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsInstanceOfType_System_Object_\" data-linktype=\"self-bookmark\">IsInstanceOfType(Object)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Determines whether the specified object is an instance of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsMarshalByRefImpl\" data-linktype=\"self-bookmark\">IsMarshalByRefImpl()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Implements the <span class=\"xref\">stem.Type.IsMarshalByRef*</span> property and determines whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is marshaled by reference.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsPointerImpl\" data-linktype=\"self-bookmark\">IsPointerImpl()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, implements the <span class=\"xref\">stem.Type.IsPointer*</span> property and determines whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is a pointer.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsPrimitiveImpl\" data-linktype=\"self-bookmark\">IsPrimitiveImpl()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When overridden in a derived class, implements the <span class=\"xref\">stem.Type.IsPrimitive*</span> property and determines whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is one of the primitive types.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsSubclassOf_System_Type_\" data-linktype=\"self-bookmark\">IsSubclassOf(Type)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Determines whether the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> derives from the specified <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_IsValueTypeImpl\" data-linktype=\"self-bookmark\">IsValueTypeImpl()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Implements the <span class=\"xref\">stem.Type.IsValueType*</span> property and determines whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is a value type; that is, not a class or an interface.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_MakeArrayType\" data-linktype=\"self-bookmark\">MakeArrayType()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object representing a one-dimensional array of the current type, with a lower bound of zero.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_MakeArrayType_System_Int32_\" data-linktype=\"self-bookmark\">MakeArrayType(Int32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object representing an array of the current type, with the specified number of dimensions.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_MakeByRefType\" data-linktype=\"self-bookmark\">MakeByRefType()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents the current type when passed as a <code>ref</code> parameter (<code>ByRef</code> parameter in Visual Basic).</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_MakeGenericType_System_Type___\" data-linktype=\"self-bookmark\">MakeGenericType(Type[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object representing the resulting constructed type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_MakePointerType\" data-linktype=\"self-bookmark\">MakePointerType()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents a pointer to the current type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_ReflectionOnlyGetType_System_String_System_Boolean_System_Boolean_\" data-linktype=\"self-bookmark\">ReflectionOnlyGetType(String,Boolean,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found. The type is loaded for reflection only, not for execution.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_ToString\" data-linktype=\"self-bookmark\">ToString()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Returns a <code>String</code> representing the name of the current <code>Type</code>.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Operators\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_op_Equality_System_Type_System_Type_\" data-linktype=\"self-bookmark\">op_Equality(Type,Type)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Indicates whether two <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects are equal.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_op_Inequality_System_Type_System_Type_\" data-linktype=\"self-bookmark\">op_Inequality(Type,Type)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Indicates whether two <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects are not equal.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Explicit Interface Implementations\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_System_Runtime_InteropServices__Type_GetIDsOfNames_System_Guid__System_IntPtr_System_UInt32_System_UInt32_System_IntPtr_\" data-linktype=\"self-bookmark\">_Type.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Maps a set of names to a corresponding set of dispatch identifiers.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_System_Runtime_InteropServices__Type_GetTypeInfo_System_UInt32_System_UInt32_System_IntPtr_\" data-linktype=\"self-bookmark\">_Type.GetTypeInfo(UInt32,UInt32,IntPtr)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Retrieves the type information for an object, which can then be used to get the type information for an interface.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_System_Runtime_InteropServices__Type_GetTypeInfoCount_System_UInt32__\" data-linktype=\"self-bookmark\">_Type.GetTypeInfoCount(UInt32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Type_System_Runtime_InteropServices__Type_Invoke_System_UInt32_System_Guid__System_UInt32_System_Int16_System_IntPtr_System_IntPtr_System_IntPtr_System_IntPtr_\" data-linktype=\"self-bookmark\">_Type.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Provides access to properties and methods exposed by an object.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"constructors\">\r\n        <h2>Constructors\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Type__ctor\">\r\n    \r\n            <a id=\"System_Type__ctor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Type()</div>        \r\n          </div>\r\n    \r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> class.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected Type ();</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This constructor is invoked by derived classes during the construction of type objects.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"fields\">\r\n        <h2>Fields\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Type_Delimiter\">\r\n    \r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Delimiter</div>        \r\n          </div>\r\n    \r\n            <p>Separates names in the namespace of the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>. This field is read-only.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static readonly char Delimiter;</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_EmptyTypes\">\r\n    \r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">EmptyTypes</div>        \r\n          </div>\r\n    \r\n            <p>Represents an empty array of type <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>. This field is read-only.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static readonly Type[] EmptyTypes;</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example shows the <code>EmptyTypes</code> field used in one of the <code>GetConstructor</code> methods to get a constructor that takes no parameters.  </p>\n<pre><code class=\"lang-cs\" name=\"Classic Type.EmptyTypes Example#1\">cInfo = type.GetConstructor (BindingFlags.ExactBinding, null, \n         Type.EmptyTypes, null);\n</code></pre><pre><code class=\"lang-vb\" name=\"Classic Type.EmptyTypes Example#1\">cInfo = type.GetConstructor(BindingFlags.ExactBinding, _\n   Nothing, Type.EmptyTypes, Nothing)\n</code></pre><pre><code class=\"lang-cpp\" name=\"Classic Type.EmptyTypes Example#1\">      cInfo = type-&gt;GetConstructor( BindingFlags::ExactBinding, nullptr,\n         Type::EmptyTypes, nullptr );\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_FilterAttribute\">\r\n    \r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">FilterAttribute</div>        \r\n          </div>\r\n    \r\n            <p>Represents the member filter used on attributes. This field is read-only.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static readonly System.Reflection.MemberFilter FilterAttribute;</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This field holds a reference to the delegate used by the <a class=\"xref\" href=\"system.type#System_Type_FindMembers_\" data-linktype=\"relative-path\">FindMembers</a> method. The method encapsulated by this delegate takes two parameters: the first is a <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a> object and the second is an <code>Object</code>. The method determines whether the <code>MemberInfo</code> object matches the criteria specified by the <code>Object</code>. The <code>Object</code> may be assigned the value of any one of the fields on the classes <a class=\"xref\" href=\"system.reflection.fieldattributes\" data-linktype=\"relative-path\">FieldAttributes</a>, <a class=\"xref\" href=\"system.reflection.methodattributes\" data-linktype=\"relative-path\">MethodAttributes</a>, or <a class=\"xref\" href=\"system.reflection.methodimplattributes\" data-linktype=\"relative-path\">MethodImplAttributes</a>.  </p>\n<p> For example, the <code>Object</code> can be assigned the value of a field from <code>FieldAttributes</code> such as Public. In that case, when the <code>FilterAttribute</code> delegate is invoked, it will return <code>true</code> only if the method represented by the <code>MemberInfo</code> object is decorated with the public field attribute in metadata.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example gets the <code>FilterAttribute</code> delegate, passes it as a parameter to the <a class=\"xref\" href=\"system.type#System_Type_FindMembers_\" data-linktype=\"relative-path\">FindMembers</a> method, and displays the specified members and their attributes.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_FilterAttribute#1\">using System;\nusing System.Reflection;\nusing System.Security;\n\npublic class MyFilterAttributeSample\n{\n    public static void Main()\n    {\n        try\n        {\n            MemberFilter myFilter = Type.FilterAttribute;\n            Type myType = typeof(System.String);\n            MemberInfo[] myMemberInfoArray = myType.FindMembers(MemberTypes.Constructor\n                |MemberTypes.Method, BindingFlags.Public | BindingFlags.Static |\n                BindingFlags.Instance, myFilter, MethodAttributes.SpecialName);\n            foreach (MemberInfo myMemberinfo in myMemberInfoArray) \n            { \n                Console.Write (&quot;<br>&quot; + myMemberinfo.Name);\n                Console.Write (&quot; is a &quot; + myMemberinfo.MemberType.ToString()); \n            }\n        }\n        catch(ArgumentNullException e)\n        {\n            Console.Write(&quot;ArgumentNullException : &quot; + e.Message); \n        }   \n        catch(SecurityException e)\n        {\n            Console.Write(&quot;SecurityException : &quot; + e.Message); \n        }   \n        catch(Exception e)\n        {\n            Console.Write(&quot;Exception :&quot; + e.Message); \n        } \n    }\t\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_FilterAttribute#1\">using namespace System;\nusing namespace System::Collections;\nusing namespace System::Reflection;\nusing namespace System::Security;\nint main()\n{\n   try\n   {\n      MemberFilter^ myFilter = Type::FilterAttribute;\n      Type^ myType = System::String::typeid;\n      array&lt;MemberInfo^&gt;^myMemberInfoArray = myType-&gt;FindMembers( static_cast&lt;MemberTypes&gt;(MemberTypes::Constructor | MemberTypes::Method), static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Static | BindingFlags::Instance), myFilter, MethodAttributes::SpecialName );\n      IEnumerator^ myEnum = myMemberInfoArray-&gt;GetEnumerator();\n      while ( myEnum-&gt;MoveNext() )\n      {\n         MemberInfo^ myMemberinfo = safe_cast&lt;MemberInfo^&gt;(myEnum-&gt;Current);\n         Console::Write( &quot;<br> {0}&quot;, myMemberinfo-&gt;Name );\n         Console::Write( &quot; is a {0}&quot;, myMemberinfo-&gt;MemberType );\n      }\n   }\n   catch ( ArgumentNullException^ e ) \n   {\n      Console::Write( &quot;ArgumentNullException : {0}&quot;, e-&gt;Message );\n   }\n   catch ( SecurityException^ e ) \n   {\n      Console::Write( &quot;SecurityException : {0}&quot;, e-&gt;Message );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::Write( &quot;Exception : {0}&quot;, e-&gt;Message );\n   }\n\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_FilterAttribute#1\">Imports System\nImports System.Reflection\nImports System.Security\nImports Microsoft.VisualBasic\n\nPublic Class MyFilterAttributeSample\n\n    Public Shared Sub Main()\n        Try\n            Dim myFilter As MemberFilter = Type.FilterAttribute\n            Dim myType As Type = GetType(System.String)\n            Dim myMemberInfoArray As MemberInfo() = myType.FindMembers(MemberTypes.Constructor Or MemberTypes.Method, BindingFlags.Public Or BindingFlags.Static Or BindingFlags.Instance, myFilter, MethodAttributes.SpecialName)\n            Dim myMemberinfo As MemberInfo\n            For Each myMemberinfo In myMemberInfoArray\n                Console.Write(ControlChars.newline + myMemberinfo.Name)\n                Console.Write(&quot; is a &quot; + myMemberinfo.MemberType.ToString())\n            Next myMemberinfo\n\n        Catch e As ArgumentNullException\n            Console.Write(&quot;ArgumentNullException : &quot; + e.Message.ToString())\n        Catch e As SecurityException\n            Console.Write(&quot;SecurityException : &quot; + e.Message.ToString())\n        Catch e As Exception\n            Console.Write(&quot;Exception :&quot; + e.Message.ToString())\n        End Try\n    End Sub &#39;Main\nEnd Class &#39;MyFilterAttributeSample\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_FilterName\">\r\n    \r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">FilterName</div>        \r\n          </div>\r\n    \r\n            <p>Represents the case-sensitive member filter used on names. This field is read-only.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static readonly System.Reflection.MemberFilter FilterName;</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This field holds a reference to the delegate used by the <a class=\"xref\" href=\"system.type#System_Type_FindMembers_\" data-linktype=\"relative-path\">FindMembers</a> method. The method encapsulated by this delegate takes two parameters: the first is a <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a> object and the second is an <code>Object</code>. The method determines whether the <code>MemberInfo</code> object matches the criteria specified by the <code>Object</code>. The <code>Object</code> is assigned a string value, which may include a trailing &quot;*&quot; wildcard character. Only wildcard end string matching is supported.  </p>\n<p> For example, the <code>Object</code> may be assigned the value &quot;Byte*&quot;. In that case, when the <code>FilterName</code> delegate is invoked, it will return <code>true</code> only if the method represented by the <code>MemberInfo</code> object has a name that begins with &quot;Byte&quot;.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example gets the methods associated with the user-defined <code>Application</code> type.  </p>\n<pre><code class=\"lang-cpp\" name=\"Classic Type.FilterName Example#1\">using namespace System;\nusing namespace System::Collections;\nusing namespace System::Reflection;\nusing namespace System::Security;\nint main()\n{\n   try\n   {\n      MemberFilter^ myFilter = Type::FilterNameIgnoreCase;\n      Type^ myType = System::String::typeid;\n      array&lt;MemberInfo^&gt;^myMemberinfo1 = myType-&gt;FindMembers( static_cast&lt;MemberTypes&gt;(MemberTypes::Constructor | MemberTypes::Method), static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Static | BindingFlags::Instance), myFilter, &quot;C*&quot; );\n      IEnumerator^ myEnum = myMemberinfo1-&gt;GetEnumerator();\n      while ( myEnum-&gt;MoveNext() )\n      {\n         MemberInfo^ myMemberinfo2 = safe_cast&lt;MemberInfo^&gt;(myEnum-&gt;Current);\n         Console::Write( &quot;<br> {0}&quot;, myMemberinfo2-&gt;Name );\n         MemberTypes Mymembertypes = myMemberinfo2-&gt;MemberType;\n         Console::WriteLine( &quot; is a {0}&quot;, Mymembertypes );\n      }\n   }\n   catch ( ArgumentNullException^ e ) \n   {\n      Console::Write( &quot;ArgumentNullException : {0}&quot;, e-&gt;Message );\n   }\n   catch ( SecurityException^ e ) \n   {\n      Console::Write( &quot;SecurityException : {0}&quot;, e-&gt;Message );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::Write( &quot;Exception : {0}&quot;, e-&gt;Message );\n   }\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Classic Type.FilterName Example#1\"> // Get the set of methods associated with the type\n MemberInfo[] mi = typeof(Application).FindMembers(MemberTypes.Constructor | \n     MemberTypes.Method, \n     BindingFlags.Public | BindingFlags.Static | BindingFlags.NonPublic |\n     BindingFlags.Instance | BindingFlags.DeclaredOnly,\n     Type.FilterName, &quot;*&quot;);\n   Console.WriteLine(&quot;Number of methods (includes constructors): &quot; + mi.Length);\n</code></pre><pre><code class=\"lang-vb\" name=\"Classic Type.FilterName Example#1\"> &#39; Get the set of methods associated with the type\n Dim mi As MemberInfo() = _\n    GetType(Application).FindMembers( _\n    MemberTypes.Constructor Or MemberTypes.Method, _\n    BindingFlags.DeclaredOnly, _\n    Type.FilterName, &quot;*&quot;)\n Console.WriteLine(&quot;Number of methods (includes constructors): &quot; &amp; _\n    mi.Length.ToString())\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_FilterNameIgnoreCase\">\r\n    \r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">FilterNameIgnoreCase</div>        \r\n          </div>\r\n    \r\n            <p>Represents the case-insensitive member filter used on names. This field is read-only.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This field holds a reference to the delegate used by the <a class=\"xref\" href=\"system.type#System_Type_FindMembers_\" data-linktype=\"relative-path\">FindMembers</a> method. The method encapsulated by this delegate takes two parameters: the first is a <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a> object and the second is an <code>Object</code>. The method determines whether the <code>MemberInfo</code> object matches the criteria specified by the <code>Object</code>. The <code>Object</code> is assigned a string value, which may include a trailing &quot;*&quot; wildcard character. Only wildcard end string matching is supported.  </p>\n<p> For example, the <code>Object</code> may be assigned the value &quot;ByTe*&quot;. In that case, when the <code>FilterName</code> delegate is invoked, it will return true only if the method represented by the <code>MemberInfo</code> object has a name that begins with &quot;byte&quot;, ignoring case.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example gets the <code>MemberFilter</code> delegate, passes it as a parameter to the <a class=\"xref\" href=\"system.type#System_Type_FindMembers_\" data-linktype=\"relative-path\">FindMembers</a> method, and displays the methods and their attributes of the <code>String</code> class that begin with the letter &quot;c&quot;, disregarding the case.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_FilterNameIgnoreCase#1\"> // Get the set of methods associated with the type\n MemberInfo[] mi = typeof(Application).FindMembers(MemberTypes.Constructor | \n     MemberTypes.Method, \n     BindingFlags.Public | BindingFlags.Static | BindingFlags.NonPublic |\n     BindingFlags.Instance | BindingFlags.DeclaredOnly,\n     Type.FilterName, &quot;*&quot;);\n   Console.WriteLine(&quot;Number of methods (includes constructors): &quot; + mi.Length);\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_FilterNameIgnoreCase#1\"> &#39; Get the set of methods associated with the type\n Dim mi As MemberInfo() = _\n    GetType(Application).FindMembers( _\n    MemberTypes.Constructor Or MemberTypes.Method, _\n    BindingFlags.DeclaredOnly, _\n    Type.FilterName, &quot;*&quot;)\n Console.WriteLine(&quot;Number of methods (includes constructors): &quot; &amp; _\n    mi.Length.ToString())\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_FilterNameIgnoreCase#1\">using namespace System;\nusing namespace System::Collections;\nusing namespace System::Reflection;\nusing namespace System::Security;\nint main()\n{\n   try\n   {\n      MemberFilter^ myFilter = Type::FilterNameIgnoreCase;\n      Type^ myType = System::String::typeid;\n      array&lt;MemberInfo^&gt;^myMemberinfo1 = myType-&gt;FindMembers( static_cast&lt;MemberTypes&gt;(MemberTypes::Constructor | MemberTypes::Method), static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Static | BindingFlags::Instance), myFilter, &quot;C*&quot; );\n      IEnumerator^ myEnum = myMemberinfo1-&gt;GetEnumerator();\n      while ( myEnum-&gt;MoveNext() )\n      {\n         MemberInfo^ myMemberinfo2 = safe_cast&lt;MemberInfo^&gt;(myEnum-&gt;Current);\n         Console::Write( &quot;<br> {0}&quot;, myMemberinfo2-&gt;Name );\n         MemberTypes Mymembertypes = myMemberinfo2-&gt;MemberType;\n         Console::WriteLine( &quot; is a {0}&quot;, Mymembertypes );\n      }\n   }\n   catch ( ArgumentNullException^ e ) \n   {\n      Console::Write( &quot;ArgumentNullException : {0}&quot;, e-&gt;Message );\n   }\n   catch ( SecurityException^ e ) \n   {\n      Console::Write( &quot;SecurityException : {0}&quot;, e-&gt;Message );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::Write( &quot;Exception : {0}&quot;, e-&gt;Message );\n   }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_Missing\">\r\n    \r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Missing</div>        \r\n          </div>\r\n    \r\n            <p>Represents a missing value in the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> information. This field is read-only.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static readonly object Missing;</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Use the <code>Missing</code> field for invocation through reflection to obtain the default value of a parameter. If the <code>Missing</code> field is passed in for a parameter value and there is no default value for that parameter, an <a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a> is thrown.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example shows the use of the <code>Missing</code> field to invoke a method with its default arguments.  </p>\n<pre><code class=\"lang-cs\" name=\"Classic Type.Missing Example#1\">using System;\nusing System.Reflection;\nusing System.CodeDom.Compiler;\n\nclass Example\n{\n    public static void Main()\n    {\n        // VB source for example. Not all versions of CS and CPP compilers\n        // support optional arguments.\n        string codeLines =\n            &quot;Imports System<br><br>&quot; +\n            &quot;Public Class OptionalArg<br>&quot; +\n            &quot;  Public Sub MyMethod(ByVal a As Integer, _<br>&quot; +\n            &quot;    Optional ByVal b As Double = 1.2, _<br>&quot; +\n            &quot;    Optional ByVal c As Integer = 1)<br><br>&quot; +\n            &quot;    Console.WriteLine(\\&quot;a = \\&quot; &amp; a &amp; \\&quot; b = \\&quot; &amp; b &amp; \\&quot; c = \\&quot; &amp; c)<br>&quot; +\n            &quot;  End Sub<br>&quot; +\n            &quot;End Class<br>&quot;;\n\n        // Generate a OptionalArg instance from the source above.\n        object o = GenerateObjectFromSource(&quot;OptionalArg&quot;, codeLines, &quot;VisualBasic&quot;);\n        Type t;\n\n        t = o.GetType();\n        BindingFlags bf = BindingFlags.Public | BindingFlags.Instance |\n            BindingFlags.InvokeMethod | BindingFlags.OptionalParamBinding;\n\n        t.InvokeMember(&quot;MyMethod&quot;, bf, null, o, new object[] {10, 55.3, 12});\n        t.InvokeMember(&quot;MyMethod&quot;, bf, null, o, new object[] {10, 1.3, Type.Missing});\n        t.InvokeMember(&quot;MyMethod&quot;, bf, null, o, new object[] {10, Type.Missing, Type.Missing});\n    }\n\n    private static object GenerateObjectFromSource(string objectName,\n        string sourceLines, string providerName)\n    {\n        object genObject = null;\n        CodeDomProvider codeProvider = CodeDomProvider.CreateProvider(providerName);\n        CompilerParameters cp = new CompilerParameters();\n\n        cp.GenerateExecutable = false;\n        cp.GenerateInMemory = true;\n\n        CompilerResults results =\n            codeProvider.CompileAssemblyFromSource(cp, sourceLines);\n        if (results.Errors.Count == 0)\n        {\n            genObject = results.CompiledAssembly.CreateInstance(objectName);\n        }\n\n        return genObject;\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"Classic Type.Missing Example#1\">#using &lt;System.dll&gt;\n\nusing namespace System;\nusing namespace System::Reflection;\nusing namespace System::CodeDom::Compiler;\n\nref class Example\n{\npublic:\n    static void Main()\n    {\n        // VB source for example. Not all versions of CS and CPP compilers\n        // support optional arguments.\n        String^ codeLines =\n            &quot;Imports System<br><br>&quot; +\n            &quot;Public Class OptionalArg<br>&quot; +\n            &quot;  Public Sub MyMethod(ByVal a As Integer, _<br>&quot; +\n            &quot;    Optional ByVal b As Double = 1.2, _<br>&quot; +\n            &quot;    Optional ByVal c As Integer = 1)<br><br>&quot; +\n            &quot;    Console.WriteLine(\\&quot;a = \\&quot; &amp; a &amp; \\&quot; b = \\&quot; &amp; b &amp; \\&quot; c = \\&quot; &amp; c)<br>&quot; +\n            &quot;  End Sub<br>&quot; +\n            &quot;End Class<br>&quot;;\n\n        // Generate a OptionalArg instance from the source above.\n        Object^ o = GenerateObjectFromSource(&quot;OptionalArg&quot;, codeLines, &quot;VisualBasic&quot;);\n        Type^ t;\n\n        t = o-&gt;GetType();\n        BindingFlags bf = BindingFlags::Public | BindingFlags::Instance |\n            BindingFlags::InvokeMethod | BindingFlags::OptionalParamBinding;\n\n        t-&gt;InvokeMember(&quot;MyMethod&quot;, bf, nullptr, o, gcnew array&lt;Object^&gt; {10, 55.3, 12});\n        t-&gt;InvokeMember(&quot;MyMethod&quot;, bf, nullptr, o, gcnew array&lt;Object^&gt; {10, 1.3, Type::Missing});\n        t-&gt;InvokeMember(&quot;MyMethod&quot;, bf, nullptr, o, gcnew array&lt;Object^&gt; {10, Type::Missing, Type::Missing});\n    }\n\nprivate:\n    static Object^ GenerateObjectFromSource(String^ objectName,\n        String^ sourceLines, String^ providerName)\n    {\n        Object^ genObject = nullptr;\n        CodeDomProvider^ codeProvider = CodeDomProvider::CreateProvider(providerName);\n        CompilerParameters^ cp = gcnew CompilerParameters();\n\n        cp-&gt;GenerateExecutable = false;\n        cp-&gt;GenerateInMemory = true;\n\n        CompilerResults^ results =\n            codeProvider-&gt;CompileAssemblyFromSource(cp, sourceLines);\n        if (results-&gt;Errors-&gt;Count == 0)\n        {\n            genObject = results-&gt;CompiledAssembly-&gt;CreateInstance(objectName);\n        }\n\n        return genObject;\n    }\n};\n\nint main()\n{\n    Example::Main();\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Classic Type.Missing Example#1\">Imports System\nImports System.Reflection\n\nPublic Class OptionalArg\n    Public Sub MyMethod(ByVal a As Integer, _\n        Optional ByVal b As Double = 1.2, _\n        Optional ByVal c As Integer = 1)\n        \n        Console.WriteLine(&quot;a = &quot; &amp; a &amp; &quot; b = &quot; &amp; b &amp; &quot; c = &quot; &amp; c)\n    End Sub\nEnd Class\n\nClass Example\n    Public Shared Sub Main()\n        Dim o As New OptionalArg()\n        Dim t As Type\n        t = GetType(OptionalArg)\n\n        Dim bf As BindingFlags = _\n            BindingFlags.Public Or BindingFlags.Instance Or _\n            BindingFlags.InvokeMethod Or BindingFlags.OptionalParamBinding\n\n        t.InvokeMember(&quot;MyMethod&quot;, bf, Nothing, o, New Object() {10, 55.3, 12})\n        t.InvokeMember(&quot;MyMethod&quot;, bf, Nothing, o, New Object() {10, 1.3, Type.Missing})\n        t.InvokeMember(&quot;MyMethod&quot;, bf, Nothing, o, New Object() {10, Type.Missing, Type.Missing})\n    End Sub\nEnd Class\n</code></pre><p> This code produces the following output:  </p>\n<p> a = 10 b = 55.3 c = 12  </p>\n<p> a = 10 b = 1.3 c = 1  </p>\n<p> a = 10 b = 1.2 c = 1</p>\n\r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"properties\">\r\n        <h2>Properties\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Type_Assembly\">\r\n    \r\n            <a id=\"System_Type_Assembly_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Assembly</div>        \r\n          </div>\r\n    \r\n            <p>Gets the <a class=\"xref\" href=\"system.reflection.assembly\" data-linktype=\"relative-path\">Assembly</a> in which the type is declared. For generic types, gets the <a class=\"xref\" href=\"system.reflection.assembly\" data-linktype=\"relative-path\">Assembly</a> in which the generic type is defined.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract System.Reflection.Assembly Assembly { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.assembly\" data-linktype=\"relative-path\">Assembly</a></div>\r\n                  </div>\r\n                  <p>An <a class=\"xref\" href=\"system.reflection.assembly\" data-linktype=\"relative-path\">Assembly</a> instance that describes the assembly containing the current type. For generic types, the instance describes the assembly that contains the generic type definition, not the assembly that creates and uses a particular constructed type.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents a constructed generic type, this property returns the assembly that contains the generic type definition. For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition <code>MyGenericStack&lt;T&gt;</code> (<code>MyGenericStack(Of T)</code> in Visual Basic, <code>generic&lt;T&gt; ref class MyGenericStack</code> in C++). If you create an instance of <code>MyGenericStack&lt;int&gt;</code> (<code>MyGenericStack(Of Integer)</code> in Visual Basic) in another assembly, the Assembly property for the constructed type returns an <a class=\"xref\" href=\"system.reflection.assembly\" data-linktype=\"relative-path\">Assembly</a> object that represents MyGenerics.dll.  </p>\n<p> Similarly, if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents an unassigned generic parameter <code>T</code>, this property returns the assembly that contains the generic type that defines <code>T</code>.  </p>\n<p> If the Assembly property is not available on a particular .NET platform, such as .NET Core or the Universal Windows Platform, use the  <code>System.Reflection.TypeInfo.Assembly</code> property instead. <a href=\"assetId:///?qualifyHint=False&amp;autoUpgrade=True\" data-linktype=\"external\">qualifyHint=False&amp;autoUpgrade=True</a>  </p>\n<p> This property is read-only.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example displays the assembly name associated with the class and the fully qualified name of the type.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_Assembly#1\">using namespace System;\nusing namespace System::Reflection;\nint main()\n{\n   Type^ objType = System::Array::typeid;\n   \n   // Print the full assembly name.\n   Console::WriteLine( &quot;Full assembly name: {0}.&quot;, objType-&gt;Assembly-&gt;FullName );\n   \n   // Print the qualified assembly name.\n   Console::WriteLine( &quot;Qualified assembly name: {0}.&quot;, objType-&gt;AssemblyQualifiedName );\n}\n// The example displays the following output if run under the .NET Framework 4.5:\n//    Full assembly name:\n//       mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089.\n//    Qualified assembly name:\n//       System.Array, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089.\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_Assembly#1\">Imports System.Reflection\n\nClass Example\n    Public Shared Sub Main()\n        Dim objType As Type = GetType(System.Array)\n        &#39; Display the full assembly name.\n        Console.WriteLine(&quot;Full assembly name:{1}   {0}.&quot;, \n                          objType.Assembly.FullName.ToString(), vbCrLf)\n        &#39; Display the qualified assembly name.\n        Console.WriteLine(&quot;Qualified assembly name: {1}   {0}.&quot;, \n                          objType.AssemblyQualifiedName.ToString(), vbCrLf)\n    End Sub\nEnd Class \n&#39; The example displays the following output if run under the .NET Framework 4.5:\n&#39;    Full assembly name:\n&#39;       mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089.\n&#39;    Qualified assembly name:\n&#39;       System.Array, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089.\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_Assembly#1\">using System;\nusing System.Reflection;\n\nclass MyAssemblyClass\n{\n    public static void Main()\n    {\n        Type objType = typeof(System.Array);\n                    \n        // Print the full assembly name.\n        Console.WriteLine (&quot;Full assembly name:<br>   {0}.&quot;, \n                           objType.Assembly.FullName.ToString()); \n\n        // Print the qualified assembly name.\n        Console.WriteLine (&quot;Qualified assembly name:<br>   {0}.&quot;, \n                           objType.AssemblyQualifiedName.ToString()); \n    }\n}\n// The example displays the following output if run under the .NET Framework 4.5:\n//    Full assembly name:\n//       mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089.\n//    Qualified assembly name:\n//       System.Array, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089.\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_AssemblyQualifiedName\">\r\n    \r\n            <a id=\"System_Type_AssemblyQualifiedName_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">AssemblyQualifiedName</div>        \r\n          </div>\r\n    \r\n            <p>Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object was loaded.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract string AssemblyQualifiedName { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </div>\r\n                  <p>The assembly-qualified name of the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, which includes the name of the assembly from which the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> was loaded, or <code>null</code> if the current instance represents a generic type parameter.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly. The display name of an assembly is obtained using the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_FullName_\" data-linktype=\"relative-path\">FullName</a> property.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, &quot;ProcessorArchitecture=msil&quot;. However, it is not included in the string returned by the AssemblyQualifiedName property, for compatibility reasons. See <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_ProcessorArchitecture_\" data-linktype=\"relative-path\">ProcessorArchitecture</a>.  </p>\n</div>\n<p> All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.  </p>\n<table>\n<thead>\n<tr>\n<th>Delimiter</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Backslash (\\)</td>\n<td>Escape character.</td>\n</tr>\n<tr>\n<td>Comma (,)</td>\n<td>Precedes the Assembly name.</td>\n</tr>\n<tr>\n<td>Plus sign (+)</td>\n<td>Precedes a nested class.</td>\n</tr>\n<tr>\n<td>Period (.)</td>\n<td>Denotes namespace identifiers.</td>\n</tr>\n<tr>\n<td>Brackets ([])</td>\n<td>After a type name, denotes an array of that type.<br><br> -or-<br><br> For a generic type, encloses the generic type argument list.<br><br> -or-<br><br> Within a type argument list, encloses an assembly-qualified type.</td>\n</tr>\n</tbody>\n</table>\n<p> For example, the assembly-qualified name for a class might look like this:  </p>\n<pre><code>TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089\n</code></pre><p> If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (\\) to prevent it from being interpreted as a nesting separator. Reflection would emit this string as follows:  </p>\n<pre><code>TopNamespace.Sub\\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089\n</code></pre><p> A &quot;++&quot; becomes &quot;\\+\\+&quot;, and a &quot;\\&quot; becomes &quot;\\\\&quot;.  </p>\n<p> This qualified name can be persisted and later used to load the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>. To search for and load a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, use <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> either with the type name only or with the assembly qualified type name. <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> with the type name only will look for the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> in the caller&#39;s assembly and then in the System assembly. <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> with the assembly qualified type name will look for the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> in any assembly.  </p>\n<p> Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use <code>t.GetElementType().ToString()</code>, where <code>t</code> is the type.  </p>\n<p> Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the &#39;,&#39; separator are relevant, but spaces after the &#39;,&#39; separator are ignored.  </p>\n<p> Generic arguments of generic types are themselves qualified by assembly name. For example, in the assembly-qualified type name for <code>MyGenericClass&lt;int&gt;</code> (<code>MyGenericClass(Of Integer)</code> in Visual Basic), <code>int</code> is expanded to the assembly-qualified type name for <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a>.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents a generic parameter, this property returns <code>null</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example displays the assembly name associated with the class and the fully qualified name of the type.  </p>\n<pre><code class=\"lang-cpp\" name=\"type_assembly#1\">using namespace System;\nusing namespace System::Reflection;\nint main()\n{\n   Type^ objType = System::Array::typeid;\n   \n   // Print the full assembly name.\n   Console::WriteLine( &quot;Full assembly name: {0}.&quot;, objType-&gt;Assembly-&gt;FullName );\n   \n   // Print the qualified assembly name.\n   Console::WriteLine( &quot;Qualified assembly name: {0}.&quot;, objType-&gt;AssemblyQualifiedName );\n}\n// The example displays the following output if run under the .NET Framework 4.5:\n//    Full assembly name:\n//       mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089.\n//    Qualified assembly name:\n//       System.Array, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089.\n</code></pre><pre><code class=\"lang-vb\" name=\"type_assembly#1\">Imports System.Reflection\n\nClass Example\n    Public Shared Sub Main()\n        Dim objType As Type = GetType(System.Array)\n        &#39; Display the full assembly name.\n        Console.WriteLine(&quot;Full assembly name:{1}   {0}.&quot;, \n                          objType.Assembly.FullName.ToString(), vbCrLf)\n        &#39; Display the qualified assembly name.\n        Console.WriteLine(&quot;Qualified assembly name: {1}   {0}.&quot;, \n                          objType.AssemblyQualifiedName.ToString(), vbCrLf)\n    End Sub\nEnd Class \n&#39; The example displays the following output if run under the .NET Framework 4.5:\n&#39;    Full assembly name:\n&#39;       mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089.\n&#39;    Qualified assembly name:\n&#39;       System.Array, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089.\n</code></pre><pre><code class=\"lang-cs\" name=\"type_assembly#1\">using System;\nusing System.Reflection;\n\nclass MyAssemblyClass\n{\n    public static void Main()\n    {\n        Type objType = typeof(System.Array);\n                    \n        // Print the full assembly name.\n        Console.WriteLine (&quot;Full assembly name:<br>   {0}.&quot;, \n                           objType.Assembly.FullName.ToString()); \n\n        // Print the qualified assembly name.\n        Console.WriteLine (&quot;Qualified assembly name:<br>   {0}.&quot;, \n                           objType.AssemblyQualifiedName.ToString()); \n    }\n}\n// The example displays the following output if run under the .NET Framework 4.5:\n//    Full assembly name:\n//       mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089.\n//    Qualified assembly name:\n//       System.Array, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089.\n</code></pre><p> The following example compares the strings returned by the <a class=\"xref\" href=\"system.type#System_Type_ToString_\" data-linktype=\"relative-path\">ToString</a> method and the <code>Name</code>, <a class=\"xref\" href=\"system.type#System_Type_FullName_\" data-linktype=\"relative-path\">FullName</a>, and AssemblyQualifiedName properties.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Type.ToString#1\">Imports System.Collections.Generic\nImports System.Globalization\n\nModule Example\n   Public Sub Main()\n      Dim t As Type = GetType(String)\n      ShowTypeInfo(t)\n\n      t = GetType(System.Collections.Generic.List(Of))\n      ShowTypeInfo(t)\n\n      Dim list As New List(Of String)()\n      t = list.GetType()\n      ShowTypeInfo(t)\n      \n      Dim v As Object = 12\n      t = v.GetType()\n      ShowTypeInfo(t)\n      \n      t = GetType(IFormatProvider)\n      ShowTypeInfo(t)\n      \n      Dim ifmt As IFormatProvider = NumberFormatInfo.CurrentInfo\n      t = ifmt.GetType()\n      ShowTypeInfo(t)\n   End Sub\n   \n   Private Sub ShowTypeInfo(t As Type)\n      Console.WriteLine(&quot;Name: {0}&quot;, t.Name)\n      Console.WriteLine(&quot;Full Name: {0}&quot;, t.FullName)\n      Console.WriteLine(&quot;ToString:  {0}&quot;, t.ToString())\n      Console.WriteLine(&quot;Assembly Qualified Name: {0}&quot;, t.AssemblyQualifiedName)\n      Console.WriteLine()\n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;    Name: String\n&#39;    Full Name: System.String\n&#39;    ToString:  System.String\n&#39;    Assembly Qualified Name: System.String, mscorlib, Version=4.0.0.0, Culture=neutr\n&#39;    al, PublicKeyToken=b77a5c561934e089\n&#39;\n&#39;    Name: List`1\n&#39;    Full Name: System.Collections.Generic.List`1\n&#39;    ToString:  System.Collections.Generic.List`1[T]\n&#39;    Assembly Qualified Name: System.Collections.Generic.List`1, mscorlib, Version=4.\n&#39;    0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\n&#39;\n&#39;    Name: List`1\n&#39;    Full Name: System.Collections.Generic.List`1[[System.String, mscorlib, Version=4\n&#39;    .0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]\n&#39;    ToString:  System.Collections.Generic.List`1[System.String]\n&#39;    Assembly Qualified Name: System.Collections.Generic.List`1[[System.String, mscor\n&#39;    lib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], mscorl\n&#39;    ib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\n&#39;\n&#39;    Name: Int32\n&#39;    Full Name: System.Int32\n&#39;    ToString:  System.Int32\n&#39;    Assembly Qualified Name: System.Int32, mscorlib, Version=4.0.0.0, Culture=neutra\n&#39;    l, PublicKeyToken=b77a5c561934e089\n&#39;\n&#39;    Name: IFormatProvider\n&#39;    Full Name: System.IFormatProvider\n&#39;    ToString:  System.IFormatProvider\n&#39;    Assembly Qualified Name: System.IFormatProvider, mscorlib, Version=4.0.0.0, Cult\n&#39;    ure=neutral, PublicKeyToken=b77a5c561934e089\n&#39;\n&#39;    Name: NumberFormatInfo\n&#39;    Full Name: System.Globalization.NumberFormatInfo\n&#39;    ToString:  System.Globalization.NumberFormatInfo\n&#39;    Assembly Qualified Name: System.Globalization.NumberFormatInfo, mscorlib, Versio\n&#39;    n=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.ToString#1\">using System;\nusing System.Collections.Generic;\nusing System.Globalization;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Type t = typeof(String);\n      ShowTypeInfo(t);\n\n      t = typeof(System.Collections.Generic.List&lt;&gt;);\n      ShowTypeInfo(t);\n\n      var list = new List&lt;String&gt;();\n      t = list.GetType();\n      ShowTypeInfo(t);\n\n      Object v = 12;\n      t = v.GetType();\n      ShowTypeInfo(t);\n\n      t = typeof(IFormatProvider);\n      ShowTypeInfo(t);\n\n      IFormatProvider ifmt = NumberFormatInfo.CurrentInfo;\n      t = ifmt.GetType();\n      ShowTypeInfo(t);\n   }\n\n   private static void ShowTypeInfo(Type t)\n   {\n      Console.WriteLine(&quot;Name: {0}&quot;, t.Name);\n      Console.WriteLine(&quot;Full Name: {0}&quot;, t.FullName);\n      Console.WriteLine(&quot;ToString:  {0}&quot;, t.ToString());\n      Console.WriteLine(&quot;Assembly Qualified Name: {0}&quot;,\n                        t.AssemblyQualifiedName);\n      Console.WriteLine();\n   }\n}\n// The example displays output like the following:\n//    Name: String\n//    Full Name: System.String\n//    ToString:  System.String\n//    Assembly Qualified Name: System.String, mscorlib, Version=4.0.0.0, Culture=neutr\n//    al, PublicKeyToken=b77a5c561934e089\n//\n//    Name: List`1\n//    Full Name: System.Collections.Generic.List`1\n//    ToString:  System.Collections.Generic.List`1[T]\n//    Assembly Qualified Name: System.Collections.Generic.List`1, mscorlib, Version=4.\n//    0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\n//\n//    Name: List`1\n//    Full Name: System.Collections.Generic.List`1[[System.String, mscorlib, Version=4\n//    .0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]\n//    ToString:  System.Collections.Generic.List`1[System.String]\n//    Assembly Qualified Name: System.Collections.Generic.List`1[[System.String, mscor\n//    lib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], mscorl\n//    ib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\n//\n//    Name: Int32\n//    Full Name: System.Int32\n//    ToString:  System.Int32\n//    Assembly Qualified Name: System.Int32, mscorlib, Version=4.0.0.0, Culture=neutra\n//    l, PublicKeyToken=b77a5c561934e089\n//\n//    Name: IFormatProvider\n//    Full Name: System.IFormatProvider\n//    ToString:  System.IFormatProvider\n//    Assembly Qualified Name: System.IFormatProvider, mscorlib, Version=4.0.0.0, Cult\n//    ure=neutral, PublicKeyToken=b77a5c561934e089\n//\n//    Name: NumberFormatInfo\n//    Full Name: System.Globalization.NumberFormatInfo\n//    ToString:  System.Globalization.NumberFormatInfo\n//    Assembly Qualified Name: System.Globalization.NumberFormatInfo, mscorlib, Versio\n//    n=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_Attributes\">\r\n    \r\n            <a id=\"System_Type_Attributes_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Attributes</div>        \r\n          </div>\r\n    \r\n            <p>Gets the attributes associated with the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.TypeAttributes Attributes { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">TypeAttributes</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">TypeAttributes</a> object representing the attribute set of the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, unless the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a generic type parameter, in which case the value is unspecified.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Some members of the <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">TypeAttributes</a> enumeration are masks that represent a group of values. Each group includes one member whose underlying value is zero. For example, the underlying value of the <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a> member in the <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a> group is zero, as is the <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a> member in the <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a> group. Because of this, you must use the mask before testing for those values. The example provides an illustration.  </p>\n<div class=\"TIP\"><h5>Tip</h5><p> For most purposes, properties like<a class=\"xref\" href=\"system.type#System_Type_IsClass_\" data-linktype=\"relative-path\">IsClass</a>,<a class=\"xref\" href=\"system.type#System_Type_IsAutoLayout_\" data-linktype=\"relative-path\">IsAutoLayout</a>, and<a class=\"xref\" href=\"system.type#System_Type_IsSpecialName_\" data-linktype=\"relative-path\">IsSpecialName</a> are easier to use than type attributes.  </p>\n</div>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this property returns the attributes of the generic type definition. For example, the attributes returned for <code>MyGenericClass&lt;int&gt;</code> (<code>MyGenericClass(Of Integer)</code> in Visual Basic) are the attributes of <code>MyGenericClass&lt;T&gt;</code> (<code>MyGenericClass(Of T)</code> in Visual Basic).  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a generic type parameter  that is, if the <a class=\"xref\" href=\"system.type#System_Type_IsGenericParameter_\" data-linktype=\"relative-path\">IsGenericParameter</a> property returns <code>true</code>  the <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">TypeAttributes</a> value returned by this property is unspecified.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example usesthe Attributes property.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Type.Attributes#1\">Imports System.Reflection\n\nFriend Structure S\n    Public X As Integer\nEnd Structure\n\nPublic MustInherit Class Example\n    Protected NotInheritable Class NestedClass\n    End Class\n\n    Public Interface INested\n    End Interface\n\n    Public Shared Sub Main()\n        &#39; Create an array of types.\n        Dim types() As Type = { GetType(Example), GetType(NestedClass),\n                                GetType(INested), GetType(S) }\n\n        For Each t In types\n           Console.WriteLine(&quot;Attributes for type {0}:&quot;, t.Name)\n\n           Dim attr As TypeAttributes = t.Attributes\n\n           &#39; Use the visibility mask to test for visibility attributes.\n           Dim visibility As TypeAttributes = attr And TypeAttributes.VisibilityMask\n           Select Case visibility\n               Case TypeAttributes.NotPublic:\n                   Console.WriteLine(&quot;   ...is not Public&quot;)\n               Case TypeAttributes.Public:\n                   Console.WriteLine(&quot;   ...is Public&quot;)\n               Case TypeAttributes.NestedPublic:\n                   Console.WriteLine(&quot;   ...is nested and Public&quot;)\n               Case TypeAttributes.NestedPrivate:\n                   Console.WriteLine(&quot;   ...is nested and Private&quot;)\n               Case TypeAttributes.NestedFamANDAssem:\n                   Console.WriteLine(&quot;   ...is nested, and inheritable only within the assembly&quot; &amp; _\n                      vbLf &amp; &quot;         (cannot be declared in Visual Basic)&quot;)\n               Case TypeAttributes.NestedAssembly:\n                   Console.WriteLine(&quot;   ...is nested and Friend&quot;)\n               Case TypeAttributes.NestedFamily:\n                   Console.WriteLine(&quot;   ...is nested and Protected&quot;)\n               Case TypeAttributes.NestedFamORAssem:\n                   Console.WriteLine(&quot;   ...is nested and Protected Friend&quot;)\n           End Select\n\n           &#39; Use the layout mask to test for layout attributes.\n           Dim layout As TypeAttributes = attr And TypeAttributes.LayoutMask\n           Select Case layout\n               Case TypeAttributes.AutoLayout:\n                   Console.WriteLine(&quot;   ...is AutoLayout&quot;)\n               Case TypeAttributes.SequentialLayout:\n                   Console.WriteLine(&quot;   ...is SequentialLayout&quot;)\n               Case TypeAttributes.ExplicitLayout:\n                   Console.WriteLine(&quot;   ...is ExplicitLayout&quot;)\n           End Select\n\n           &#39; Use the class semantics mask to test for class semantics attributes.\n           Dim classSemantics As TypeAttributes = attr And TypeAttributes.ClassSemanticsMask\n           Select Case classSemantics\n               Case TypeAttributes.Class:\n                   If t.IsValueType Then\n                       Console.WriteLine(&quot;   ...is a value type&quot;)\n                   Else\n                       Console.WriteLine(&quot;   ...is a class&quot;)\n                   End If\n               Case TypeAttributes.Interface:\n                   Console.WriteLine(&quot;   ...is an interface&quot;)\n           End Select\n\n           If 0 &lt;&gt; (attr And TypeAttributes.Abstract) Then _\n               Console.WriteLine(&quot;   ...is MustInherit&quot;)\n\n           If 0 &lt;&gt; (attr And TypeAttributes.Sealed) Then _\n               Console.WriteLine(&quot;   ...is NotInheritable&quot;)\n           Console.WriteLine()\n       Next\n    End Sub\nEnd Class\n&#39; The example displays the following output:\n&#39;       Attributes for type Example:\n&#39;          ...is Public\n&#39;          ...is AutoLayout\n&#39;          ...is a class\n&#39;          ...is MustInherit\n&#39;\n&#39;       Attributes for type NestedClass:\n&#39;          ...is nested and Protected\n&#39;          ...is AutoLayout\n&#39;          ...is a class\n&#39;          ...is NotInheritable\n&#39;\n&#39;       Attributes for type INested:\n&#39;          ...is nested and Public\n&#39;          ...is AutoLayout\n&#39;          ...is an interface\n&#39;          ...is MustInherit\n&#39;\n&#39;       Attributes for type S:\n&#39;          ...is not Public\n&#39;          ...is SequentialLayout\n&#39;          ...is a value type\n&#39;          ...is NotInheritable\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.Attributes#1\">using System;\nusing System.Reflection;\n\ninternal struct S\n{\n    public int X;\n}\n\npublic abstract class Example\n{\n    protected sealed class NestedClass {}\n\n    public interface INested {}\n\n    public static void Main()\n    {\n        // Create an array of types.\n        Type[] types = { typeof(Example), typeof(NestedClass),\n                         typeof(INested), typeof(S) };\n\n        foreach (var t in types) {\n           Console.WriteLine(&quot;Attributes for type {0}:&quot;, t.Name);\n\n           TypeAttributes attr = t.Attributes;\n\n           // To test for visibility attributes, you must use the visibility mask.\n           TypeAttributes visibility = attr &amp; TypeAttributes.VisibilityMask;\n           switch (visibility)\n           {\n               case TypeAttributes.NotPublic:\n                   Console.WriteLine(&quot;   ...is not public&quot;);\n                   break;\n               case TypeAttributes.Public:\n                   Console.WriteLine(&quot;   ...is public&quot;);\n                   break;\n               case TypeAttributes.NestedPublic:\n                   Console.WriteLine(&quot;   ...is nested and public&quot;);\n                   break;\n               case TypeAttributes.NestedPrivate:\n                   Console.WriteLine(&quot;   ...is nested and private&quot;);\n                   break;\n               case TypeAttributes.NestedFamANDAssem:\n                   Console.WriteLine(&quot;   ...is nested, and inheritable only within the assembly&quot; +\n                      &quot;<br>         (cannot be declared in C#)&quot;);\n                   break;\n               case TypeAttributes.NestedAssembly:\n                   Console.WriteLine(&quot;   ...is nested and internal&quot;);\n                   break;\n               case TypeAttributes.NestedFamily:\n                   Console.WriteLine(&quot;   ...is nested and protected&quot;);\n                   break;\n               case TypeAttributes.NestedFamORAssem:\n                   Console.WriteLine(&quot;   ...is nested and protected internal&quot;);\n                   break;\n           }\n\n           &#39; Use the layout mask to test for layout attributes.\n           TypeAttributes layout = attr &amp; TypeAttributes.LayoutMask;\n           switch (layout)\n           {\n               case TypeAttributes.AutoLayout:\n                   Console.WriteLine(&quot;   ...is AutoLayout&quot;);\n                   break;\n               case TypeAttributes.SequentialLayout:\n                   Console.WriteLine(&quot;   ...is SequentialLayout&quot;);\n                   break;\n               case TypeAttributes.ExplicitLayout:\n                   Console.WriteLine(&quot;   ...is ExplicitLayout&quot;);\n                   break;\n           }\n\n           &#39; Use the class semantics mask to test for class semantics attributes.\n           TypeAttributes classSemantics = attr &amp; TypeAttributes.ClassSemanticsMask;\n           switch (classSemantics)\n           {\n               case TypeAttributes.Class:\n                   if (t.IsValueType)\n                   {\n                       Console.WriteLine(&quot;   ...is a value type&quot;);\n                   }\n                   else\n                   {\n                       Console.WriteLine(&quot;   ...is a class&quot;);\n                   }\n                   break;\n               case TypeAttributes.Interface:\n                   Console.WriteLine(&quot;   ...is an interface&quot;);\n                   break;\n           }\n\n           if (0!=(attr &amp; TypeAttributes.Abstract))\n           {\n               Console.WriteLine(&quot;   ...is abstract&quot;);\n           }\n\n           if (0!=(attr &amp; TypeAttributes.Sealed))\n           {\n               Console.WriteLine(&quot;   ...is sealed&quot;);\n           }\n           Console.WriteLine();\n       }\n    }\n}\n// The example displays the following output:\n//       Attributes for type Example:\n//          ...is Public\n//          ...is AutoLayout\n//          ...is a class\n//          ...is MustInherit\n//\n//       Attributes for type NestedClass:\n//          ...is nested and Protected\n//          ...is AutoLayout\n//          ...is a class\n//          ...is NotInheritable\n//\n//       Attributes for type INested:\n//          ...is nested and Public\n//          ...is AutoLayout\n//          ...is an interface\n//          ...is MustInherit\n//\n//       Attributes for type S:\n//          ...is not Public\n//          ...is SequentialLayout\n//          ...is a value type\n//          ...is NotInheritable\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_BaseType\">\r\n    \r\n            <a id=\"System_Type_BaseType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">BaseType</div>        \r\n          </div>\r\n    \r\n            <p>Gets the type from which the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> directly inherits.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract Type BaseType { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>The <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> from which the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> directly inherits, or <code>null</code> if the current <code>Type</code> represents the <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a> class or an interface.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The base type is the type from which the current type directly inherits. <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a> is the only type that does not have a base type, therefore <code>null</code> is returned as the base type of <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>.  </p>\n<p> Interfaces inherit from zero or more base interfaces; therefore, this property returns <code>null</code> if the <code>Type</code> object represents an interface. The base interfaces can be determined with <a class=\"xref\" href=\"system.type#System_Type_GetInterfaces_\" data-linktype=\"relative-path\">GetInterfaces</a> or <a class=\"xref\" href=\"system.type#System_Type_FindInterfaces_\" data-linktype=\"relative-path\">FindInterfaces</a>.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, the base type reflects the generic arguments. For example, consider the following declarations:  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Type.BaseType#1\">generic&lt;typename U&gt; ref class B { };\ngeneric&lt;typename T&gt; ref class C : B&lt;T&gt; { };\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.BaseType#1\">Class B(Of U)\nEnd Class\nClass C(Of T)\n    Inherits B(Of T)\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.BaseType#1\">class B&lt;U&gt; { }\nclass C&lt;T&gt; : B&lt;T&gt; { }\n</code></pre><p> For the constructed type <code>C&lt;int&gt;</code> (<code>C(Of Integer)</code> in Visual Basic), the BaseType property returns <code>B&lt;int&gt;</code>.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter of a generic type definition, BaseType returns the class constraint, that is, the class the type parameter must inherit. If there is no class constraint, BaseType returns <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a>.  </p>\n<p> This property is read-only.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example demonstrates using the BaseType property.  </p>\n<pre><code class=\"lang-cpp\" name=\"TestBaseType#1\">using namespace System;\nvoid main()\n{\n   Type^ t = int::typeid;\n   Console::WriteLine( &quot;{0} inherits from {1}.&quot;, t, t-&gt;BaseType );\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"TestBaseType#1\">using System;\nclass TestType \n{\n    public static void Main() \n    {\n        Type t = typeof(int);\n        Console.WriteLine(&quot;{0} inherits from {1}.&quot;, t,t.BaseType);\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"TestBaseType#1\">Imports System\n\nClass TestType\n   \n    Public Shared Sub Main()\n        Dim t As Type = GetType(Integer)\n        Console.WriteLine(&quot;{0} inherits from {1}.&quot;, t, t.BaseType)\n    End Sub &#39;Main\nEnd Class &#39;TestType\n</code></pre><p> The following example uses recursion to list the complete inheritance hierarchy of each class found in an assembly. The example defines a class named <code>C</code> that derives from a class named <code>B</code>, which, in turn, derives from a class named <code>A</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.BaseType#2\">using System;\n\npublic class Example\n{\n   public static void Main()\n   {\n      foreach (var t in typeof(Example).Assembly.GetTypes()) {\n         Console.WriteLine(&quot;{0} derived from: &quot;, t.FullName);\n         var derived = t;\n         do { \n            derived = derived.BaseType;\n            if (derived != null) \n               Console.WriteLine(&quot;   {0}&quot;, derived.FullName);\n\n         } while (derived != null);\n         Console.WriteLine(); \n      } \n   }\n}\n\npublic class A {} \n\npublic class B : A\n{}\n\npublic class C : B   \n{}\n// The example displays the following output:\n//       Example derived from:\n//          System.Object\n//       \n//       A derived from:\n//          System.Object\n//       \n//       B derived from:\n//          A\n//          System.Object\n//       \n//       C derived from:\n//          B\n//          A\n//          System.Object\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.BaseType#2\">Public Class Example\n   Public Shared Sub Main()\n      For Each t In GetType(Example).Assembly.GetTypes()\n         Console.WriteLine(&quot;{0} derived from: &quot;, t.FullName)\n         Dim derived As Type = t\n         Do \n            derived = derived.BaseType\n            If derived IsNot Nothing Then \n               Console.WriteLine(&quot;   {0}&quot;, derived.FullName)\n            End If   \n         Loop While derived IsNot Nothing\n         Console.WriteLine() \n      Next \n   End Sub\nEnd Class\n\nPublic Class A \nEnd Class\n\nPublic Class B : Inherits A\nEnd Class\n\nPublic Class C : Inherits B\nEnd Class\n&#39; The example displays the following output:\n&#39;       Example derived from:\n&#39;          System.Object\n&#39;       \n&#39;       A derived from:\n&#39;          System.Object\n&#39;       \n&#39;       B derived from:\n&#39;          A\n&#39;          System.Object\n&#39;       \n&#39;       C derived from:\n&#39;          B\n&#39;          A\n&#39;          System.Object\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_ContainsGenericParameters\">\r\n    \r\n            <a id=\"System_Type_ContainsGenericParameters_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ContainsGenericParameters</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object has type parameters that have not been replaced by specific types.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool ContainsGenericParameters { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object is itself a generic type parameter or has type parameters for which specific types have not been supplied; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type. Another way of saying this is that when examined recursively, the type must contain no generic type parameters.  </p>\n<p> Since types can be arbitrarily complex, making this determination is difficult. For convenience and to reduce the chance of error, the ContainsGenericParameters property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot. If the ContainsGenericParameters property returns <code>true</code>, the type cannot be instantiated.  </p>\n<p> The ContainsGenericParameters property searches recursively for type parameters. For example, it returns <code>true</code> for an array whose elements are type <code>A&lt;T&gt;</code> (<code>A(Of T)</code> in Visual Basic), even though the array is not itself generic. Contrast this with the behavior of the <a class=\"xref\" href=\"system.type#System_Type_IsGenericType_\" data-linktype=\"relative-path\">IsGenericType</a> property, which returns <code>false</code> for arrays.  </p>\n<p> For a set of example classes and a table showing the values of the ContainsGenericParameters property, see <a class=\"xref\" href=\"system.type#System_Type_IsGenericType_\" data-linktype=\"relative-path\">IsGenericType</a>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example defines a generic class with two type parameters and then defines a second generic class that derives from the first class. The derived class&#39;s base class has two type arguments: the first is <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a> and the second is a type parameter of the derived type. The example displays information about these generic classes, including the positions reported by the <a class=\"xref\" href=\"system.type#System_Type_GenericParameterPosition_\" data-linktype=\"relative-path\">GenericParameterPosition</a> property.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.HasUnboundGenericParameters#1\">using System;\nusing System.Reflection;\nusing System.Collections.Generic;\n\n// Define a base class with two type parameters.\npublic class Base&lt;T, U&gt; { }\n\n// Define a derived class. The derived class inherits from a constructed\n// class that meets the following criteria:\n//   (1) Its generic type definition is Base&lt;T, U&gt;.\n//   (2) It specifies int for the first type parameter.\n//   (3) For the second type parameter, it uses the same type that is used\n//       for the type parameter of the derived class.\n// Thus, the derived class is a generic type with one type parameter, but\n// its base class is an open constructed type with one type argument and\n// one type parameter.\npublic class Derived&lt;V&gt; : Base&lt;int, V&gt; { }\n\npublic class Test\n{\n    public static void Main()\n    {\n        Console.WriteLine(\n            &quot;\\r<br>--- Display a generic type and the open constructed&quot;);\n        Console.WriteLine(&quot;    type from which it is derived.&quot;);\n\n        // Create a Type object representing the generic type definition \n        // for the Derived type, by omitting the type argument. (For\n        // types with multiple type parameters, supply the commas but\n        // omit the type arguments.) \n        //\n        Type derivedType = typeof(Derived&lt;&gt;);\n        DisplayGenericTypeInfo(derivedType);\n\n        // Display its open constructed base type.\n        DisplayGenericTypeInfo(derivedType.BaseType);\n    }\n\n    private static void DisplayGenericTypeInfo(Type t)\n    {\n        Console.WriteLine(&quot;\\r<br>{0}&quot;, t);\n\n        Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;Is this a generic type definition? {0}&quot;, \n            t.IsGenericTypeDefinition);\n\n        Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;Is it a generic type? {0}&quot;, \n            t.IsGenericType);\n\n        Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;Does it have unassigned generic parameters? {0}&quot;, \n            t.ContainsGenericParameters);\n\n        if (t.IsGenericType)\n        {\n            // If this is a generic type, display the type arguments.\n            //\n            Type[] typeArguments = t.GetGenericArguments();\n\n            Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;List type arguments ({0}):&quot;, \n                typeArguments.Length);\n\n            foreach (Type tParam in typeArguments)\n            {\n                // IsGenericParameter is true only for generic type\n                // parameters.\n                //\n                if (tParam.IsGenericParameter)\n                {\n                    Console.WriteLine(\n                        &quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}  (unassigned - parameter position {1})&quot;,\n                        tParam,\n                        tParam.GenericParameterPosition);\n                }\n                else\n                {\n                    Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;, tParam);\n                }\n            }\n        }\n    }\n}\n\n/* This example produces the following output:\n\n--- Display a generic type and the open constructed\n    type from which it is derived.\n\nDerived`1[V]\n        Is this a generic type definition? True\n        Is it a generic type? True\n        Does it have unassigned generic parameters? True\n        List type arguments (1):\n                V  (unassigned - parameter position 0)\n\nBase`2[System.Int32,V]\n        Is this a generic type definition? False\n        Is it a generic type? True\n        Does it have unassigned generic parameters? True\n        List type arguments (2):\n                System.Int32\n                V  (unassigned - parameter position 0)\n */\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Type.HasUnboundGenericParameters#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Collections::Generic;\n\n// Define a base class with two type parameters.\ngeneric&lt; class T,class U &gt;\npublic ref class Base {};\n\n// Define a derived class. The derived class inherits from a constructed\n// class that meets the following criteria:\n//   (1) Its generic type definition is Base&lt;T, U&gt;.\n//   (2) It specifies int for the first type parameter.\n//   (3) For the second type parameter, it uses the same type that is used\n//       for the type parameter of the derived class.\n// Thus, the derived class is a generic type with one type parameter, but\n// its base class is an open constructed type with one type argument and\n// one type parameter.\ngeneric&lt;class V&gt;\npublic ref class Derived : Base&lt;int,V&gt; {};\n\npublic ref class Test\n{\npublic:\n    static void Main()\n    {\n        Console::WriteLine( \n            L&quot;\\r<br>--- Display a generic type and the open constructed&quot;);\n        Console::WriteLine(L&quot;    type from which it is derived.&quot;);\n      \n        // Create a Type object representing the generic type definition\n        // for the Derived type. Note the absence of type arguments.\n        //\n        Type^ derivedType = Derived::typeid;\n        DisplayGenericTypeInfo(derivedType);\n      \n        // Display its open constructed base type.\n        DisplayGenericTypeInfo(derivedType-&gt;BaseType);\n    }\n\n\nprivate:\n    static void DisplayGenericTypeInfo(Type^ t)\n    {\n        Console::WriteLine(L&quot;\\r<br>{0}&quot;, t);\n        Console::WriteLine(L&quot;&nbsp;&nbsp;&nbsp;&nbsp;Is this a generic type definition? {0}&quot;,\n            t-&gt;IsGenericTypeDefinition);\n        Console::WriteLine(L&quot;&nbsp;&nbsp;&nbsp;&nbsp;Is it a generic type? {0}&quot;, t-&gt;IsGenericType);\n        Console::WriteLine(L&quot;&nbsp;&nbsp;&nbsp;&nbsp;Does it have unassigned generic parameters? {0}&quot;,\n            t-&gt;ContainsGenericParameters);\n        if (t-&gt;IsGenericType)\n        {\n         \n            // If this is a generic type, display the type arguments.\n            //\n            array&lt;Type^&gt;^typeArguments = t-&gt;GetGenericArguments();\n            Console::WriteLine(L&quot;&nbsp;&nbsp;&nbsp;&nbsp;List type arguments ({0}):&quot;,\n                typeArguments-&gt;Length);\n            System::Collections::IEnumerator^ myEnum = \n                typeArguments-&gt;GetEnumerator();\n            while (myEnum-&gt;MoveNext())\n            {\n                Type^ tParam = safe_cast&lt;Type^&gt;(myEnum-&gt;Current);\n            \n                // IsGenericParameter is true only for generic type\n                // parameters.\n                //\n                if (tParam-&gt;IsGenericParameter)\n                {\n                    Console::WriteLine( \n                        L&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}  (unassigned - parameter position {1})&quot;, \n                        tParam, tParam-&gt;GenericParameterPosition);\n                }\n                else\n                {\n                    Console::WriteLine(L&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;, tParam);\n                }\n            }\n        }\n    }\n};\n\nint main()\n{\n    Test::Main();\n}\n\n/* This example produces the following output:\n\n--- Display a generic type and the open constructed\n    type from which it is derived.\n\nDerived`1[V]\n        Is this a generic type definition? True\n        Is it a generic type? True\n        Does it have unassigned generic parameters? True\n        List type arguments (1):\n                V  (unassigned - parameter position 0)\n\nBase`2[System.Int32,V]\n        Is this a generic type definition? False\n        Is it a generic type? True\n        Does it have unassigned generic parameters? True\n        List type arguments (2):\n                System.Int32\n                V  (unassigned - parameter position 0)\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.HasUnboundGenericParameters#1\">Imports System\nImports System.Reflection\nImports System.Collections.Generic\nImports Microsoft.VisualBasic\n\n&#39; Define a base class with two type parameters.\nPublic Class Base(Of T, U)\nEnd Class\n\n&#39; Define a derived class. The derived class inherits from a constructed\n&#39; class that meets the following criteria:\n&#39;   (1) Its generic type definition is Base&lt;T, U&gt;.\n&#39;   (2) It uses int for the first type parameter.\n&#39;   (3) For the second type parameter, it uses the same type that is used\n&#39;       for the type parameter of the derived class.\n&#39; Thus, the derived class is a generic type with one type parameter, but\n&#39; its base class is an open constructed type with one assigned type\n&#39; parameter and one unassigned type parameter.\nPublic Class Derived(Of V)\n    Inherits Base(Of Integer, V)\nEnd Class\n\nPublic Class Test\n    \n    Public Shared Sub Main() \n        Console.WriteLine(vbCrLf _\n            &amp; &quot;--- Display a generic type and the open constructed&quot;)\n        Console.WriteLine(&quot;    type from which it is derived.&quot;)\n        \n        &#39; Create a Type object representing the generic type definition \n        &#39; for the Derived type, by omitting the type argument. (For\n        &#39; types with multiple type parameters, supply the commas but\n        &#39; omit the type arguments.) \n        &#39;\n        Dim derivedType As Type = GetType(Derived(Of ))\n        DisplayGenericTypeInfo(derivedType)\n        \n        &#39; Display its open constructed base type.\n        DisplayGenericTypeInfo(derivedType.BaseType)\n    \n    End Sub &#39;Main\n    \n    Private Shared Sub DisplayGenericTypeInfo(ByVal t As Type) \n        Console.WriteLine(vbCrLf &amp; &quot;{0}&quot;, t)\n        \n        Console.WriteLine(vbTab &amp; &quot;Is this a generic type definition? &quot; _\n            &amp; t.IsGenericTypeDefinition)\n        \n        Console.WriteLine(vbTab &amp; &quot;Is it a generic type? &quot; _\n            &amp; t.IsGenericType)\n        \n        Console.WriteLine(vbTab _\n            &amp; &quot;Does it have unassigned generic parameters? &quot; _\n            &amp; t.ContainsGenericParameters)\n        \n        If t.IsGenericType Then\n            &#39; If this is a generic type, display the type arguments.\n            &#39;\n            Dim typeArguments As Type() = t.GetGenericArguments()\n            \n            Console.WriteLine(vbTab &amp; &quot;List type arguments (&quot; _\n                &amp; typeArguments.Length &amp; &quot;):&quot;)\n            \n            For Each tParam As Type In typeArguments\n                &#39; IsGenericParameter is true only for generic type\n                &#39; parameters.\n                &#39;\n                If tParam.IsGenericParameter Then\n                    Console.WriteLine(vbTab &amp; vbTab &amp; tParam.ToString() _\n                        &amp; &quot;  (unassigned - parameter position &quot; _\n                        &amp; tParam.GenericParameterPosition &amp; &quot;)&quot;)\n                Else\n                    Console.WriteLine(vbTab &amp; vbTab &amp; tParam.ToString())\n                End If\n            Next tParam\n        End If\n    \n    End Sub &#39;DisplayGenericTypeInfo\nEnd Class &#39;Test\n\n&#39; This example produces the following output:\n&#39;\n&#39;--- Display a generic type and the open constructed\n&#39;    type from which it is derived.\n&#39;\n&#39;Derived`1[V]\n&#39;        Is this a generic type definition? True\n&#39;        Is it a generic type? True\n&#39;        Does it have unassigned generic parameters? True\n&#39;        List type arguments (1):\n&#39;                V  (unassigned - parameter position 0)\n&#39;\n&#39;Base`2[System.Int32,V]\n&#39;        Is this a generic type definition? False\n&#39;        Is it a generic type? True\n&#39;        Does it have unassigned generic parameters? True\n&#39;        List type parameters (2):\n&#39;                System.Int32\n&#39;                V  (unassigned - parameter position 0)\n&#39; \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_DeclaringMethod\">\r\n    \r\n            <a id=\"System_Type_DeclaringMethod_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">DeclaringMethod</div>        \r\n          </div>\r\n    \r\n            <p>Gets a <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> that represents the declaring method, if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter of a generic method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual System.Reflection.MethodBase DeclaringMethod { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a></div>\r\n                  </div>\r\n                  <p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter of a generic method, a <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> that represents declaring method; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The declaring method is a generic method definition. That is, if DeclaringMethod does not return <code>null</code>, then <code>DeclaringMethod.IsGenericMethodDefinition</code> returns <code>true</code>.  </p>\n<p> The <a class=\"xref\" href=\"system.type#System_Type_DeclaringType_\" data-linktype=\"relative-path\">DeclaringType</a> and DeclaringMethod properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:  </p>\n<ul>\n<li><p>If the DeclaringMethod property returns a <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a>, that <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> represents a generic method definition, and the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents a type parameter of that generic method definition.  </p>\n</li>\n<li><p>If the DeclaringMethod property returns <code>null</code>, then the <a class=\"xref\" href=\"system.type#System_Type_DeclaringType_\" data-linktype=\"relative-path\">DeclaringType</a> property always returns a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object representing a generic type definition, and the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents a type parameter of that generic type definition.  </p>\n</li>\n<li><p>Getting the DeclaringMethod property on a type whose <a class=\"xref\" href=\"system.type#System_Type_IsGenericParameter_\" data-linktype=\"relative-path\">IsGenericParameter</a> property is <code>false</code> throws an <a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a>.  </p>\n<p>The <a class=\"xref\" href=\"system.reflection.methodbase\" data-linktype=\"relative-path\">MethodBase</a> that is returned by the DeclaringMethod property is either a <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> in the case of a generic method, or a <a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a> in the case of a generic constructor.  </p>\n</li>\n</ul>\n<div class=\"NOTE\"><h5>Note</h5><p> In the .NET Framework version 2.0, generic constructors are not supported.  </p>\n</div>\n<p> For a list of the invariant conditions for terms used in generic reflection, see the <a class=\"xref\" href=\"system.type#System_Type_IsGenericType_\" data-linktype=\"relative-path\">IsGenericType</a> property remarks.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example defines a class that has a generic method, assigns a type argument to the method, and invokes the resulting constructed generic method. It also displays information about the generic method definition and the constructed method. When displaying information about the type parameters of the generic method definition, in the <code>DisplayGenericMethodInfo</code> method, the example code shows the value of the DeclaringMethod property for the method&#39;s generic type parameter.  </p>\n<pre><code class=\"lang-cs\" name=\"MethodInfo.Generics#1\">using System;\nusing System.Reflection;\n\n// Define a class with a generic method.\npublic class Example\n{\n    public static void Generic&lt;T&gt;(T toDisplay)\n    {\n        Console.WriteLine(&quot;\\r<br>Here it is: {0}&quot;, toDisplay);\n    }\n}\n\npublic class Test\n{\n    public static void Main()\n    {\n        Console.WriteLine(&quot;\\r<br>--- Examine a generic method.&quot;);\n\n        // Create a Type object representing class Example, and\n        // get a MethodInfo representing the generic method.\n        //\n        Type ex = typeof(Example);\n        MethodInfo mi = ex.GetMethod(&quot;Generic&quot;);\n\n        DisplayGenericMethodInfo(mi);\n\n        // Assign the int type to the type parameter of the Example \n        // method.\n        //\n        MethodInfo miConstructed = mi.MakeGenericMethod(typeof(int));\n\n        DisplayGenericMethodInfo(miConstructed);\n\n        // Invoke the method.\n        object[] args = {42};\n        miConstructed.Invoke(null, args);\n\n        // Invoke the method normally.\n        Example.Generic&lt;int&gt;(42);\n\n        // Get the generic type definition from the closed method,\n        // and show it&#39;s the same as the original definition.\n        //\n        MethodInfo miDef = miConstructed.GetGenericMethodDefinition();\n        Console.WriteLine(&quot;\\r<br>The definition is the same: {0}&quot;,\n            miDef == mi);\n    }\n        \n    private static void DisplayGenericMethodInfo(MethodInfo mi)\n    {\n        Console.WriteLine(&quot;\\r<br>{0}&quot;, mi);\n\n        Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;Is this a generic method definition? {0}&quot;, \n            mi.IsGenericMethodDefinition);\n\n        Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;Is it a generic method? {0}&quot;, \n            mi.IsGenericMethod);\n\n        Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;Does it have unassigned generic parameters? {0}&quot;, \n            mi.ContainsGenericParameters);\n\n        // If this is a generic method, display its type arguments.\n        //\n        if (mi.IsGenericMethod)\n        {\n            Type[] typeArguments = mi.GetGenericArguments();\n\n            Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;List type arguments ({0}):&quot;, \n                typeArguments.Length);\n\n            foreach (Type tParam in typeArguments)\n            {\n                // IsGenericParameter is true only for generic type\n                // parameters.\n                //\n                if (tParam.IsGenericParameter)\n                {\n                    Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}  parameter position {1}&quot; +\n                        &quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   declaring method: {2}&quot;,\n                        tParam,\n                        tParam.GenericParameterPosition,\n                        tParam.DeclaringMethod);\n                }\n                else\n                {\n                    Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;, tParam);\n                }\n            }\n        }\n    }\n}\n\n/* This example produces the following output:\n\n--- Examine a generic method.\n\nVoid Generic[T](T)\n        Is this a generic method definition? True\n        Is it a generic method? True\n        Does it have unassigned generic parameters? True\n        List type arguments (1):\n                T  parameter position 0\n                   declaring method: Void Generic[T](T)\n\nVoid Generic[Int32](Int32)\n        Is this a generic method definition? False\n        Is it a generic method? True\n        Does it have unassigned generic parameters? False\n        List type arguments (1):\n                System.Int32\n\nHere it is: 42\n\nHere it is: 42\n\nThe definition is the same: True\n\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"MethodInfo.Generics#1\">Imports System\nImports System.Reflection\n\n&#39; Define a class with a generic method.\nPublic Class Example\n    Public Shared Sub Generic(Of T)(ByVal toDisplay As T)\n        Console.WriteLine(vbCrLf &amp; &quot;Here it is: {0}&quot;, toDisplay)\n    End Sub\nEnd Class\n\nPublic Class Test\n    Public Shared Sub Main() \n        Console.WriteLine(vbCrLf &amp; &quot;--- Examine a generic method.&quot;)\n        \n        &#39; Create a Type object representing class Example, and\n        &#39; get a MethodInfo representing the generic method.\n        &#39;\n        Dim ex As Type = GetType(Example)\n        Dim mi As MethodInfo = ex.GetMethod(&quot;Generic&quot;)\n        \n        DisplayGenericMethodInfo(mi)\n        \n        &#39; Assign the Integer type to the type parameter of the Example \n        &#39; method.\n        &#39;\n        Dim arguments() As Type = { GetType(Integer) }\n        Dim miConstructed As MethodInfo = mi.MakeGenericMethod(arguments)\n        \n        DisplayGenericMethodInfo(miConstructed)\n\n        &#39; Invoke the method.\n        Dim args() As Object = { 42 }\n        miConstructed.Invoke(Nothing, args)\n        \n        &#39; Invoke the method normally.\n        Example.Generic(Of Integer)(42)\n        \n        &#39; Get the generic type definition from the constructed method,\n        &#39; and show that it&#39;s the same as the original definition.\n        &#39;\n        Dim miDef As MethodInfo = miConstructed.GetGenericMethodDefinition()\n        Console.WriteLine(vbCrLf &amp; &quot;The definition is the same: {0}&quot;, _\n            miDef Is mi)\n    End Sub &#39;Main\n      \n    Private Shared Sub DisplayGenericMethodInfo(ByVal mi As MethodInfo) \n        Console.WriteLine(vbCrLf &amp; mi.ToString())\n        \n        Console.WriteLine(vbTab _\n            &amp; &quot;Is this a generic method definition? {0}&quot;, _\n            mi.IsGenericMethodDefinition)\n\n        Console.WriteLine(vbTab &amp; &quot;Is it a generic method? {0}&quot;, _\n            mi.IsGenericMethod)\n\n        Console.WriteLine(vbTab _\n            &amp; &quot;Does it have unassigned generic parameters? {0}&quot;, _\n            mi.ContainsGenericParameters)\n\n        &#39; If this is a generic method, display its type arguments.\n        &#39;\n        If mi.IsGenericMethod Then\n            Dim typeArguments As Type() = mi.GetGenericArguments()\n            \n            Console.WriteLine(vbTab &amp; &quot;List type arguments ({0}):&quot;, _\n                typeArguments.Length)\n            \n            For Each tParam As Type In typeArguments\n                &#39; IsGenericParameter is true only for generic type\n                &#39; parameters.\n                &#39;\n                If tParam.IsGenericParameter Then\n                    Console.WriteLine(vbTab &amp; vbTab _\n                        &amp; &quot;{0}  parameter position: {1}&quot; _\n                        &amp; vbCrLf &amp; vbTab &amp; vbTab _\n                        &amp; &quot;   declaring method: {2}&quot;, _\n                        tParam,  _\n                        tParam.GenericParameterPosition, _\n                        tParam.DeclaringMethod)\n                Else\n                    Console.WriteLine(vbTab &amp; vbTab &amp; tParam.ToString())\n                End If\n            Next tParam\n        End If\n    End Sub \nEnd Class \n\n&#39; This example produces the following output:\n&#39;\n&#39;--- Examine a generic method.\n&#39;\n&#39;Void Generic[T](T)\n&#39;        Is this a generic method definition? True\n&#39;        Is it a generic method? True\n&#39;        Does it have unassigned generic parameters? True\n&#39;        List type arguments (1):\n&#39;                T  parameter position: 0\n&#39;                   declaring method: Void Generic[T](T)\n&#39;\n&#39;Void Generic[Int32](Int32)\n&#39;        Is this a generic method definition? False\n&#39;        Is it a generic method? True\n&#39;        Does it have unassigned generic parameters? False\n&#39;        List type arguments (1):\n&#39;                System.Int32\n&#39;\n&#39;Here it is: 42\n&#39;\n&#39;Here it is: 42\n&#39;\n&#39;The definition is the same: True\n&#39;\n</code></pre><pre><code class=\"lang-cpp\" name=\"MethodInfo.Generics#1\">using namespace System;\nusing namespace System::Reflection;\n\n// Define a class with a generic method.\nref class Example\n{\npublic:\n    generic&lt;typename T&gt; static void Generic(T toDisplay)\n    {\n        Console::WriteLine(&quot;\\r<br>Here it is: {0}&quot;, toDisplay);\n    }\n};\n\nvoid DisplayGenericMethodInfo(MethodInfo^ mi)\n{\n    Console::WriteLine(&quot;\\r<br>{0}&quot;, mi);\n\n    Console::WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;Is this a generic method definition? {0}&quot;, \n        mi-&gt;IsGenericMethodDefinition);\n\n    Console::WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;Is it a generic method? {0}&quot;, \n        mi-&gt;IsGenericMethod);\n\n    Console::WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;Does it have unassigned generic parameters? {0}&quot;, \n        mi-&gt;ContainsGenericParameters);\n\n    // If this is a generic method, display its type arguments.\n    //\n    if (mi-&gt;IsGenericMethod)\n    {\n        array&lt;Type^&gt;^ typeArguments = mi-&gt;GetGenericArguments();\n\n        Console::WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;List type arguments ({0}):&quot;, \n            typeArguments-&gt;Length);\n\n        for each (Type^ tParam in typeArguments)\n        {\n            // IsGenericParameter is true only for generic type\n            // parameters.\n            //\n            if (tParam-&gt;IsGenericParameter)\n            {\n                Console::WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}  parameter position {1}&quot; +\n                    &quot;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;   declaring method: {2}&quot;,\n                    tParam,\n                    tParam-&gt;GenericParameterPosition,\n                    tParam-&gt;DeclaringMethod);\n            }\n            else\n            {\n                Console::WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;, tParam);\n            }\n        }\n    }\n};\n\nvoid main()\n{\n    Console::WriteLine(&quot;\\r<br>--- Examine a generic method.&quot;);\n\n    // Create a Type object representing class Example, and\n    // get a MethodInfo representing the generic method.\n    //\n    Type^ ex = Example::typeid;\n    MethodInfo^ mi = ex-&gt;GetMethod(&quot;Generic&quot;);\n\n    DisplayGenericMethodInfo(mi);\n\n    // Assign the int type to the type parameter of the Example \n    // method.\n    //\n    MethodInfo^ miConstructed = mi-&gt;MakeGenericMethod(int::typeid);\n\n    DisplayGenericMethodInfo(miConstructed);\n\n    // Invoke the method.\n    array&lt;Object^&gt;^ args = { 42 };\n    miConstructed-&gt;Invoke((Object^) 0, args);\n\n    // Invoke the method normally.\n    Example::Generic&lt;int&gt;(42);\n\n    // Get the generic type definition from the closed method,\n    // and show it&#39;s the same as the original definition.\n    //\n    MethodInfo^ miDef = miConstructed-&gt;GetGenericMethodDefinition();\n    Console::WriteLine(&quot;\\r<br>The definition is the same: {0}&quot;,\n            miDef == mi);\n};\n        \n/* This example produces the following output:\n\n--- Examine a generic method.\n\nVoid Generic[T](T)\n        Is this a generic method definition? True\n        Is it a generic method? True\n        Does it have unassigned generic parameters? True\n        List type arguments (1):\n                T  parameter position 0\n                   declaring method: Void Generic[T](T)\n\nVoid Generic[Int32](Int32)\n        Is this a generic method definition? False\n        Is it a generic method? True\n        Does it have unassigned generic parameters? False\n        List type arguments (1):\n                System.Int32\n\nHere it is: 42\n\nHere it is: 42\n\nThe definition is the same: True\n\n */\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_DeclaringType\">\r\n    \r\n            <a id=\"System_Type_DeclaringType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">DeclaringType</div>        \r\n          </div>\r\n    \r\n            <p>Gets the type that declares the current nested type or generic type parameter.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override Type DeclaringType { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object representing the enclosing type, if the current type is a nested type; or the generic type definition, if the current type is a type parameter of a generic type; or the type that declares the generic method, if the current type is a type parameter of a generic method; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents a type parameter of a generic type, this property returns the generic type definition.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition. If the type is generic, the generic type definition is returned. That is, the following code returns the generic type definition of the <a class=\"xref\" href=\"system.collections.generic.list-1\" data-linktype=\"relative-path\">List&lt;T&gt;</a> generic class, which contains the &lt;xref:System.Collections.Generic.List%601.ConvertAll%2A&gt; generic method:  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Type.DeclaringType#1\">    Type^ t = List&lt;String^&gt;::typeid-&gt;GetMethod(&quot;ConvertAll&quot;)-&gt;GetGenericArguments()[0]-&gt;DeclaringType;\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.DeclaringType#1\">        Type t = typeof(List&lt;string&gt;).GetMethod(&quot;ConvertAll&quot;).GetGenericArguments()[0].DeclaringType;\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.DeclaringType#1\">        Dim t As Type = GetType(List(Of String)).GetMethod(&quot;ConvertAll&quot;).GetGenericArguments()(0).DeclaringType\n</code></pre><p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, the DeclaringType and <a class=\"xref\" href=\"system.type#System_Type_DeclaringMethod_\" data-linktype=\"relative-path\">DeclaringMethod</a> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:  </p>\n<ul>\n<li><p>If the <a class=\"xref\" href=\"system.type#System_Type_DeclaringMethod_\" data-linktype=\"relative-path\">DeclaringMethod</a> property returns a <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a>, that <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> represents a generic method definition, and the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents a type parameter of that generic method definition.  </p>\n</li>\n<li><p>If the <a class=\"xref\" href=\"system.type#System_Type_DeclaringMethod_\" data-linktype=\"relative-path\">DeclaringMethod</a> property returns <code>null</code>, then the DeclaringType property always returns a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object representing a generic type definition, and the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents a type parameter of that generic type definition.  </p>\n</li>\n<li><p>Getting the DeclaringType property on a type whose <a class=\"xref\" href=\"system.type#System_Type_IsGenericParameter_\" data-linktype=\"relative-path\">IsGenericParameter</a> property is <code>false</code> throws an <a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a>.</p>\n</li>\n</ul>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>This example displays the declaring type of a method in a derived class.  </p>\n<pre><code class=\"lang-cpp\" name=\"Classic Type.DeclaringType Example#1\">using namespace System;\nusing namespace System::Reflection;\n\npublic ref class dtype abstract\n{\npublic:\n   ref class MyClassA abstract\n   {\n   public:\n      virtual int m() = 0;\n   };\n\n   ref class MyClassB abstract: public MyClassA{};\n};\n\nint main()\n{\n   Console::WriteLine( &quot;The declaring type of m is {0}.&quot;, dtype::MyClassB::typeid-&gt;GetMethod( &quot;m&quot; )-&gt;DeclaringType );\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Classic Type.DeclaringType Example#1\">Imports System\nImports System.Reflection\nImports Microsoft.VisualBasic\n\nPublic MustInherit Class dtype\n\n    Public MustInherit Class MyClassA\n        Public MustOverride Function m() As Integer\n    End Class\n\n    Public MustInherit Class MyClassB\n        Inherits MyClassA\n    End Class\n\n    Public Shared Sub Main()\n        Console.WriteLine(&quot;The declaring type of m is {0}.&quot;, _\n           GetType(MyClassB).GetMethod(&quot;m&quot;).DeclaringType)\n    End Sub\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"Classic Type.DeclaringType Example#1\">using System;\nusing System.Reflection;\n \npublic abstract class dtype \n{\n    \n    public abstract class MyClassA \n    {\n        public abstract int m(); \n    }\n    \n    public abstract class MyClassB : MyClassA \n    {\n    }\n  \n    public static void Main(string[] args) \n    { \n        Console.WriteLine(&quot;The declaring type of m is {0}.&quot;,\n            typeof(MyClassB).GetMethod(&quot;m&quot;).DeclaringType);\n    }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_DefaultBinder\">\r\n    \r\n            <a id=\"System_Type_DefaultBinder_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">DefaultBinder</div>        \r\n          </div>\r\n    \r\n            <p>Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <span class=\"xref\">stem.Type.InvokeMember*</span>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Reflection.Binder DefaultBinder { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a></div>\r\n                  </div>\r\n                  <p>A reference to the default binder used by the system.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The default binder provided with the common language runtime is applicable in all but the most specialized circumstances. If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a> class and pass an instance of that type using the <code>binder</code> parameter of one of the <a class=\"xref\" href=\"system.type#System_Type_InvokeMember_\" data-linktype=\"relative-path\">InvokeMember</a> overloads.  </p>\n<p> Reflection models the accessibility rules of the common type system. For example, if the caller is in the same assembly, the caller does not need special permissions for internal members. Otherwise, the caller needs <a class=\"xref\" href=\"system.security.permissions.reflectionpermission\" data-linktype=\"relative-path\">ReflectionPermission</a>. This is consistent with lookup of members that are protected, private, and so on.  </p>\n<p> The general principle is that <a class=\"xref\" href=\"system.reflection.binder#System_Reflection_Binder_ChangeType_\" data-linktype=\"relative-path\">ChangeType</a> should perform only widening conversions, which never lose data. An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer. This is distinguished from a narrowing conversion, which may lose data. An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.  </p>\n<p> The following table lists the conversions supported by the default binder.  </p>\n<table>\n<thead>\n<tr>\n<th>Source Type</th>\n<th>Target Type</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Any type</td>\n<td>Its base type.</td>\n</tr>\n<tr>\n<td>Any type</td>\n<td>The interface it implements.</td>\n</tr>\n<tr>\n<td>Char</td>\n<td>Unt16, UInt32, Int32, UInt64, Int64, Single, Double</td>\n</tr>\n<tr>\n<td>Byte</td>\n<td>Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</td>\n</tr>\n<tr>\n<td>SByte</td>\n<td>Int16, Int32, Int64, Single, Double</td>\n</tr>\n<tr>\n<td>UInt16</td>\n<td>UInt32, Int32, UInt64, Int64, Single, Double</td>\n</tr>\n<tr>\n<td>Int16</td>\n<td>Int32, Int64, Single, Double</td>\n</tr>\n<tr>\n<td>UInt32</td>\n<td>UInt64, Int64, Single, Double</td>\n</tr>\n<tr>\n<td>Int32</td>\n<td>Int64, Single, Double</td>\n</tr>\n<tr>\n<td>UInt64</td>\n<td>Single, Double</td>\n</tr>\n<tr>\n<td>Int64</td>\n<td>Single, Double</td>\n</tr>\n<tr>\n<td>Single</td>\n<td>Double</td>\n</tr>\n<tr>\n<td>Non-reference</td>\n<td>By-reference.</td>\n</tr>\n</tbody>\n</table>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example gets the default binder from the <code>DefaultBinder</code> property, and invokes a member of MyClass by passing the <code>DefaultBinder</code> value as a parameter to <a class=\"xref\" href=\"system.type#System_Type_InvokeMember_\" data-linktype=\"relative-path\">InvokeMember</a>.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_DefaultBinder#1\">using namespace System;\nusing namespace System::Reflection;\nref class MyClass\n{\npublic:\n   void HelloWorld()\n   {\n      Console::WriteLine( &quot;Hello World&quot; );\n   }\n\n};\n\nint main()\n{\n   try\n   {\n      Binder^ defaultBinder = Type::DefaultBinder;\n      MyClass^ myClass = gcnew MyClass;\n      \n      // Invoke the HelloWorld method of MyClass.\n      myClass-&gt;GetType()-&gt;InvokeMember( &quot;HelloWorld&quot;, BindingFlags::InvokeMethod, defaultBinder, myClass, nullptr );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception : {0}&quot;, e-&gt;Message );\n   }\n\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_DefaultBinder#1\">using System;\nusing System.Reflection;\n\npublic class MyDefaultBinderSample\n{\n    public static void Main()\n    {\n        try\n        {\n            Binder defaultBinder = Type.DefaultBinder;\n            MyClass myClass = new MyClass();\n            // Invoke the HelloWorld method of MyClass.\n            myClass.GetType().InvokeMember(&quot;HelloWorld&quot;, BindingFlags.InvokeMethod,\n                defaultBinder, myClass, new object [] {});\n        }\n        catch(Exception e)\n        {\n            Console.WriteLine(&quot;Exception :&quot; + e.Message);\n        }\n    }\t\n\n    class MyClass\n    {\n        public void HelloWorld()\n        {\n            Console.WriteLine(&quot;Hello World&quot;);\n        }\t\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_DefaultBinder#1\">Imports System\nImports System.Reflection\nImports Microsoft.VisualBasic\n\nPublic Class MyDefaultBinderSample\n    Public Shared Sub Main()\n        Try\n            Dim defaultBinder As Binder = Type.DefaultBinder\n            Dim [myClass] As New [MyClass]()\n            &#39; Invoke the HelloWorld method of MyClass.\n            [myClass].GetType().InvokeMember(&quot;HelloWorld&quot;, BindingFlags.InvokeMethod, defaultBinder, [myClass], New Object() {})\n        Catch e As Exception\n            Console.WriteLine(&quot;Exception :&quot; + e.Message.ToString())\n        End Try\n    End Sub &#39;Main\n\n    Class [MyClass]\n\n        Public Sub HelloWorld()\n            Console.WriteLine(&quot;Hello World&quot;)\n        End Sub &#39;HelloWorld\n    End Class &#39;[MyClass]\nEnd Class &#39;MyDefaultBinderSample \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_FullName\">\r\n    \r\n            <a id=\"System_Type_FullName_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">FullName</div>        \r\n          </div>\r\n    \r\n            <p>Gets the fully qualified name of the type, including its namespace but not its assembly.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract string FullName { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </div>\r\n                  <p>The fully qualified name of the type, including its namespace but not its assembly; or <code>null</code> if the current instance represents a generic type parameter, an array type, pointer type, or <code>byref</code> type based on a type parameter, or a generic type that is not a generic type definition but contains unresolved type parameters.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>For example, the fully qualified name of the <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a> type is <code>System.String</code>. Contrast this with the assembly-qualified name returned by the <a class=\"xref\" href=\"system.type#System_Type_AssemblyQualifiedName_\" data-linktype=\"relative-path\">AssemblyQualifiedName</a> property, which consists of the full name plus the full assembly name.  </p>\n<p> If the current type represents a closed generic type, the type arguments in the string returned by the FullNameproperty are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name. The following example illustrates the difference in the FullName property for a type that represents generic type definition and one that represents a closed generic type.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.FullName#2\">using System;\nusing System.Collections.Generic;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Type t = typeof(List&lt;&gt;);\n      Console.WriteLine(t.FullName);\n      Console.WriteLine();\n\n      List&lt;String&gt; list = new List&lt;String&gt;();\n      t = list.GetType();\n      Console.WriteLine(t.FullName);\n   }\n}\n// The example displays the following output:\n// System.Collections.Generic.List`1\n//\n// System.Collections.Generic.List`1[[System.String, mscorlib,\n//        Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.FullName#2\">Imports System.Collections.Generic\n\nModule Example\n   Public Sub Main()\n      Dim t As Type = GetType(List(Of))\n      Console.WriteLine(t.FullName)\n      Console.WriteLine()\n\n      Dim list As New List(Of String)()\n      t = list.GetType()\n      Console.WriteLine(t.FullName)\n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;    System.Collections.Generic.List`1\n&#39;\n&#39;    System.Collections.Generic.List`1[[System.String, mscorlib,\n&#39;             Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]\n</code></pre><p> This property returns <code>null</code> if:  </p>\n<ul>\n<li><p>The current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents a type parameter of a generic type.  </p>\n<p> The following example retrieves the type parameter of the <a class=\"xref\" href=\"system.nullable-1\" data-linktype=\"relative-path\">Nullable&lt;T&gt;</a> type and attempts to display its FullName property.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.FullName#3\">using System;\nusing System.Reflection;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Type t = typeof(Nullable&lt;&gt;); \n      Console.WriteLine(t.FullName);\n      if (t.IsGenericType) {\n         Console.Write(&quot;   Generic Type Parameters: &quot;);\n         Type[] gtArgs = t.GetGenericArguments();\n         for (int ctr = 0; ctr &lt; gtArgs.Length; ctr++) {\n            Console.WriteLine(gtArgs[ctr].FullName ??\n                              &quot;(unassigned) &quot; + gtArgs[ctr].ToString());\n          }\n         Console.WriteLine();\n      }\n   }\n}\n// The example displays the following output:\n//       System.Nullable`1\n//          Generic Type Parameters: (unassigned) T\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.FullName#3\">Imports System.Reflection\n\nModule Example\n   Public Sub Main()\n      Dim t As Type = GetType(Nullable(Of )) \n      Console.WriteLine(t.FullName)\n      If t.IsGenericType Then\n         Console.Write(&quot;   Generic Type Parameters: &quot;)\n         Dim gtArgs As Type() = t.GetGenericArguments\n         For ctr As Integer = 0 To gtArgs.Length - 1\n            Console.WriteLine(If(gtArgs(ctr).FullName, \n                              &quot;(unassigned) &quot; + gtArgs(ctr).ToString()))\n            If ctr &lt; gtArgs.Length - 1 Then Console.Write(&quot;, &quot;)   \n         Next\n         Console.WriteLine()\n      End If\n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       System.Nullable`1\n&#39;          Generic Type Parameters: (unassigned) T\n</code></pre></li>\n<li><p>The current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents an array type, a pointer  type, or a <code>byref</code> type that is based on a generic type parameter.  </p>\n<p> The following example defines a generic type, <code>Generictype1&lt;T&gt;</code>, with three methods: <code>Display(T[])</code>, which is passed an array of type T; <code>HandleT(T)</code>, which is passed a T object; and <code>ChangeValue(ref T)</code>, which is passed a T object by reference. Because C# and Visual Basic do not allow us to define T as a pointer in the <code>HandleT</code> method, we have to call the <a class=\"xref\" href=\"system.type#System_Type_MakePointerType_\" data-linktype=\"relative-path\">MakePointerType</a> method on the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents the method&#39;s parameter type to create a pointer to a generic type. The output from the example shows that in all three cases, the FullName property is <code>null</code>.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Type.FullName#4\">Imports System.Reflection\n\nPublic Class GenericType1(Of T)\n   Public Sub Display(elements As T())\n   End Sub\n   \n   &#39; Visual Basic does not support pointer types.\n   Public Sub HandleT(obj As T)\n   End Sub\n   \n   \n   Public Function ChangeValue(ByRef arg As T) As Boolean\n      Return True\n   End Function\nEnd Class\n\nModule Example\n   Public Sub Main()\n      Dim t As Type = GetType(GenericType1(Of ))\n      Console.WriteLine(&quot;Type Name: {0}&quot;, t.FullName)\n      Dim methods() As MethodInfo = t.GetMethods(BindingFlags.Instance Or\n                                                 BindingFlags.DeclaredOnly Or\n                                                 BindingFlags.Public)\n      For Each method In methods \n         Console.WriteLine(&quot;   Method: {0}&quot;, method.Name)\n         &#39; Get method parameters.\n         Dim param As ParameterInfo = method.GetParameters()(0)\n         Dim paramType As Type = param.ParameterType\n         If method.Name = &quot;HandleT&quot; Then\n            paramType = paramType.MakePointerType()\n         End If\n         Console.WriteLine(&quot;      Parameter: {0}&quot;, \n                           If(paramType.FullName, \n                              paramType.ToString() + &quot; (unassigned)&quot;))\n      Next\n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       Type Name: GenericType1`1\n&#39;          Method: Display\n&#39;             Parameter: T[] (unassigned)\n&#39;          Method: HandleT\n&#39;             Parameter: T* (unassigned)\n&#39;          Method: ChangeValue\n&#39;             Parameter: T&amp; (unassigned)\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.FullName#4\">using System;\nusing System.Reflection;\n\npublic class GenericType1&lt;T&gt; \n{\n   public void Display(T[] elements)  \n   {}\n   \n   public void HandleT(T obj)\n   {}\n   \n   public bool ChangeValue(ref T arg) \n   {\n      return true;\n   }\n}\n\npublic class Example\n{\n   public static void Main()\n   {\n      Type t = typeof(GenericType1&lt;&gt;);\n      Console.WriteLine(&quot;Type Name: {0}&quot;, t.FullName);\n      MethodInfo[] methods = t.GetMethods(BindingFlags.Instance |\n                                          BindingFlags.DeclaredOnly |\n                                          BindingFlags.Public);\n      foreach (var method in methods) { \n         Console.WriteLine(&quot;   Method: {0}&quot;, method.Name);\n         // Get method parameters.\n         ParameterInfo param = method.GetParameters()[0];\n         Type paramType = param.ParameterType;\n         if (method.Name == &quot;HandleT&quot;)\n            paramType = paramType.MakePointerType();\n         Console.WriteLine(&quot;      Parameter: {0}&quot;, \n                           paramType.FullName ?? \n                           paramType.ToString() + &quot; (unassigned)&quot;);\n      }\n   }\n}\n// The example displays the following output:\n//       Type Name: GenericType1`1\n//          Method: Display\n//             Parameter: T[] (unassigned))\n//          Method: HandleT\n//             Parameter: T* (unassigned)\n//          Method: ChangeValue\n//             Parameter: T&amp; (unassigned)\n</code></pre></li>\n<li><p>The current type contains generic type parameters that have not been replaced by specific types (that is, the <a class=\"xref\" href=\"system.type#System_Type_ContainsGenericParameters_\" data-linktype=\"relative-path\">ContainsGenericParameters</a> property returns <code>true</code>), but the type is not a generic type definition (that is, the <a class=\"xref\" href=\"system.type#System_Type_IsGenericTypeDefinition_\" data-linktype=\"relative-path\">IsGenericTypeDefinition</a> property returns <code>false</code>  </p>\n<p> In the following example, <code>Derived&lt;T&gt;</code> inherits from <code>Base&lt;T&gt;</code>. The <a class=\"xref\" href=\"system.type#System_Type_BaseType_\" data-linktype=\"relative-path\">BaseType</a> property obtains the  <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents the base type of <code>Derived&lt;T&gt;</code>, and its FullName property returns <code>null</code>.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Type.FullName#5\">Imports System.Reflection\n\nPublic Class Base(Of T)\nEnd Class\n\nPublic Class Derived(Of T) : Inherits Base(Of T)\nEnd Class\n\nModule Example\n   Public Sub Main()\n      Dim t As Type = GetType(Derived(Of ))\n      Console.WriteLine(&quot;Generic Class: {0}&quot;, t.FullName)\n      Console.WriteLine(&quot;   Contains Generic Paramters: {0}&quot;,\n                        t.ContainsGenericParameters)\n      Console.WriteLine(&quot;   Generic Type Definition: {0}&quot;,\n                        t.IsGenericTypeDefinition)                 \n      Console.WriteLine()\n      \n      Dim baseType As Type = t.BaseType\n      Console.WriteLine(&quot;Its Base Class: {0}&quot;, \n                        If(baseType.FullName,  \n                        &quot;(unassigned) &quot; + baseType.ToString()))\n      Console.WriteLine(&quot;   Contains Generic Paramters: {0}&quot;,\n                        baseType.ContainsGenericParameters)\n      Console.WriteLine(&quot;   Generic Type Definition: {0}&quot;,\n                        baseType.IsGenericTypeDefinition)                 \n      Console.WriteLine(&quot;   Full Name: {0}&quot;, \n                        baseType.GetGenericTypeDefinition().FullName)\n      Console.WriteLine()\n      \n      t = GetType(Base(Of ))\n      Console.WriteLine(&quot;Generic Class: {0}&quot;, t.FullName)\n      Console.WriteLine(&quot;   Contains Generic Paramters: {0}&quot;,\n                        t.ContainsGenericParameters)\n      Console.WriteLine(&quot;   Generic Type Definition: {0}&quot;,\n                        t.IsGenericTypeDefinition)                 \n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       Generic Class: Derived`1\n&#39;          Contains Generic Paramters: True\n&#39;          Generic Type Definition: True\n&#39;       \n&#39;       Its Base Class: (unassigned) Base`1[T]\n&#39;          Contains Generic Paramters: True\n&#39;          Generic Type Definition: False\n&#39;          Full Name: Base`1\n&#39;       \n&#39;       Generic Class: Base`1\n&#39;          Contains Generic Paramters: True\n&#39;          Generic Type Definition: True\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.FullName#5\">using System;\nusing System.Reflection;\n\npublic class Base&lt;T&gt; { }\n\npublic class Derived&lt;T&gt; : Base&lt;T&gt; { }\n\npublic class Example\n{\n   public static void Main()\n   {\n      Type t = typeof(Derived&lt;&gt;);\n      Console.WriteLine(&quot;Generic Class: {0}&quot;, t.FullName);\n      Console.WriteLine(&quot;   Contains Generic Paramters: {0}&quot;,\n                        t.ContainsGenericParameters);\n      Console.WriteLine(&quot;   Generic Type Definition: {0}\\n&quot;,\n                        t.IsGenericTypeDefinition);                 \n\n      Type baseType = t.BaseType;\n      Console.WriteLine(&quot;Its Base Class: {0}&quot;, \n                        baseType.FullName ?? \n                        &quot;(unassigned) &quot; + baseType.ToString());\n      Console.WriteLine(&quot;   Contains Generic Paramters: {0}&quot;,\n                        baseType.ContainsGenericParameters);\n      Console.WriteLine(&quot;   Generic Type Definition: {0}&quot;,\n                        baseType.IsGenericTypeDefinition);                 \n      Console.WriteLine(&quot;   Full Name: {0}\\n&quot;, \n                        baseType.GetGenericTypeDefinition().FullName);\n\n      t = typeof(Base&lt;&gt;);\n      Console.WriteLine(&quot;Generic Class: {0}&quot;, t.FullName);\n      Console.WriteLine(&quot;   Contains Generic Paramters: {0}&quot;,\n                        t.ContainsGenericParameters);\n      Console.WriteLine(&quot;   Generic Type Definition: {0}\\n&quot;,\n                        t.IsGenericTypeDefinition);                 \n\n\n   }\n}\n// The example displays the following output:\n//       Generic Class: Derived`1\n//          Contains Generic Paramters: True\n//          Generic Type Definition: True\n//       \n//       Its Base Class: (unassigned) Base`1[T]\n//          Contains Generic Paramters: True\n//          Generic Type Definition: False\n//          Full Name: Base`1\n//       \n//       Generic Class: Base`1\n//          Contains Generic Paramters: True\n//          Generic Type Definition: True\n</code></pre><p> To get a FullName that is not <code>null</code>, you can use the <a class=\"xref\" href=\"system.type#System_Type_GetGenericTypeDefinition_\" data-linktype=\"relative-path\">GetGenericTypeDefinition</a> method to get the generic type definition, as the example illustrates.  </p>\n<p>This property is read-only.</p>\n</li>\n</ul>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example displays the full name of the specified type.  </p>\n<pre><code class=\"lang-cpp\" name=\"TestFullName#1\">using namespace System;\nint main()\n{\n   Type^ t = Array::typeid;\n   Console::WriteLine( &quot;The full name of the Array type is {0}.&quot;, t-&gt;FullName );\n}\n\n/* This example produces the following output:\n\nThe full name of the Array type is System.Array.\n */\n</code></pre><pre><code class=\"lang-cs\" name=\"TestFullName#1\">using System;\nclass TestFullName \n{\npublic static void Main() \n    {\n    Type t = typeof(Array);\n    Console.WriteLine(&quot;The full name of the Array type is {0}.&quot;, t.FullName);\n    }\n} \n\n/* This example produces the following output:\n\nThe full name of the Array type is System.Array.\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"TestFullName#1\">Imports System\n\nClass TestFullName\n   \n    Public Shared Sub Main()\n        Dim t As Type = GetType(Array)\n        Console.WriteLine(&quot;The full name of the Array type is {0}.&quot;, t.FullName)\n    End Sub &#39;Main\nEnd Class &#39;TestFullName\n\n&#39; This example produces the following output:\n&#39;\n&#39;The full name of the Array type is System.Array.\n&#39;\n</code></pre><p> The following example compares the strings returned by the <a class=\"xref\" href=\"system.type#System_Type_ToString_\" data-linktype=\"relative-path\">ToString</a> method and the <code>Name</code>, FullName, and <a class=\"xref\" href=\"system.type#System_Type_AssemblyQualifiedName_\" data-linktype=\"relative-path\">AssemblyQualifiedName</a> properties.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Type.ToString#1\">Imports System.Collections.Generic\nImports System.Globalization\n\nModule Example\n   Public Sub Main()\n      Dim t As Type = GetType(String)\n      ShowTypeInfo(t)\n\n      t = GetType(System.Collections.Generic.List(Of))\n      ShowTypeInfo(t)\n\n      Dim list As New List(Of String)()\n      t = list.GetType()\n      ShowTypeInfo(t)\n      \n      Dim v As Object = 12\n      t = v.GetType()\n      ShowTypeInfo(t)\n      \n      t = GetType(IFormatProvider)\n      ShowTypeInfo(t)\n      \n      Dim ifmt As IFormatProvider = NumberFormatInfo.CurrentInfo\n      t = ifmt.GetType()\n      ShowTypeInfo(t)\n   End Sub\n   \n   Private Sub ShowTypeInfo(t As Type)\n      Console.WriteLine(&quot;Name: {0}&quot;, t.Name)\n      Console.WriteLine(&quot;Full Name: {0}&quot;, t.FullName)\n      Console.WriteLine(&quot;ToString:  {0}&quot;, t.ToString())\n      Console.WriteLine(&quot;Assembly Qualified Name: {0}&quot;, t.AssemblyQualifiedName)\n      Console.WriteLine()\n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;    Name: String\n&#39;    Full Name: System.String\n&#39;    ToString:  System.String\n&#39;    Assembly Qualified Name: System.String, mscorlib, Version=4.0.0.0, Culture=neutr\n&#39;    al, PublicKeyToken=b77a5c561934e089\n&#39;\n&#39;    Name: List`1\n&#39;    Full Name: System.Collections.Generic.List`1\n&#39;    ToString:  System.Collections.Generic.List`1[T]\n&#39;    Assembly Qualified Name: System.Collections.Generic.List`1, mscorlib, Version=4.\n&#39;    0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\n&#39;\n&#39;    Name: List`1\n&#39;    Full Name: System.Collections.Generic.List`1[[System.String, mscorlib, Version=4\n&#39;    .0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]\n&#39;    ToString:  System.Collections.Generic.List`1[System.String]\n&#39;    Assembly Qualified Name: System.Collections.Generic.List`1[[System.String, mscor\n&#39;    lib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], mscorl\n&#39;    ib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\n&#39;\n&#39;    Name: Int32\n&#39;    Full Name: System.Int32\n&#39;    ToString:  System.Int32\n&#39;    Assembly Qualified Name: System.Int32, mscorlib, Version=4.0.0.0, Culture=neutra\n&#39;    l, PublicKeyToken=b77a5c561934e089\n&#39;\n&#39;    Name: IFormatProvider\n&#39;    Full Name: System.IFormatProvider\n&#39;    ToString:  System.IFormatProvider\n&#39;    Assembly Qualified Name: System.IFormatProvider, mscorlib, Version=4.0.0.0, Cult\n&#39;    ure=neutral, PublicKeyToken=b77a5c561934e089\n&#39;\n&#39;    Name: NumberFormatInfo\n&#39;    Full Name: System.Globalization.NumberFormatInfo\n&#39;    ToString:  System.Globalization.NumberFormatInfo\n&#39;    Assembly Qualified Name: System.Globalization.NumberFormatInfo, mscorlib, Versio\n&#39;    n=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.ToString#1\">using System;\nusing System.Collections.Generic;\nusing System.Globalization;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Type t = typeof(String);\n      ShowTypeInfo(t);\n\n      t = typeof(System.Collections.Generic.List&lt;&gt;);\n      ShowTypeInfo(t);\n\n      var list = new List&lt;String&gt;();\n      t = list.GetType();\n      ShowTypeInfo(t);\n\n      Object v = 12;\n      t = v.GetType();\n      ShowTypeInfo(t);\n\n      t = typeof(IFormatProvider);\n      ShowTypeInfo(t);\n\n      IFormatProvider ifmt = NumberFormatInfo.CurrentInfo;\n      t = ifmt.GetType();\n      ShowTypeInfo(t);\n   }\n\n   private static void ShowTypeInfo(Type t)\n   {\n      Console.WriteLine(&quot;Name: {0}&quot;, t.Name);\n      Console.WriteLine(&quot;Full Name: {0}&quot;, t.FullName);\n      Console.WriteLine(&quot;ToString:  {0}&quot;, t.ToString());\n      Console.WriteLine(&quot;Assembly Qualified Name: {0}&quot;,\n                        t.AssemblyQualifiedName);\n      Console.WriteLine();\n   }\n}\n// The example displays output like the following:\n//    Name: String\n//    Full Name: System.String\n//    ToString:  System.String\n//    Assembly Qualified Name: System.String, mscorlib, Version=4.0.0.0, Culture=neutr\n//    al, PublicKeyToken=b77a5c561934e089\n//\n//    Name: List`1\n//    Full Name: System.Collections.Generic.List`1\n//    ToString:  System.Collections.Generic.List`1[T]\n//    Assembly Qualified Name: System.Collections.Generic.List`1, mscorlib, Version=4.\n//    0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\n//\n//    Name: List`1\n//    Full Name: System.Collections.Generic.List`1[[System.String, mscorlib, Version=4\n//    .0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]\n//    ToString:  System.Collections.Generic.List`1[System.String]\n//    Assembly Qualified Name: System.Collections.Generic.List`1[[System.String, mscor\n//    lib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], mscorl\n//    ib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\n//\n//    Name: Int32\n//    Full Name: System.Int32\n//    ToString:  System.Int32\n//    Assembly Qualified Name: System.Int32, mscorlib, Version=4.0.0.0, Culture=neutra\n//    l, PublicKeyToken=b77a5c561934e089\n//\n//    Name: IFormatProvider\n//    Full Name: System.IFormatProvider\n//    ToString:  System.IFormatProvider\n//    Assembly Qualified Name: System.IFormatProvider, mscorlib, Version=4.0.0.0, Cult\n//    ure=neutral, PublicKeyToken=b77a5c561934e089\n//\n//    Name: NumberFormatInfo\n//    Full Name: System.Globalization.NumberFormatInfo\n//    ToString:  System.Globalization.NumberFormatInfo\n//    Assembly Qualified Name: System.Globalization.NumberFormatInfo, mscorlib, Versio\n//    n=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GenericParameterAttributes\">\r\n    \r\n            <a id=\"System_Type_GenericParameterAttributes_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GenericParameterAttributes</div>        \r\n          </div>\r\n    \r\n            <p>Gets a combination of <a class=\"xref\" href=\"system.reflection.genericparameterattributes\" data-linktype=\"relative-path\">GenericParameterAttributes</a> flags that describe the covariance and special constraints of the current generic type parameter.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.genericparameterattributes\" data-linktype=\"relative-path\">GenericParameterAttributes</a></div>\r\n                  </div>\r\n                  <p>A bitwise combination of <a class=\"xref\" href=\"system.reflection.genericparameterattributes\" data-linktype=\"relative-path\">GenericParameterAttributes</a> values that describes the covariance and special constraints of the current generic type parameter.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object is not a generic type parameter. That is, the <span class=\"xref\">stem.Type.IsGenericParameter*</span> property returns <code>false</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The invoked method is not supported in the base class.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints. Use the <a class=\"xref\" href=\"system.reflection.genericparameterattributes\" data-linktype=\"relative-path\">System.Reflection.GenericParameterAttributes</a> value to select the covariance flags, and use the <a class=\"xref\" href=\"system.reflection.genericparameterattributes\" data-linktype=\"relative-path\">System.Reflection.GenericParameterAttributes</a> value to select the constraint flags.  </p>\n<p> For a list of the invariant conditions for terms used in generic reflection, see the <a class=\"xref\" href=\"system.type#System_Type_IsGenericType_\" data-linktype=\"relative-path\">IsGenericType</a> property remarks.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example defines a generic type <code>Test</code> with two type parameters that have different constraints. When the program executes, the constraints are examined using the GenericParameterAttributes property and the <a class=\"xref\" href=\"system.type#System_Type_GetGenericParameterConstraints_\" data-linktype=\"relative-path\">GetGenericParameterConstraints</a> method.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Type.GetGenericParameterConstraints#1\">Imports System\nImports System.Reflection\n\n&#39; Define a sample interface to use as an interface constraint.\nPublic Interface ITest\nEnd Interface \n\n&#39; Define a base type to use as a base class constraint.\nPublic Class Base\nEnd Class \n\n&#39; Define the generic type to examine. The first generic type parameter,\n&#39; T, derives from the class Base and implements ITest. This demonstrates\n&#39; a base class constraint and an interface constraint. The second generic \n&#39; type parameter, U, must be a reference type (Class) and must have a \n&#39; default constructor (New). This demonstrates special constraints.\n&#39;\nPublic Class Test(Of T As {Base, ITest}, U As {New, Class}) \nEnd Class\n\n&#39; Define a type that derives from Base and implements ITtest. This type\n&#39; satisfies the constraints on T in class Test.\nPublic Class Derived\n    Inherits Base\n    Implements ITest\nEnd Class \n\nPublic Class Example\n    \n    Public Shared Sub Main() \n        &#39; To get the generic type definition, omit the type\n        &#39; arguments but retain the comma to indicate the number\n        &#39; of type arguments. \n        &#39;\n        Dim def As Type = GetType(Test(Of ,))\n        Console.WriteLine(vbCrLf &amp; &quot;Examining generic type {0}&quot;, def)\n        \n        &#39; Get the type parameters of the generic type definition,\n        &#39; and display them.\n        &#39;\n        Dim defparams() As Type = def.GetGenericArguments()\n        For Each tp As Type In defparams\n\n            Console.WriteLine(vbCrLf &amp; &quot;Type parameter: {0}&quot;, tp.Name)\n            Console.WriteLine(vbTab &amp; ListGenericParameterAttributes(tp))\n            \n            &#39; List the base class and interface constraints. The\n            &#39; constraints do not appear in any particular order. An\n            &#39; empty array is returned if there are no constraints.\n            &#39;\n            Dim tpConstraints As Type() = _\n                tp.GetGenericParameterConstraints()\n            For Each tpc As Type In  tpConstraints\n                Console.WriteLine(vbTab &amp; tpc.ToString())\n            Next tpc\n        Next tp\n    \n    End Sub \n    \n    &#39; List the variance and special constraint flags.\n    &#39;\n    Private Shared Function ListGenericParameterAttributes(ByVal t As Type) As String \n        Dim retval As String\n        Dim gpa As GenericParameterAttributes = t.GenericParameterAttributes\n\n        &#39; Select the variance flags.\n        Dim variance As GenericParameterAttributes = _\n            gpa And GenericParameterAttributes.VarianceMask\n        \n        If variance = GenericParameterAttributes.None Then\n            retval = &quot;No variance flag;&quot;\n        Else\n            If (variance And GenericParameterAttributes.Covariant) &lt;&gt; 0 Then\n                retval = &quot;Covariant;&quot;\n            Else\n                retval = &quot;Contravariant;&quot;\n            End If\n        End If \n\n        &#39; Select the constraint flags.\n        Dim constraints As GenericParameterAttributes = _\n            gpa And GenericParameterAttributes.SpecialConstraintMask\n        \n        If constraints = GenericParameterAttributes.None Then\n            retval &amp;= &quot; no special constraints.&quot;\n        Else\n            If (constraints And GenericParameterAttributes.ReferenceTypeConstraint) &lt;&gt; 0 Then\n                retval &amp;= &quot; ReferenceTypeConstraint&quot;\n            End If\n            If (constraints And GenericParameterAttributes.NotNullableValueTypeConstraint) &lt;&gt; 0 Then\n                retval &amp;= &quot; NotNullableValueTypeConstraint&quot;\n            End If\n            If (constraints And GenericParameterAttributes.DefaultConstructorConstraint) &lt;&gt; 0 Then\n                retval &amp;= &quot; DefaultConstructorConstraint&quot;\n            End If\n        End If \n        Return retval\n    \n    End Function \nEnd Class \n&#39; This example produces the following output:\n&#39;\n&#39;Examining generic type Test`2[T,U]\n&#39;\n&#39;Type parameter: T\n&#39;        No variance flag; no special constraints.\n&#39;        Base\n&#39;        ITest\n&#39;\n&#39;Type parameter: U\n&#39;        No variance flag; ReferenceTypeConstraint DefaultConstructorConstraint\n&#39; \n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.GetGenericParameterConstraints#1\">using System;\nusing System.Reflection;\n\n// Define a sample interface to use as an interface constraint.\npublic interface ITest {}\n\n// Define a base type to use as a base class constraint.\npublic class Base {}\n\n// Define the generic type to examine. The first generic type parameter,\n// T, derives from the class Base and implements ITest. This demonstrates\n// a base class constraint and an interface constraint. The second generic \n// type parameter, U, must be a reference type (class) and must have a \n// default constructor (new()). This demonstrates special constraints.\n//\npublic class Test&lt;T,U&gt; \n    where T : Base, ITest \n    where U : class, new() {}\n\n// Define a type that derives from Base and implements ITest. This type\n// satisfies the constraints on T in class Test.\npublic class Derived : Base, ITest {}\n\npublic class Example\n{\n    public static void Main()\n    {\n        // To get the generic type definition, omit the type\n        // arguments but retain the comma to indicate the number\n        // of type arguments. \n        //\n        Type def = typeof(Test&lt;,&gt;);\n        Console.WriteLine(&quot;\\r<br>Examining generic type {0}&quot;, def);\n\n        // Get the type parameters of the generic type definition,\n        // and display them.\n        //\n        Type[] defparams = def.GetGenericArguments();\n        foreach (Type tp in defparams)\n        {\n            Console.WriteLine(&quot;\\r<br>Type parameter: {0}&quot;, tp.Name);\n            Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;, \n                ListGenericParameterAttributes(tp));\n\n            // List the base class and interface constraints. The\n            // constraints are returned in no particular order. If \n            // there are no class or interface constraints, an empty\n            // array is returned.\n            //\n            Type[] tpConstraints = tp.GetGenericParameterConstraints();\n            foreach (Type tpc in tpConstraints)\n            {\n                Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;, tpc);\n            }\n        }\n    }\n\n    // List the variance and special constraint flags. \n    //\n    private static string ListGenericParameterAttributes(Type t)\n    {\n        string retval;\n        GenericParameterAttributes gpa = t.GenericParameterAttributes;\n        GenericParameterAttributes variance = gpa &amp; \n            GenericParameterAttributes.VarianceMask;\n\n        // Select the variance flags.\n        if (variance == GenericParameterAttributes.None)\n            retval = &quot;No variance flag;&quot;;\n        else\n        {\n            if ((variance &amp; GenericParameterAttributes.Covariant) != 0)\n                retval = &quot;Covariant;&quot;;\n            else\n                retval = &quot;Contravariant;&quot;;\n        }\n\n        // Select \n        GenericParameterAttributes constraints = gpa &amp; \n            GenericParameterAttributes.SpecialConstraintMask;\n\n        if (constraints == GenericParameterAttributes.None)\n            retval += &quot; No special constraints&quot;;\n        else\n        {\n            if ((constraints &amp; GenericParameterAttributes.ReferenceTypeConstraint) != 0)\n                retval += &quot; ReferenceTypeConstraint&quot;;\n            if ((constraints &amp; GenericParameterAttributes.NotNullableValueTypeConstraint) != 0)\n                retval += &quot; NotNullableValueTypeConstraint&quot;;\n            if ((constraints &amp; GenericParameterAttributes.DefaultConstructorConstraint) != 0)\n                retval += &quot; DefaultConstructorConstraint&quot;;\n        }\n\n        return retval;\n    }\n}\n/* This example produces the following output:\n\nExamining generic type Test`2[T,U]\n\nType parameter: T\n        No variance flag; no special constraints.\n        Base\n        ITest\n\nType parameter: U\n        No variance flag; ReferenceTypeConstraint DefaultConstructorConstraint\n */\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Type.GetGenericParameterConstraints#1\">using namespace System;\nusing namespace System::Collections;\nusing namespace System::Reflection;\n\n// Define a sample interface to use as an interface constraint.\ninterface class ITest{};\n\n// Define a base type to use as a class constraint.\npublic ref class Base{};\n\n// Define the generic type to examine. The first generic type parameter,\n// T, derives from the class Base and implements ITest. This demonstrates\n// a base class constraint and an interface constraint. In the .NET\n// Framework version 2.0, C++ has no way of expressing special constraints.\n// See the C# example code.\n//\ngeneric &lt;typename T, typename U&gt;\n   where T :  Base, ITest\nref class Test {};\n\n// Define a type that derives from Base and implements interface\n// ITest. This type satisfies the constraint on T in class Test.\npublic ref class Derived: public Base, public ITest {};\n\npublic ref class Example\n{\npublic:\n   static void Main()\n   {\n      // Create a constructed type from Test&lt;T,U&gt;, and from it\n      // get the generic type definition.\n      //\n      Type^ def = Test::typeid;\n      Console::WriteLine( L&quot;\\r<br>Examining generic type {0}&quot;, def );\n      \n      // Get the type parameters of the generic type definition,\n      // and display them.\n      //\n      for each (Type^ tp in def-&gt;GetGenericArguments())\n      {\n         Console::WriteLine( L&quot;\\r<br>Type parameter: {0}&quot;, tp);\n         Console::WriteLine( L&quot;&nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;, \n            ListGenericParameterAttributes( tp ) );\n         \n         // List the base class and interface constraints. The\n         // constraints do not appear in any particular order. If\n         // there are no class or interface constraints, an empty\n         // array is returned.\n         //\n         for each (Type^ constraint in tp-&gt;GetGenericParameterConstraints())\n         {\n            Console::WriteLine( L&quot;&nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;, constraint );\n         }\n      }\n   }\n\nprivate:\n\n   // List the variance and special constraint flags. \n   //\n   static String^ ListGenericParameterAttributes( Type^ t )\n   {\n      String^ retval;\n      GenericParameterAttributes gpa = t-&gt;GenericParameterAttributes;\n\n      // Select the variance flag.\n      GenericParameterAttributes variance =\n         static_cast&lt;GenericParameterAttributes&gt;(\n            gpa &amp; GenericParameterAttributes::VarianceMask );\n\n      if ( variance == GenericParameterAttributes::None )\n            retval = L&quot;No variance flag;&quot;;\n      else\n      {\n         if ( (variance &amp; GenericParameterAttributes::Covariant) !=\n               GenericParameterAttributes::None )\n            retval = L&quot;Covariant;&quot;;\n         else\n            retval = L&quot;Contravariant;&quot;;\n      }\n\n      // Select the special constraint flags.\n      GenericParameterAttributes constraints =\n         static_cast&lt;GenericParameterAttributes&gt;(\n            gpa &amp; GenericParameterAttributes::SpecialConstraintMask);\n\n      if ( constraints == GenericParameterAttributes::None )\n            retval = String::Concat( retval, L&quot; No special constraints&quot; );\n      else\n      {\n         if ( (constraints &amp; GenericParameterAttributes::ReferenceTypeConstraint) !=\n               GenericParameterAttributes::None )\n            retval = String::Concat( retval, L&quot; ReferenceTypeConstraint&quot; );\n\n         if ( (constraints &amp; GenericParameterAttributes::NotNullableValueTypeConstraint) !=\n               GenericParameterAttributes::None )\n            retval = String::Concat( retval, L&quot; NotNullableValueTypeConstraint&quot; );\n\n         if ( (constraints &amp; GenericParameterAttributes::DefaultConstructorConstraint) !=\n               GenericParameterAttributes::None )\n            retval = String::Concat( retval, L&quot; DefaultConstructorConstraint&quot; );\n      }\n\n      return retval;\n   }\n};\n\nint main()\n{\n   Example::Main();\n}\n\n/* This example produces the following output:\n\nExamining generic type Test`2[T,U]\n\nType parameter: T\n        No variance flag; No special constraints\n        Base\n        ITest\n\nType parameter: U\n        No variance flag; No special constraints\n */\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GenericParameterPosition\">\r\n    \r\n            <a id=\"System_Type_GenericParameterPosition_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GenericParameterPosition</div>        \r\n          </div>\r\n    \r\n            <p>Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents a type parameter of a generic type or a generic method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual int GenericParameterPosition { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </div>\r\n                  <p>The position of a type parameter in the type parameter list of the generic type or method that defines the parameter. Position numbers begin at 0.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The current type does not represent a type parameter. That is, <span class=\"xref\">stem.Type.IsGenericParameter*</span> returns <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The GenericParameterPosition property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined. The <a class=\"xref\" href=\"system.type#System_Type_DeclaringType_\" data-linktype=\"relative-path\">DeclaringType</a> and <a class=\"xref\" href=\"system.type#System_Type_DeclaringMethod_\" data-linktype=\"relative-path\">DeclaringMethod</a> properties identify the generic type or method definition:  </p>\n<ul>\n<li><p>If the <a class=\"xref\" href=\"system.type#System_Type_DeclaringMethod_\" data-linktype=\"relative-path\">DeclaringMethod</a> property returns a <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a>, that <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> represents a generic method definition, and the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents a type parameter of that generic method definition.  </p>\n</li>\n<li><p>If the <a class=\"xref\" href=\"system.type#System_Type_DeclaringMethod_\" data-linktype=\"relative-path\">DeclaringMethod</a> property returns <code>null</code>, then the <a class=\"xref\" href=\"system.type#System_Type_DeclaringType_\" data-linktype=\"relative-path\">DeclaringType</a> property always returns a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object representing a generic type definition, and the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents a type parameter of that generic type definition.  </p>\n<p>To provide the correct context for the value of the GenericParameterPosition property, it is necessary to identify the generic type or method a type parameter belongs to. For example, consider the return value of the generic method <code>GetSomething</code> in the following code:  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Type.GenericParameterPosition#1\">generic&lt;typename T, typename U&gt; public ref class B { };\ngeneric&lt;typename V&gt; public ref class A\n{\npublic:\n    generic&lt;typename X&gt; B&lt;V, X&gt;^ GetSomething()\n    {\n        return gcnew B&lt;V, X&gt;();\n    }\n};\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.GenericParameterPosition#1\">public class B&lt;T, U&gt; { }\npublic class A&lt;V&gt;\n{\n    public B&lt;V, X&gt; GetSomething&lt;X&gt;()\n    {\n        return new B&lt;V, X&gt;();\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.GenericParameterPosition#1\">Public Class B(Of T, U)\nEnd Class\nPublic Class A(Of V)\n    Public Function GetSomething(Of X)() As B(Of V, X)\n        Return New B(Of V, X)()\n    End Function\nEnd Class\n</code></pre><p>The type returned by <code>GetSomething</code> depends on the type arguments supplied to class <code>A</code> and to <code>GetSomething</code> itself. You can obtain a <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> for <code>GetSomething</code>, and from that you can obtain the return type. When you examine the type parameters of the return type, GenericParameterPosition returns 0 for both. The position of <code>V</code> is 0 because <code>V</code> is the first type parameter in the type parameter list for class <code>A</code>. The position of <code>X</code> is 0 because <code>X</code> is the first type parameter in the type parameter list for <code>GetSomething</code>.  </p>\n</li>\n</ul>\n<div class=\"NOTE\"><h5>Note</h5><p> Calling the GenericParameterPosition property causes an exception if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> does not represent a type parameter. When you examine the type arguments of an open constructed type, use the <a class=\"xref\" href=\"system.type#System_Type_IsGenericParameter_\" data-linktype=\"relative-path\">IsGenericParameter</a> property to tell which are type parameters and which are types. The <a class=\"xref\" href=\"system.type#System_Type_IsGenericParameter_\" data-linktype=\"relative-path\">IsGenericParameter</a> property returns <code>true</code> for a type parameter; you can then use the GenericParameterPosition method to obtain its position and use the <a class=\"xref\" href=\"system.type#System_Type_DeclaringMethod_\" data-linktype=\"relative-path\">DeclaringMethod</a> and <a class=\"xref\" href=\"system.type#System_Type_DeclaringType_\" data-linktype=\"relative-path\">DeclaringType</a> properties to determine the generic method or type definition that defines it.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example defines a generic class with two type parameters and defines a second generic class that derives from the first class. The derived class&#39;s base class has two type arguments: the first is <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a>, and the second is a type parameter of the derived type. The example displays information about these generic classes, including the positions reported by the GenericParameterPosition property.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.HasUnboundGenericParameters#1\">using System;\nusing System.Reflection;\nusing System.Collections.Generic;\n\n// Define a base class with two type parameters.\npublic class Base&lt;T, U&gt; { }\n\n// Define a derived class. The derived class inherits from a constructed\n// class that meets the following criteria:\n//   (1) Its generic type definition is Base&lt;T, U&gt;.\n//   (2) It specifies int for the first type parameter.\n//   (3) For the second type parameter, it uses the same type that is used\n//       for the type parameter of the derived class.\n// Thus, the derived class is a generic type with one type parameter, but\n// its base class is an open constructed type with one type argument and\n// one type parameter.\npublic class Derived&lt;V&gt; : Base&lt;int, V&gt; { }\n\npublic class Test\n{\n    public static void Main()\n    {\n        Console.WriteLine(\n            &quot;\\r<br>--- Display a generic type and the open constructed&quot;);\n        Console.WriteLine(&quot;    type from which it is derived.&quot;);\n\n        // Create a Type object representing the generic type definition \n        // for the Derived type, by omitting the type argument. (For\n        // types with multiple type parameters, supply the commas but\n        // omit the type arguments.) \n        //\n        Type derivedType = typeof(Derived&lt;&gt;);\n        DisplayGenericTypeInfo(derivedType);\n\n        // Display its open constructed base type.\n        DisplayGenericTypeInfo(derivedType.BaseType);\n    }\n\n    private static void DisplayGenericTypeInfo(Type t)\n    {\n        Console.WriteLine(&quot;\\r<br>{0}&quot;, t);\n\n        Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;Is this a generic type definition? {0}&quot;, \n            t.IsGenericTypeDefinition);\n\n        Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;Is it a generic type? {0}&quot;, \n            t.IsGenericType);\n\n        Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;Does it have unassigned generic parameters? {0}&quot;, \n            t.ContainsGenericParameters);\n\n        if (t.IsGenericType)\n        {\n            // If this is a generic type, display the type arguments.\n            //\n            Type[] typeArguments = t.GetGenericArguments();\n\n            Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;List type arguments ({0}):&quot;, \n                typeArguments.Length);\n\n            foreach (Type tParam in typeArguments)\n            {\n                // IsGenericParameter is true only for generic type\n                // parameters.\n                //\n                if (tParam.IsGenericParameter)\n                {\n                    Console.WriteLine(\n                        &quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}  (unassigned - parameter position {1})&quot;,\n                        tParam,\n                        tParam.GenericParameterPosition);\n                }\n                else\n                {\n                    Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;, tParam);\n                }\n            }\n        }\n    }\n}\n\n/* This example produces the following output:\n\n--- Display a generic type and the open constructed\n    type from which it is derived.\n\nDerived`1[V]\n        Is this a generic type definition? True\n        Is it a generic type? True\n        Does it have unassigned generic parameters? True\n        List type arguments (1):\n                V  (unassigned - parameter position 0)\n\nBase`2[System.Int32,V]\n        Is this a generic type definition? False\n        Is it a generic type? True\n        Does it have unassigned generic parameters? True\n        List type arguments (2):\n                System.Int32\n                V  (unassigned - parameter position 0)\n */\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Type.HasUnboundGenericParameters#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Collections::Generic;\n\n// Define a base class with two type parameters.\ngeneric&lt; class T,class U &gt;\npublic ref class Base {};\n\n// Define a derived class. The derived class inherits from a constructed\n// class that meets the following criteria:\n//   (1) Its generic type definition is Base&lt;T, U&gt;.\n//   (2) It specifies int for the first type parameter.\n//   (3) For the second type parameter, it uses the same type that is used\n//       for the type parameter of the derived class.\n// Thus, the derived class is a generic type with one type parameter, but\n// its base class is an open constructed type with one type argument and\n// one type parameter.\ngeneric&lt;class V&gt;\npublic ref class Derived : Base&lt;int,V&gt; {};\n\npublic ref class Test\n{\npublic:\n    static void Main()\n    {\n        Console::WriteLine( \n            L&quot;\\r<br>--- Display a generic type and the open constructed&quot;);\n        Console::WriteLine(L&quot;    type from which it is derived.&quot;);\n      \n        // Create a Type object representing the generic type definition\n        // for the Derived type. Note the absence of type arguments.\n        //\n        Type^ derivedType = Derived::typeid;\n        DisplayGenericTypeInfo(derivedType);\n      \n        // Display its open constructed base type.\n        DisplayGenericTypeInfo(derivedType-&gt;BaseType);\n    }\n\n\nprivate:\n    static void DisplayGenericTypeInfo(Type^ t)\n    {\n        Console::WriteLine(L&quot;\\r<br>{0}&quot;, t);\n        Console::WriteLine(L&quot;&nbsp;&nbsp;&nbsp;&nbsp;Is this a generic type definition? {0}&quot;,\n            t-&gt;IsGenericTypeDefinition);\n        Console::WriteLine(L&quot;&nbsp;&nbsp;&nbsp;&nbsp;Is it a generic type? {0}&quot;, t-&gt;IsGenericType);\n        Console::WriteLine(L&quot;&nbsp;&nbsp;&nbsp;&nbsp;Does it have unassigned generic parameters? {0}&quot;,\n            t-&gt;ContainsGenericParameters);\n        if (t-&gt;IsGenericType)\n        {\n         \n            // If this is a generic type, display the type arguments.\n            //\n            array&lt;Type^&gt;^typeArguments = t-&gt;GetGenericArguments();\n            Console::WriteLine(L&quot;&nbsp;&nbsp;&nbsp;&nbsp;List type arguments ({0}):&quot;,\n                typeArguments-&gt;Length);\n            System::Collections::IEnumerator^ myEnum = \n                typeArguments-&gt;GetEnumerator();\n            while (myEnum-&gt;MoveNext())\n            {\n                Type^ tParam = safe_cast&lt;Type^&gt;(myEnum-&gt;Current);\n            \n                // IsGenericParameter is true only for generic type\n                // parameters.\n                //\n                if (tParam-&gt;IsGenericParameter)\n                {\n                    Console::WriteLine( \n                        L&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}  (unassigned - parameter position {1})&quot;, \n                        tParam, tParam-&gt;GenericParameterPosition);\n                }\n                else\n                {\n                    Console::WriteLine(L&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;, tParam);\n                }\n            }\n        }\n    }\n};\n\nint main()\n{\n    Test::Main();\n}\n\n/* This example produces the following output:\n\n--- Display a generic type and the open constructed\n    type from which it is derived.\n\nDerived`1[V]\n        Is this a generic type definition? True\n        Is it a generic type? True\n        Does it have unassigned generic parameters? True\n        List type arguments (1):\n                V  (unassigned - parameter position 0)\n\nBase`2[System.Int32,V]\n        Is this a generic type definition? False\n        Is it a generic type? True\n        Does it have unassigned generic parameters? True\n        List type arguments (2):\n                System.Int32\n                V  (unassigned - parameter position 0)\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.HasUnboundGenericParameters#1\">Imports System\nImports System.Reflection\nImports System.Collections.Generic\nImports Microsoft.VisualBasic\n\n&#39; Define a base class with two type parameters.\nPublic Class Base(Of T, U)\nEnd Class\n\n&#39; Define a derived class. The derived class inherits from a constructed\n&#39; class that meets the following criteria:\n&#39;   (1) Its generic type definition is Base&lt;T, U&gt;.\n&#39;   (2) It uses int for the first type parameter.\n&#39;   (3) For the second type parameter, it uses the same type that is used\n&#39;       for the type parameter of the derived class.\n&#39; Thus, the derived class is a generic type with one type parameter, but\n&#39; its base class is an open constructed type with one assigned type\n&#39; parameter and one unassigned type parameter.\nPublic Class Derived(Of V)\n    Inherits Base(Of Integer, V)\nEnd Class\n\nPublic Class Test\n    \n    Public Shared Sub Main() \n        Console.WriteLine(vbCrLf _\n            &amp; &quot;--- Display a generic type and the open constructed&quot;)\n        Console.WriteLine(&quot;    type from which it is derived.&quot;)\n        \n        &#39; Create a Type object representing the generic type definition \n        &#39; for the Derived type, by omitting the type argument. (For\n        &#39; types with multiple type parameters, supply the commas but\n        &#39; omit the type arguments.) \n        &#39;\n        Dim derivedType As Type = GetType(Derived(Of ))\n        DisplayGenericTypeInfo(derivedType)\n        \n        &#39; Display its open constructed base type.\n        DisplayGenericTypeInfo(derivedType.BaseType)\n    \n    End Sub &#39;Main\n    \n    Private Shared Sub DisplayGenericTypeInfo(ByVal t As Type) \n        Console.WriteLine(vbCrLf &amp; &quot;{0}&quot;, t)\n        \n        Console.WriteLine(vbTab &amp; &quot;Is this a generic type definition? &quot; _\n            &amp; t.IsGenericTypeDefinition)\n        \n        Console.WriteLine(vbTab &amp; &quot;Is it a generic type? &quot; _\n            &amp; t.IsGenericType)\n        \n        Console.WriteLine(vbTab _\n            &amp; &quot;Does it have unassigned generic parameters? &quot; _\n            &amp; t.ContainsGenericParameters)\n        \n        If t.IsGenericType Then\n            &#39; If this is a generic type, display the type arguments.\n            &#39;\n            Dim typeArguments As Type() = t.GetGenericArguments()\n            \n            Console.WriteLine(vbTab &amp; &quot;List type arguments (&quot; _\n                &amp; typeArguments.Length &amp; &quot;):&quot;)\n            \n            For Each tParam As Type In typeArguments\n                &#39; IsGenericParameter is true only for generic type\n                &#39; parameters.\n                &#39;\n                If tParam.IsGenericParameter Then\n                    Console.WriteLine(vbTab &amp; vbTab &amp; tParam.ToString() _\n                        &amp; &quot;  (unassigned - parameter position &quot; _\n                        &amp; tParam.GenericParameterPosition &amp; &quot;)&quot;)\n                Else\n                    Console.WriteLine(vbTab &amp; vbTab &amp; tParam.ToString())\n                End If\n            Next tParam\n        End If\n    \n    End Sub &#39;DisplayGenericTypeInfo\nEnd Class &#39;Test\n\n&#39; This example produces the following output:\n&#39;\n&#39;--- Display a generic type and the open constructed\n&#39;    type from which it is derived.\n&#39;\n&#39;Derived`1[V]\n&#39;        Is this a generic type definition? True\n&#39;        Is it a generic type? True\n&#39;        Does it have unassigned generic parameters? True\n&#39;        List type arguments (1):\n&#39;                V  (unassigned - parameter position 0)\n&#39;\n&#39;Base`2[System.Int32,V]\n&#39;        Is this a generic type definition? False\n&#39;        Is it a generic type? True\n&#39;        Does it have unassigned generic parameters? True\n&#39;        List type parameters (2):\n&#39;                System.Int32\n&#39;                V  (unassigned - parameter position 0)\n&#39; \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GenericTypeArguments\">\r\n    \r\n            <a id=\"System_Type_GenericTypeArguments_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GenericTypeArguments</div>        \r\n          </div>\r\n    \r\n            <p>Gets an array of the generic type arguments for this type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual Type[] GenericTypeArguments { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </div>\r\n                  <p>An array of the generic type arguments for this type.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type. If the current type is a generic type definition, this property returns an empty array.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> If a generic type is used in a generic method or in another generic type, some of its generic type arguments might be generic type parameters of the enclosing method or type.  </p>\n</div>\n<p> To get the generic type parameters of a type that represents a generic type definition, use the <a class=\"xref\" href=\"system.reflection.typeinfo#System_Reflection_TypeInfo_GenericTypeParameters_\" data-linktype=\"relative-path\">GenericTypeParameters</a> property. To get a <a class=\"xref\" href=\"system.reflection.typeinfo\" data-linktype=\"relative-path\">TypeInfo</a> object for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object, use the <a class=\"xref\" href=\"system.reflection.introspectionextensions#System_Reflection_IntrospectionExtensions_GetTypeInfo_\" data-linktype=\"relative-path\">GetTypeInfo</a> extension method.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GUID\">\r\n    \r\n            <a id=\"System_Type_GUID_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GUID</div>        \r\n          </div>\r\n    \r\n            <p>Gets the GUID associated with the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract Guid GUID { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.guid\" data-linktype=\"relative-path\">Guid</a></div>\r\n                  </div>\r\n                  <p>The GUID associated with the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A GUID is associated with a type using the <a class=\"xref\" href=\"system.runtime.interopservices.guidattribute\" data-linktype=\"relative-path\">GuidAttribute</a> attribute.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates the class <code>MyClass1</code> with a public method, creates a <code>Type</code> object corresponding to <code>MyClass1</code>, and gets the <a class=\"xref\" href=\"system.guid\" data-linktype=\"relative-path\">Guid</a> structure using the <code>GUID</code> property of the <code>Type</code> class.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_Guid#1\">using System;\n\nclass MyGetTypeFromCLSID\n{\n    public class MyClass1\n    {\n        public void MyMethod1()\n        {\n        }\n    }\n    public static void Main()\n    {\n        // Get the type corresponding to the class MyClass.\n        Type myType = typeof(MyClass1);\n        // Get the object of the Guid.\n        Guid myGuid =(Guid) myType.GUID;\n        Console.WriteLine(&quot;The name of the class is &quot;+myType.ToString());\n        Console.WriteLine(&quot;The ClassId of MyClass is &quot;+myType.GUID);\t\t\t\t\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_Guid#1\">using namespace System;\nref class MyGetTypeFromCLSID\n{\npublic:\n   ref class MyClass1\n   {\n   public:\n      void MyMethod1(){}\n   };\n};\n\nint main()\n{\n   \n   // Get the type corresponding to the class MyClass.\n   Type^ myType = MyGetTypeFromCLSID::MyClass1::typeid;\n   \n   // Get the Object* of the Guid.\n   Guid myGuid = (Guid)myType-&gt;GUID;\n   Console::WriteLine( &quot;The name of the class is {0}&quot;, myType );\n   Console::WriteLine( &quot;The ClassId of MyClass is {0}&quot;, myType-&gt;GUID );\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_Guid#1\">Class MyGetTypeFromCLSID\n\n    Public Class MyClass1\n\n        Public Sub MyMethod1()\n        End Sub &#39;MyMethod1\n\n    End Class &#39;MyClass1\n\n    Public Shared Sub Main()\n        &#39; Get the type corresponding to the class MyClass.\n        Dim myType As Type = GetType(MyClass1)\n        &#39; Get the object of the Guid.\n        Dim myGuid As Guid = myType.GUID\n        Console.WriteLine((&quot;The name of the class is &quot; + myType.ToString()))\n        Console.WriteLine((&quot;The ClassId of MyClass is &quot; + myType.GUID.ToString()))\n    End Sub &#39;Main \nEnd Class &#39;MyGetTypeFromCLSID\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_HasElementType\">\r\n    \r\n            <a id=\"System_Type_HasElementType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">HasElementType</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> encompasses or refers to another type; that is, whether the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is an array, a pointer, or is passed by reference.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool HasElementType { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is an array, a pointer, or is passed by reference; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>For example, Type.GetType(&quot;Int32[]&quot;).HasElementType returns <code>true</code>, but Type.GetType(&quot;Int32&quot;).HasElementType returns <code>false</code>. HasElementType also returns <code>true</code> for &quot;Int32*&quot; and &quot;Int32&amp;&quot;.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <code>false</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example returns <code>true</code> or <code>false</code> depending on whether or not the object is an array, a reference type, or a pointer.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_HasElementType#1\">// This code must be compiled with the /unsafe switch:\n//   csc /unsafe source.cs\nusing System;\nusing System.Reflection;\n\npublic class Example\n{\n    // This method is for demonstration purposes.\n    unsafe public void Test(ref int x, out int y, int* z) \n    { \n        *z = x = y = 0; \n    }\n\n    public static void Main()\n    {\n        // All of the following display &#39;True&#39;.\n\n        // Define an array, get its type, and display HasElementType. \n        int[] nums = {1, 1, 2, 3, 5, 8, 13};\n        Type t = nums.GetType();\n        Console.WriteLine(&quot;HasElementType is &#39;{0}&#39; for array types.&quot;, t.HasElementType);\n\n        // Test an array type without defining an array.\n        t = typeof(Example[]);\n        Console.WriteLine(&quot;HasElementType is &#39;{0}&#39; for array types.&quot;, t.HasElementType);\n\n        // When you use Reflection Emit to emit dynamic methods and\n        // assemblies, you can create array types using MakeArrayType.\n        // The following creates the type &#39;array of Example&#39;.\n        t = typeof(Example).MakeArrayType();\n        Console.WriteLine(&quot;HasElementType is &#39;{0}&#39; for array types.&quot;, t.HasElementType);\n\n        // When you reflect over methods, HasElementType is true for\n        // ref, out, and pointer parameter types. The following \n        // gets the Test method, defined above, and examines its\n        // parameters.\n        MethodInfo mi = typeof(Example).GetMethod(&quot;Test&quot;);\n        ParameterInfo[] parms = mi.GetParameters();\n        t = parms[0].ParameterType;\n        Console.WriteLine(&quot;HasElementType is &#39;{0}&#39; for ref parameter types.&quot;, t.HasElementType);\n        t = parms[1].ParameterType;\n        Console.WriteLine(&quot;HasElementType is &#39;{0}&#39; for out parameter types.&quot;, t.HasElementType);\n        t = parms[2].ParameterType;\n        Console.WriteLine(&quot;HasElementType is &#39;{0}&#39; for pointer parameter types.&quot;, t.HasElementType);\n\n        // When you use Reflection Emit to emit dynamic methods and\n        // assemblies, you can create pointer and ByRef types to use\n        // when you define method parameters.\n        t = typeof(Example).MakePointerType();\n        Console.WriteLine(&quot;HasElementType is &#39;{0}&#39; for pointer types.&quot;, t.HasElementType);\n        t = typeof(Example).MakeByRefType();\n        Console.WriteLine(&quot;HasElementType is &#39;{0}&#39; for ByRef types.&quot;, t.HasElementType);\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_HasElementType#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Runtime::InteropServices;\n\npublic ref class Example\n{\npublic:\n    // This method is for demonstration purposes. It includes a\n    // tracking reference (C# ref, VB ByRef), an out parameter,\n    // and a pointer.\n    void Test(int% x, [OutAttribute()] int% y, int* z)\n    { \n        *z = x = y = 0; \n    }    \n};\n\nint main()\n{\n    // All of the following display &#39;True&#39;.\n\n    // Define a managed array, get its type, and display HasElementType. \n    array&lt;Example^&gt;^ examples = {gcnew Example(), gcnew Example()};\n    Type^ t = examples::typeid; \n    Console::WriteLine(t);\n    Console::WriteLine(&quot;HasElementType is &#39;{0}&#39; for managed array types.&quot;, t-&gt;HasElementType);\n\n    // When you use Reflection Emit to emit dynamic methods and\n    // assemblies, you can create array types using MakeArrayType.\n    // The following creates the type &#39;array of Example&#39;.\n    t = Example::typeid-&gt;MakeArrayType();\n    Console::WriteLine(&quot;HasElementType is &#39;{0}&#39; for managed array types.&quot;, t-&gt;HasElementType);\n\n    // When you reflect over methods, HasElementType is true for\n    // ref, out, and pointer parameter types. The following \n    // gets the Test method, defined above, and examines its\n    // parameters.\n    MethodInfo^ mi = Example::typeid-&gt;GetMethod(&quot;Test&quot;);\n    array&lt;ParameterInfo^&gt;^ parms = mi-&gt;GetParameters();\n    t = parms[0]-&gt;ParameterType;\n    Console::WriteLine(&quot;HasElementType is &#39;{0}&#39; for ref parameter types.&quot;, t-&gt;HasElementType);\n    t = parms[1]-&gt;ParameterType;\n    Console::WriteLine(&quot;HasElementType is &#39;{0}&#39; for out parameter types.&quot;, t-&gt;HasElementType);\n    t = parms[2]-&gt;ParameterType;\n    Console::WriteLine(&quot;HasElementType is &#39;{0}&#39; for pointer parameter types.&quot;, t-&gt;HasElementType);\n\n    // When you use Reflection Emit to emit dynamic methods and\n    // assemblies, you can create pointer and ByRef types to use\n    // when you define method parameters.\n    t = Example::typeid-&gt;MakePointerType();\n    Console::WriteLine(&quot;HasElementType is &#39;{0}&#39; for pointer types.&quot;, t-&gt;HasElementType);\n    t = Example::typeid-&gt;MakeByRefType();\n    Console::WriteLine(&quot;HasElementType is &#39;{0}&#39; for ByRef types.&quot;, t-&gt;HasElementType);\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_HasElementType#1\">Imports System\nImports System.Reflection\nImports System.Runtime.InteropServices\n\nPublic Class Example\n\n    &#39; This method is for demonstration purposes.\n    Public Shared Sub Test(ByRef x As Integer, &lt;Out&gt; ByRef y As Integer)\n    End Sub\n\n    Public Shared Sub Main()\n        &#39; All of the following display &#39;True&#39;.\n\n        &#39; Define an array, get its type, and display HasElementType. \n        Dim nums() As Integer = {1, 1, 2, 3, 5, 8, 13}\n        Dim t As Type = nums.GetType()\n        Console.WriteLine(&quot;HasElementType is &#39;{0}&#39; for array types.&quot;, t.HasElementType)\n\n        &#39; Test an array type without defining an array.\n        t = GetType(Example())\n        Console.WriteLine(&quot;HasElementType is &#39;{0}&#39; for array types.&quot;, t.HasElementType)\n\n        &#39; When you use Reflection Emit to emit dynamic methods and\n        &#39; assemblies, you can create array types using MakeArrayType.\n        &#39; The following creates the type &#39;array of Example&#39;.\n        t = GetType(Example).MakeArrayType()\n        Console.WriteLine(&quot;HasElementType is &#39;{0}&#39; for array types.&quot;, t.HasElementType)\n\n        &#39; When you reflect over methods, HasElementType is true for\n        &#39; ref, out, and pointer parameter types. The following \n        &#39; gets the Test method, defined above, and examines its\n        &#39; parameters.\n        Dim mi As MethodInfo = GetType(Example).GetMethod(&quot;Test&quot;)\n        Dim parms() As ParameterInfo = mi.GetParameters()\n        t = parms(0).ParameterType\n        Console.WriteLine(&quot;HasElementType is &#39;{0}&#39; for ref parameter types.&quot;, t.HasElementType)\n        t = parms(1).ParameterType\n        Console.WriteLine(&quot;HasElementType is &#39;{0}&#39; for &lt;Out&gt; parameter types.&quot;, t.HasElementType)\n\n        &#39; When you use Reflection Emit to emit dynamic methods and\n        &#39; assemblies, you can create pointer and ByRef types to use\n        &#39; when you define method parameters.\n        t = GetType(Example).MakePointerType()\n        Console.WriteLine(&quot;HasElementType is &#39;{0}&#39; for pointer types.&quot;, t.HasElementType)\n        t = GetType(Example).MakeByRefType()\n        Console.WriteLine(&quot;HasElementType is &#39;{0}&#39; for ByRef types.&quot;, t.HasElementType)\n    End Sub \n\nEnd Class\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsAbstract\">\r\n    \r\n            <a id=\"System_Type_IsAbstract_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsAbstract</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is abstract and must be overridden.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsAbstract { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is abstract; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The IsAbstract property returns <code>true</code> in the following cases:  </p>\n<ul>\n<li><p>The current type is abstract; that is, it cannot be instantiated, but can only serve as the base class for derived classes. In C#, abstract classes are marked with the <a href=\"../Topic/abstract%20(C%23%20Reference).md\" data-linktype=\"relative-path\">abstract</a> keyword; in Visual Basic, they are marked with the <a href=\"../Topic/MustInherit%20(Visual%20Basic).md\" data-linktype=\"relative-path\">MustInherit</a> keyword.  </p>\n</li>\n<li><p>The current type is an interface.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this property always returns <code>false</code>.</p>\n</li>\n</ul>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects that represent the following types:contains type returns <code>true</code> if the specified object is <code>abstract</code>; otherwise, it returns <code>false</code>.  </p>\n<ul>\n<li><p><code>AbstractClass</code>, an abstract class (a class marked as <code>abstract</code> in C# and <code>MustInherit</code> in Visual Basic).  </p>\n</li>\n<li><p><code>DerivedClass</code>, a class that inherits from <code>AbstractClass</code>.  </p>\n</li>\n<li><p><code>SingleClass</code>, a non-inheritable class. It is defined as <code>sealed</code> in C# and <code>NotInheritable</code> in Visual Basic.  </p>\n</li>\n<li><p><code>ITypeInfo</code>, an interface.  </p>\n</li>\n<li><p><code>ImplementingClass</code>, a class that implements the <code>ITypeInfo</code> interface.  </p>\n<p>The method returns <code>true</code> only for <code>AbstractClass</code>, the abstract class, and <code>ITypeInfo</code>, the interface.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.IsAbstract#1\">using System;\n\npublic abstract class AbstractClass\n{}\n\npublic class DerivedClass : AbstractClass\n{}\n\npublic sealed class SingleClass\n{}\n\npublic interface ITypeInfo\n{\n   string GetName();\n}\n\npublic class ImplementingClass : ITypeInfo\n{\n   public string GetName()\n   {\n      return this.GetType().FullName;\n   }\n}\n\ndelegate string InputOutput(string inp);\n\npublic class Example\n{\n   public static void Main()\n   {\n      Type[] types= { typeof(AbstractClass),\n                      typeof(DerivedClass),\n                      typeof(ITypeInfo),\n                      typeof(SingleClass),\n                      typeof(ImplementingClass),\n                      typeof(InputOutput) };\n      foreach (var type in types)\n         Console.WriteLine(&quot;{0} is abstract: {1}&quot;,\n                           type.Name, type.IsAbstract);\n\n   }\n}\n// The example displays the following output:\n//       AbstractClass is abstract: True\n//       DerivedClass is abstract: False\n//       ITypeInfo is abstract: True\n//       SingleClass is abstract: False\n//       ImplementingClass is abstract: False\n//       InputOutput is abstract: False\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.IsAbstract#1\">Public MustInherit Class AbstractClass\nEnd Class\n\nPublic Class DerivedClass : Inherits AbstractClass\nEnd Class\n\nPublic NotInheritable Class SingleClass\nEnd Class\n\nPublic Interface ITypeInfo\n   Function GetName() As String\nEnd Interface\n\nPublic Class ImplementingClass : Implements ITypeInfo\n   Public Function GetName() As String _\n          Implements ITypeInfo.GetName\n      Return Me.GetType().FullName\n   End Function\nEnd Class\n\nDelegate Function InputOutput(inp As String) As String\n\nModule Example\n   Public Sub Main()\n      Dim types() As Type = { GetType(AbstractClass),\n                              GetType(DerivedClass),\n                              GetType(ITypeInfo),\n                              GetType(SingleClass),\n                              GetType(ImplementingClass),\n                              GetType(InputOutput) }\n      For Each type In types\n         Console.WriteLine(&quot;{0} is abstract: {1}&quot;,\n                           type.Name, type.IsAbstract)\n      Next\n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       AbstractClass is abstract: True\n&#39;       DerivedClass is abstract: False\n&#39;       ITypeInfo is abstract: True\n&#39;       SingleClass is abstract: False\n&#39;       ImplementingClass is abstract: False\n&#39;       InputOutput is abstract: False\n</code></pre></li>\n</ul>\n\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsAnsiClass\">\r\n    \r\n            <a id=\"System_Type_IsAnsiClass_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsAnsiClass</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the string format attribute <code>AnsiClass</code> is selected for the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsAnsiClass { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the string format attribute <code>AnsiClass</code> is selected for the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">TypeAttributes</a> selects the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a generic type, this property pertains to the generic type definition from which the type was constructed. For example, if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents <code>MyGenericType&lt;int&gt;</code> (<code>MyGenericType(Of Integer)</code> in Visual Basic), the value of this property is determined by <code>MyGenericType&lt;T&gt;</code>.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter of a generic type, this property always returns <code>false</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example gets the field information and checks for the <code>AnsiClass</code> attribute.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_IsAnsiClass#1\">using namespace System;\nusing namespace System::Reflection;\npublic ref class MyClass\n{\nprotected:\n   String^ myField;\n\npublic:\n   MyClass()\n   {\n      myField =  &quot;A sample protected field&quot;;\n   }\n};\n\nint main()\n{\n   try\n   {\n      MyClass^ myObject = gcnew MyClass;\n      \n      // Get the type of the &#39;MyClass&#39;.\n      Type^ myType = MyClass::typeid;\n      \n      // Get the field information and the attributes associated with MyClass.\n      FieldInfo^ myFieldInfo = myType-&gt;GetField( &quot;myField&quot;, static_cast&lt;BindingFlags&gt;(BindingFlags::NonPublic | BindingFlags::Instance) );\n      Console::WriteLine( &quot;<br>Checking for the AnsiClass attribute for a field.<br>&quot; );\n      \n      // Get and display the name, field, and the AnsiClass attribute.\n      Console::WriteLine( &quot;Name of Class: {0} <br>Value of Field: {1} <br>IsAnsiClass = {2}&quot;, myType-&gt;FullName, myFieldInfo-&gt;GetValue( myObject ), myType-&gt;IsAnsiClass );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception: {0}&quot;, e-&gt;Message );\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_IsAnsiClass#1\">Imports System\nImports System.Reflection\nImports Microsoft.VisualBasic\nPublic Class MyClass1\n    Protected myField As String = &quot;A sample protected field.&quot;\nEnd Class &#39;MyClass1\nPublic Class MyType_IsAnsiClass\n    Public Shared Sub Main()\n        Try\n            Dim myObject As New MyClass1()\n            &#39; Get the type of MyClass1.\n            Dim myType As Type = GetType(MyClass1)\n            &#39; Get the field information and the attributes associated with MyClass1.\n            Dim myFieldInfo As FieldInfo = myType.GetField(&quot;myField&quot;, BindingFlags.NonPublic Or BindingFlags.Instance)\n\n            Console.WriteLine(ControlChars.NewLine + &quot;Checking for AnsiClass attribute for a field.&quot; + ControlChars.NewLine)\n            &#39; Get and display the name, field, and the AnsiClass attribute.\n            Console.WriteLine(&quot;Name of Class: {0} &quot; + ControlChars.NewLine + &quot;Value of Field: {1} &quot; + ControlChars.NewLine + &quot;IsAnsiClass = {2}&quot;, myType.FullName, myFieldInfo.GetValue(myObject), myType.IsAnsiClass)\n        Catch e As Exception\n            Console.WriteLine(&quot;Exception: {0}&quot;, e.Message.ToString())\n        End Try\n    End Sub &#39;Main\nEnd Class &#39;MyType_IsAnsiClass\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_IsAnsiClass#1\">using System;\nusing System.Reflection;\npublic class MyClass\n{\n    protected string myField = &quot;A sample protected field.&quot; ;\n}\npublic class MyType_IsAnsiClass\n{\n    public static void Main()\n    {\n        try\n        {\n            MyClass myObject = new MyClass();\n            // Get the type of the &#39;MyClass&#39;.\n            Type myType = typeof(MyClass);\n            // Get the field information and the attributes associated with MyClass.\n            FieldInfo myFieldInfo = myType.GetField(&quot;myField&quot;, BindingFlags.NonPublic|BindingFlags.Instance);\n            Console.WriteLine( &quot;<br>Checking for the AnsiClass attribute for a field.<br>&quot;); \n            // Get and display the name, field, and the AnsiClass attribute.\n            Console.WriteLine(&quot;Name of Class: {0} <br>Value of Field: {1} <br>IsAnsiClass = {2}&quot;, myType.FullName, myFieldInfo.GetValue(myObject), myType.IsAnsiClass);\n        }\n        catch(Exception e)\n        {\n            Console.WriteLine(&quot;Exception: {0}&quot;,e.Message);\n        }\n    }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsArray\">\r\n    \r\n            <a id=\"System_Type_IsArray_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsArray</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value that indicates whether the type is an array.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsArray { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the current type is an array; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The IsArray property returns <code>false</code> for the <a class=\"xref\" href=\"system.array\" data-linktype=\"relative-path\">Array</a> class. It also returns <code>false</code> if the current instance is a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents a collection type or an interface designed to work with collections, such as <a class=\"xref\" href=\"system.collections.ienumerable\" data-linktype=\"relative-path\">IEnumerable</a> or <a class=\"xref\" href=\"system.collections.generic.ienumerable-1\" data-linktype=\"relative-path\">IEnumerable&lt;T&gt;</a>.  </p>\n<p> To check for an array, use code such as:  </p>\n<p><codecontentplaceholder>0</codecontentplaceholder><br><codecontentplaceholder>1</codecontentplaceholder><br> If the current type represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <code>false</code>.  </p>\n<p> This property is read-only.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example demonstrates using theIsArray property.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.IsArray#1\">using System;\nusing System.Collections;\nusing System.Collections.Generic;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Type[] types = { typeof(String), typeof(int[]),\n                       typeof(ArrayList), typeof(Array),\n                       typeof(List&lt;String&gt;),\n                       typeof(IEnumerable&lt;Char&gt;) };\n      foreach (var t in types)\n         Console.WriteLine(&quot;{0,-15} IsArray = {1}&quot;, t.Name + &quot;:&quot;,\n                           t.IsArray);\n   }\n}\n// The example displays the following output:\n//       String:         IsArray = False\n//       Int32[]:        IsArray = True\n//       ArrayList:      IsArray = False\n//       Array:          IsArray = False\n//       List`1:         IsArray = False\n//       IEnumerable`1:  IsArray = False\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.IsArray#1\">Imports System.Collections\nImports System.Collections.Generic\n\nModule Example\n   Public Sub Main()\n      Dim types() As Type = { GetType(String), GetType(Integer()),\n                              GetType(ArrayList), GetType(Array),\n                              GetType(List(Of String)),\n                              GetType(IEnumerable(Of Char)) }\n      For Each t In types\n         Console.WriteLine(&quot;{0,-15} IsArray = {1}&quot;, t.Name + &quot;:&quot;, t.IsArray)\n      Next\n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       String:         IsArray = False\n&#39;       Int32[]:        IsArray = True\n&#39;       ArrayList:      IsArray = False\n&#39;       Array:          IsArray = False\n&#39;       List`1:         IsArray = False\n&#39;       IEnumerable`1:  IsArray = False\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsAutoClass\">\r\n    \r\n            <a id=\"System_Type_IsAutoClass_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsAutoClass</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the string format attribute <code>AutoClass</code> is selected for the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsAutoClass { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the string format attribute <code>AutoClass</code> is selected for the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">TypeAttributes</a> selects the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents <code>MyGenericType&lt;int&gt;</code> (<code>MyGenericType(Of Integer)</code> in Visual Basic), the value of this property is determined by <code>MyGenericType&lt;T&gt;</code>.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter of a generic type, this property always returns <code>false</code>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsAutoLayout\">\r\n    \r\n            <a id=\"System_Type_IsAutoLayout_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsAutoLayout</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsAutoLayout { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <span class=\"xref\">stem.Type.Attributes*</span> property of the current type includes <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">TypeAttributes</a>; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This property is provided as a convenience. Alternatively, you can use the <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a>enumeration value to select the type layout attributes, and then test whether <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a> is set. The <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a>,<a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a>, and <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a> enumeration values indicate the way the fields of the type are laid out in memory.  </p>\n<p> For dynamic types, you can specify <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a> when you create the type. In code, apply the <a class=\"xref\" href=\"system.runtime.interopservices.structlayoutattribute\" data-linktype=\"relative-path\">StructLayoutAttribute</a> attribute with the <a class=\"xref\" href=\"system.runtime.interopservices.layoutkind\" data-linktype=\"relative-path\">System.Runtime.InteropServices.LayoutKind</a> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> You cannot use the <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_GetCustomAttributes_\" data-linktype=\"relative-path\">GetCustomAttributes</a> method to determine whether the <a class=\"xref\" href=\"system.runtime.interopservices.structlayoutattribute\" data-linktype=\"relative-path\">StructLayoutAttribute</a> has been applied to a type.  </p>\n</div>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents <code>MyGenericType&lt;int&gt;</code> (<code>MyGenericType(Of Integer)</code> in Visual Basic), the value of this property is determined by <code>MyGenericType&lt;T&gt;.</code>  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this property always returns <code>false</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an instance of the type and displays the IsAutoLayout property.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_IsAutoLayout#1\">#using &lt;System.dll&gt;\n\nusing namespace System;\nusing namespace System::Reflection;\nusing namespace System::ComponentModel;\nusing namespace System::Runtime::InteropServices;\n\n// The MyDemoAttribute class is selected as AutoLayout.\n\n[StructLayoutAttribute(LayoutKind::Auto)]\npublic ref class MyDemoAttribute{};\n\nvoid MyAutoLayoutMethod( String^ typeName )\n{\n   try\n   {\n      \n      // Create an instance of the Type class using the GetType method.\n      Type^ myType = Type::GetType( typeName );\n      \n      // Get and display the IsAutoLayout property of the\n      // MyDemoAttribute instance.\n      Console::WriteLine( &quot;<br>The AutoLayout property for the MyDemoAttribute is {0}.&quot;, myType-&gt;IsAutoLayout );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;<br>An exception occurred: {0}.&quot;, e-&gt;Message );\n   }\n\n}\n\nint main()\n{\n   MyAutoLayoutMethod( &quot;MyDemoAttribute&quot; );\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_IsAutoLayout#1\">Imports System\nImports System.Runtime.InteropServices\nImports Microsoft.VisualBasic\n\n&#39; The Demo class is has the AutoLayout attribute.\n&lt;StructLayoutAttribute(LayoutKind.Auto)&gt; _\nPublic Class Demo\nEnd Class \n\nPublic Class Example\n    Public Shared Sub Main()\n        &#39; Get the Type object for the Demo class.\n        Dim myType As Type = GetType(Demo)\n        &#39; Get and display the IsAutoLayout property of the \n        &#39; Demo class.\n        Console.WriteLine(&quot;The AutoLayout property for the Demo class is &#39;{0}&#39;.&quot;, _\n            myType.IsAutoLayout.ToString())\n    End Sub \nEnd Class \n</code></pre><pre><code class=\"lang-cs\" name=\"Type_IsAutoLayout#1\">using System;\nusing System.Runtime.InteropServices;\n\n// The Demo class is attributed as AutoLayout.\n[StructLayoutAttribute(LayoutKind.Auto)]\npublic class Demo\n{\n}\n\npublic class Example\n{\n    public static void Main()\n    {\n        // Create an instance of the Type class using the GetType method.\n        Type  myType=typeof(Demo);\n        // Get and display the IsAutoLayout property of the \n        // Demoinstance.\n        Console.WriteLine(&quot;<br>The AutoLayout property for the Demo class is {0}.&quot;,\n            myType.IsAutoLayout); \n    }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsByRef\">\r\n    \r\n            <a id=\"System_Type_IsByRef_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsByRef</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is passed by reference.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsByRef { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is passed by reference; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>To get to the actual type, dereference the type that was passed by reference, and then call <a class=\"xref\" href=\"system.type#System_Type_GetElementType_\" data-linktype=\"relative-path\">GetElementType</a> on that type.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example demonstrates a use of the <code>IsByRef</code> property to check whether a specified type is passed by reference. The example defines the class <code>MyTypeDelegator</code>, which overrides the <code>HasElementTypeImpl</code> method. The main class checks for the <code>HasElementType</code> property and displays the element type.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_HasElementTypeImpl#1\">using namespace System;\nusing namespace System::Reflection;\npublic ref class MyTypeDelegator: public TypeDelegator\n{\npublic:\n   String^ myElementType;\n\nprivate:\n   Type^ myType;\n\npublic:\n   MyTypeDelegator( Type^ myType )\n      : TypeDelegator( myType )\n   {\n      this-&gt;myType = myType;\n   }\n\n\nprotected:\n\n   // Override Type::HasElementTypeImpl().\n   virtual bool HasElementTypeImpl() override\n   {\n      \n      // Determine whether the type is an array.\n      if ( myType-&gt;IsArray )\n      {\n         myElementType = &quot;array&quot;;\n         return true;\n      }\n\n      \n      // Determine whether the type is a reference.\n      if ( myType-&gt;IsByRef )\n      {\n         myElementType = &quot;reference&quot;;\n         return true;\n      }\n\n      \n      // Determine whether the type is a pointer.\n      if ( myType-&gt;IsPointer )\n      {\n         myElementType = &quot;pointer&quot;;\n         return true;\n      }\n\n      \n      // Return false if the type is not a reference, array, or pointer type.\n      return false;\n   }\n\n};\n\nint main()\n{\n   try\n   {\n      int myInt = 0;\n      array&lt;Int32&gt;^myArray = gcnew array&lt;Int32&gt;(5);\n      MyTypeDelegator^ myType = gcnew MyTypeDelegator( myArray-&gt;GetType() );\n      \n      // Determine whether myType is an array, pointer, reference type.\n      Console::WriteLine( &quot;<br>Determine whether a variable is an array, pointer, or reference type.<br>&quot; );\n      if ( myType-&gt;HasElementType )\n            Console::WriteLine( &quot;The type of myArray is {0}.&quot;, myType-&gt;myElementType );\n      else\n            Console::WriteLine( &quot;myArray is not an array, pointer, or reference type.&quot; );\n      myType = gcnew MyTypeDelegator( myInt.GetType() );\n      \n      // Determine whether myType is an array, pointer, reference type.\n      if ( myType-&gt;HasElementType )\n            Console::WriteLine( &quot;The type of myInt is {0}.&quot;, myType-&gt;myElementType );\n      else\n            Console::WriteLine( &quot;myInt is not an array, pointer, or reference type.&quot; );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception: {0}&quot;, e-&gt;Message );\n   }\n\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_HasElementTypeImpl#1\">using System;\nusing System.Reflection;\npublic class MyTypeDelegator : TypeDelegator\n{\n    public string myElementType = null;\n    private Type myType = null ; \n    public MyTypeDelegator(Type myType) : base(myType)\n    {\n        this.myType = myType;\n    }\n    // Override Type.HasElementTypeImpl().\n    protected override bool HasElementTypeImpl()\n    {\n        // Determine whether the type is an array.\n        if(myType.IsArray)\n        {\n            myElementType = &quot;array&quot;;\n            return true;\n        }\n        // Determine whether the type is a reference.\n        if(myType.IsByRef)\n        {\n            myElementType = &quot;reference&quot;;\n            return true;\n        }\n        // Determine whether the type is a pointer.\n        if(myType.IsPointer)\n        { \n            myElementType = &quot;pointer&quot;;\n            return true;\n        }\n        // Return false if the type is not a reference, array, or pointer type.\n        return false;\n    }  \n}\npublic class Type_HasElementTypeImpl\n{\n    public static void Main()\n    {\n        try\n        {\n            int myInt = 0 ; \n            int[] myArray = new int[5];\n            MyTypeDelegator myType = new MyTypeDelegator(myArray.GetType());\n            // Determine whether myType is an array, pointer, reference type.  \n            Console.WriteLine(&quot;<br>Determine whether a variable is an array, pointer, or reference type.<br>&quot;);\n            if( myType.HasElementType)\n                Console.WriteLine(&quot;The type of myArray is {0}.&quot;, myType.myElementType);\n            else\n                Console.WriteLine(&quot;myArray is not an array, pointer, or reference type.&quot;);\n            myType = new MyTypeDelegator(myInt.GetType());\n            // Determine whether myType is an array, pointer, reference type. \n            if( myType.HasElementType)\n                Console.WriteLine(&quot;The type of myInt is {0}.&quot;, myType.myElementType);\n            else\n                Console.WriteLine(&quot;myInt is not an array, pointer, or reference type.&quot;);\n        }\n        catch( Exception e )\n        {\n            Console.WriteLine(&quot;Exception: {0}&quot;, e.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_HasElementTypeImpl#1\">Imports System\nImports System.Reflection\nImports Microsoft.VisualBasic\nPublic Class MyTypeDelegator\n    Inherits TypeDelegator\n    Public myElementType As String = Nothing\n    Private myType As Type = Nothing\n    Public Sub New(ByVal myType As Type)\n        MyBase.New(myType)\n        Me.myType = myType\n    End Sub &#39;New\n    &#39; Override Type.HasElementTypeImpl().\n    Protected Overrides Function HasElementTypeImpl() As Boolean\n        &#39; Determine whether the type is an array.\n        If myType.IsArray Then\n            myElementType = &quot;array&quot;\n            Return True\n        End If\n        &#39; Determine whether the type is a reference.\n        If myType.IsByRef Then\n            myElementType = &quot;reference&quot;\n            Return True\n        End If\n        &#39; Determine whether the type is a pointer.\n        If myType.IsPointer Then\n            myElementType = &quot;pointer&quot;\n            Return True\n        End If\n        &#39; The type is not a reference, array, or pointer type.\n        Return False\n    End Function &#39;HasElementTypeImpl\nEnd Class &#39;MyTypeDelegator\nPublic Class Type_HasElementTypeImpl\n    Public Shared Sub Main()\n        Try\n            Dim myInt As Integer = 0\n            Dim myArray(4) As Integer\n            Dim myType As New MyTypeDelegator(myArray.GetType())\n            Console.WriteLine(ControlChars.NewLine + &quot;Determine whether a variable refers to an array or pointer or reference type.&quot; + ControlChars.NewLine)\n            &#39; Determine whether myType is an array, pointer, reference type.  \n            If myType.HasElementType Then\n                Console.WriteLine(&quot;The type of myArray is {0}.&quot;, myType.myElementType.ToString())\n            Else\n                Console.WriteLine(&quot;myArray is not an array, pointer, or reference type.&quot;)\n            End If\n            myType = New MyTypeDelegator(myInt.GetType())\n            &#39; Determine whether myType is an array, pointer, reference type. \n            If myType.HasElementType Then\n                Console.WriteLine(&quot;The type of myInt is {0}.&quot;, myType.myElementType.ToString())\n            Else\n                Console.WriteLine(&quot;myInt is not an array, pointer, or reference type.&quot;)\n            End If\n        Catch e As Exception\n            Console.WriteLine(&quot;Exception: {0}&quot;, e.Message.ToString())\n        End Try\n    End Sub &#39;Main\nEnd Class &#39;Type_HasElementTypeImpl\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsClass\">\r\n    \r\n            <a id=\"System_Type_IsClass_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsClass</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is a class or a delegate; that is, not a value type or interface.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsClass { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is a class; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This property returns <code>true</code> for classes as well as delegates. It returns <code>false</code> for value types (for structures and enumerations) even if they are boxed.  </p>\n<p> If the current<a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this property always returns <code>true</code>.If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this property returns <code>true</code> if the generic type definition is a class definition; that is, it does not define an interface or a value type.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> This property returns <code>true</code> for <code>Type</code> instances that represent the <a class=\"xref\" href=\"system.enum\" data-linktype=\"relative-path\">Enum</a> and <a class=\"xref\" href=\"system.valuetype\" data-linktype=\"relative-path\">ValueType</a> classes. These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves. For more information, see the <a class=\"xref\" href=\"system.type#System_Type_IsValueType_\" data-linktype=\"relative-path\">IsValueType</a>and <a class=\"xref\" href=\"system.type#System_Type_IsEnum_\" data-linktype=\"relative-path\">IsEnum</a> properties.  </p>\n</div>\n<p> The <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a>enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a> attribute. If you retrieve the value of a type&#39;s Attributes property and use the <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a> value to determine whether a type is a class instead of a value type, you must also call the <a class=\"xref\" href=\"system.type#System_Type_IsValueType_\" data-linktype=\"relative-path\">IsValueType</a> property. The example for the <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">TypeAttributes</a> enumeration contains additional information as well as anexample.  </p>\n<p> This property is read-only.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an instance of a type and indicates whether the type is a class.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_IsClass#1\">using System;\nusing System.Reflection;\n\npublic  class MyDemoClass\n{\n}\n\npublic class MyTypeClass\n{\n    public static void Main(string[] args)\n    {\n        try\n        {\n            Type  myType = typeof(MyDemoClass);\n            // Get and display the &#39;IsClass&#39; property of the &#39;MyDemoClass&#39; instance.\n            Console.WriteLine(&quot;<br>Is the specified type a class? {0}.&quot;, myType.IsClass); \n        }\n        catch(Exception e)\n        {\n            Console.WriteLine(&quot;<br>An exception occurred: {0}.&quot; ,e.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_IsClass#1\">using namespace System;\nusing namespace System::Reflection;\npublic ref class MyDemoClass{};\n\nint main()\n{\n   try\n   {\n      Type^ myType = Type::GetType( &quot;MyDemoClass&quot; );\n      \n      // Get and display the &#39;IsClass&#39; property of the &#39;MyDemoClass&#39; instance.\n      Console::WriteLine( &quot;<br>Is the specified type a class? {0}.&quot;, myType-&gt;IsClass );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;<br>An exception occurred: {0}.&quot;, e-&gt;Message );\n   }\n\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_IsClass#1\">Imports System\nImports System.Reflection\nImports Microsoft.VisualBasic\n\nPublic Class MyDemoClass\nEnd Class &#39;MyDemoClass\n\nPublic Class MyTypeClass\n    Public Shared Sub Main()\n        Try\n            Dim myType As Type = GetType(MyDemoClass)\n            &#39; Get and display the &#39;IsClass&#39; property of the &#39;MyDemoClass&#39; instance.\n            Console.WriteLine(ControlChars.Cr + &quot;Is the specified type a class? {0}.&quot;, myType.IsClass.ToString())\n        Catch e As Exception\n            Console.WriteLine(ControlChars.Cr + &quot;An exception occurred: {0}.&quot;, e.Message.ToString())\n        End Try\n    End Sub &#39;Main\nEnd Class &#39;MyTypeClass\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsCOMObject\">\r\n    \r\n            <a id=\"System_Type_IsCOMObject_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsCOMObject</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is a COM object.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsCOMObject { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is a COM object; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method returns <code>false</code> for COM interfaces because they are not objects. COM interfaces can be implemented by Microsoft .NET Framework objects.  </p>\n<p> You can also load a COM class and get a <code>Type</code> object for that COM class by using the <a href=\"../Topic/Tlbimp.exe%20(Type%20Library%20Importer).md\" data-linktype=\"relative-path\">Tlbimp.exe (Type Library Importer)</a> tool.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents <code>MyGenericType&lt;int</code>&gt; (<code>MyGenericType(Of Integer)</code> in Visual Basic), the value of this property is determined by <code>MyGenericType&lt;T&gt;</code>.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this property always returns <code>false</code>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsConstructedGenericType\">\r\n    \r\n            <a id=\"System_Type_IsConstructedGenericType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsConstructedGenericType</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value that indicates whether this object represents a constructed generic type. You can create instances of a constructed generic type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool IsConstructedGenericType { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if this object represents a constructed generic type; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A constructed generic type has had explicit types supplied for all of its generic type parameters. It is also referred to as a closed generic type.  </p>\n<p> When this property is <code>true</code>, you can create instances of the current type; when it is <code>false</code>, you can&#39;t.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsContextful\">\r\n    \r\n            <a id=\"System_Type_IsContextful_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsContextful</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> can be hosted in a context.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsContextful { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> can be hosted in a context; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization. For more detailed information on remoting contexts, see <a class=\"xref\" href=\"system.runtime.remoting.contexts.context\" data-linktype=\"relative-path\">Context</a>.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this property always returns <code>false</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example demonstrates the <code>IsContextful</code>, <a class=\"xref\" href=\"system.type#System_Type_IsMarshalByRef_\" data-linktype=\"relative-path\">IsMarshalByRef</a>, and <a class=\"xref\" href=\"system.type#System_Type_IsPrimitive_\" data-linktype=\"relative-path\">IsPrimitive</a> properties of the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> class. It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_IsContextful#1\">using System;\nusing System.Runtime.Remoting.Contexts;\n\npublic class ContextBoundClass: ContextBoundObject\n{\n    public string Value = &quot;The Value property.&quot;;\n}\n\npublic class Example\n{\n    public static void Main()\n    {\n         // Determine whether the types can be hosted in a Context.\n         Console.WriteLine(&quot;The IsContextful property for the {0} type is {1}.&quot;,\n                           typeof(Example).Name, typeof(Example).IsContextful);\n         Console.WriteLine(&quot;The IsContextful property for the {0} type is {1}.&quot;,\n                           typeof(ContextBoundClass).Name, typeof(ContextBoundClass).IsContextful);\n\n         // Determine whether the types are marshalled by reference.\n         Console.WriteLine(&quot;The IsMarshalByRef property of {0} is {1}.&quot;,\n                           typeof(Example).Name, typeof(Example).IsMarshalByRef);\n         Console.WriteLine(&quot;The IsMarshalByRef property of {0} is {1}.&quot;,\n                           typeof(ContextBoundClass).Name, typeof(ContextBoundClass).IsMarshalByRef);\n         \n         // Determine whether the types are primitive datatypes.\n         Console.WriteLine(&quot;{0} is a primitive data type: {1}.&quot;,\n                           typeof(int).Name, typeof(int).IsPrimitive);\n         Console.WriteLine(&quot;{0} is a primitive data type: {1}.&quot;,\n                           typeof(string).Name, typeof(string).IsPrimitive);\n    }\n}\n// The example displays the following output:\n//    The IsContextful property for the Example type is False.\n//    The IsContextful property for the ContextBoundClass type is True.\n//    The IsMarshalByRef property of Example is False.\n//    The IsMarshalByRef property of ContextBoundClass is True.\n//    Int32 is a primitive data type: True.\n//    String is a primitive data type: False.\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_IsContextful#1\">using namespace System;\nusing namespace System::Runtime::Remoting::Contexts;\n\npublic ref class ContextBoundClass: public ContextBoundObject\n{\n   public:\n      String^ Value;\n};\n\npublic ref class Example\n{\npublic:\n   void Demo()\n   {\n      // Determine whether the types can be hosted in a Context.\n      Console::WriteLine(&quot;The IsContextful property for the {0} type is {1}.&quot;,\n                         Example::typeid-&gt;Name, Example::typeid-&gt;IsContextful);\n      Console::WriteLine(&quot;The IsContextful property for the {0} type is {1}.&quot;,\n                         ContextBoundClass::typeid-&gt;Name, ContextBoundClass::typeid-&gt;IsContextful);\n      \n      // Determine whether the types are marshalled by reference.\n      Console::WriteLine(&quot;The IsMarshalByRef property of {0} is {1}.&quot;,\n                         Example::typeid-&gt;Name, Example::typeid-&gt;IsMarshalByRef );\n      Console::WriteLine(&quot;The IsMarshalByRef property of {0} is {1}.&quot;,\n                         ContextBoundClass::typeid-&gt;Name, ContextBoundClass::typeid-&gt;IsMarshalByRef );\n      \n      // Determine whether the types are primitive datatypes.\n      Console::WriteLine(&quot;{0} is a primitive data type: {1}.&quot;,\n                         int::typeid-&gt;Name, int::typeid-&gt;IsPrimitive );\n      Console::WriteLine(&quot;{0} is a primitive data type: {1}.&quot;,\n                         String::typeid-&gt;Name, String::typeid-&gt;IsPrimitive );\n   }\n};\n\nint main()\n{\n   Example^ ex = gcnew Example;\n   ex-&gt;Demo();\n}\n// The example displays the following output:\n//    The IsContextful property for the Example type is False.\n//    The IsContextful property for the ContextBoundClass type is True.\n//    The IsMarshalByRef property of Example is False.\n//    The IsMarshalByRef property of ContextBoundClass is True.\n//    Int32 is a primitive data type: True.\n//    String is a primitive data type: False.\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_IsContextful#1\">Imports System.Runtime.Remoting.Contexts\n\nPublic Class ContextBoundClass : Inherits ContextBoundObject\n    Public Value As String = &quot;The Value property.&quot;\nEnd Class\n\nPublic Class Example\n    Public Shared Sub Main()\n         &#39; Determine whether the types can be hosted in a Context.\n         Console.WriteLine(&quot;The IsContextful property for the {0} type is {1}.&quot;,\n                           GetType(Example).Name, GetType(Example).IsContextful)\n         Console.WriteLine(&quot;The IsContextful property for the {0} type is {1}.&quot;,\n                           GetType(ContextBoundClass).Name, GetType(ContextBoundClass).IsContextful)\n         &#39; Determine whether the types are marshalled by reference.\n         Console.WriteLine(&quot;The IsMarshalByRef property of {0} is {1}.&quot;,\n                           GetType(Example).Name, GetType(Example).IsMarshalByRef)\n         Console.WriteLine(&quot;The IsMarshalByRef property of {0} is {1}.&quot;,\n                           GetType(ContextBoundClass).Name, GetType(ContextBoundClass).IsMarshalByRef)\n         &#39; Determine whether the types are primitive datatypes.\n         Console.WriteLine(&quot;{0} is a primitive data type: {1}.&quot;,\n                           GetType(Integer).Name, GetType(Integer).IsPrimitive)\n         Console.WriteLine(&quot;{0} is a primitive data type: {1}.&quot;,\n                           GetType(String).Name, GetType(String).IsPrimitive)\n    End Sub\nEnd Class\n&#39; The example displays the following output:\n&#39;    The IsContextful property for the Example type is False.\n&#39;    The IsContextful property for the ContextBoundClass type is True.\n&#39;    The IsMarshalByRef property of Example is False.\n&#39;    The IsMarshalByRef property of ContextBoundClass is True.\n&#39;    Int32 is a primitive data type: True.\n&#39;    String is a primitive data type: False.\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsEnum\">\r\n    \r\n            <a id=\"System_Type_IsEnum_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsEnum</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents an enumeration.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool IsEnum { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents an enumeration; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This property returns <code>true</code> for an enumeration, but not for the <a class=\"xref\" href=\"system.enum\" data-linktype=\"relative-path\">Enum</a> type itself.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents <code>MyGenericType&lt;int&gt;</code> (<code>MyGenericType(Of Integer)</code> in Visual Basic), the value of this property is determined by <code>MyGenericType&lt;T&gt;</code>.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this property always returns <code>false</code>.  </p>\n<p> This property is read-only.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example demonstrates how to use the <code>IsEnum</code> property.  </p>\n<pre><code class=\"lang-cpp\" name=\"TestIsEnum#1\">using namespace System;\nenum class Color\n{ Red, Blue, Green };\n\nint main()\n{\n   Type^ colorType = Color::typeid;\n   Type^ enumType = Enum::typeid;\n   Console::WriteLine( &quot;Is Color an enum? {0}.&quot;, colorType-&gt;IsEnum );\n   Console::WriteLine( &quot;Is Color a value type? {0}.&quot;, colorType-&gt;IsValueType );\n   Console::WriteLine( &quot;Is Enum an enum Type? {0}.&quot;, enumType-&gt;IsEnum );\n   Console::WriteLine( &quot;Is Enum a value type? {0}.&quot;, enumType-&gt;IsValueType );\n}\n// The example displays the following output:\n//     Is Color an enum? True.\n//     Is Color a value type? True.\n//     Is Enum an enum type? False.\n//     Is Enum a value type? False.\n</code></pre><pre><code class=\"lang-cs\" name=\"TestIsEnum#1\">using System;\npublic enum Color \n{ Red, Blue, Green }\n\nclass TestIsEnum \n{\n    public static void Main() \n    {\n       Type colorType = typeof(Color);\n       Type enumType = typeof(Enum);\n       Console.WriteLine(&quot;Is Color an enum? {0}.&quot;, colorType.IsEnum);\n       Console.WriteLine(&quot;Is Color a value type? {0}.&quot;, colorType.IsValueType);\n       Console.WriteLine(&quot;Is Enum an enum Type? {0}.&quot;, enumType.IsEnum);\n       Console.WriteLine(&quot;Is Enum a value type? {0}.&quot;, enumType.IsValueType);\n   }\n}\n// The example displays the following output:\n//     Is Color an enum? True.\n//     Is Color a value type? True.\n//     Is Enum an enum type? False.\n//     Is Enum a value type? False.\n</code></pre><pre><code class=\"lang-vb\" name=\"TestIsEnum#1\">Imports System\n\nPublic Enum Color\n    Red\n    Blue\n    Green\nEnd Enum\n\nClass Example\n   Public Shared Sub Main()\n        Dim colorType As Type = GetType(Color)\n        Dim enumType As Type = GetType([Enum])\n        Console.WriteLine(&quot;Is Color an enum? {0}.&quot;, colorType.IsEnum)\n        Console.WriteLine(&quot;Is Color a value type? {0}.&quot;, colorType.IsValueType)\n        Console.WriteLine(&quot;Is Enum an enum type? {0}.&quot;, enumType.IsEnum)\n        Console.WriteLine(&quot;Is Enum a value type? {0}.&quot;, enumType.IsValueType)\n    End Sub \nEnd Class\n&#39; The example displays the following output:\n&#39;     Is Color an enum? True.\n&#39;     Is Color a value type? True.\n&#39;     Is Enum an enum type? False.\n&#39;     Is Enum a value type? False.\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsExplicitLayout\">\r\n    \r\n            <a id=\"System_Type_IsExplicitLayout_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsExplicitLayout</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsExplicitLayout { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <span class=\"xref\">stem.Type.Attributes*</span> property of the current type includes <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">TypeAttributes</a>; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This property is provided as a convenience. Alternatively, you can use the <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a>enumeration value to select the type layout attributes, and then test whether <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a> is set. The <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a>, <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a>, and <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a> enumeration values indicate the way the fields of the type are laid out in memory.  </p>\n<p> For dynamic types, you can specify <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a> when you create the type. In code, apply the <a class=\"xref\" href=\"system.runtime.interopservices.structlayoutattribute\" data-linktype=\"relative-path\">StructLayoutAttribute</a> attribute with the <a class=\"xref\" href=\"system.runtime.interopservices.layoutkind\" data-linktype=\"relative-path\">System.Runtime.InteropServices.LayoutKind</a> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> You cannot use the <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_GetCustomAttributes_\" data-linktype=\"relative-path\">GetCustomAttributes</a> method to determine whether the <a class=\"xref\" href=\"system.runtime.interopservices.structlayoutattribute\" data-linktype=\"relative-path\">StructLayoutAttribute</a> has been applied to a type.  </p>\n</div>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents <code>MyGenericType&lt;int&gt;</code> (<code>MyGenericType(Of Integer)</code> in Visual Basic), the value of this property is determined by <code>MyGenericType&lt;T&gt;</code>.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this property always returns <code>false</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an instance of a type and displays the value of its IsExplicitLayout property. It uses the <code>MySystemTime</code> class, which is also in the code example for <a class=\"xref\" href=\"system.runtime.interopservices.structlayoutattribute\" data-linktype=\"relative-path\">StructLayoutAttribute</a>.  </p>\n<pre><code class=\"lang-vb\" name=\"Type_IsExplicitLayout#1\">Imports System\nImports System.Reflection\nImports System.ComponentModel\nImports System.Runtime.InteropServices\nImports Microsoft.VisualBasic\n\n&#39;Class to test for the ExplicitLayout property.\n   &lt;StructLayout(LayoutKind.Explicit, Size := 16, CharSet := CharSet.Ansi)&gt;  _\n   Public Class MySystemTime\n      &lt;FieldOffset(0)&gt; Public wYear As Short\n      &lt;FieldOffset(2)&gt; Public wMonth As Short\n      &lt;FieldOffset(4)&gt; Public wDayOfWeek As Short\n      &lt;FieldOffset(6)&gt; Public wDay As Short\n      &lt;FieldOffset(8)&gt; Public wHour As Short\n      &lt;FieldOffset(10)&gt; Public wMinute As Short\n      &lt;FieldOffset(12)&gt; Public wSecond As Short\n      &lt;FieldOffset(14)&gt; Public wMilliseconds As Short\n   End Class \n\nPublic Class Program\n    Public Shared Sub Main()\n        &#39;Create an instance of type using the GetType method.\n        Dim t As Type = GetType(MySystemTime)\n        &#39; Get and display the IsExplicitLayout property.\n        Console.WriteLine(vbCrLf &amp; &quot;IsExplicitLayout for MySystemTime is {0}.&quot;, _\n            t.IsExplicitLayout)\n    End Sub\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_IsExplicitLayout#1\">using System;\nusing System.Reflection;\nusing System.ComponentModel;\nusing System.Runtime.InteropServices;\n\n\n// Class to test for the ExplicitLayout property.\n[StructLayout(LayoutKind.Explicit, Size=16, CharSet=CharSet.Ansi)]\npublic class MySystemTime\n{\n   [FieldOffset(0)]public ushort wYear;\n   [FieldOffset(2)]public ushort wMonth;\n   [FieldOffset(4)]public ushort wDayOfWeek;\n   [FieldOffset(6)]public ushort wDay;\n   [FieldOffset(8)]public ushort wHour;\n   [FieldOffset(10)]public ushort wMinute;\n   [FieldOffset(12)]public ushort wSecond;\n   [FieldOffset(14)]public ushort wMilliseconds;\n}\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        // Create an instance of the type using the GetType method.\n        Type  t = typeof(MySystemTime);\n        // Get and display the IsExplicitLayout property.\n        Console.WriteLine(&quot;<br>IsExplicitLayout for MySystemTime is {0}.&quot;,\n            t.IsExplicitLayout);\n    }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsGenericParameter\">\r\n    \r\n            <a id=\"System_Type_IsGenericParameter_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsGenericParameter</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool IsGenericParameter { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents a type parameter of a generic type definition or generic method definition; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects that represent generic type parameters can be obtained by calling the <a class=\"xref\" href=\"system.type#System_Type_GetGenericArguments_\" data-linktype=\"relative-path\">GetGenericArguments</a> method of a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents a generic type definition, or the <a class=\"xref\" href=\"system.reflection.methodinfo#System_Reflection_MethodInfo_GetGenericArguments_\" data-linktype=\"relative-path\">GetGenericArguments</a> method of a <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> object that represents a generic method definition.  </p>\n<ul>\n<li><p>For a generic type or method definition, the IsGenericParameter property returns <code>true</code> for every element of the resulting array.  </p>\n</li>\n<li><p>For a closed constructed type or method, the IsGenericParameter property returns <code>false</code> for every element of the array returned by the <a class=\"xref\" href=\"system.type#System_Type_GetGenericArguments_\" data-linktype=\"relative-path\">GetGenericArguments</a> method.  </p>\n</li>\n<li><p>For an open constructed type or method, some elements of the array might be specific types and others might be type parameters. IsGenericParameter returns <code>false</code> for the types and <code>true</code> for the type parameters. The code example for the <a class=\"xref\" href=\"system.type#System_Type_ContainsGenericParameters_\" data-linktype=\"relative-path\">ContainsGenericParameters</a> property demonstrates a generic class with a mixture of types and type parameters.  </p>\n<p>For a list of the invariant conditions for terms used in generic reflection, see the <a class=\"xref\" href=\"system.type#System_Type_IsGenericType_\" data-linktype=\"relative-path\">IsGenericType</a> property remarks.</p>\n</li>\n</ul>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses the IsGenericParameter property to test for generic type parameters in a generic type.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Type.IsGenericParameter#2\">      if ( t-&gt;IsGenericType )\n      {\n         \n         // If this is a generic type, display the type arguments.\n         //\n         array&lt;Type^&gt;^typeArguments = t-&gt;GetGenericArguments();\n         Console::WriteLine( L&quot;&nbsp;&nbsp;&nbsp;&nbsp;List type arguments ({0}):&quot;,\n            typeArguments-&gt;Length );\n         System::Collections::IEnumerator^ myEnum =\n            typeArguments-&gt;GetEnumerator();\n         while ( myEnum-&gt;MoveNext() )\n         {\n            Type^ tParam = safe_cast&lt;Type^&gt;(myEnum-&gt;Current);\n            \n            // If this is a type parameter, display its\n            // position.\n            //\n            if ( tParam-&gt;IsGenericParameter )\n            {\n               Console::WriteLine(\n                  L&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}&nbsp;&nbsp;&nbsp;&nbsp;(unassigned - parameter position {1})&quot;,\n                  tParam, tParam-&gt;GenericParameterPosition );\n            }\n            else\n            {\n               Console::WriteLine( L&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;, tParam );\n            }\n         }\n      }\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.IsGenericParameter#2\">        If t.IsGenericType Then\n            &#39; If this is a generic type, display the type arguments.\n            &#39;\n            Dim typeArguments As Type() = t.GetGenericArguments()\n            \n            Console.WriteLine(vbTab &amp; &quot;List type arguments (&quot; _\n                &amp; typeArguments.Length &amp; &quot;):&quot;)\n            \n            For Each tParam As Type In typeArguments\n                &#39; If this is a type parameter, display its position.\n                &#39;\n                If tParam.IsGenericParameter Then\n                    Console.WriteLine(vbTab &amp; vbTab &amp; tParam.ToString() _\n                        &amp; vbTab &amp; &quot;(unassigned - parameter position &quot; _\n                        &amp; tParam.GenericParameterPosition &amp; &quot;)&quot;)\n                Else\n                    Console.WriteLine(vbTab &amp; vbTab &amp; tParam.ToString())\n                End If\n            Next tParam\n        End If\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.IsGenericParameter#2\">        if (t.IsGenericType)\n        {\n            // If this is a generic type, display the type arguments.\n            //\n            Type[] typeArguments = t.GetGenericArguments();\n\n            Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;List type arguments ({0}):&quot;, \n                typeArguments.Length);\n\n            foreach (Type tParam in typeArguments)\n            {\n                // If this is a type parameter, display its\n                // position.\n                //\n                if (tParam.IsGenericParameter)\n                {\n                    Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}&nbsp;&nbsp;&nbsp;&nbsp;(unassigned - parameter position {1})&quot;,\n                        tParam,\n                        tParam.GenericParameterPosition);\n                }\n                else\n                {\n                    Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;, tParam);\n                }\n            }\n        }\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsGenericType\">\r\n    \r\n            <a id=\"System_Type_IsGenericType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsGenericType</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the current type is a generic type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool IsGenericType { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the current type is a generic type; otherwise,<code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Use the IsGenericType property to determine whether a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents a generic type. Use the <a class=\"xref\" href=\"system.type#System_Type_ContainsGenericParameters_\" data-linktype=\"relative-path\">ContainsGenericParameters</a> property to determine whether a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents an open constructed type or a closed constructed type.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The IsGenericType property returns <code>false</code> if the immediate type is not generic. For example, an array whose elements are of type <code>A&lt;int&gt;</code> (<code>A(Of Integer)</code> in Visual Basic) is not itself a generic type.  </p>\n</div>\n<p> The following table summarizes the invariant conditions for common terms used in generic reflection.  </p>\n<table>\n<thead>\n<tr>\n<th>Term</th>\n<th>Invariant</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>generic type definition</td>\n<td>The <a class=\"xref\" href=\"system.type#System_Type_IsGenericTypeDefinition_\" data-linktype=\"relative-path\">IsGenericTypeDefinition</a> property is <code>true</code>.<br><br> Defines a generic type. A constructed type is created by calling the <a class=\"xref\" href=\"system.type#System_Type_MakeGenericType_\" data-linktype=\"relative-path\">MakeGenericType</a> method on a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents a generic type definition and specifying an array of type arguments.<br><br> <a class=\"xref\" href=\"system.type#System_Type_MakeGenericType_\" data-linktype=\"relative-path\">MakeGenericType</a> can be called only on generic type definitions.<br><br> Any generic type definition is a generic type (the IsGenericType property is <code>true</code>), but the converse is not true.</td>\n</tr>\n<tr>\n<td>generic type</td>\n<td>The IsGenericType property is <code>true</code>.<br><br> Can be a generic type definition, an open constructed type, or a closed constructed type.<br><br> Note that an array type whose element type is generic is not itself a generic type. The same is true of a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object representing a pointer to a generic type.</td>\n</tr>\n<tr>\n<td>open constructed type</td>\n<td>The <a class=\"xref\" href=\"system.type#System_Type_ContainsGenericParameters_\" data-linktype=\"relative-path\">ContainsGenericParameters</a> property is <code>true</code>.<br><br> Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <a class=\"xref\" href=\"system.type#System_Type_ContainsGenericParameters_\" data-linktype=\"relative-path\">ContainsGenericParameters</a> property is <code>true</code>.<br><br> It is not possible to create an instance of an open constructed type.<br><br> Note that not all open constructed types are generic. For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.</td>\n</tr>\n<tr>\n<td>closed constructed type</td>\n<td>The <a class=\"xref\" href=\"system.type#System_Type_ContainsGenericParameters_\" data-linktype=\"relative-path\">ContainsGenericParameters</a> property is <code>false</code>.<br><br> When examined recursively, the type has no unassigned generic parameters.</td>\n</tr>\n<tr>\n<td>generic type parameter</td>\n<td>The <a class=\"xref\" href=\"system.type#System_Type_IsGenericParameter_\" data-linktype=\"relative-path\">IsGenericParameter</a> property is <code>true</code>.<br><br> The <a class=\"xref\" href=\"system.type#System_Type_ContainsGenericParameters_\" data-linktype=\"relative-path\">ContainsGenericParameters</a> property is <code>true</code>.<br><br> In a generic type definition, a placeholder for a type that will be assigned later.</td>\n</tr>\n<tr>\n<td>generic type argument</td>\n<td>Can be any type, including a generic type parameter.<br><br> Type arguments are specified as an array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects passed to the <a class=\"xref\" href=\"system.type#System_Type_MakeGenericType_\" data-linktype=\"relative-path\">MakeGenericType</a> method when creating a constructed generic type. If instances of the resulting type are to be created, the <a class=\"xref\" href=\"system.type#System_Type_ContainsGenericParameters_\" data-linktype=\"relative-path\">ContainsGenericParameters</a> property must be <code>false</code> for all the type arguments.</td>\n</tr>\n</tbody>\n</table>\n<p> The following code example and table illustrate some of these terms and invariants. The <code>Derived</code> class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Type.IsGenericType#2\">generic&lt;typename T, typename U&gt; public ref class Base {};\n\ngeneric&lt;typename T&gt; public ref class G {};\n\ngeneric&lt;typename V&gt; public ref class Derived : Base&lt;String^, V&gt;\n{\npublic:\n    G&lt;Derived&lt;V&gt;^&gt;^ F;\n\n    ref class Nested {};\n};\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.IsGenericType#2\">public class Base&lt;T, U&gt; {}\n\npublic class Derived&lt;V&gt; : Base&lt;string, V&gt;\n{\n    public G&lt;Derived &lt;V&gt;&gt; F;\n\n    public class Nested {}\n}\n\npublic class G&lt;T&gt; {}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.IsGenericType#2\">Public Class Base(Of T, U)\nEnd Class\n\nPublic Class Derived(Of V)\n    Inherits Base(Of String, V)\n\n    Public F As G(Of Derived(Of V))\n\n    Public Class Nested\n    End Class\nEnd Class\n\nPublic Class G(Of T)\nEnd Class\n</code></pre><p> The following table shows examples that use and build on the classes <code>Base</code>, <code>Derived</code>, and <code>G</code>. When the C++ and C# code is the same, only one entry is shown.  </p>\n<table>\n<thead>\n<tr>\n<th>Example</th>\n<th>Invariants</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>Derived(Of V)</code><br><br> <code>Derived&lt;V&gt;</code></td>\n<td>For this type:<br><br> IsGenericType is <code>true</code>.<br><br> <a class=\"xref\" href=\"system.type#System_Type_IsGenericTypeDefinition_\" data-linktype=\"relative-path\">IsGenericTypeDefinition</a> is <code>true</code>.<br><br> <a class=\"xref\" href=\"system.type#System_Type_ContainsGenericParameters_\" data-linktype=\"relative-path\">ContainsGenericParameters</a> is <code>true</code>.</td>\n</tr>\n<tr>\n<td><code>Base(Of String, V)</code><br><br> <code>Base&lt;String,V&gt;</code><br><br> <code>Base&lt;String^,V&gt;</code></td>\n<td>For this type:<br><br> IsGenericType is <code>true</code>.<br><br> <a class=\"xref\" href=\"system.type#System_Type_IsGenericTypeDefinition_\" data-linktype=\"relative-path\">IsGenericTypeDefinition</a> is <code>false</code>.<br><br> <a class=\"xref\" href=\"system.type#System_Type_ContainsGenericParameters_\" data-linktype=\"relative-path\">ContainsGenericParameters</a> is <code>true</code>.</td>\n</tr>\n<tr>\n<td><code>Dim d() As Derived(Of Integer)</code><br><br> <code>Derived&lt;int&gt;[] d;</code><br><br> <code>array&lt;Derived&lt;int&gt;^&gt;^ d;</code></td>\n<td>For the type of variable <code>d</code>:<br><br> IsGenericType is <code>false</code> because <code>d</code> is an array.<br><br> <a class=\"xref\" href=\"system.type#System_Type_IsGenericTypeDefinition_\" data-linktype=\"relative-path\">IsGenericTypeDefinition</a> is <code>false</code>.<br><br> <a class=\"xref\" href=\"system.type#System_Type_ContainsGenericParameters_\" data-linktype=\"relative-path\">ContainsGenericParameters</a> is <code>false</code>.</td>\n</tr>\n<tr>\n<td><code>T</code>, <code>U</code>, and <code>V</code> (everywhere they appear)</td>\n<td><a class=\"xref\" href=\"system.type#System_Type_IsGenericParameter_\" data-linktype=\"relative-path\">IsGenericParameter</a> is <code>true</code>.<br><br> IsGenericType is <code>false</code> because there is no way to constrain a type parameter to generic types.<br><br> <a class=\"xref\" href=\"system.type#System_Type_IsGenericTypeDefinition_\" data-linktype=\"relative-path\">IsGenericTypeDefinition</a> is <code>false</code>.<br><br> <a class=\"xref\" href=\"system.type#System_Type_ContainsGenericParameters_\" data-linktype=\"relative-path\">ContainsGenericParameters</a> is <code>true</code> because <code>T</code>, <code>U</code>, and <code>V</code> are themselves generic type parameters. This does not imply anything about type arguments that are assigned to them later.</td>\n</tr>\n<tr>\n<td>The type of field <code>F</code></td>\n<td>IsGenericType is <code>true</code>.<br><br> <a class=\"xref\" href=\"system.type#System_Type_IsGenericTypeDefinition_\" data-linktype=\"relative-path\">IsGenericTypeDefinition</a> is <code>false</code> because a type has been assigned to to the type parameter of <code>G</code>. Note that this is equivalent to having called the <a class=\"xref\" href=\"system.type#System_Type_MakeGenericType_\" data-linktype=\"relative-path\">MakeGenericType</a> method.<br><br> <a class=\"xref\" href=\"system.type#System_Type_ContainsGenericParameters_\" data-linktype=\"relative-path\">ContainsGenericParameters</a> is <code>true</code> because the type of field <code>F</code> has a type argument that is an open constructed type. The constructed type is open because its type argument (that is, <code>Base</code>) is a generic type definition. This illustrates the recursive nature of the IsGenericType property.</td>\n</tr>\n<tr>\n<td>The nested class <code>Nested</code></td>\n<td>IsGenericType is <code>true</code>, even though the <code>Nested</code> class has no generic type parameters of its own, because it is nested in a generic type.<br><br> <a class=\"xref\" href=\"system.type#System_Type_IsGenericTypeDefinition_\" data-linktype=\"relative-path\">IsGenericTypeDefinition</a> is <code>true</code>. That is, you can call the <a class=\"xref\" href=\"system.type#System_Type_MakeGenericType_\" data-linktype=\"relative-path\">MakeGenericType</a> method and supply the type parameter of the enclosing type, <code>Derived</code>.<br><br> <a class=\"xref\" href=\"system.type#System_Type_ContainsGenericParameters_\" data-linktype=\"relative-path\">ContainsGenericParameters</a> is <code>true</code> because the enclosing type, <code>Derived</code>, has generic type parameters. This illustrates the recursive nature of the <a class=\"xref\" href=\"system.type#System_Type_ContainsGenericParameters_\" data-linktype=\"relative-path\">ContainsGenericParameters</a> property.</td>\n</tr>\n</tbody>\n</table>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example displays the value of the IsGenericType, <a class=\"xref\" href=\"system.type#System_Type_IsGenericTypeDefinition_\" data-linktype=\"relative-path\">IsGenericTypeDefinition</a>, <a class=\"xref\" href=\"system.type#System_Type_IsGenericParameter_\" data-linktype=\"relative-path\">IsGenericParameter</a>, and <a class=\"xref\" href=\"system.type#System_Type_ContainsGenericParameters_\" data-linktype=\"relative-path\">ContainsGenericParameters</a> properties for the types described in the Remarks section. For explanations of the property values, see the accompanying table in Remarks.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Type.IsGenericType#1\">using namespace System;\nusing namespace System::Reflection;\n\ngeneric&lt;typename T, typename U&gt; public ref class Base {};\n\ngeneric&lt;typename T&gt; public ref class G {};\n\ngeneric&lt;typename V&gt; public ref class Derived : Base&lt;String^, V&gt;\n{\npublic: \n    G&lt;Derived&lt;V&gt;^&gt;^ F;\n\n    ref class Nested {};\n};\n\nvoid DisplayGenericType(Type^ t, String^ caption)\n{\n    Console::WriteLine(&quot;<br>{0}&quot;, caption);\n    Console::WriteLine(&quot;    Type: {0}&quot;, t);\n\n    Console::WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;            IsGenericType: {0}&quot;, \n        t-&gt;IsGenericType);\n    Console::WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;  IsGenericTypeDefinition: {0}&quot;, \n        t-&gt;IsGenericTypeDefinition);\n    Console::WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;ContainsGenericParameters: {0}&quot;, \n        t-&gt;ContainsGenericParameters);\n    Console::WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;       IsGenericParameter: {0}&quot;, \n        t-&gt;IsGenericParameter);\n}\n\nvoid main()\n{\n    // Get the generic type definition for Derived, and the base\n    // type for Derived.\n    //\n    Type^ tDerived = Derived::typeid;\n    Type^ tDerivedBase = tDerived-&gt;BaseType;\n\n    // Declare an array of Derived&lt;int&gt;, and get its type.\n    //\n    array&lt;Derived&lt;int&gt;^&gt;^ d = gcnew array&lt;Derived&lt;int&gt;^&gt;(0);\n    Type^ tDerivedArray = d-&gt;GetType();\n\n    // Get a generic type parameter, the type of a field, and a\n    // type that is nested in Derived. Notice that in order to\n    // get the nested type it is necessary to either (1) specify\n    // the generic type definition Derived::typeid, as shown here,\n    // or (2) specify a type parameter for Derived.\n    //\n    Type^ tT = Base::typeid-&gt;GetGenericArguments()[0];\n    Type^ tF = tDerived-&gt;GetField(&quot;F&quot;)-&gt;FieldType;\n    Type^ tNested = Derived::Nested::typeid;\n\n    DisplayGenericType(tDerived, &quot;generic&lt;V&gt; Derived&quot;);\n    DisplayGenericType(tDerivedBase, &quot;Base type of generic&lt;V&gt; Derived&quot;);\n    DisplayGenericType(tDerivedArray, &quot;Array of Derived&lt;int&gt;&quot;);\n    DisplayGenericType(tT, &quot;Type parameter T from generic&lt;T&gt; Base&quot;);\n    DisplayGenericType(tF, &quot;Field type, G&lt;Derived&lt;V&gt;^&gt;^&quot;);\n    DisplayGenericType(tNested, &quot;Nested type in generic&lt;V&gt; Derived&quot;);\n}\n\n/* This code example produces the following output:\n\ngeneric&lt;V&gt; Derived\n    Type: Derived`1[V]\n                    IsGenericType: True\n          IsGenericTypeDefinition: True\n        ContainsGenericParameters: True\n               IsGenericParameter: False\n\nBase type of generic&lt;V&gt; Derived\n    Type: Base`2[System.String,V]\n                    IsGenericType: True\n          IsGenericTypeDefinition: False\n        ContainsGenericParameters: True\n               IsGenericParameter: False\n\nArray of Derived&lt;int&gt;\n    Type: Derived`1[System.Int32][]\n                    IsGenericType: False\n          IsGenericTypeDefinition: False\n        ContainsGenericParameters: False\n               IsGenericParameter: False\n\nType parameter T from generic&lt;T&gt; Base\n    Type: T\n                    IsGenericType: False\n          IsGenericTypeDefinition: False\n        ContainsGenericParameters: True\n               IsGenericParameter: True\n\nField type, G&lt;Derived&lt;V&gt;^&gt;^\n    Type: G`1[Derived`1[V]]\n                    IsGenericType: True\n          IsGenericTypeDefinition: False\n        ContainsGenericParameters: True\n               IsGenericParameter: False\n\nNested type in generic&lt;V&gt; Derived\n    Type: Derived`1+Nested[V]\n                    IsGenericType: True\n          IsGenericTypeDefinition: True\n        ContainsGenericParameters: True\n               IsGenericParameter: False\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.IsGenericType#1\">Imports System\nImports System.Reflection\n\n&#39; \nPublic Class Base(Of T, U)\nEnd Class\n\nPublic Class Derived(Of V) \n    Inherits Base(Of String, V)\n\n    Public F As G(Of Derived(Of V))\n\n    Public Class Nested\n    End Class\nEnd Class\n\nPublic Class G(Of T)\nEnd Class \n\nModule Example\n\n    Sub Main\n\n        &#39; Get the generic type definition for Derived, and the base\n        &#39; type for Derived.\n        &#39;\n        Dim tDerived As Type = GetType(Derived(Of ))\n        Dim tDerivedBase As Type = tDerived.BaseType\n\n        &#39; Declare an array of Derived(Of Integer), and get its type.\n        &#39;\n        Dim d(0) As Derived(Of Integer)\n        Dim tDerivedArray As Type = d.GetType()\n\n        &#39; Get a generic type parameter, the type of a field, and a\n        &#39; type that is nested in Derived. Notice that in order to\n        &#39; get the nested type it is necessary to either (1) specify\n        &#39; the generic type definition Derived(Of ), as shown here,\n        &#39; or (2) specify a type parameter for Derived.\n        &#39;\n        Dim tT As Type = GetType(Base(Of ,)).GetGenericArguments()(0)\n        Dim tF As Type = tDerived.GetField(&quot;F&quot;).FieldType\n        Dim tNested As Type = GetType(Derived(Of ).Nested)\n\n        DisplayGenericType(tDerived, &quot;Derived(Of V)&quot;)\n        DisplayGenericType(tDerivedBase, &quot;Base type of Derived(Of V)&quot;)\n        DisplayGenericType(tDerivedArray, &quot;Array of Derived(Of Integer)&quot;)\n        DisplayGenericType(tT, &quot;Type parameter T from Base(Of T)&quot;)\n        DisplayGenericType(tF, &quot;Field type, G(Of Derived(Of V))&quot;)\n        DisplayGenericType(tNested, &quot;Nested type in Derived(Of V)&quot;)\n\n    End Sub\n\n    Sub DisplayGenericType(ByVal t As Type, ByVal caption As String)\n\n        Console.WriteLine(vbLf &amp; caption)\n        Console.WriteLine(&quot;    Type: {0}&quot;, t)\n\n        Console.WriteLine(vbTab &amp; &quot;            IsGenericType: {0}&quot;, _\n            t.IsGenericType)\n        Console.WriteLine(vbTab &amp; &quot;  IsGenericTypeDefinition: {0}&quot;, _\n            t.IsGenericTypeDefinition)\n        Console.WriteLine(vbTab &amp; &quot;ContainsGenericParameters: {0}&quot;, _\n            t.ContainsGenericParameters)\n        Console.WriteLine(vbTab &amp; &quot;       IsGenericParameter: {0}&quot;, _\n            t.IsGenericParameter)\n\n    End Sub\n\nEnd Module\n\n&#39; This code example produces the following output:\n&#39;\n&#39;Derived(Of V)\n&#39;    Type: Derived`1[V]\n&#39;                    IsGenericType: True\n&#39;          IsGenericTypeDefinition: True\n&#39;        ContainsGenericParameters: True\n&#39;               IsGenericParameter: False\n&#39;\n&#39;Base type of Derived(Of V)\n&#39;    Type: Base`2[System.String,V]\n&#39;                    IsGenericType: True\n&#39;          IsGenericTypeDefinition: False\n&#39;        ContainsGenericParameters: True\n&#39;               IsGenericParameter: False\n&#39;\n&#39;Array of Derived(Of Integer)\n&#39;    Type: Derived`1[System.Int32][]\n&#39;                    IsGenericType: False\n&#39;          IsGenericTypeDefinition: False\n&#39;        ContainsGenericParameters: False\n&#39;               IsGenericParameter: False\n&#39;\n&#39;Type parameter T from Base(Of T)\n&#39;    Type: T\n&#39;                    IsGenericType: False\n&#39;          IsGenericTypeDefinition: False\n&#39;        ContainsGenericParameters: True\n&#39;               IsGenericParameter: True\n&#39;\n&#39;Field type, G(Of Derived(Of V))\n&#39;    Type: G`1[Derived`1[V]]\n&#39;                    IsGenericType: True\n&#39;          IsGenericTypeDefinition: False\n&#39;        ContainsGenericParameters: True\n&#39;               IsGenericParameter: False\n&#39;\n&#39;Nested type in Derived(Of V)\n&#39;    Type: Derived`1+Nested[V]\n&#39;                    IsGenericType: True\n&#39;          IsGenericTypeDefinition: True\n&#39;        ContainsGenericParameters: True\n&#39;               IsGenericParameter: False\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.IsGenericType#1\">using System;\nusing System.Reflection;\n\npublic class Base&lt;T, U&gt; {}\n\npublic class Derived&lt;V&gt; : Base&lt;string, V&gt;\n{\n    public G&lt;Derived &lt;V&gt;&gt; F;\n\n    public class Nested {}\n}\n\npublic class G&lt;T&gt; {}\n\nclass Example\n{\n    public static void Main()\n    {\n        // Get the generic type definition for Derived, and the base\n        // type for Derived.\n        //\n        Type tDerived = typeof(Derived&lt;&gt;);\n        Type tDerivedBase = tDerived.BaseType;\n\n        // Declare an array of Derived&lt;int&gt;, and get its type.\n        //\n        Derived&lt;int&gt;[] d = new Derived&lt;int&gt;[0];\n        Type tDerivedArray = d.GetType();\n\n        // Get a generic type parameter, the type of a field, and a\n        // type that is nested in Derived. Notice that in order to\n        // get the nested type it is necessary to either (1) specify\n        // the generic type definition Derived&lt;&gt;, as shown here,\n        // or (2) specify a type parameter for Derived.\n        //\n        Type tT = typeof(Base&lt;,&gt;).GetGenericArguments()[0];\n        Type tF = tDerived.GetField(&quot;F&quot;).FieldType;\n        Type tNested = typeof(Derived&lt;&gt;.Nested);\n\n        DisplayGenericType(tDerived, &quot;Derived&lt;V&gt;&quot;);\n        DisplayGenericType(tDerivedBase, &quot;Base type of Derived&lt;V&gt;&quot;);\n        DisplayGenericType(tDerivedArray, &quot;Array of Derived&lt;int&gt;&quot;);\n        DisplayGenericType(tT, &quot;Type parameter T from Base&lt;T&gt;&quot;);\n        DisplayGenericType(tF, &quot;Field type, G&lt;Derived&lt;V&gt;&gt;&quot;);\n        DisplayGenericType(tNested, &quot;Nested type in Derived&lt;V&gt;&quot;);\n    }\n\n    public static void DisplayGenericType(Type t, string caption)\n    {\n        Console.WriteLine(&quot;<br>{0}&quot;, caption);\n        Console.WriteLine(&quot;    Type: {0}&quot;, t);\n\n        Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;            IsGenericType: {0}&quot;, \n            t.IsGenericType);\n        Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;  IsGenericTypeDefinition: {0}&quot;, \n            t.IsGenericTypeDefinition);\n        Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;ContainsGenericParameters: {0}&quot;, \n            t.ContainsGenericParameters);\n        Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;       IsGenericParameter: {0}&quot;, \n            t.IsGenericParameter);\n    }\n}\n\n/* This code example produces the following output:\n\nDerived&lt;V&gt;\n    Type: Derived`1[V]\n                    IsGenericType: True\n          IsGenericTypeDefinition: True\n        ContainsGenericParameters: True\n               IsGenericParameter: False\n\nBase type of Derived&lt;V&gt;\n    Type: Base`2[System.String,V]\n                    IsGenericType: True\n          IsGenericTypeDefinition: False\n        ContainsGenericParameters: True\n               IsGenericParameter: False\n\nArray of Derived&lt;int&gt;\n    Type: Derived`1[System.Int32][]\n                    IsGenericType: False\n          IsGenericTypeDefinition: False\n        ContainsGenericParameters: False\n               IsGenericParameter: False\n\nType parameter T from Base&lt;T&gt;\n    Type: T\n                    IsGenericType: False\n          IsGenericTypeDefinition: False\n        ContainsGenericParameters: True\n               IsGenericParameter: True\n\nField type, G&lt;Derived&lt;V&gt;&gt;\n    Type: G`1[Derived`1[V]]\n                    IsGenericType: True\n          IsGenericTypeDefinition: False\n        ContainsGenericParameters: True\n               IsGenericParameter: False\n\nNested type in Derived&lt;V&gt;\n    Type: Derived`1+Nested[V]\n                    IsGenericType: True\n          IsGenericTypeDefinition: True\n        ContainsGenericParameters: True\n               IsGenericParameter: False\n */\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsGenericTypeDefinition\">\r\n    \r\n            <a id=\"System_Type_IsGenericTypeDefinition_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsGenericTypeDefinition</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a generic type definition, from which other generic types can be constructed.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool IsGenericTypeDefinition { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents a generic type definition; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A generic type definition is a template from which other types can be constructed. For example, from the generic type definition <code>G&lt;T&gt;</code> (expressed in C# syntax; <code>G(Of T)</code> in Visual Basic or <code>generic &lt;typename T&gt; ref class G</code> in C++) you can construct and instantiate the type <code>G&lt;int&gt;</code> (<code>G(Of Integer)</code> in Visual Basic), by calling the <a class=\"xref\" href=\"system.type#System_Type_MakeGenericType_\" data-linktype=\"relative-path\">MakeGenericType</a> method with a generic argument list containing the <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a> type. Given a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object representing this constructed type, the <a class=\"xref\" href=\"system.type#System_Type_GetGenericTypeDefinition_\" data-linktype=\"relative-path\">GetGenericTypeDefinition</a> method gets the generic type definition back again.  </p>\n<p> Use the IsGenericTypeDefinition property to determine whether you can create new types from the current type. If the IsGenericTypeDefinition property returns <code>true</code>, you can call the <a class=\"xref\" href=\"system.type#System_Type_MakeGenericType_\" data-linktype=\"relative-path\">MakeGenericType</a> method to create new generic types.  </p>\n<p> For a list of the invariant conditions for terms used in generic reflection, see the <a class=\"xref\" href=\"system.type#System_Type_IsGenericType_\" data-linktype=\"relative-path\">IsGenericType</a> property remarks.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example displays information about a type, including whether or not it is a generic type definition. Information is displayed for a constructed type, for its generic type definition, and for an ordinary type.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.IsGenericTypeDefinition#1\">using System;\nusing System.Reflection;\nusing System.Collections.Generic;\n\npublic class Test\n{\n    private static void DisplayGenericTypeInfo(Type t)\n    {\n        Console.WriteLine(&quot;\\r<br>{0}&quot;, t);\n\n        Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;Is this a generic type definition? {0}&quot;, \n            t.IsGenericTypeDefinition);\n\n        Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;Is it a generic type? {0}&quot;, \n            t.IsGenericType);\n\n        if (t.IsGenericType)\n        {\n            // If this is a generic type, display the type arguments.\n            //\n            Type[] typeArguments = t.GetGenericArguments();\n\n            Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;List type arguments ({0}):&quot;, \n                typeArguments.Length);\n\n            foreach (Type tParam in typeArguments)\n            {\n                // If this is a type parameter, display its\n                // position.\n                //\n                if (tParam.IsGenericParameter)\n                {\n                    Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}&nbsp;&nbsp;&nbsp;&nbsp;(unassigned - parameter position {1})&quot;,\n                        tParam,\n                        tParam.GenericParameterPosition);\n                }\n                else\n                {\n                    Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;, tParam);\n                }\n            }\n        }\n    }\n\n    public static void Main()\n    {\n        Console.WriteLine(&quot;\\r<br>--- Display information about a constructed type, its&quot;);\n        Console.WriteLine(&quot;    generic type definition, and an ordinary type.&quot;);\n\n        // Create a Dictionary of Test objects, using strings for the\n        // keys.       \n        Dictionary&lt;string, Test&gt; d = new Dictionary&lt;string, Test&gt;();\n\n        // Display information for the constructed type and its generic\n        // type definition.\n        DisplayGenericTypeInfo(d.GetType());\n        DisplayGenericTypeInfo(d.GetType().GetGenericTypeDefinition());\n\n        // Display information for an ordinary type.\n        DisplayGenericTypeInfo(typeof(string));\n    }\n}\n\n/* This example produces the following output:\n\n--- Display information about a constructed type, its\n    generic type definition, and an ordinary type.\n\nSystem.Collections.Generic.Dictionary[System.String,Test]\n        Is this a generic type definition? False\n        Is it a generic type? True\n        List type arguments (2):\n                System.String\n                Test\n\nSystem.Collections.Generic.Dictionary[TKey,TValue]\n        Is this a generic type definition? True\n        Is it a generic type? True\n        List type arguments (2):\n                TKey    (unassigned - parameter position 0)\n                TValue  (unassigned - parameter position 1)\n\nSystem.String\n        Is this a generic type definition? False\n        Is it a generic type? False\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.IsGenericTypeDefinition#1\">Imports System\nImports System.Reflection\nImports System.Collections.Generic\nImports Microsoft.VisualBasic\n\nPublic Class Test\n    Private Shared Sub DisplayGenericTypeInfo(ByVal t As Type) \n        Console.WriteLine(vbCrLf &amp; t.ToString())\n        \n        Console.WriteLine(vbTab &amp; &quot;Is this a generic type definition? &quot; _\n            &amp; t.IsGenericTypeDefinition)\n        \n        Console.WriteLine(vbTab &amp; &quot;Is it a generic type? &quot; _\n            &amp; t.IsGenericType)\n        \n        If t.IsGenericType Then\n            &#39; If this is a generic type, display the type arguments.\n            &#39;\n            Dim typeArguments As Type() = t.GetGenericArguments()\n            \n            Console.WriteLine(vbTab &amp; &quot;List type arguments (&quot; _\n                &amp; typeArguments.Length &amp; &quot;):&quot;)\n            \n            For Each tParam As Type In typeArguments\n                &#39; If this is a type parameter, display its position.\n                &#39;\n                If tParam.IsGenericParameter Then\n                    Console.WriteLine(vbTab &amp; vbTab &amp; tParam.ToString() _\n                        &amp; vbTab &amp; &quot;(unassigned - parameter position &quot; _\n                        &amp; tParam.GenericParameterPosition &amp; &quot;)&quot;)\n                Else\n                    Console.WriteLine(vbTab &amp; vbTab &amp; tParam.ToString())\n                End If\n            Next tParam\n        End If\n    \n    End Sub \n    \n    \n    Public Shared Sub Main() \n        Console.WriteLine(vbCrLf &amp; &quot;--- Display information about a constructed type, its&quot;)\n        Console.WriteLine(&quot;    generic type definition, and an ordinary type.&quot;)\n        \n        &#39; Create a Dictionary of Test objects, using strings for the\n        &#39; keys.       \n        Dim d As New Dictionary(Of String, Test)()\n\n        DisplayGenericTypeInfo(d.GetType())\n        DisplayGenericTypeInfo(d.GetType().GetGenericTypeDefinition())\n        \n        &#39; Display information for an ordinary type.\n        DisplayGenericTypeInfo(GetType(String))\n    \n    End Sub &#39;Main\nEnd Class &#39;Test\n\n&#39; This example produces the following output:\n&#39;\n&#39;--- Display information about a constructed type, its\n&#39;    generic type definition, and an ordinary type.\n&#39;\n&#39;System.Collections.Generic.Dictionary[System.String, Test]\n&#39;        Is this a generic type definition? False\n&#39;        Is it a generic type? True\n&#39;        List type arguments (2):\n&#39;                System.String\n&#39;                Test\n&#39;\n&#39;System.Collections.Generic.Dictionary[TKey,TValue]\n&#39;        Is this a generic type definition? True\n&#39;        Is it a generic type? True\n&#39;        List type arguments (2):\n&#39;                TKey    (unassigned - parameter position 0)\n&#39;                TValue  (unassigned - parameter position 1)\n&#39;\n&#39;System.String\n&#39;        Is this a generic type definition? False\n&#39;        Is it a generic type? False\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Type.IsGenericTypeDefinition#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Collections::Generic;\n\npublic ref class Test\n{\nprivate:\n   static void DisplayGenericTypeInfo( Type^ t )\n   {\n      Console::WriteLine( L&quot;\\r<br>{0}&quot;, t );\n      Console::WriteLine( L&quot;&nbsp;&nbsp;&nbsp;&nbsp;Is this a generic type definition? {0}&quot;,\n         t-&gt;IsGenericTypeDefinition );\n      Console::WriteLine( L&quot;&nbsp;&nbsp;&nbsp;&nbsp;Is it a generic type? {0}&quot;,\n         t-&gt;IsGenericType );\n      \n      if ( t-&gt;IsGenericType )\n      {\n         \n         // If this is a generic type, display the type arguments.\n         //\n         array&lt;Type^&gt;^typeArguments = t-&gt;GetGenericArguments();\n         Console::WriteLine( L&quot;&nbsp;&nbsp;&nbsp;&nbsp;List type arguments ({0}):&quot;,\n            typeArguments-&gt;Length );\n         System::Collections::IEnumerator^ myEnum =\n            typeArguments-&gt;GetEnumerator();\n         while ( myEnum-&gt;MoveNext() )\n         {\n            Type^ tParam = safe_cast&lt;Type^&gt;(myEnum-&gt;Current);\n            \n            // If this is a type parameter, display its\n            // position.\n            //\n            if ( tParam-&gt;IsGenericParameter )\n            {\n               Console::WriteLine(\n                  L&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}&nbsp;&nbsp;&nbsp;&nbsp;(unassigned - parameter position {1})&quot;,\n                  tParam, tParam-&gt;GenericParameterPosition );\n            }\n            else\n            {\n               Console::WriteLine( L&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;, tParam );\n            }\n         }\n      }\n   }\n\n\npublic:\n   static void Main()\n   {\n      Console::Write( L&quot;\\r<br>--- Display information about a &quot; );\n      Console::WriteLine( L&quot;constructed type, its&quot; );\n      Console::WriteLine( L&quot;    generic type definition, and an ordinary type.&quot; );\n      \n      // Create a Dictionary of Test objects, using strings for the\n      // keys.\n      Dictionary&lt; String^,Test^ &gt;^ d = gcnew Dictionary&lt; String^,Test^ &gt;;\n      \n      // Display information for the constructed type and its generic\n      // type definition.\n      DisplayGenericTypeInfo( d-&gt;GetType() );\n      DisplayGenericTypeInfo( d-&gt;GetType()-&gt;GetGenericTypeDefinition() );\n      \n      // Display information for an ordinary type.\n      DisplayGenericTypeInfo( String::typeid );\n   }\n\n};\n\nint main()\n{\n   Test::Main();\n}\n\n/* This example produces the following output:\n\n--- Display information about a constructed type, its\n    generic type definition, and an ordinary type.\n\nSystem.Collections.Generic.Dictionary[System.String,Test]\n        Is this a generic type definition? False\n        Is it a generic type? True\n        List type arguments (2):\n                System.String\n                Test\n\nSystem.Collections.Generic.Dictionary[TKey,TValue]\n        Is this a generic type definition? True\n        Is it a generic type? True\n        List type arguments (2):\n                TKey    (unassigned - parameter position 0)\n                TValue  (unassigned - parameter position 1)\n\nSystem.String\n        Is this a generic type definition? False\n        Is it a generic type? False\n */\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsImport\">\r\n    \r\n            <a id=\"System_Type_IsImport_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsImport</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> has a <a class=\"xref\" href=\"system.runtime.interopservices.comimportattribute\" data-linktype=\"relative-path\">ComImportAttribute</a> attribute applied, indicating that it was imported from a COM type library.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsImport { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> has a <a class=\"xref\" href=\"system.runtime.interopservices.comimportattribute\" data-linktype=\"relative-path\">ComImportAttribute</a>; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents <code>MyGenericType&lt;int&gt;</code> (<code>MyGenericType(Of Integer)</code> in Visual Basic), the value of this property is determined by <code>MyGenericType&lt;T&gt;.</code>  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this property always returns <code>false</code>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsInterface\">\r\n    \r\n            <a id=\"System_Type_IsInterface_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsInterface</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is an interface; that is, not a class or a value type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsInterface { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is an interface; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">TypeAttributes</a> distinguishes a type declaration as class, interface or value type.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this property always returns <code>false</code>.  </p>\n<p> This property is read-only.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an interface, checks for the interface type, and indicates whether a class has the <code>IsInterface</code> property set.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_IsInterface#1\">using namespace System;\n\n// Declare an interface.\ninterface class myIFace{};\npublic ref class MyIsInterface{};\n\nvoid main()\n{\n   try\n   {\n      // Get the IsInterface attribute for myIFace.\n      bool myBool1 = myIFace::typeid-&gt;IsInterface;\n      \n      //Display the IsInterface attribute for myIFace.\n      Console::WriteLine( &quot;Is the specified type an interface? {0}.&quot;, myBool1 );\n      \n      // Get the attribute IsInterface for MyIsInterface.\n      bool myBool2 = MyIsInterface::typeid-&gt;IsInterface;\n      \n      //Display the IsInterface attribute for MyIsInterface.\n      Console::WriteLine( &quot;Is the specified type an interface? {0}.&quot;, myBool2 );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;<br>An exception occurred: {0}.&quot;, e-&gt;Message );\n   }\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_IsInterface#1\">using System;\n// Declare an interface.\ninterface myIFace\n{\n}\nclass MyIsInterface \n{\n    public static void Main(string []args)\n    {\n        try\n        {\n            // Get the IsInterface attribute for myIFace.\n            bool myBool1 = typeof(myIFace).IsInterface;    \n            //Display the IsInterface attribute for myIFace.\n            Console.WriteLine(&quot;Is the specified type an interface? {0}.&quot;, myBool1);\n            // Get the attribute IsInterface for MyIsInterface.\n            bool myBool2 = typeof(MyIsInterface).IsInterface;    \n            //Display the IsInterface attribute for MyIsInterface.\n            Console.WriteLine(&quot;Is the specified type an interface? {0}.&quot;, myBool2);         \n        }\n        catch(Exception e)\n        {\n            Console.WriteLine(&quot;<br>An exception occurred: {0}.&quot;, e.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_IsInterface#1\">&#39; Declare an interface.\nInterface IInterface\nEnd Interface\n\nClass Example : Implements IInterface\n   Public Shared Sub Main()\n      &#39; Determine whether IInterface is an interface.\n       Dim isInterface1 As Boolean = GetType(IInterface).IsInterface\n       Console.WriteLine(&quot;Is IInterface an interface? {0}&quot;, isInterface1)\n\n       &#39; Determine whether Example is an interface.\n       Dim isInterface2 As Boolean = GetType(Example).IsInterface\n       Console.WriteLine(&quot;Is Example an interface? {0}&quot;, isInterface2)\n   End Sub \nEnd Class \n&#39; The example displays the following output:\n&#39;       Is IInterface an interface? True\n&#39;       Is Example an interface? False\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsLayoutSequential\">\r\n    \r\n            <a id=\"System_Type_IsLayoutSequential_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsLayoutSequential</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsLayoutSequential { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <span class=\"xref\">stem.Type.Attributes*</span> property of the current type includes <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">TypeAttributes</a>; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This property is provided as a convenience. Alternatively, you can use the <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a>enumeration value to select the type layout attributes, and then test whether <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a> is set. The <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a>, <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a>, and <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a> enumeration values indicate the way the fields of the type are laid out in memory.  </p>\n<p> For dynamic types, you can specify <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a> when you create the type. In code, apply the <a class=\"xref\" href=\"system.runtime.interopservices.structlayoutattribute\" data-linktype=\"relative-path\">StructLayoutAttribute</a> attribute with the <a class=\"xref\" href=\"system.runtime.interopservices.layoutkind\" data-linktype=\"relative-path\">System.Runtime.InteropServices.LayoutKind</a> enumeration value to the type, to specify that layout is sequential.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> You cannot use the <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_GetCustomAttributes_\" data-linktype=\"relative-path\">GetCustomAttributes</a> method to determine whether the <a class=\"xref\" href=\"system.runtime.interopservices.structlayoutattribute\" data-linktype=\"relative-path\">StructLayoutAttribute</a> has been applied to a type.  </p>\n</div>\n<p> For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, &quot;Partition II: Metadata Definition and Semantics&quot;. The documentation is available online; see <a href=\"http://go.microsoft.com/fwlink/?LinkID=99212\" data-linktype=\"external\">ECMA C# and Common Language Infrastructure Standards</a> on MSDN and <a href=\"http://go.microsoft.com/fwlink/?LinkID=65552\" data-linktype=\"external\">Standard ECMA-335 - Common Language Infrastructure (CLI)</a> on the Ecma International Web site.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents <code>MyGenericType&lt;int&gt;</code> (<code>MyGenericType(Of Integer)</code> in Visual Basic), the value of this property is determined by <code>MyGenericType&lt;T&gt;</code>.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this property always returns <code>false</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an instance of a class for which the <a class=\"xref\" href=\"system.runtime.interopservices.layoutkind\" data-linktype=\"relative-path\">System.Runtime.InteropServices.LayoutKind</a>enumeration value in the <a class=\"xref\" href=\"system.runtime.interopservices.structlayoutattribute\" data-linktype=\"relative-path\">StructLayoutAttribute</a> class has been set, checks for the IsLayoutSequential property, and displays the result.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_IsLayoutSequential#1\">using System;\nusing System.Reflection;\nusing System.ComponentModel;\nusing System.Runtime.InteropServices;\nclass MyTypeSequential1\n{\n}\n[StructLayoutAttribute(LayoutKind.Sequential)]\nclass MyTypeSequential2\n{\n    public static void Main(string []args)\n    {\n        try\n        {\n            // Create an instance of myTypeSeq1.\n            MyTypeSequential1 myObj1 = new MyTypeSequential1();\n            Type myTypeObj1 = myObj1.GetType();\n            // Check for and display the SequentialLayout attribute.\n            Console.WriteLine(&quot;<br>The object myObj1 has IsLayoutSequential: {0}.&quot;, myObj1.GetType().IsLayoutSequential);\n            // Create an instance of &#39;myTypeSeq2&#39; class.\n            MyTypeSequential2 myObj2 = new MyTypeSequential2();\n            Type myTypeObj2 = myObj2.GetType();\n            // Check for and display the SequentialLayout attribute.\n            Console.WriteLine(&quot;<br>The object myObj2 has IsLayoutSequential: {0}.&quot;, myObj2.GetType().IsLayoutSequential);\n        }\n        catch(Exception e)\n        {\n            Console.WriteLine(&quot;<br>An exception occurred: {0}&quot;, e.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_IsLayoutSequential#1\">#using &lt;System.dll&gt;\n\nusing namespace System;\nusing namespace System::Reflection;\nusing namespace System::ComponentModel;\nusing namespace System::Runtime::InteropServices;\nref class MyTypeSequential1{};\n\n\n[StructLayoutAttribute(LayoutKind::Sequential)]\nref class MyTypeSequential2{};\n\nint main()\n{\n   try\n   {\n      \n      // Create an instance of myTypeSeq1.\n      MyTypeSequential1^ myObj1 = gcnew MyTypeSequential1;\n      \n      // Check for and display the SequentialLayout attribute.\n      Console::WriteLine( &quot;<br>The object myObj1 has IsLayoutSequential: {0}.&quot;, myObj1-&gt;GetType()-&gt;IsLayoutSequential );\n      \n      // Create an instance of &#39;myTypeSeq2&#39; class.\n      MyTypeSequential2^ myObj2 = gcnew MyTypeSequential2;\n      \n      // Check for and display the SequentialLayout attribute.\n      Console::WriteLine( &quot;<br>The object myObj2 has IsLayoutSequential: {0}.&quot;, myObj2-&gt;GetType()-&gt;IsLayoutSequential );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;<br>An exception occurred: {0}&quot;, e-&gt;Message );\n   }\n\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_IsLayoutSequential#1\">Imports System\nImports System.Reflection\nImports System.ComponentModel\nImports System.Runtime.InteropServices\nImports Microsoft.VisualBasic\nClass MyTypeSequential1\nEnd Class &#39;MyTypeSequential1\n&lt;StructLayoutAttribute(LayoutKind.Sequential)&gt; Class MyTypeSequential2\n    Public Shared Sub Main()\n        Try\n            &#39; Create an instance of MyTypeSequential1.\n            Dim myObj1 As New MyTypeSequential1()\n            Dim myTypeObj1 As Type = myObj1.GetType()\n            &#39; Check for and display the SequentialLayout attribute.\n            Console.WriteLine(ControlChars.Cr + &quot;The object myObj1 has IsLayoutSequential: {0}.&quot;, myObj1.GetType().IsLayoutSequential.ToString())\n            &#39; Create an instance of MyTypeSequential2.\n            Dim myObj2 As New MyTypeSequential2()\n            Dim myTypeObj2 As Type = myObj2.GetType()\n            &#39; Check for and display the SequentialLayout attribute.\n            Console.WriteLine(ControlChars.Cr + &quot;The object myObj2 has IsLayoutSequential: {0}.&quot;, myObj2.GetType().IsLayoutSequential.ToString())\n        Catch e As Exception\n            Console.WriteLine(ControlChars.Cr + &quot;An exception occurred: {0}&quot;, e.Message.ToString())\n        End Try\n    End Sub &#39;Main\nEnd Class &#39;MyTypeSeq2\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsMarshalByRef\">\r\n    \r\n            <a id=\"System_Type_IsMarshalByRef_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsMarshalByRef</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is marshaled by reference.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsMarshalByRef { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is marshaled by reference; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example demonstrates the <code>IsContextful</code>, IsMarshalByRef, and <a class=\"xref\" href=\"system.type#System_Type_IsPrimitive_\" data-linktype=\"relative-path\">IsPrimitive</a> properties of the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> class. It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_IsContextful#1\">using System;\nusing System.Runtime.Remoting.Contexts;\n\npublic class ContextBoundClass: ContextBoundObject\n{\n    public string Value = &quot;The Value property.&quot;;\n}\n\npublic class Example\n{\n    public static void Main()\n    {\n         // Determine whether the types can be hosted in a Context.\n         Console.WriteLine(&quot;The IsContextful property for the {0} type is {1}.&quot;,\n                           typeof(Example).Name, typeof(Example).IsContextful);\n         Console.WriteLine(&quot;The IsContextful property for the {0} type is {1}.&quot;,\n                           typeof(ContextBoundClass).Name, typeof(ContextBoundClass).IsContextful);\n\n         // Determine whether the types are marshalled by reference.\n         Console.WriteLine(&quot;The IsMarshalByRef property of {0} is {1}.&quot;,\n                           typeof(Example).Name, typeof(Example).IsMarshalByRef);\n         Console.WriteLine(&quot;The IsMarshalByRef property of {0} is {1}.&quot;,\n                           typeof(ContextBoundClass).Name, typeof(ContextBoundClass).IsMarshalByRef);\n         \n         // Determine whether the types are primitive datatypes.\n         Console.WriteLine(&quot;{0} is a primitive data type: {1}.&quot;,\n                           typeof(int).Name, typeof(int).IsPrimitive);\n         Console.WriteLine(&quot;{0} is a primitive data type: {1}.&quot;,\n                           typeof(string).Name, typeof(string).IsPrimitive);\n    }\n}\n// The example displays the following output:\n//    The IsContextful property for the Example type is False.\n//    The IsContextful property for the ContextBoundClass type is True.\n//    The IsMarshalByRef property of Example is False.\n//    The IsMarshalByRef property of ContextBoundClass is True.\n//    Int32 is a primitive data type: True.\n//    String is a primitive data type: False.\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_IsContextful#1\">using namespace System;\nusing namespace System::Runtime::Remoting::Contexts;\n\npublic ref class ContextBoundClass: public ContextBoundObject\n{\n   public:\n      String^ Value;\n};\n\npublic ref class Example\n{\npublic:\n   void Demo()\n   {\n      // Determine whether the types can be hosted in a Context.\n      Console::WriteLine(&quot;The IsContextful property for the {0} type is {1}.&quot;,\n                         Example::typeid-&gt;Name, Example::typeid-&gt;IsContextful);\n      Console::WriteLine(&quot;The IsContextful property for the {0} type is {1}.&quot;,\n                         ContextBoundClass::typeid-&gt;Name, ContextBoundClass::typeid-&gt;IsContextful);\n      \n      // Determine whether the types are marshalled by reference.\n      Console::WriteLine(&quot;The IsMarshalByRef property of {0} is {1}.&quot;,\n                         Example::typeid-&gt;Name, Example::typeid-&gt;IsMarshalByRef );\n      Console::WriteLine(&quot;The IsMarshalByRef property of {0} is {1}.&quot;,\n                         ContextBoundClass::typeid-&gt;Name, ContextBoundClass::typeid-&gt;IsMarshalByRef );\n      \n      // Determine whether the types are primitive datatypes.\n      Console::WriteLine(&quot;{0} is a primitive data type: {1}.&quot;,\n                         int::typeid-&gt;Name, int::typeid-&gt;IsPrimitive );\n      Console::WriteLine(&quot;{0} is a primitive data type: {1}.&quot;,\n                         String::typeid-&gt;Name, String::typeid-&gt;IsPrimitive );\n   }\n};\n\nint main()\n{\n   Example^ ex = gcnew Example;\n   ex-&gt;Demo();\n}\n// The example displays the following output:\n//    The IsContextful property for the Example type is False.\n//    The IsContextful property for the ContextBoundClass type is True.\n//    The IsMarshalByRef property of Example is False.\n//    The IsMarshalByRef property of ContextBoundClass is True.\n//    Int32 is a primitive data type: True.\n//    String is a primitive data type: False.\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_IsContextful#1\">Imports System.Runtime.Remoting.Contexts\n\nPublic Class ContextBoundClass : Inherits ContextBoundObject\n    Public Value As String = &quot;The Value property.&quot;\nEnd Class\n\nPublic Class Example\n    Public Shared Sub Main()\n         &#39; Determine whether the types can be hosted in a Context.\n         Console.WriteLine(&quot;The IsContextful property for the {0} type is {1}.&quot;,\n                           GetType(Example).Name, GetType(Example).IsContextful)\n         Console.WriteLine(&quot;The IsContextful property for the {0} type is {1}.&quot;,\n                           GetType(ContextBoundClass).Name, GetType(ContextBoundClass).IsContextful)\n         &#39; Determine whether the types are marshalled by reference.\n         Console.WriteLine(&quot;The IsMarshalByRef property of {0} is {1}.&quot;,\n                           GetType(Example).Name, GetType(Example).IsMarshalByRef)\n         Console.WriteLine(&quot;The IsMarshalByRef property of {0} is {1}.&quot;,\n                           GetType(ContextBoundClass).Name, GetType(ContextBoundClass).IsMarshalByRef)\n         &#39; Determine whether the types are primitive datatypes.\n         Console.WriteLine(&quot;{0} is a primitive data type: {1}.&quot;,\n                           GetType(Integer).Name, GetType(Integer).IsPrimitive)\n         Console.WriteLine(&quot;{0} is a primitive data type: {1}.&quot;,\n                           GetType(String).Name, GetType(String).IsPrimitive)\n    End Sub\nEnd Class\n&#39; The example displays the following output:\n&#39;    The IsContextful property for the Example type is False.\n&#39;    The IsContextful property for the ContextBoundClass type is True.\n&#39;    The IsMarshalByRef property of Example is False.\n&#39;    The IsMarshalByRef property of ContextBoundClass is True.\n&#39;    Int32 is a primitive data type: True.\n&#39;    String is a primitive data type: False.\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsNested\">\r\n    \r\n            <a id=\"System_Type_IsNested_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsNested</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents a type whose definition is nested inside the definition of another type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsNested { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is nested inside another type; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The IsNested property returns <code>true</code> for all nested types, regardless of visibility. To test for nesting and visibility at the same time, use the related properties <a class=\"xref\" href=\"system.type#System_Type_IsNestedAssembly_\" data-linktype=\"relative-path\">IsNestedAssembly</a>, <a class=\"xref\" href=\"system.type#System_Type_IsNestedFamily_\" data-linktype=\"relative-path\">IsNestedFamily</a>, <a class=\"xref\" href=\"system.type#System_Type_IsNestedFamANDAssem_\" data-linktype=\"relative-path\">IsNestedFamANDAssem</a>, <a class=\"xref\" href=\"system.type#System_Type_IsNestedFamORAssem_\" data-linktype=\"relative-path\">IsNestedFamORAssem</a>, <a class=\"xref\" href=\"system.type#System_Type_IsNestedPrivate_\" data-linktype=\"relative-path\">IsNestedPrivate</a>, or <a class=\"xref\" href=\"system.type#System_Type_IsNestedPublic_\" data-linktype=\"relative-path\">IsNestedPublic</a>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">TypeAttributes</a> enumeration member selects the visibility attributes for a type.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an outer class with a number of nested classes that have various types of visibility. It then retrieves the value of a number of visibility-related <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> properties for the parent type and each of its nested types.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Type.IsNestedFamAndAssem#1\">&#39; Create a Class with a number of nested Classes.\nPublic Class OuterClass\n    Private Class PrivateClass\n    End Class\n\n    Protected Class ProtectedClass\n    End Class\n\n    Friend Class InternalClass\n    End Class\n\n    Protected Friend Class ProtectedInternalClass\n    End Class\n\n    Public Class PublicClass\n    End Class\n\n    Public Shared Sub Main()\n        &#39; Create an array of Type objects for all the Classes.\n        Dim types() As Type = { GetType(OuterClass),\n                                GetType(OuterClass.PublicClass),\n                                GetType(OuterClass.PrivateClass),\n                                GetType(OuterClass.ProtectedClass),\n                                GetType(OuterClass.InternalClass),\n                                GetType(OuterClass.ProtectedInternalClass) }\n        &#39; Display the property values of each nested Class.\n        For Each type In types\n           Console.WriteLine(&quot;{0} property values:&quot;, type.Name)\n           Console.WriteLine(&quot;   Public Class: {0}&quot;, type.IsPublic)\n           Console.WriteLine(&quot;   Not a Public Class: {0}&quot;, type.IsNotPublic)\n           Console.WriteLine(&quot;   Nested Class: {0}&quot;, type.IsNested)\n           Console.WriteLine(&quot;   Nested Private Class: {0}&quot;, type.IsNestedPrivate)\n           Console.WriteLine(&quot;   Nested Internal Class: {0}&quot;, type.IsNestedAssembly)\n           Console.WriteLine(&quot;   Nested Protected Class: {0}&quot;, type.IsNestedFamily)\n           Console.WriteLine(&quot;   Nested Family Or Assembly Class: {0}&quot;, type.IsNestedFamORAssem)\n           Console.WriteLine(&quot;   Nested Family And Assembly Class: {0}&quot;, type.IsNestedFamANDAssem)\n           Console.WriteLine(&quot;   Nested Public Class: {0}&quot;, type.IsNestedPublic)\n           Console.WriteLine()\n        Next\n    End Sub\nEnd Class\n&#39; The example displays the following output:\n&#39;    OuterClass property values:\n&#39;       Public Class: True\n&#39;       Not a Public Class: False\n&#39;       Nested Class: False\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    PublicClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: True\n&#39;\n&#39;    PrivateClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: True\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    ProtectedClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: True\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    InternalClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: True\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    ProtectedInternalClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: True\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.IsNestedFamAndAssem#1\">using System;\n\n// Create a class with a number of nested classes.\npublic class OuterClass\n{\n    private class PrivateClass\n    {}\n\n    protected class ProtectedClass\n    {}\n\n    internal class InternalClass\n    {}\n\n    protected internal class ProtectedInternalClass\n    {}\n\n    public class PublicClass\n    {}\n\n    public static void Main()\n    {\n        // Create an array of Type objects for all the classes.\n        Type[] types = { typeof(OuterClass),\n                         typeof(OuterClass.PublicClass),\n                         typeof(OuterClass.PrivateClass),\n                         typeof(OuterClass.ProtectedClass),\n                         typeof(OuterClass.InternalClass),\n                         typeof(OuterClass.ProtectedInternalClass) };\n        // Display the property values of each nested class.\n        foreach (var type in types) {\n           Console.WriteLine(&quot;<br>{0} property values:&quot;, type.Name);\n           Console.WriteLine(&quot;   Public Class: {0}&quot;, type.IsPublic);\n           Console.WriteLine(&quot;   Not a Public Class: {0}&quot;, type.IsNotPublic);\n           Console.WriteLine(&quot;   Nested Class: {0}&quot;, type.IsNested);\n           Console.WriteLine(&quot;   Nested Private Class: {0}&quot;, type.IsNestedPrivate);\n           Console.WriteLine(&quot;   Nested Internal Class: {0}&quot;, type.IsNestedAssembly);\n           Console.WriteLine(&quot;   Nested Protected Class: {0}&quot;, type.IsNestedFamily);\n           Console.WriteLine(&quot;   Nested Family Or Assembly Class: {0}&quot;, type.IsNestedFamORAssem);\n           Console.WriteLine(&quot;   Nested Family And Assembly Class: {0}&quot;, type.IsNestedFamANDAssem);\n           Console.WriteLine(&quot;   Nested Public Class: {0}&quot;, type.IsNestedPublic);\n        }\n    }\n}\n// The example displays the following output:\n//    OuterClass property values:\n//       Public Class: True\n//       Not a Public Class: False\n//       Nested Class: False\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    PublicClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: True\n//\n//    PrivateClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: True\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    ProtectedClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: True\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    InternalClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: True\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    ProtectedInternalClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: True\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsNestedAssembly\">\r\n    \r\n            <a id=\"System_Type_IsNestedAssembly_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsNestedAssembly</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is nested and visible only within its own assembly.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsNestedAssembly { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is nested and visible only within its own assembly; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter of a generic type, this property always returns <code>false</code>.  </p>\n<p> <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a> selects the visibility attributes.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an outer class with a number of nested classes that have various types of visibility. It then retrieves the value of a number of visibility-related <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> properties for the parent type and each of its nested types.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Type.IsNestedFamAndAssem#1\">&#39; Create a Class with a number of nested Classes.\nPublic Class OuterClass\n    Private Class PrivateClass\n    End Class\n\n    Protected Class ProtectedClass\n    End Class\n\n    Friend Class InternalClass\n    End Class\n\n    Protected Friend Class ProtectedInternalClass\n    End Class\n\n    Public Class PublicClass\n    End Class\n\n    Public Shared Sub Main()\n        &#39; Create an array of Type objects for all the Classes.\n        Dim types() As Type = { GetType(OuterClass),\n                                GetType(OuterClass.PublicClass),\n                                GetType(OuterClass.PrivateClass),\n                                GetType(OuterClass.ProtectedClass),\n                                GetType(OuterClass.InternalClass),\n                                GetType(OuterClass.ProtectedInternalClass) }\n        &#39; Display the property values of each nested Class.\n        For Each type In types\n           Console.WriteLine(&quot;{0} property values:&quot;, type.Name)\n           Console.WriteLine(&quot;   Public Class: {0}&quot;, type.IsPublic)\n           Console.WriteLine(&quot;   Not a Public Class: {0}&quot;, type.IsNotPublic)\n           Console.WriteLine(&quot;   Nested Class: {0}&quot;, type.IsNested)\n           Console.WriteLine(&quot;   Nested Private Class: {0}&quot;, type.IsNestedPrivate)\n           Console.WriteLine(&quot;   Nested Internal Class: {0}&quot;, type.IsNestedAssembly)\n           Console.WriteLine(&quot;   Nested Protected Class: {0}&quot;, type.IsNestedFamily)\n           Console.WriteLine(&quot;   Nested Family Or Assembly Class: {0}&quot;, type.IsNestedFamORAssem)\n           Console.WriteLine(&quot;   Nested Family And Assembly Class: {0}&quot;, type.IsNestedFamANDAssem)\n           Console.WriteLine(&quot;   Nested Public Class: {0}&quot;, type.IsNestedPublic)\n           Console.WriteLine()\n        Next\n    End Sub\nEnd Class\n&#39; The example displays the following output:\n&#39;    OuterClass property values:\n&#39;       Public Class: True\n&#39;       Not a Public Class: False\n&#39;       Nested Class: False\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    PublicClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: True\n&#39;\n&#39;    PrivateClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: True\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    ProtectedClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: True\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    InternalClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: True\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    ProtectedInternalClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: True\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.IsNestedFamAndAssem#1\">using System;\n\n// Create a class with a number of nested classes.\npublic class OuterClass\n{\n    private class PrivateClass\n    {}\n\n    protected class ProtectedClass\n    {}\n\n    internal class InternalClass\n    {}\n\n    protected internal class ProtectedInternalClass\n    {}\n\n    public class PublicClass\n    {}\n\n    public static void Main()\n    {\n        // Create an array of Type objects for all the classes.\n        Type[] types = { typeof(OuterClass),\n                         typeof(OuterClass.PublicClass),\n                         typeof(OuterClass.PrivateClass),\n                         typeof(OuterClass.ProtectedClass),\n                         typeof(OuterClass.InternalClass),\n                         typeof(OuterClass.ProtectedInternalClass) };\n        // Display the property values of each nested class.\n        foreach (var type in types) {\n           Console.WriteLine(&quot;<br>{0} property values:&quot;, type.Name);\n           Console.WriteLine(&quot;   Public Class: {0}&quot;, type.IsPublic);\n           Console.WriteLine(&quot;   Not a Public Class: {0}&quot;, type.IsNotPublic);\n           Console.WriteLine(&quot;   Nested Class: {0}&quot;, type.IsNested);\n           Console.WriteLine(&quot;   Nested Private Class: {0}&quot;, type.IsNestedPrivate);\n           Console.WriteLine(&quot;   Nested Internal Class: {0}&quot;, type.IsNestedAssembly);\n           Console.WriteLine(&quot;   Nested Protected Class: {0}&quot;, type.IsNestedFamily);\n           Console.WriteLine(&quot;   Nested Family Or Assembly Class: {0}&quot;, type.IsNestedFamORAssem);\n           Console.WriteLine(&quot;   Nested Family And Assembly Class: {0}&quot;, type.IsNestedFamANDAssem);\n           Console.WriteLine(&quot;   Nested Public Class: {0}&quot;, type.IsNestedPublic);\n        }\n    }\n}\n// The example displays the following output:\n//    OuterClass property values:\n//       Public Class: True\n//       Not a Public Class: False\n//       Nested Class: False\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    PublicClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: True\n//\n//    PrivateClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: True\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    ProtectedClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: True\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    InternalClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: True\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    ProtectedInternalClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: True\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsNestedFamANDAssem\">\r\n    \r\n            <a id=\"System_Type_IsNestedFamANDAssem_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsNestedFamANDAssem</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is nested and visible only to classes that belong to both its own family and its own assembly.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsNestedFamANDAssem { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is nested and visible only to classes that belong to both its own family and its own assembly; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter of a generic type, this property always returns <code>false</code>.  </p>\n<p> <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a> selects the visibility attributes.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The C# and Visual Basic languages do not include semantics that allow you to define a nested type that is visible only to protected types in its own assembly. <code>protected internal</code> visibility in C# and <code>Protected Friend</code> visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly.  </p>\n</div>\n<p> A <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object&#39;s family is defined as all objects of the same <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> and of its subtypes.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an outer class with a number of nested classes that have various types of visibility. It then retrieves the value of a number of visibility-related <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> properties for the parent type and each of its nested types.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Type.IsNestedFamAndAssem#1\">&#39; Create a Class with a number of nested Classes.\nPublic Class OuterClass\n    Private Class PrivateClass\n    End Class\n\n    Protected Class ProtectedClass\n    End Class\n\n    Friend Class InternalClass\n    End Class\n\n    Protected Friend Class ProtectedInternalClass\n    End Class\n\n    Public Class PublicClass\n    End Class\n\n    Public Shared Sub Main()\n        &#39; Create an array of Type objects for all the Classes.\n        Dim types() As Type = { GetType(OuterClass),\n                                GetType(OuterClass.PublicClass),\n                                GetType(OuterClass.PrivateClass),\n                                GetType(OuterClass.ProtectedClass),\n                                GetType(OuterClass.InternalClass),\n                                GetType(OuterClass.ProtectedInternalClass) }\n        &#39; Display the property values of each nested Class.\n        For Each type In types\n           Console.WriteLine(&quot;{0} property values:&quot;, type.Name)\n           Console.WriteLine(&quot;   Public Class: {0}&quot;, type.IsPublic)\n           Console.WriteLine(&quot;   Not a Public Class: {0}&quot;, type.IsNotPublic)\n           Console.WriteLine(&quot;   Nested Class: {0}&quot;, type.IsNested)\n           Console.WriteLine(&quot;   Nested Private Class: {0}&quot;, type.IsNestedPrivate)\n           Console.WriteLine(&quot;   Nested Internal Class: {0}&quot;, type.IsNestedAssembly)\n           Console.WriteLine(&quot;   Nested Protected Class: {0}&quot;, type.IsNestedFamily)\n           Console.WriteLine(&quot;   Nested Family Or Assembly Class: {0}&quot;, type.IsNestedFamORAssem)\n           Console.WriteLine(&quot;   Nested Family And Assembly Class: {0}&quot;, type.IsNestedFamANDAssem)\n           Console.WriteLine(&quot;   Nested Public Class: {0}&quot;, type.IsNestedPublic)\n           Console.WriteLine()\n        Next\n    End Sub\nEnd Class\n&#39; The example displays the following output:\n&#39;    OuterClass property values:\n&#39;       Public Class: True\n&#39;       Not a Public Class: False\n&#39;       Nested Class: False\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    PublicClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: True\n&#39;\n&#39;    PrivateClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: True\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    ProtectedClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: True\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    InternalClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: True\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    ProtectedInternalClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: True\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.IsNestedFamAndAssem#1\">using System;\n\n// Create a class with a number of nested classes.\npublic class OuterClass\n{\n    private class PrivateClass\n    {}\n\n    protected class ProtectedClass\n    {}\n\n    internal class InternalClass\n    {}\n\n    protected internal class ProtectedInternalClass\n    {}\n\n    public class PublicClass\n    {}\n\n    public static void Main()\n    {\n        // Create an array of Type objects for all the classes.\n        Type[] types = { typeof(OuterClass),\n                         typeof(OuterClass.PublicClass),\n                         typeof(OuterClass.PrivateClass),\n                         typeof(OuterClass.ProtectedClass),\n                         typeof(OuterClass.InternalClass),\n                         typeof(OuterClass.ProtectedInternalClass) };\n        // Display the property values of each nested class.\n        foreach (var type in types) {\n           Console.WriteLine(&quot;<br>{0} property values:&quot;, type.Name);\n           Console.WriteLine(&quot;   Public Class: {0}&quot;, type.IsPublic);\n           Console.WriteLine(&quot;   Not a Public Class: {0}&quot;, type.IsNotPublic);\n           Console.WriteLine(&quot;   Nested Class: {0}&quot;, type.IsNested);\n           Console.WriteLine(&quot;   Nested Private Class: {0}&quot;, type.IsNestedPrivate);\n           Console.WriteLine(&quot;   Nested Internal Class: {0}&quot;, type.IsNestedAssembly);\n           Console.WriteLine(&quot;   Nested Protected Class: {0}&quot;, type.IsNestedFamily);\n           Console.WriteLine(&quot;   Nested Family Or Assembly Class: {0}&quot;, type.IsNestedFamORAssem);\n           Console.WriteLine(&quot;   Nested Family And Assembly Class: {0}&quot;, type.IsNestedFamANDAssem);\n           Console.WriteLine(&quot;   Nested Public Class: {0}&quot;, type.IsNestedPublic);\n        }\n    }\n}\n// The example displays the following output:\n//    OuterClass property values:\n//       Public Class: True\n//       Not a Public Class: False\n//       Nested Class: False\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    PublicClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: True\n//\n//    PrivateClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: True\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    ProtectedClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: True\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    InternalClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: True\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    ProtectedInternalClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: True\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsNestedFamily\">\r\n    \r\n            <a id=\"System_Type_IsNestedFamily_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsNestedFamily</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is nested and visible only within its own family.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsNestedFamily { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is nested and visible only within its own family; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter of a generic type, this property always returns <code>false</code>.  </p>\n<p> <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a> selects the visibility attributes.  </p>\n<p> A <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object&#39;s family is defined as all objects of the exact same <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> and of its subtypes.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an outer class with a number of nested classes that have various types of visibility. It then retrieves the value of a number of visibility-related <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> properties for the parent type and each of its nested types.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Type.IsNestedFamAndAssem#1\">&#39; Create a Class with a number of nested Classes.\nPublic Class OuterClass\n    Private Class PrivateClass\n    End Class\n\n    Protected Class ProtectedClass\n    End Class\n\n    Friend Class InternalClass\n    End Class\n\n    Protected Friend Class ProtectedInternalClass\n    End Class\n\n    Public Class PublicClass\n    End Class\n\n    Public Shared Sub Main()\n        &#39; Create an array of Type objects for all the Classes.\n        Dim types() As Type = { GetType(OuterClass),\n                                GetType(OuterClass.PublicClass),\n                                GetType(OuterClass.PrivateClass),\n                                GetType(OuterClass.ProtectedClass),\n                                GetType(OuterClass.InternalClass),\n                                GetType(OuterClass.ProtectedInternalClass) }\n        &#39; Display the property values of each nested Class.\n        For Each type In types\n           Console.WriteLine(&quot;{0} property values:&quot;, type.Name)\n           Console.WriteLine(&quot;   Public Class: {0}&quot;, type.IsPublic)\n           Console.WriteLine(&quot;   Not a Public Class: {0}&quot;, type.IsNotPublic)\n           Console.WriteLine(&quot;   Nested Class: {0}&quot;, type.IsNested)\n           Console.WriteLine(&quot;   Nested Private Class: {0}&quot;, type.IsNestedPrivate)\n           Console.WriteLine(&quot;   Nested Internal Class: {0}&quot;, type.IsNestedAssembly)\n           Console.WriteLine(&quot;   Nested Protected Class: {0}&quot;, type.IsNestedFamily)\n           Console.WriteLine(&quot;   Nested Family Or Assembly Class: {0}&quot;, type.IsNestedFamORAssem)\n           Console.WriteLine(&quot;   Nested Family And Assembly Class: {0}&quot;, type.IsNestedFamANDAssem)\n           Console.WriteLine(&quot;   Nested Public Class: {0}&quot;, type.IsNestedPublic)\n           Console.WriteLine()\n        Next\n    End Sub\nEnd Class\n&#39; The example displays the following output:\n&#39;    OuterClass property values:\n&#39;       Public Class: True\n&#39;       Not a Public Class: False\n&#39;       Nested Class: False\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    PublicClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: True\n&#39;\n&#39;    PrivateClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: True\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    ProtectedClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: True\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    InternalClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: True\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    ProtectedInternalClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: True\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.IsNestedFamAndAssem#1\">using System;\n\n// Create a class with a number of nested classes.\npublic class OuterClass\n{\n    private class PrivateClass\n    {}\n\n    protected class ProtectedClass\n    {}\n\n    internal class InternalClass\n    {}\n\n    protected internal class ProtectedInternalClass\n    {}\n\n    public class PublicClass\n    {}\n\n    public static void Main()\n    {\n        // Create an array of Type objects for all the classes.\n        Type[] types = { typeof(OuterClass),\n                         typeof(OuterClass.PublicClass),\n                         typeof(OuterClass.PrivateClass),\n                         typeof(OuterClass.ProtectedClass),\n                         typeof(OuterClass.InternalClass),\n                         typeof(OuterClass.ProtectedInternalClass) };\n        // Display the property values of each nested class.\n        foreach (var type in types) {\n           Console.WriteLine(&quot;<br>{0} property values:&quot;, type.Name);\n           Console.WriteLine(&quot;   Public Class: {0}&quot;, type.IsPublic);\n           Console.WriteLine(&quot;   Not a Public Class: {0}&quot;, type.IsNotPublic);\n           Console.WriteLine(&quot;   Nested Class: {0}&quot;, type.IsNested);\n           Console.WriteLine(&quot;   Nested Private Class: {0}&quot;, type.IsNestedPrivate);\n           Console.WriteLine(&quot;   Nested Internal Class: {0}&quot;, type.IsNestedAssembly);\n           Console.WriteLine(&quot;   Nested Protected Class: {0}&quot;, type.IsNestedFamily);\n           Console.WriteLine(&quot;   Nested Family Or Assembly Class: {0}&quot;, type.IsNestedFamORAssem);\n           Console.WriteLine(&quot;   Nested Family And Assembly Class: {0}&quot;, type.IsNestedFamANDAssem);\n           Console.WriteLine(&quot;   Nested Public Class: {0}&quot;, type.IsNestedPublic);\n        }\n    }\n}\n// The example displays the following output:\n//    OuterClass property values:\n//       Public Class: True\n//       Not a Public Class: False\n//       Nested Class: False\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    PublicClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: True\n//\n//    PrivateClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: True\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    ProtectedClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: True\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    InternalClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: True\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    ProtectedInternalClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: True\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsNestedFamORAssem\">\r\n    \r\n            <a id=\"System_Type_IsNestedFamORAssem_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsNestedFamORAssem</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is nested and visible only to classes that belong to either its own family or to its own assembly.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsNestedFamORAssem { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is nested and visible only to classes that belong to its own family or to its own assembly; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the visibility of a type is <code>protected internal</code> in C# or <code>Protected Friend</code> in Visual Basic, the IsNestedFamORAssem property returns <code>true</code>.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter of a generic type, this property always returns <code>false</code>.  </p>\n<p> <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a> selects the visibility attributes.  </p>\n<p> A <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object&#39;s family is defined as all objects of the exact same <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> and of its subtypes.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an outer class with a number of nested classes that have various types of visibility. It then retrieves the value of a number of visibility-related <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> properties for the parent type and each of its nested types.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Type.IsNestedFamAndAssem#1\">&#39; Create a Class with a number of nested Classes.\nPublic Class OuterClass\n    Private Class PrivateClass\n    End Class\n\n    Protected Class ProtectedClass\n    End Class\n\n    Friend Class InternalClass\n    End Class\n\n    Protected Friend Class ProtectedInternalClass\n    End Class\n\n    Public Class PublicClass\n    End Class\n\n    Public Shared Sub Main()\n        &#39; Create an array of Type objects for all the Classes.\n        Dim types() As Type = { GetType(OuterClass),\n                                GetType(OuterClass.PublicClass),\n                                GetType(OuterClass.PrivateClass),\n                                GetType(OuterClass.ProtectedClass),\n                                GetType(OuterClass.InternalClass),\n                                GetType(OuterClass.ProtectedInternalClass) }\n        &#39; Display the property values of each nested Class.\n        For Each type In types\n           Console.WriteLine(&quot;{0} property values:&quot;, type.Name)\n           Console.WriteLine(&quot;   Public Class: {0}&quot;, type.IsPublic)\n           Console.WriteLine(&quot;   Not a Public Class: {0}&quot;, type.IsNotPublic)\n           Console.WriteLine(&quot;   Nested Class: {0}&quot;, type.IsNested)\n           Console.WriteLine(&quot;   Nested Private Class: {0}&quot;, type.IsNestedPrivate)\n           Console.WriteLine(&quot;   Nested Internal Class: {0}&quot;, type.IsNestedAssembly)\n           Console.WriteLine(&quot;   Nested Protected Class: {0}&quot;, type.IsNestedFamily)\n           Console.WriteLine(&quot;   Nested Family Or Assembly Class: {0}&quot;, type.IsNestedFamORAssem)\n           Console.WriteLine(&quot;   Nested Family And Assembly Class: {0}&quot;, type.IsNestedFamANDAssem)\n           Console.WriteLine(&quot;   Nested Public Class: {0}&quot;, type.IsNestedPublic)\n           Console.WriteLine()\n        Next\n    End Sub\nEnd Class\n&#39; The example displays the following output:\n&#39;    OuterClass property values:\n&#39;       Public Class: True\n&#39;       Not a Public Class: False\n&#39;       Nested Class: False\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    PublicClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: True\n&#39;\n&#39;    PrivateClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: True\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    ProtectedClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: True\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    InternalClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: True\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    ProtectedInternalClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: True\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.IsNestedFamAndAssem#1\">using System;\n\n// Create a class with a number of nested classes.\npublic class OuterClass\n{\n    private class PrivateClass\n    {}\n\n    protected class ProtectedClass\n    {}\n\n    internal class InternalClass\n    {}\n\n    protected internal class ProtectedInternalClass\n    {}\n\n    public class PublicClass\n    {}\n\n    public static void Main()\n    {\n        // Create an array of Type objects for all the classes.\n        Type[] types = { typeof(OuterClass),\n                         typeof(OuterClass.PublicClass),\n                         typeof(OuterClass.PrivateClass),\n                         typeof(OuterClass.ProtectedClass),\n                         typeof(OuterClass.InternalClass),\n                         typeof(OuterClass.ProtectedInternalClass) };\n        // Display the property values of each nested class.\n        foreach (var type in types) {\n           Console.WriteLine(&quot;<br>{0} property values:&quot;, type.Name);\n           Console.WriteLine(&quot;   Public Class: {0}&quot;, type.IsPublic);\n           Console.WriteLine(&quot;   Not a Public Class: {0}&quot;, type.IsNotPublic);\n           Console.WriteLine(&quot;   Nested Class: {0}&quot;, type.IsNested);\n           Console.WriteLine(&quot;   Nested Private Class: {0}&quot;, type.IsNestedPrivate);\n           Console.WriteLine(&quot;   Nested Internal Class: {0}&quot;, type.IsNestedAssembly);\n           Console.WriteLine(&quot;   Nested Protected Class: {0}&quot;, type.IsNestedFamily);\n           Console.WriteLine(&quot;   Nested Family Or Assembly Class: {0}&quot;, type.IsNestedFamORAssem);\n           Console.WriteLine(&quot;   Nested Family And Assembly Class: {0}&quot;, type.IsNestedFamANDAssem);\n           Console.WriteLine(&quot;   Nested Public Class: {0}&quot;, type.IsNestedPublic);\n        }\n    }\n}\n// The example displays the following output:\n//    OuterClass property values:\n//       Public Class: True\n//       Not a Public Class: False\n//       Nested Class: False\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    PublicClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: True\n//\n//    PrivateClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: True\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    ProtectedClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: True\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    InternalClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: True\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    ProtectedInternalClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: True\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsNestedPrivate\">\r\n    \r\n            <a id=\"System_Type_IsNestedPrivate_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsNestedPrivate</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is nested and declared private.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsNestedPrivate { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is nested and declared private; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter of a generic type, this property always returns <code>false</code>.  </p>\n<p> <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a> selects the visibility attributes.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an outer class with a number of nested classes that have various types of visibility. It then retrieves the value of a number of visibility-related <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> properties for the parent type and each of its nested types.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Type.IsNestedFamAndAssem#1\">&#39; Create a Class with a number of nested Classes.\nPublic Class OuterClass\n    Private Class PrivateClass\n    End Class\n\n    Protected Class ProtectedClass\n    End Class\n\n    Friend Class InternalClass\n    End Class\n\n    Protected Friend Class ProtectedInternalClass\n    End Class\n\n    Public Class PublicClass\n    End Class\n\n    Public Shared Sub Main()\n        &#39; Create an array of Type objects for all the Classes.\n        Dim types() As Type = { GetType(OuterClass),\n                                GetType(OuterClass.PublicClass),\n                                GetType(OuterClass.PrivateClass),\n                                GetType(OuterClass.ProtectedClass),\n                                GetType(OuterClass.InternalClass),\n                                GetType(OuterClass.ProtectedInternalClass) }\n        &#39; Display the property values of each nested Class.\n        For Each type In types\n           Console.WriteLine(&quot;{0} property values:&quot;, type.Name)\n           Console.WriteLine(&quot;   Public Class: {0}&quot;, type.IsPublic)\n           Console.WriteLine(&quot;   Not a Public Class: {0}&quot;, type.IsNotPublic)\n           Console.WriteLine(&quot;   Nested Class: {0}&quot;, type.IsNested)\n           Console.WriteLine(&quot;   Nested Private Class: {0}&quot;, type.IsNestedPrivate)\n           Console.WriteLine(&quot;   Nested Internal Class: {0}&quot;, type.IsNestedAssembly)\n           Console.WriteLine(&quot;   Nested Protected Class: {0}&quot;, type.IsNestedFamily)\n           Console.WriteLine(&quot;   Nested Family Or Assembly Class: {0}&quot;, type.IsNestedFamORAssem)\n           Console.WriteLine(&quot;   Nested Family And Assembly Class: {0}&quot;, type.IsNestedFamANDAssem)\n           Console.WriteLine(&quot;   Nested Public Class: {0}&quot;, type.IsNestedPublic)\n           Console.WriteLine()\n        Next\n    End Sub\nEnd Class\n&#39; The example displays the following output:\n&#39;    OuterClass property values:\n&#39;       Public Class: True\n&#39;       Not a Public Class: False\n&#39;       Nested Class: False\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    PublicClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: True\n&#39;\n&#39;    PrivateClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: True\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    ProtectedClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: True\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    InternalClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: True\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    ProtectedInternalClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: True\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.IsNestedFamAndAssem#1\">using System;\n\n// Create a class with a number of nested classes.\npublic class OuterClass\n{\n    private class PrivateClass\n    {}\n\n    protected class ProtectedClass\n    {}\n\n    internal class InternalClass\n    {}\n\n    protected internal class ProtectedInternalClass\n    {}\n\n    public class PublicClass\n    {}\n\n    public static void Main()\n    {\n        // Create an array of Type objects for all the classes.\n        Type[] types = { typeof(OuterClass),\n                         typeof(OuterClass.PublicClass),\n                         typeof(OuterClass.PrivateClass),\n                         typeof(OuterClass.ProtectedClass),\n                         typeof(OuterClass.InternalClass),\n                         typeof(OuterClass.ProtectedInternalClass) };\n        // Display the property values of each nested class.\n        foreach (var type in types) {\n           Console.WriteLine(&quot;<br>{0} property values:&quot;, type.Name);\n           Console.WriteLine(&quot;   Public Class: {0}&quot;, type.IsPublic);\n           Console.WriteLine(&quot;   Not a Public Class: {0}&quot;, type.IsNotPublic);\n           Console.WriteLine(&quot;   Nested Class: {0}&quot;, type.IsNested);\n           Console.WriteLine(&quot;   Nested Private Class: {0}&quot;, type.IsNestedPrivate);\n           Console.WriteLine(&quot;   Nested Internal Class: {0}&quot;, type.IsNestedAssembly);\n           Console.WriteLine(&quot;   Nested Protected Class: {0}&quot;, type.IsNestedFamily);\n           Console.WriteLine(&quot;   Nested Family Or Assembly Class: {0}&quot;, type.IsNestedFamORAssem);\n           Console.WriteLine(&quot;   Nested Family And Assembly Class: {0}&quot;, type.IsNestedFamANDAssem);\n           Console.WriteLine(&quot;   Nested Public Class: {0}&quot;, type.IsNestedPublic);\n        }\n    }\n}\n// The example displays the following output:\n//    OuterClass property values:\n//       Public Class: True\n//       Not a Public Class: False\n//       Nested Class: False\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    PublicClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: True\n//\n//    PrivateClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: True\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    ProtectedClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: True\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    InternalClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: True\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    ProtectedInternalClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: True\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsNestedPublic\">\r\n    \r\n            <a id=\"System_Type_IsNestedPublic_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsNestedPublic</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether a class is nested and declared public.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsNestedPublic { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the class is nested and declared public; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter of a generic type, this property always returns <code>false</code>.  </p>\n<p> <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a> selects the visibility attributes.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an outer class with a number of nested classes that have various types of visibility. It then retrieves the value of a number of visibility-related <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> properties for the parent type and each of its nested types.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Type.IsNestedFamAndAssem#1\">&#39; Create a Class with a number of nested Classes.\nPublic Class OuterClass\n    Private Class PrivateClass\n    End Class\n\n    Protected Class ProtectedClass\n    End Class\n\n    Friend Class InternalClass\n    End Class\n\n    Protected Friend Class ProtectedInternalClass\n    End Class\n\n    Public Class PublicClass\n    End Class\n\n    Public Shared Sub Main()\n        &#39; Create an array of Type objects for all the Classes.\n        Dim types() As Type = { GetType(OuterClass),\n                                GetType(OuterClass.PublicClass),\n                                GetType(OuterClass.PrivateClass),\n                                GetType(OuterClass.ProtectedClass),\n                                GetType(OuterClass.InternalClass),\n                                GetType(OuterClass.ProtectedInternalClass) }\n        &#39; Display the property values of each nested Class.\n        For Each type In types\n           Console.WriteLine(&quot;{0} property values:&quot;, type.Name)\n           Console.WriteLine(&quot;   Public Class: {0}&quot;, type.IsPublic)\n           Console.WriteLine(&quot;   Not a Public Class: {0}&quot;, type.IsNotPublic)\n           Console.WriteLine(&quot;   Nested Class: {0}&quot;, type.IsNested)\n           Console.WriteLine(&quot;   Nested Private Class: {0}&quot;, type.IsNestedPrivate)\n           Console.WriteLine(&quot;   Nested Internal Class: {0}&quot;, type.IsNestedAssembly)\n           Console.WriteLine(&quot;   Nested Protected Class: {0}&quot;, type.IsNestedFamily)\n           Console.WriteLine(&quot;   Nested Family Or Assembly Class: {0}&quot;, type.IsNestedFamORAssem)\n           Console.WriteLine(&quot;   Nested Family And Assembly Class: {0}&quot;, type.IsNestedFamANDAssem)\n           Console.WriteLine(&quot;   Nested Public Class: {0}&quot;, type.IsNestedPublic)\n           Console.WriteLine()\n        Next\n    End Sub\nEnd Class\n&#39; The example displays the following output:\n&#39;    OuterClass property values:\n&#39;       Public Class: True\n&#39;       Not a Public Class: False\n&#39;       Nested Class: False\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    PublicClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: True\n&#39;\n&#39;    PrivateClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: True\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    ProtectedClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: True\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    InternalClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: True\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: False\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n&#39;\n&#39;    ProtectedInternalClass property values:\n&#39;       Public Class: False\n&#39;       Not a Public Class: False\n&#39;       Nested Class: True\n&#39;       Nested Private Class: False\n&#39;       Nested Internal Class: False\n&#39;       Nested Protected Class: False\n&#39;       Nested Family Or Assembly Class: True\n&#39;       Nested Family And Assembly Class: False\n&#39;       Nested Public Class: False\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.IsNestedFamAndAssem#1\">using System;\n\n// Create a class with a number of nested classes.\npublic class OuterClass\n{\n    private class PrivateClass\n    {}\n\n    protected class ProtectedClass\n    {}\n\n    internal class InternalClass\n    {}\n\n    protected internal class ProtectedInternalClass\n    {}\n\n    public class PublicClass\n    {}\n\n    public static void Main()\n    {\n        // Create an array of Type objects for all the classes.\n        Type[] types = { typeof(OuterClass),\n                         typeof(OuterClass.PublicClass),\n                         typeof(OuterClass.PrivateClass),\n                         typeof(OuterClass.ProtectedClass),\n                         typeof(OuterClass.InternalClass),\n                         typeof(OuterClass.ProtectedInternalClass) };\n        // Display the property values of each nested class.\n        foreach (var type in types) {\n           Console.WriteLine(&quot;<br>{0} property values:&quot;, type.Name);\n           Console.WriteLine(&quot;   Public Class: {0}&quot;, type.IsPublic);\n           Console.WriteLine(&quot;   Not a Public Class: {0}&quot;, type.IsNotPublic);\n           Console.WriteLine(&quot;   Nested Class: {0}&quot;, type.IsNested);\n           Console.WriteLine(&quot;   Nested Private Class: {0}&quot;, type.IsNestedPrivate);\n           Console.WriteLine(&quot;   Nested Internal Class: {0}&quot;, type.IsNestedAssembly);\n           Console.WriteLine(&quot;   Nested Protected Class: {0}&quot;, type.IsNestedFamily);\n           Console.WriteLine(&quot;   Nested Family Or Assembly Class: {0}&quot;, type.IsNestedFamORAssem);\n           Console.WriteLine(&quot;   Nested Family And Assembly Class: {0}&quot;, type.IsNestedFamANDAssem);\n           Console.WriteLine(&quot;   Nested Public Class: {0}&quot;, type.IsNestedPublic);\n        }\n    }\n}\n// The example displays the following output:\n//    OuterClass property values:\n//       Public Class: True\n//       Not a Public Class: False\n//       Nested Class: False\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    PublicClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: True\n//\n//    PrivateClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: True\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    ProtectedClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: True\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    InternalClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: True\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: False\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n//\n//    ProtectedInternalClass property values:\n//       Public Class: False\n//       Not a Public Class: False\n//       Nested Class: True\n//       Nested Private Class: False\n//       Nested Internal Class: False\n//       Nested Protected Class: False\n//       Nested Family Or Assembly Class: True\n//       Nested Family And Assembly Class: False\n//       Nested Public Class: False\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsNotPublic\">\r\n    \r\n            <a id=\"System_Type_IsNotPublic_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsNotPublic</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is not declared public.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsNotPublic { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is not declared public and is not a nested type; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Do not use this property with nested types; use the <a class=\"xref\" href=\"system.type#System_Type_IsNestedPublic_\" data-linktype=\"relative-path\">IsNestedPublic</a> property instead.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter of a generic type, this property returns <code>false</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>This example usesthe <code>IsNotPublic</code> property to get the visibility of the type.  </p>\n<pre><code class=\"lang-cpp\" name=\"Classic Type.IsNotPublic Example#1\">using namespace System;\nusing namespace System::IO;\nusing namespace System::Reflection;\n\nint main()\n{\n   //Get the Type and MemberInfo.\n   Type^ t = Type::GetType(&quot;System.IO.File&quot;);\n   array&lt;MemberInfo^&gt;^ members = t-&gt;GetMembers();\n   \n   //Get and display the DeclaringType method.\n   Console::WriteLine(&quot;There are {0} members in {1}.&quot;,\n                      members-&gt;Length, t-&gt;FullName );\n   Console::WriteLine(&quot;Is {0} non-public? {1}&quot;,\n                      t-&gt;FullName, t-&gt;IsNotPublic );\n}\n// The example displays the following output:\n//       There are 60 members in System.IO.File.\n//       Is System.IO.File non-public? False\n</code></pre><pre><code class=\"lang-vb\" name=\"Classic Type.IsNotPublic Example#1\">Imports System.IO\nImports System.Reflection\n\nModule Example\n    Public Sub Main()\n        &#39;Get the Type and MemberInfo.\n        Dim t As Type = Type.GetType(&quot;System.IO.File&quot;)\n        Dim members As MemberInfo() = t.GetMembers()\n        &#39;Get and display the DeclaringType method.\n        Console.WriteLine(&quot;There are {0} members in {1}.&quot;,\n                          members.Length, t.FullName)\n        Console.WriteLine(&quot;Is {0} non-public? {1}&quot;,\n                          t.FullName, t.IsNotPublic)\n    End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;       There are 60 members in System.IO.File.\n&#39;       Is System.IO.File non-public? False\n</code></pre><pre><code class=\"lang-cs\" name=\"Classic Type.IsNotPublic Example#1\">using System;\nusing System.IO;\nusing System.Reflection;\n\nclass Example\n{ \n    public static void Main()\n    { \n        // Get the Type and MemberInfo.\n        Type t = Type.GetType(&quot;System.IO.File&quot;);\n        MemberInfo[] members = t.GetMembers();\n        // Get and display the DeclaringType method.\n        Console.WriteLine(&quot;<br>There are {0} members in {1}.&quot;,\n                          members.Length, t.FullName);\n        Console.WriteLine(&quot;Is {0} non-public? {1}&quot;,\n                          t.FullName, t.IsNotPublic);\n    }\n}\n// The example displays output like the following:\n//       There are 60 members in System.IO.File.\n//       Is System.IO.File non-public? False\n</code></pre><p> The following code example demonstrates why you cannot use <code>IsPublic</code> and <code>IsNotPublic</code> for nested classes.  </p>\n<pre><code class=\"lang-cpp\" name=\"Classic Type.IsNotPublic Example#2\">public ref class A\n{\npublic:\n   ref class B{};\n\n\nprivate:\n   ref class C{};\n\n\n};\n</code></pre><pre><code class=\"lang-vb\" name=\"Classic Type.IsNotPublic Example#2\">Public Class A\n    Public Class B\n    End Class\n    Private Class C\n    End Class\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"Classic Type.IsNotPublic Example#2\">public class A \n{\n    public class B { }\n    private class C { }\n}\n</code></pre><p> For nested classes, ignore the results of <code>IsPublic</code> and <code>IsNotPublic</code> and pay attention only to the results of <code>IsNestedPublic</code> and <code>IsNestedPrivate</code>. The reflection output for this code fragment would be as follows:  </p>\n<table>\n<thead>\n<tr>\n<th>Class</th>\n<th>IsNotPublic</th>\n<th>IsPublic</th>\n<th>IsNestedPublic</th>\n<th>IsNestedPrivate</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A</td>\n<td>FALSE</td>\n<td>TRUE</td>\n<td>FALSE</td>\n<td>FALSE</td>\n</tr>\n<tr>\n<td>B</td>\n<td>FALSE</td>\n<td>FALSE</td>\n<td>TRUE</td>\n<td>FALSE</td>\n</tr>\n<tr>\n<td>C</td>\n<td>FALSE</td>\n<td>FALSE</td>\n<td>FALSE</td>\n<td>TRUE</td>\n</tr>\n</tbody>\n</table>\n\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsPointer\">\r\n    \r\n            <a id=\"System_Type_IsPointer_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsPointer</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is a pointer.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsPointer { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is a pointer; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <code>false</code>.  </p>\n<p> This property is read-only.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example shows a use of the <code>IsPointer</code> property.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_HasElementTypeImpl#1\">using namespace System;\nusing namespace System::Reflection;\npublic ref class MyTypeDelegator: public TypeDelegator\n{\npublic:\n   String^ myElementType;\n\nprivate:\n   Type^ myType;\n\npublic:\n   MyTypeDelegator( Type^ myType )\n      : TypeDelegator( myType )\n   {\n      this-&gt;myType = myType;\n   }\n\n\nprotected:\n\n   // Override Type::HasElementTypeImpl().\n   virtual bool HasElementTypeImpl() override\n   {\n      \n      // Determine whether the type is an array.\n      if ( myType-&gt;IsArray )\n      {\n         myElementType = &quot;array&quot;;\n         return true;\n      }\n\n      \n      // Determine whether the type is a reference.\n      if ( myType-&gt;IsByRef )\n      {\n         myElementType = &quot;reference&quot;;\n         return true;\n      }\n\n      \n      // Determine whether the type is a pointer.\n      if ( myType-&gt;IsPointer )\n      {\n         myElementType = &quot;pointer&quot;;\n         return true;\n      }\n\n      \n      // Return false if the type is not a reference, array, or pointer type.\n      return false;\n   }\n\n};\n\nint main()\n{\n   try\n   {\n      int myInt = 0;\n      array&lt;Int32&gt;^myArray = gcnew array&lt;Int32&gt;(5);\n      MyTypeDelegator^ myType = gcnew MyTypeDelegator( myArray-&gt;GetType() );\n      \n      // Determine whether myType is an array, pointer, reference type.\n      Console::WriteLine( &quot;<br>Determine whether a variable is an array, pointer, or reference type.<br>&quot; );\n      if ( myType-&gt;HasElementType )\n            Console::WriteLine( &quot;The type of myArray is {0}.&quot;, myType-&gt;myElementType );\n      else\n            Console::WriteLine( &quot;myArray is not an array, pointer, or reference type.&quot; );\n      myType = gcnew MyTypeDelegator( myInt.GetType() );\n      \n      // Determine whether myType is an array, pointer, reference type.\n      if ( myType-&gt;HasElementType )\n            Console::WriteLine( &quot;The type of myInt is {0}.&quot;, myType-&gt;myElementType );\n      else\n            Console::WriteLine( &quot;myInt is not an array, pointer, or reference type.&quot; );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception: {0}&quot;, e-&gt;Message );\n   }\n\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_HasElementTypeImpl#1\">using System;\nusing System.Reflection;\npublic class MyTypeDelegator : TypeDelegator\n{\n    public string myElementType = null;\n    private Type myType = null ; \n    public MyTypeDelegator(Type myType) : base(myType)\n    {\n        this.myType = myType;\n    }\n    // Override Type.HasElementTypeImpl().\n    protected override bool HasElementTypeImpl()\n    {\n        // Determine whether the type is an array.\n        if(myType.IsArray)\n        {\n            myElementType = &quot;array&quot;;\n            return true;\n        }\n        // Determine whether the type is a reference.\n        if(myType.IsByRef)\n        {\n            myElementType = &quot;reference&quot;;\n            return true;\n        }\n        // Determine whether the type is a pointer.\n        if(myType.IsPointer)\n        { \n            myElementType = &quot;pointer&quot;;\n            return true;\n        }\n        // Return false if the type is not a reference, array, or pointer type.\n        return false;\n    }  \n}\npublic class Type_HasElementTypeImpl\n{\n    public static void Main()\n    {\n        try\n        {\n            int myInt = 0 ; \n            int[] myArray = new int[5];\n            MyTypeDelegator myType = new MyTypeDelegator(myArray.GetType());\n            // Determine whether myType is an array, pointer, reference type.  \n            Console.WriteLine(&quot;<br>Determine whether a variable is an array, pointer, or reference type.<br>&quot;);\n            if( myType.HasElementType)\n                Console.WriteLine(&quot;The type of myArray is {0}.&quot;, myType.myElementType);\n            else\n                Console.WriteLine(&quot;myArray is not an array, pointer, or reference type.&quot;);\n            myType = new MyTypeDelegator(myInt.GetType());\n            // Determine whether myType is an array, pointer, reference type. \n            if( myType.HasElementType)\n                Console.WriteLine(&quot;The type of myInt is {0}.&quot;, myType.myElementType);\n            else\n                Console.WriteLine(&quot;myInt is not an array, pointer, or reference type.&quot;);\n        }\n        catch( Exception e )\n        {\n            Console.WriteLine(&quot;Exception: {0}&quot;, e.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_HasElementTypeImpl#1\">Imports System\nImports System.Reflection\nImports Microsoft.VisualBasic\nPublic Class MyTypeDelegator\n    Inherits TypeDelegator\n    Public myElementType As String = Nothing\n    Private myType As Type = Nothing\n    Public Sub New(ByVal myType As Type)\n        MyBase.New(myType)\n        Me.myType = myType\n    End Sub &#39;New\n    &#39; Override Type.HasElementTypeImpl().\n    Protected Overrides Function HasElementTypeImpl() As Boolean\n        &#39; Determine whether the type is an array.\n        If myType.IsArray Then\n            myElementType = &quot;array&quot;\n            Return True\n        End If\n        &#39; Determine whether the type is a reference.\n        If myType.IsByRef Then\n            myElementType = &quot;reference&quot;\n            Return True\n        End If\n        &#39; Determine whether the type is a pointer.\n        If myType.IsPointer Then\n            myElementType = &quot;pointer&quot;\n            Return True\n        End If\n        &#39; The type is not a reference, array, or pointer type.\n        Return False\n    End Function &#39;HasElementTypeImpl\nEnd Class &#39;MyTypeDelegator\nPublic Class Type_HasElementTypeImpl\n    Public Shared Sub Main()\n        Try\n            Dim myInt As Integer = 0\n            Dim myArray(4) As Integer\n            Dim myType As New MyTypeDelegator(myArray.GetType())\n            Console.WriteLine(ControlChars.NewLine + &quot;Determine whether a variable refers to an array or pointer or reference type.&quot; + ControlChars.NewLine)\n            &#39; Determine whether myType is an array, pointer, reference type.  \n            If myType.HasElementType Then\n                Console.WriteLine(&quot;The type of myArray is {0}.&quot;, myType.myElementType.ToString())\n            Else\n                Console.WriteLine(&quot;myArray is not an array, pointer, or reference type.&quot;)\n            End If\n            myType = New MyTypeDelegator(myInt.GetType())\n            &#39; Determine whether myType is an array, pointer, reference type. \n            If myType.HasElementType Then\n                Console.WriteLine(&quot;The type of myInt is {0}.&quot;, myType.myElementType.ToString())\n            Else\n                Console.WriteLine(&quot;myInt is not an array, pointer, or reference type.&quot;)\n            End If\n        Catch e As Exception\n            Console.WriteLine(&quot;Exception: {0}&quot;, e.Message.ToString())\n        End Try\n    End Sub &#39;Main\nEnd Class &#39;Type_HasElementTypeImpl\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsPrimitive\">\r\n    \r\n            <a id=\"System_Type_IsPrimitive_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsPrimitive</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is one of the primitive types.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsPrimitive { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is one of the primitive types; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The primitive types are <a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a>, <a class=\"xref\" href=\"system.byte\" data-linktype=\"relative-path\">Byte</a>, <a class=\"xref\" href=\"system.sbyte\" data-linktype=\"relative-path\">SByte</a>, <a class=\"xref\" href=\"system.int16\" data-linktype=\"relative-path\">Int16</a>, <a class=\"xref\" href=\"system.uint16\" data-linktype=\"relative-path\">UInt16</a>, <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a>, <a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a>, <a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a>, <a class=\"xref\" href=\"system.uint64\" data-linktype=\"relative-path\">UInt64</a>, <a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a>, <a class=\"xref\" href=\"system.uintptr\" data-linktype=\"relative-path\">UIntPtr</a>, <a class=\"xref\" href=\"system.char\" data-linktype=\"relative-path\">Char</a>, <a class=\"xref\" href=\"system.double\" data-linktype=\"relative-path\">Double</a>, and <a class=\"xref\" href=\"system.single\" data-linktype=\"relative-path\">Single</a>.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <code>false</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example demonstrates the <code>IsContextful</code>, <a class=\"xref\" href=\"system.type#System_Type_IsMarshalByRef_\" data-linktype=\"relative-path\">IsMarshalByRef</a>, and IsPrimitive properties of the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> class. It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_IsContextful#1\">using System;\nusing System.Runtime.Remoting.Contexts;\n\npublic class ContextBoundClass: ContextBoundObject\n{\n    public string Value = &quot;The Value property.&quot;;\n}\n\npublic class Example\n{\n    public static void Main()\n    {\n         // Determine whether the types can be hosted in a Context.\n         Console.WriteLine(&quot;The IsContextful property for the {0} type is {1}.&quot;,\n                           typeof(Example).Name, typeof(Example).IsContextful);\n         Console.WriteLine(&quot;The IsContextful property for the {0} type is {1}.&quot;,\n                           typeof(ContextBoundClass).Name, typeof(ContextBoundClass).IsContextful);\n\n         // Determine whether the types are marshalled by reference.\n         Console.WriteLine(&quot;The IsMarshalByRef property of {0} is {1}.&quot;,\n                           typeof(Example).Name, typeof(Example).IsMarshalByRef);\n         Console.WriteLine(&quot;The IsMarshalByRef property of {0} is {1}.&quot;,\n                           typeof(ContextBoundClass).Name, typeof(ContextBoundClass).IsMarshalByRef);\n         \n         // Determine whether the types are primitive datatypes.\n         Console.WriteLine(&quot;{0} is a primitive data type: {1}.&quot;,\n                           typeof(int).Name, typeof(int).IsPrimitive);\n         Console.WriteLine(&quot;{0} is a primitive data type: {1}.&quot;,\n                           typeof(string).Name, typeof(string).IsPrimitive);\n    }\n}\n// The example displays the following output:\n//    The IsContextful property for the Example type is False.\n//    The IsContextful property for the ContextBoundClass type is True.\n//    The IsMarshalByRef property of Example is False.\n//    The IsMarshalByRef property of ContextBoundClass is True.\n//    Int32 is a primitive data type: True.\n//    String is a primitive data type: False.\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_IsContextful#1\">using namespace System;\nusing namespace System::Runtime::Remoting::Contexts;\n\npublic ref class ContextBoundClass: public ContextBoundObject\n{\n   public:\n      String^ Value;\n};\n\npublic ref class Example\n{\npublic:\n   void Demo()\n   {\n      // Determine whether the types can be hosted in a Context.\n      Console::WriteLine(&quot;The IsContextful property for the {0} type is {1}.&quot;,\n                         Example::typeid-&gt;Name, Example::typeid-&gt;IsContextful);\n      Console::WriteLine(&quot;The IsContextful property for the {0} type is {1}.&quot;,\n                         ContextBoundClass::typeid-&gt;Name, ContextBoundClass::typeid-&gt;IsContextful);\n      \n      // Determine whether the types are marshalled by reference.\n      Console::WriteLine(&quot;The IsMarshalByRef property of {0} is {1}.&quot;,\n                         Example::typeid-&gt;Name, Example::typeid-&gt;IsMarshalByRef );\n      Console::WriteLine(&quot;The IsMarshalByRef property of {0} is {1}.&quot;,\n                         ContextBoundClass::typeid-&gt;Name, ContextBoundClass::typeid-&gt;IsMarshalByRef );\n      \n      // Determine whether the types are primitive datatypes.\n      Console::WriteLine(&quot;{0} is a primitive data type: {1}.&quot;,\n                         int::typeid-&gt;Name, int::typeid-&gt;IsPrimitive );\n      Console::WriteLine(&quot;{0} is a primitive data type: {1}.&quot;,\n                         String::typeid-&gt;Name, String::typeid-&gt;IsPrimitive );\n   }\n};\n\nint main()\n{\n   Example^ ex = gcnew Example;\n   ex-&gt;Demo();\n}\n// The example displays the following output:\n//    The IsContextful property for the Example type is False.\n//    The IsContextful property for the ContextBoundClass type is True.\n//    The IsMarshalByRef property of Example is False.\n//    The IsMarshalByRef property of ContextBoundClass is True.\n//    Int32 is a primitive data type: True.\n//    String is a primitive data type: False.\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_IsContextful#1\">Imports System.Runtime.Remoting.Contexts\n\nPublic Class ContextBoundClass : Inherits ContextBoundObject\n    Public Value As String = &quot;The Value property.&quot;\nEnd Class\n\nPublic Class Example\n    Public Shared Sub Main()\n         &#39; Determine whether the types can be hosted in a Context.\n         Console.WriteLine(&quot;The IsContextful property for the {0} type is {1}.&quot;,\n                           GetType(Example).Name, GetType(Example).IsContextful)\n         Console.WriteLine(&quot;The IsContextful property for the {0} type is {1}.&quot;,\n                           GetType(ContextBoundClass).Name, GetType(ContextBoundClass).IsContextful)\n         &#39; Determine whether the types are marshalled by reference.\n         Console.WriteLine(&quot;The IsMarshalByRef property of {0} is {1}.&quot;,\n                           GetType(Example).Name, GetType(Example).IsMarshalByRef)\n         Console.WriteLine(&quot;The IsMarshalByRef property of {0} is {1}.&quot;,\n                           GetType(ContextBoundClass).Name, GetType(ContextBoundClass).IsMarshalByRef)\n         &#39; Determine whether the types are primitive datatypes.\n         Console.WriteLine(&quot;{0} is a primitive data type: {1}.&quot;,\n                           GetType(Integer).Name, GetType(Integer).IsPrimitive)\n         Console.WriteLine(&quot;{0} is a primitive data type: {1}.&quot;,\n                           GetType(String).Name, GetType(String).IsPrimitive)\n    End Sub\nEnd Class\n&#39; The example displays the following output:\n&#39;    The IsContextful property for the Example type is False.\n&#39;    The IsContextful property for the ContextBoundClass type is True.\n&#39;    The IsMarshalByRef property of Example is False.\n&#39;    The IsMarshalByRef property of ContextBoundClass is True.\n&#39;    Int32 is a primitive data type: True.\n&#39;    String is a primitive data type: False.\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsPublic\">\r\n    \r\n            <a id=\"System_Type_IsPublic_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsPublic</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is declared public.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsPublic { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is declared public and is not a nested type; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Do not use with nested types; use <a class=\"xref\" href=\"system.type#System_Type_IsNestedPublic_\" data-linktype=\"relative-path\">IsNestedPublic</a> instead.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter of a generic type, this property returns <code>true</code>.  </p>\n<p> <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">System.Reflection.TypeAttributes</a> selects the visibility attributes.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an instance of <code>MyTestClass</code>, checks for the <code>IsPublic</code> property, and displays the result.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type.IsPublic#1\">using namespace System;\n\n// Declare MyTestClass as public.\npublic ref class TestClass{};\n\nint main()\n{\n   TestClass^ testClassInstance = gcnew TestClass;\n   \n   // Get the type of myTestClassInstance.\n   Type^ testType = testClassInstance-&gt;GetType();\n   \n   // Get the IsPublic property of the myTestClassInstance.\n   bool isPublic = testType-&gt;IsPublic;\n   Console::WriteLine( &quot;Is {0} public? {1}&quot;, testType-&gt;FullName, isPublic);\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Type.IsPublic#1\">using System;\n\npublic class TestClass\n{\n}\n\npublic class Example\n{\n   public static void Main()\n   {\n      TestClass testClassInstance = new TestClass();\n      // Get the type of myTestClassInstance.\n      Type   testType = testClassInstance.GetType();\n      // Get the IsPublic property of testClassInstance.\n      bool isPublic = testType.IsPublic;\n      Console.WriteLine(&quot;Is {0} public? {1}&quot;, testType.FullName, isPublic);\n   }\n}\n// The example displays the following output:\n//        Is TestClass public? True\n</code></pre><pre><code class=\"lang-vb\" name=\"Type.IsPublic#1\">Public Class TestClass\nEnd Class\n\nPublic Class Example\n   Public Shared Sub Main()\n      Dim testClassInstance As New TestClass()\n      \n      &#39; Get the type of testClassInstance.\n      Dim testType As Type = testClassInstance.GetType()\n      &#39; Get the IsPublic property of testClassInstance.\n      Dim isPublic As Boolean = testType.IsPublic\n      Console.WriteLine(&quot;Is {0} public? {1}&quot;, testType.FullName, isPublic)\n   End Sub \nEnd Class \n&#39; The example displays the following output:\n&#39;       Is TestClass public? True\n</code></pre><p> For nested classes, ignore the results of <code>IsPublic</code> and <code>IsNotPublic</code> and pay attention only to the results of <a class=\"xref\" href=\"system.type#System_Type_IsNestedPublic_\" data-linktype=\"relative-path\">IsNestedPublic</a> and <a class=\"xref\" href=\"system.type#System_Type_IsNestedPrivate_\" data-linktype=\"relative-path\">IsNestedPrivate</a>.</p>\n\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsSealed\">\r\n    \r\n            <a id=\"System_Type_IsSealed_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsSealed</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is declared sealed.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsSealed { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is declared sealed; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter of a generic type, this property always returns <code>true</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an instance of a <code>sealed</code> class, checks for the <code>IsSealed</code> property, and displays the result.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_IsSealed#1\">using namespace System;\n\n// Declare MyTestClass as sealed.\nref class TestClass sealed{};\n\nint main()\n{\n      TestClass^ testClassInstance = gcnew TestClass;\n      \n      // Get the type of testClassInstance.\n      Type^ type = testClassInstance-&gt;GetType();\n      \n      // Get the IsSealed property of the myTestClassInstance.\n      bool sealed = type-&gt;IsSealed;\n      Console::WriteLine(&quot;{0} is sealed: {1}.&quot;, type-&gt;FullName, sealed);\n}\n// The example displays the following output:\n//        TestClass is sealed: True.\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_IsSealed#1\">using System;\n\n public class Example\n {\n     // Declare InnerClass as sealed.\n     sealed public class InnerClass\n     {\n     }\n\n     public static void Main()\n     {\n          InnerClass inner = new InnerClass();\n          // Get the type of InnerClass.\n          Type innerType = inner.GetType();\n          // Get the IsSealed property of  innerClass.\n          bool isSealed = innerType.IsSealed;\n          Console.WriteLine(&quot;{0} is sealed: {1}.&quot;, innerType.FullName, isSealed);\n     }\n}\n// The example displays the following output:\n//        Example+InnerClass is sealed: True.\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_IsSealed#1\">Public Class Example\n    &#39; Declare InnerClass as sealed.\n    Public NotInheritable Class InnerClass\n    End Class\n    \n    Public Shared Sub Main()\n         Dim inner As New InnerClass()\n         &#39; Get the type of InnerClass.\n         Dim innerType As Type = inner.GetType()\n         &#39; Get the IsSealed property of InnerClass.\n         Dim sealed As Boolean = innerType.IsSealed\n         Console.WriteLine(&quot;{0} is sealed: {1}.&quot;, innerType.FullName, sealed)\n    End Sub\nEnd Class\n&#39; The example displays the following output:\n&#39;       Example+InnerClass is sealed: True.\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsSecurityCritical\">\r\n    \r\n            <a id=\"System_Type_IsSecurityCritical_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsSecurityCritical</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool IsSecurityCritical { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the current type is security-critical or security-safe-critical at the current trust level; <code>false</code> if it is transparent.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The IsSecurityCritical, <a class=\"xref\" href=\"system.type#System_Type_IsSecuritySafeCritical_\" data-linktype=\"relative-path\">IsSecuritySafeCritical</a>, and <a class=\"xref\" href=\"system.type#System_Type_IsSecurityTransparent_\" data-linktype=\"relative-path\">IsSecurityTransparent</a> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR). The combinations of these properties are shown in the following table:  </p>\n<table>\n<thead>\n<tr>\n<th>Security level</th>\n<th>IsSecurityCritical</th>\n<th>IsSecuritySafeCritical</th>\n<th>IsSecurityTransparent</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Critical</td>\n<td><code>true</code></td>\n<td><code>false</code></td>\n<td><code>false</code></td>\n</tr>\n<tr>\n<td>Safe critical</td>\n<td><code>true</code></td>\n<td><code>true</code></td>\n<td><code>false</code></td>\n</tr>\n<tr>\n<td>Transparent</td>\n<td><code>false</code></td>\n<td><code>false</code></td>\n<td><code>true</code></td>\n</tr>\n</tbody>\n</table>\n<p> Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime&#39;s rules.  </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_IsFullyTrusted_\" data-linktype=\"relative-path\">IsFullyTrusted</a> and <a class=\"xref\" href=\"system.appdomain#System_AppDomain_IsFullyTrusted_\" data-linktype=\"relative-path\">IsFullyTrusted</a> properties.  </p>\n</div>\n<p> For more information about reflection and transparency, see <a href=\"../Topic/Security%20Considerations%20for%20Reflection.md\" data-linktype=\"relative-path\">Security Considerations for Reflection</a>. For information about transparency, see <a href=\"../Topic/Security%20Changes%20in%20the%20.NET%20Framework.md\" data-linktype=\"relative-path\">Security Changes</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsSecuritySafeCritical\">\r\n    \r\n            <a id=\"System_Type_IsSecuritySafeCritical_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsSecuritySafeCritical</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool IsSecuritySafeCritical { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the current type is security-safe-critical at the current trust level; <code>false</code> if it is security-critical or transparent.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <a class=\"xref\" href=\"system.type#System_Type_IsSecurityCritical_\" data-linktype=\"relative-path\">IsSecurityCritical</a>, IsSecuritySafeCritical, and <a class=\"xref\" href=\"system.type#System_Type_IsSecurityTransparent_\" data-linktype=\"relative-path\">IsSecurityTransparent</a> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR). The combinations of these properties are shown in the following table:  </p>\n<table>\n<thead>\n<tr>\n<th>Security level</th>\n<th>IsSecurityCritical</th>\n<th>IsSecuritySafeCritical</th>\n<th>IsSecurityTransparent</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Critical</td>\n<td><code>true</code></td>\n<td><code>false</code></td>\n<td><code>false</code></td>\n</tr>\n<tr>\n<td>Safe critical</td>\n<td><code>true</code></td>\n<td><code>true</code></td>\n<td><code>false</code></td>\n</tr>\n<tr>\n<td>Transparent</td>\n<td><code>false</code></td>\n<td><code>false</code></td>\n<td><code>true</code></td>\n</tr>\n</tbody>\n</table>\n<p> Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime&#39;s rules.  </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_IsFullyTrusted_\" data-linktype=\"relative-path\">IsFullyTrusted</a> and <a class=\"xref\" href=\"system.appdomain#System_AppDomain_IsFullyTrusted_\" data-linktype=\"relative-path\">IsFullyTrusted</a> properties.  </p>\n</div>\n<p> For more information about reflection and transparency, see <a href=\"../Topic/Security%20Considerations%20for%20Reflection.md\" data-linktype=\"relative-path\">Security Considerations for Reflection</a>. For information about transparency, see <a href=\"../Topic/Security%20Changes%20in%20the%20.NET%20Framework.md\" data-linktype=\"relative-path\">Security Changes</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsSecurityTransparent\">\r\n    \r\n            <a id=\"System_Type_IsSecurityTransparent_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsSecurityTransparent</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool IsSecurityTransparent { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the type is security-transparent at the current trust level; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If this property returns <code>true</code>, the <a class=\"xref\" href=\"system.type#System_Type_IsSecurityCritical_\" data-linktype=\"relative-path\">IsSecurityCritical</a> and <a class=\"xref\" href=\"system.type#System_Type_IsSecuritySafeCritical_\" data-linktype=\"relative-path\">IsSecuritySafeCritical</a> properties return <code>false</code>.  </p>\n<p> The <a class=\"xref\" href=\"system.type#System_Type_IsSecurityCritical_\" data-linktype=\"relative-path\">IsSecurityCritical</a>, <a class=\"xref\" href=\"system.type#System_Type_IsSecuritySafeCritical_\" data-linktype=\"relative-path\">IsSecuritySafeCritical</a>, and IsSecurityTransparent properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR). Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime&#39;s rules.  </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_IsFullyTrusted_\" data-linktype=\"relative-path\">IsFullyTrusted</a> and <a class=\"xref\" href=\"system.appdomain#System_AppDomain_IsFullyTrusted_\" data-linktype=\"relative-path\">IsFullyTrusted</a> properties.  </p>\n</div>\n<p> For more information about reflection and transparency, see <a href=\"../Topic/Security%20Considerations%20for%20Reflection.md\" data-linktype=\"relative-path\">Security Considerations for Reflection</a>. For information about transparency, see <a href=\"../Topic/Security%20Changes%20in%20the%20.NET%20Framework.md\" data-linktype=\"relative-path\">Security Changes</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsSerializable\">\r\n    \r\n            <a id=\"System_Type_IsSerializable_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsSerializable</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is serializable.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool IsSerializable { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is serializable; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents <code>MyGenericType&lt;int&gt;</code> (<code>MyGenericType(Of Integer)</code> in Visual Basic), the value of this property is determined by <code>MyGenericType&lt;T&gt;</code>.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this property always returns <code>false</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an instance of <code>MyTestClass</code> class, sets the [Serializable] attribute, and checks the <code>IsSerializable</code> property for <code>true</code> or <code>false</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_IsSerializable#1\">using System;\nnamespace SystemType\n{\n    public class MyClass\n    {\n        // Declare a public class with the [Serializable] attribute.\n        [Serializable] public class MyTestClass \n        {\n        }\n        public static void Main(string []args)\n        {\n            try\n            {\n                bool myBool = false;\n                MyTestClass myTestClassInstance = new MyTestClass();\n                // Get the type of myTestClassInstance.\n                Type myType = myTestClassInstance.GetType();\n                // Get the IsSerializable property of myTestClassInstance.\n                myBool = myType.IsSerializable;\n                Console.WriteLine(&quot;<br>Is {0} serializable? {1}.&quot;, myType.FullName, myBool.ToString());\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(&quot;<br>An exception occurred: {0}&quot;, e.Message);\n            }\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_IsSerializable#1\">Imports System\nImports Microsoft.VisualBasic\nNamespace SystemType\n    Public Class [MyClass]\n        &#39; Declare a public class with the [Serializable] attribute.\n        &lt;Serializable()&gt; Public Class MyTestClass\n        End Class &#39;MyTestClass\n        Public Overloads Shared Sub Main()\n            Try\n                Dim myBool As Boolean = False\n                Dim myTestClassInstance As New MyTestClass()\n                &#39; Get the type of myTestClassInstance.\n                Dim myType As Type = myTestClassInstance.GetType()\n                &#39; Get the IsSerializable property of myTestClassInstance.\n                myBool = myType.IsSerializable\n                Console.WriteLine(ControlChars.Cr + &quot;Is {0} serializable? {1}.&quot;, myType.FullName, myBool.ToString())\n            Catch e As Exception\n                Console.WriteLine(ControlChars.Cr + &quot;An exception occurred: {0}&quot;, e.Message.ToString())\n            End Try\n        End Sub &#39;Main\n    End Class &#39;[MyClass]\nEnd Namespace &#39;SystemType\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_IsSerializable#1\">using namespace System;\npublic ref class MyClass\n{\npublic:\n\n   // Declare a public class with the [Serializable] attribute.\n\n   [Serializable]\n   ref class MyTestClass{};\n\n\n};\n\nint main()\n{\n   try\n   {\n      bool myBool = false;\n      MyClass::MyTestClass^ myTestClassInstance = gcnew MyClass::MyTestClass;\n      \n      // Get the type of myTestClassInstance.\n      Type^ myType = myTestClassInstance-&gt;GetType();\n      \n      // Get the IsSerializable property of myTestClassInstance.\n      myBool = myType-&gt;IsSerializable;\n      Console::WriteLine( &quot;<br>Is {0} serializable? {1}.&quot;, myType-&gt;FullName, myBool );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;<br>An exception occurred: {0}&quot;, e-&gt;Message );\n   }\n\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsSpecialName\">\r\n    \r\n            <a id=\"System_Type_IsSpecialName_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsSpecialName</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the type has a name that requires special handling.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsSpecialName { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the type has a name that requires special handling; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents <code>MyGenericType&lt;int&gt;</code> (<code>MyGenericType(Of Integer)</code> in Visual Basic), the value of this property is determined by <code>MyGenericType&lt;T&gt;</code>.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this property always returns <code>false</code>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsUnicodeClass\">\r\n    \r\n            <a id=\"System_Type_IsUnicodeClass_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsUnicodeClass</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the string format attribute <code>UnicodeClass</code> is selected for the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsUnicodeClass { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the string format attribute <code>UnicodeClass</code> is selected for the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">TypeAttributes</a> is used to select the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents <code>MyGenericType&lt;int&gt;</code> (<code>MyGenericType(Of Integer)</code> in Visual Basic), the value of this property is determined by <code>MyGenericType&lt;T&gt;</code>.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this property always returns <code>false</code>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsValueType\">\r\n    \r\n            <a id=\"System_Type_IsValueType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsValueType</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is a value type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsValueType { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is a value type; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Value types are types that are represented as sequences of bits; value types are not classes or interfaces. Value types are referred to as &quot;structs&quot; in some programming languages. Enums are a special case of value types.  </p>\n<p> This property returns <code>false</code> for the <a class=\"xref\" href=\"system.valuetype\" data-linktype=\"relative-path\">ValueType</a> class, because <a class=\"xref\" href=\"system.valuetype\" data-linktype=\"relative-path\">ValueType</a> is not a value type itself. It is the base class for all value types, and therefore any value type can be assigned to it. This would not be possible if <a class=\"xref\" href=\"system.valuetype\" data-linktype=\"relative-path\">ValueType</a> itself was a value type. Value types are boxed when they are assigned to a field of type <a class=\"xref\" href=\"system.valuetype\" data-linktype=\"relative-path\">ValueType</a>.  </p>\n<p> This property returns <code>true</code> for enumerations, but not for the <a class=\"xref\" href=\"system.enum\" data-linktype=\"relative-path\">Enum</a> type itself. For an example that demonstrates this behavior, see <a class=\"xref\" href=\"system.type#System_Type_IsEnum_\" data-linktype=\"relative-path\">IsEnum</a>.  </p>\n<p> This property is read-only.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates a variable of type <code>MyEnum</code>, checks for the <code>IsValueType</code> property, and displays the result.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_IsValueType#1\">using namespace System;\n\n// Declare an enum type.\npublic enum class NumEnum\n{\n   One, Two\n};\n\nint main()\n{\n    bool flag = false;\n    NumEnum testEnum = NumEnum::One;\n      \n    // Get the type of myTestEnum.\n    Type^ t = testEnum.GetType();\n      \n    // Get the IsValueType property of the myTestEnum\n    // variable.\n    flag = t-&gt;IsValueType;\n    Console::WriteLine(&quot;{0} is a value type: {1}&quot;, t-&gt;FullName, flag);\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_IsValueType#1\">using System;\n\n// Declare an enum type.\nenum NumEnum { One, Two }\n\npublic class Example\n{\n\n    public static void Main(string []args)\n    {\n        bool flag = false;\n        NumEnum testEnum = NumEnum.One;\n        // Get the type of myTestEnum.\n        Type t = testEnum.GetType();\n        // Get the IsValueType property of the myTestEnum variable.\n        flag = t.IsValueType;\n        Console.WriteLine(&quot;{0} is a value type: {1}&quot;, t.FullName, flag);\n    }\n}\n// The example displays the following output:\n//        NumEnum is a value type: True\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_IsValueType#1\">&#39; Declare an enum type.\nEnum NumEnum\n    One\n    Two\nEnd Enum\n    \nPublic Class Example\n\n    Public Shared Sub Main()\n        Dim flag As Boolean = False\n        Dim testEnum As NumEnum = NumEnum.One\n        &#39; Get the type of myTestEnum.\n        Dim t As Type = testEnum.GetType()\n        &#39; Get the IsValueType property of the myTestEnum variable.\n         flag = t.IsValueType()\n         Console.WriteLine(&quot;{0} is a value type: {1}&quot;, t.FullName, flag)\n     End Sub \n End Class  \n&#39; The example displays the following output:\n&#39;       NumEnum is a value type: True\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsVisible\">\r\n    \r\n            <a id=\"System_Type_IsVisible_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsVisible</div>        \r\n          </div>\r\n    \r\n            <p>Gets a value indicating whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> can be accessed by code outside the assembly.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool IsVisible { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is a public type or a public nested type such that all the enclosing types are public; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Use this property to determine whether a type is part of the public interface of a component assembly.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example tests two classes, only one of which is visible outside the assembly.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.IsVisible#1\">using System;\n\ninternal class InternalOnly \n{\n    public class Nested {}\n}\n\npublic class Example\n{\n    public class Nested {}\n\n    public static void Main()\n    {\n        Type t = typeof(InternalOnly.Nested);\n        Console.WriteLine(\n            &quot;Is the {0} class visible outside the assembly? {1}&quot;, \n            t.FullName, \n            t.IsVisible\n        );\n\n        t = typeof(Example.Nested);\n        Console.WriteLine(\n            &quot;Is the {0} class visible outside the assembly? {1}&quot;, \n            t.FullName, \n            t.IsVisible\n        );\n    }\n}\n\n/* This example produces the following output:\n\nIs the InternalOnly+Nested class visible outside the assembly? False\nIs the Example+Nested class visible outside the assembly? True\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.IsVisible#1\">Imports System\n\nFriend Class InternalOnly\n    Public Class Nested\n    End Class\nEnd Class\n\nPublic Class Example\n    Public Class Nested\n    End Class\n\n    Public Shared Sub Main()\n        With GetType(InternalOnly.Nested)\n            Console.WriteLine(&quot;Is the &quot; &amp; .FullName _ \n                &amp; &quot; class visible outside the assembly? &quot; &amp; .IsVisible)\n        End With\n\n        With GetType(Example.Nested)\n            Console.WriteLine(&quot;Is the &quot; &amp; .FullName _ \n                &amp; &quot; class visible outside the assembly? &quot; &amp; .IsVisible)\n        End With\n    End Sub\nEnd Class\n\n&#39; This example produces the following output:\n&#39;\n&#39;Is the InternalOnly+Nested class visible outside the assembly? False\n&#39;Is the Example+Nested class visible outside the assembly? True\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Type.IsVisible#1\">using namespace System;\n\nprivate ref class InternalOnly \n{\npublic:\n    ref class Nested {};\n};\n\npublic ref class Example \n{\npublic:\n    ref class Nested {};\n}; \n\n\n// Entry point of example\nint main()\n{\n    Type^ classType = InternalOnly::Nested::typeid;\n    Console::WriteLine(\n        &quot;Is the {0} class visible outside the assembly? {1}&quot;,\n        classType-&gt;FullName, classType-&gt;IsVisible);\n\n    classType = Example::Nested::typeid;\n    Console::WriteLine(\n        &quot;Is the {0} class visible outside the assembly? {1}&quot;, \n        classType-&gt;FullName, classType-&gt;IsVisible);\n}\n\n/* This example produces the following output:\n\nIs the InternalOnly+Nested class visible outside the assembly? False\nIs the Example+Nested class visible outside the assembly? True\n*/\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_MemberType\">\r\n    \r\n            <a id=\"System_Type_MemberType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">MemberType</div>        \r\n          </div>\r\n    \r\n            <p>Gets a <a class=\"xref\" href=\"system.reflection.membertypes\" data-linktype=\"relative-path\">MemberTypes</a> value indicating that this member is a type or a nested type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override System.Reflection.MemberTypes MemberType { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.membertypes\" data-linktype=\"relative-path\">MemberTypes</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"system.reflection.membertypes\" data-linktype=\"relative-path\">MemberTypes</a> value indicating that this member is a type or a nested type.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This property overrides <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_MemberType_\" data-linktype=\"relative-path\">MemberType</a>. Therefore, when you examine a set of <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a> objectsfor example, the array returned by <a class=\"xref\" href=\"system.type#System_Type_GetMembers_\" data-linktype=\"relative-path\">GetMembers</a>the <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_MemberType_\" data-linktype=\"relative-path\">MemberType</a> property returns <a class=\"xref\" href=\"system.reflection.membertypes\" data-linktype=\"relative-path\">System.Reflection.MemberTypes</a> when a given member is a nested type.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents <code>MyGenericType&lt;int&gt;</code> (<code>MyGenericType(Of Integer)</code> in Visual Basic), the value of this property is determined by <code>MyGenericType&lt;T&gt;</code>.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this property always returns<a class=\"xref\" href=\"system.reflection.membertypes\" data-linktype=\"relative-path\">System.Reflection.MemberTypes</a>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example shows the <code>MemberType</code> field as a parameter to the <code>GetMember</code> method:  </p>\n<pre><code class=\"lang-cs\" name=\"Classic Type.MemberType Example#1\">MemberInfo[] others = t.GetMember(mi.Name, mi.MemberType, BindingFlags.Public |\nBindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Instance);\n</code></pre><pre><code class=\"lang-vb\" name=\"Classic Type.MemberType Example#1\">      Dim others As MemberInfo() = t.GetMember(mi.Name, mi.MemberType, _\n      BindingFlags.Public Or BindingFlags.Static Or BindingFlags.NonPublic _\n      Or BindingFlags.Instance)\n</code></pre><pre><code class=\"lang-cpp\" name=\"Classic Type.MemberType Example#1\">      array&lt;MemberInfo^&gt;^ others = t-&gt;GetMember( mi-&gt;Name, mi-&gt;MemberType,\n         (BindingFlags)(BindingFlags::Public | BindingFlags::Static |\n            BindingFlags::NonPublic | BindingFlags::Instance) );\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_Module\">\r\n    \r\n            <a id=\"System_Type_Module_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Module</div>        \r\n          </div>\r\n    \r\n            <p>Gets the module (the DLL) in which the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is defined.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract System.Reflection.Module Module { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.module\" data-linktype=\"relative-path\">Module</a></div>\r\n                  </div>\r\n                  <p>The module in which the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is defined.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this property returns the module in which the generic type definition was defined. For example, if you create an instance of <code>MyGenericStack&lt;int&gt;</code>, the Module property for the constructed type returns the module in which <code>MyGenericStack&lt;T&gt;</code> is defined.  </p>\n<p> Similarly, if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a generic parameter <code>T</code>, this property returns the assembly that contains the generic type that defines <code>T</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>This following example demonstrates a use of the <a class=\"xref\" href=\"system.type#System_Type_Namespace_\" data-linktype=\"relative-path\">Namespace</a> and <code>Module</code> properties and the <a class=\"xref\" href=\"system.type#System_Type_ToString_\" data-linktype=\"relative-path\">ToString</a> method of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_ToString#1\">using namespace System;\n\nnamespace MyNamespace\n{\n   ref class MyClass\n   {\n   };\n}\n\nvoid main()\n{\n      Type^ myType = MyNamespace::MyClass::typeid;\n      Console::WriteLine(&quot;Displaying information about {0}:&quot;, myType );\n      \n      // Get the namespace of the class MyClass.\n      Console::WriteLine(&quot;   Namespace: {0}&quot;, myType-&gt;Namespace );\n      \n      // Get the name of the module.\n      Console::WriteLine(&quot;   Module: {0}&quot;, myType-&gt;Module );\n      \n      // Get the fully qualified common language runtime namespace.\n      Console::WriteLine(&quot;   Fully qualified type: {0}&quot;, myType );\n}\n// The example displays the following output:\n//    Displaying information about MyNamespace.MyClass:\n//       Namespace: MyNamespace\n//       Module: type_tostring.exe\n//       Fully qualified name: MyNamespace.MyClass\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_ToString#1\">using System;\n\nnamespace MyNamespace\n{\n    class MyClass\n    {\n    }\n}\n\npublic class Example\n{\n    public static void Main()\n    {\n         Type myType = typeof(MyNamespace.MyClass);\n         Console.WriteLine(&quot;Displaying information about {0}:&quot;, myType); \n         // Get the namespace of the myClass class.\n         Console.WriteLine(&quot;   Namespace: {0}.&quot;, myType.Namespace);\n         // Get the name of the module.\n         Console.WriteLine(&quot;   Module: {0}.&quot;, myType.Module);\n         // Get the fully qualified type name.\n         Console.WriteLine(&quot;   Fully qualified name: {0}.&quot;, myType.ToString());\n    }\n}\n// The example displays the following output:\n//    Displaying information about MyNamespace.MyClass:\n//       Namespace: MyNamespace.\n//       Module: type_tostring.exe.\n//       Fully qualified name: MyNamespace.MyClass.\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_ToString#1\">Namespace MyNamespace\n    Class [MyClass]\n    End Class \nEnd Namespace \n\nPublic Class Example\n    Public Shared Sub Main()\n         Dim myType As Type = GetType(MyNamespace.MyClass)\n         Console.WriteLine(&quot;, myType)\n         &#39; Get the namespace of the MyClass class.\n         Console.WriteLine(&quot;   Namespace: {0}.&quot;, myType.Namespace)\n         &#39; Get the name of the module.\n         Console.WriteLine(&quot;   Module: {0}.&quot;, myType.Module)\n         &#39; Get the fully qualified type name.\n         Console.WriteLine(&quot;   Fully qualified name: {0}.&quot;, myType.ToString())\n    End Sub\nEnd Class\n&#39; The example displays the following output:\n&#39;       Displaying information about MyNamespace.MyClass:\n&#39;          Namespace: MyNamespace.\n&#39;          Module: type_tostring.exe.\n&#39;          Fully qualified name: MyNamespace.MyClass.\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_Namespace\">\r\n    \r\n            <a id=\"System_Type_Namespace_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Namespace</div>        \r\n          </div>\r\n    \r\n            <p>Gets the namespace of the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract string Namespace { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </div>\r\n                  <p>The namespace of the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>; <code>null</code> if the current instance has no namespace or represents a generic parameter.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure. From the viewpoint of the runtime, there are no namespaces.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this property returns the namespace that contains the generic type definition. Similarly, if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a generic parameter <code>T</code>, this property returns the namespace that contains the generic type definition that defines <code>T</code>.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents a generic parameter, this property returns <code>null</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>This following example demonstrates a use of the <code>Namespace</code> and <a class=\"xref\" href=\"system.type#System_Type_Module_\" data-linktype=\"relative-path\">Module</a> properties and the <a class=\"xref\" href=\"system.type#System_Type_ToString_\" data-linktype=\"relative-path\">ToString</a> method of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_ToString#1\">using namespace System;\n\nnamespace MyNamespace\n{\n   ref class MyClass\n   {\n   };\n}\n\nvoid main()\n{\n      Type^ myType = MyNamespace::MyClass::typeid;\n      Console::WriteLine(&quot;Displaying information about {0}:&quot;, myType );\n      \n      // Get the namespace of the class MyClass.\n      Console::WriteLine(&quot;   Namespace: {0}&quot;, myType-&gt;Namespace );\n      \n      // Get the name of the module.\n      Console::WriteLine(&quot;   Module: {0}&quot;, myType-&gt;Module );\n      \n      // Get the fully qualified common language runtime namespace.\n      Console::WriteLine(&quot;   Fully qualified type: {0}&quot;, myType );\n}\n// The example displays the following output:\n//    Displaying information about MyNamespace.MyClass:\n//       Namespace: MyNamespace\n//       Module: type_tostring.exe\n//       Fully qualified name: MyNamespace.MyClass\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_ToString#1\">using System;\n\nnamespace MyNamespace\n{\n    class MyClass\n    {\n    }\n}\n\npublic class Example\n{\n    public static void Main()\n    {\n         Type myType = typeof(MyNamespace.MyClass);\n         Console.WriteLine(&quot;Displaying information about {0}:&quot;, myType); \n         // Get the namespace of the myClass class.\n         Console.WriteLine(&quot;   Namespace: {0}.&quot;, myType.Namespace);\n         // Get the name of the module.\n         Console.WriteLine(&quot;   Module: {0}.&quot;, myType.Module);\n         // Get the fully qualified type name.\n         Console.WriteLine(&quot;   Fully qualified name: {0}.&quot;, myType.ToString());\n    }\n}\n// The example displays the following output:\n//    Displaying information about MyNamespace.MyClass:\n//       Namespace: MyNamespace.\n//       Module: type_tostring.exe.\n//       Fully qualified name: MyNamespace.MyClass.\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_ToString#1\">Namespace MyNamespace\n    Class [MyClass]\n    End Class \nEnd Namespace \n\nPublic Class Example\n    Public Shared Sub Main()\n         Dim myType As Type = GetType(MyNamespace.MyClass)\n         Console.WriteLine(&quot;, myType)\n         &#39; Get the namespace of the MyClass class.\n         Console.WriteLine(&quot;   Namespace: {0}.&quot;, myType.Namespace)\n         &#39; Get the name of the module.\n         Console.WriteLine(&quot;   Module: {0}.&quot;, myType.Module)\n         &#39; Get the fully qualified type name.\n         Console.WriteLine(&quot;   Fully qualified name: {0}.&quot;, myType.ToString())\n    End Sub\nEnd Class\n&#39; The example displays the following output:\n&#39;       Displaying information about MyNamespace.MyClass:\n&#39;          Namespace: MyNamespace.\n&#39;          Module: type_tostring.exe.\n&#39;          Fully qualified name: MyNamespace.MyClass.\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_ReflectedType\">\r\n    \r\n            <a id=\"System_Type_ReflectedType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ReflectedType</div>        \r\n          </div>\r\n    \r\n            <p>Gets the class object that was used to obtain this member.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override Type ReflectedType { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>The <code>Type</code> object through which this <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object was obtained.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>For <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects, the value of this property is always the same as the value of the <a class=\"xref\" href=\"system.type#System_Type_DeclaringType_\" data-linktype=\"relative-path\">DeclaringType</a> property.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>This example displays the reflected type of a nested class.  </p>\n<pre><code class=\"lang-cs\" name=\"Classic Type.ReflectedType Example#1\">using System;\nusing System.Reflection;\n \npublic abstract class MyClassA\n{\n\n    public abstract class MyClassB \n    {\n    }\n\n    public static void Main(string[] args) \n    { \n        Console.WriteLine(&quot;Reflected type of MyClassB is {0}&quot;,\n            typeof(MyClassB).ReflectedType); //outputs MyClassA, the enclosing class\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Classic Type.ReflectedType Example#1\">Imports System\nImports System.Reflection\n\nPublic MustInherit Class MyClassA\n\n    Public MustInherit Class MyClassB\n\n    End Class\n\n    Public Shared Sub Main()\n        Console.WriteLine(&quot;Reflected type of MyClassB is {0}&quot;, _\n           GetType(MyClassB).ReflectedType)\n\t&#39;Outputs MyClassA, the enclosing type.\n    End Sub\nEnd Class\n</code></pre><pre><code class=\"lang-cpp\" name=\"Classic Type.ReflectedType Example#1\">using namespace System;\nusing namespace System::Reflection;\n\npublic ref class MyClassA abstract\n{\npublic:\n   ref class MyClassB abstract\n   {\n\n   };\n\n};\n\nint main()\n{\n   Console::WriteLine( &quot;Reflected type of MyClassB is {0}&quot;, MyClassA::MyClassB::typeid-&gt;ReflectedType );\n   //Outputs MyClassA, the enclosing type.\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_StructLayoutAttribute\">\r\n    \r\n            <a id=\"System_Type_StructLayoutAttribute_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">StructLayoutAttribute</div>        \r\n          </div>\r\n    \r\n            <p>Gets a <a class=\"xref\" href=\"system.runtime.interopservices.structlayoutattribute\" data-linktype=\"relative-path\">StructLayoutAttribute</a> that describes the layout of the current type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtime.interopservices.structlayoutattribute\" data-linktype=\"relative-path\">StructLayoutAttribute</a></div>\r\n                  </div>\r\n                  <p>Gets a <a class=\"xref\" href=\"system.runtime.interopservices.structlayoutattribute\" data-linktype=\"relative-path\">StructLayoutAttribute</a> that describes the gross layout features of the current type.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The invoked method is not supported in the base class.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p><a class=\"xref\" href=\"system.runtime.interopservices.structlayoutattribute\" data-linktype=\"relative-path\">StructLayoutAttribute</a> is not returned by the <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_GetCustomAttributes_\" data-linktype=\"relative-path\">GetCustomAttributes</a> method. Instead, use this property to get it.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example first defines a class, a structure, and a structure with special layout attributes (the structures are nested within the class). The example then uses the StructLayoutAttribute property to obtain a <a class=\"xref\" href=\"system.runtime.interopservices.structlayoutattribute\" data-linktype=\"relative-path\">StructLayoutAttribute</a> for each type, and displays the properties of the attributes.  </p>\n<pre><code class=\"lang-cs\" name=\"Type.StructLayoutAttribute#1\">using System;\nusing System.Runtime.InteropServices;\n\npublic class Example\n{\n    public static void Main()\n    {\n        DisplayLayoutAttribute(typeof(Example).StructLayoutAttribute);\n        DisplayLayoutAttribute(typeof(Test1).StructLayoutAttribute);\n        DisplayLayoutAttribute(typeof(Test2).StructLayoutAttribute);\n    }\n\n    private static void DisplayLayoutAttribute(StructLayoutAttribute sla)\n    {\n        Console.WriteLine(&quot;\\r<br>CharSet: &quot;+sla.CharSet.ToString()+&quot;\\r<br>   Pack: &quot;+sla.Pack.ToString()+&quot;\\r<br>   Size: &quot;+sla.Size.ToString()+&quot;\\r<br>  Value: &quot;+sla.Value.ToString());\n    }\n    public struct Test1\n    {\n        public byte B1;\n        public short S;\n        public byte B2;\n    }\n    [StructLayout(LayoutKind.Explicit, Pack=1)] public struct Test2\n    {\n        [FieldOffset(0)] public byte B1;\n        [FieldOffset(1)] public short S;\n        [FieldOffset(3)] public byte B2;\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type.StructLayoutAttribute#1\">using namespace System;\nusing namespace System::Runtime::InteropServices;\nvalue struct Test1\n{\npublic:\n   Byte B1;\n   short S;\n   Byte B2;\n};\n\n\n[StructLayout(LayoutKind::Explicit,Pack=1)]\nvalue struct Test2\n{\npublic:\n\n   [FieldOffset(0)]\n   Byte B1;\n\n   [FieldOffset(1)]\n   short S;\n\n   [FieldOffset(3)]\n   Byte B2;\n};\n\nstatic void DisplayLayoutAttribute( StructLayoutAttribute^ sla )\n{\n   Console::WriteLine( L&quot;\\r<br>CharSet: {0}\\r<br>   Pack: {1}\\r<br>   Size: {2}\\r<br>  Value: {3}&quot;, sla-&gt;CharSet, sla-&gt;Pack, sla-&gt;Size, sla-&gt;Value );\n}\n\nint main()\n{\n   DisplayLayoutAttribute( Test1::typeid-&gt;StructLayoutAttribute );\n   return 0;\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type.StructLayoutAttribute#1\">Imports System\nImports System.Runtime.InteropServices\n\nPublic Class Example\n    Public Shared Sub Main()\n        DisplayLayoutAttribute(GetType(Example).StructLayoutAttribute)\n        DisplayLayoutAttribute(GetType(Test1).StructLayoutAttribute)\n        DisplayLayoutAttribute(GetType(Test2).StructLayoutAttribute)\n    End Sub\n\n    Private Shared Sub DisplayLayoutAttribute( _\n        ByVal sla As StructLayoutAttribute)\n        Console.WriteLine(vbCrLf &amp; &quot;CharSet: &quot; &amp; sla.CharSet.ToString() _\n            &amp; vbCrLf &amp; &quot;   Pack: &quot; &amp; sla.Pack.ToString() _\n            &amp; vbCrLf &amp; &quot;   Size: &quot; &amp; sla.Size.ToString() _\n            &amp; vbCrLf &amp; &quot;  Value: &quot; &amp; sla.Value.ToString())\n    End Sub\n\n    Public Structure Test1\n        Public B1 As Byte\n        Public S As Short\n        Public B2 As Byte\n    End Structure\n\n    &lt;StructLayout(LayoutKind.Explicit, Pack:=1)&gt; _\n    Public Structure Test2\n        &lt;FieldOffset(0)&gt; Public B1 As Byte\n        &lt;FieldOffset(1)&gt; Public S As Short\n        &lt;FieldOffset(3)&gt; Public B2 As Byte\n    End Structure\nEnd Class\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_TypeHandle\">\r\n    \r\n            <a id=\"System_Type_TypeHandle_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">TypeHandle</div>        \r\n          </div>\r\n    \r\n            <p>Gets the handle for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual RuntimeTypeHandle TypeHandle { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtimetypehandle\" data-linktype=\"relative-path\">RuntimeTypeHandle</a></div>\r\n                  </div>\r\n                  <p>The handle for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The .NET Compact Framework does not currently support this property.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p><code>TypeHandle</code> encapsulates a pointer to an internal data structure that represents the type. This handle is unique during the process lifetime. The handle is valid only in the application domain in which it was obtained.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example returns the handle of the corresponding type and passes the handle to a method that gets the type from the handle and displays it.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_TypeHandle#1\">using System;\nusing System.Reflection;\nclass MyClass\n{\n    public int myField = 10;\n}\n\nclass Type_TypeHandle\n{\n    public static void Main()\n    {\n        try\n        {\n            MyClass myClass = new MyClass();\n\n            // Get the type of MyClass.\n            Type myClassType = myClass.GetType();\n\n            // Get the runtime handle of MyClass.\n            RuntimeTypeHandle myClassHandle = myClassType.TypeHandle;\n         \n            DisplayTypeHandle(myClassHandle);\n        }\n        catch(Exception e)\n        {\n            Console.WriteLine(&quot;Exception: {0}&quot;, e.Message );\n        }\n    }\n\n    public static void DisplayTypeHandle(RuntimeTypeHandle myTypeHandle)\n    {\n        // Get the type from the handle.\n        Type myType = Type.GetTypeFromHandle(myTypeHandle);      \n        // Display the type.\n        Console.WriteLine(&quot;<br>Displaying the type from the handle:<br>&quot;);\n        Console.WriteLine(&quot;The type is {0}.&quot;, myType.ToString());\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_TypeHandle#1\">using namespace System;\nusing namespace System::Reflection;\nref class MyClass\n{\npublic:\n   int myField;\n};\n\nvoid DisplayTypeHandle( RuntimeTypeHandle myTypeHandle )\n{\n   \n   // Get the type from the handle.\n   Type^ myType = Type::GetTypeFromHandle( myTypeHandle );\n   \n   // Display the type.\n   Console::WriteLine( &quot;<br>Displaying the type from the handle:<br>&quot; );\n   Console::WriteLine( &quot;The type is {0}.&quot;, myType );\n}\n\nint main()\n{\n   try\n   {\n      MyClass^ myClass = gcnew MyClass;\n      \n      // Get the type of MyClass.\n      Type^ myClassType = myClass-&gt;GetType();\n      \n      // Get the runtime handle of MyClass.\n      RuntimeTypeHandle myClassHandle = myClassType-&gt;TypeHandle;\n      DisplayTypeHandle( myClassHandle );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception: {0}&quot;, e-&gt;Message );\n   }\n\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_TypeHandle#1\">Imports System\nImports System.Reflection\nImports Microsoft.VisualBasic\nClass [MyClass]\n    Public myField As Integer = 10\nEnd Class &#39;[MyClass]\nClass Type_TypeHandle\n    Public Shared Sub Main()\n        Try\n            Dim [myClass] As New [MyClass]()\n\n            &#39; Get the type of MyClass.\n            Dim myClassType As Type = [myClass].GetType()\n\n            &#39; Get the runtime handle of MyClass.\n            Dim myClassHandle As RuntimeTypeHandle = myClassType.TypeHandle\n\n            DisplayTypeHandle(myClassHandle)\n        Catch e As Exception\n            Console.WriteLine(&quot;Exception: {0}&quot;, e.Message.ToString())\n        End Try\n    End Sub &#39;Main\n\n    Public Shared Sub DisplayTypeHandle(ByVal myTypeHandle As RuntimeTypeHandle)\n        &#39; Get the type from the handle.\n        Dim myType As Type = Type.GetTypeFromHandle(myTypeHandle)\n        &#39; Display the type.\n        Console.WriteLine(ControlChars.NewLine + &quot;Displaying the type from the handle:&quot; + ControlChars.NewLine)\n        Console.WriteLine(&quot;The type is {0}.&quot;, myType.ToString())\n    End Sub &#39;DisplayTypeHandle\nEnd Class &#39;Type_TypeHandle\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_TypeInitializer\">\r\n    \r\n            <a id=\"System_Type_TypeInitializer_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">TypeInitializer</div>        \r\n          </div>\r\n    \r\n            <p>Gets the initializer for the type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.ConstructorInfo TypeInitializer { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a></div>\r\n                  </div>\r\n                  <p>An object that contains the name of the class constructor for the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Class initializers are also available through the <a class=\"xref\" href=\"system.type#System_Type_FindMembers_\" data-linktype=\"relative-path\">FindMembers</a> method, or through overloads of the <a class=\"xref\" href=\"system.type#System_Type_GetMember_\" data-linktype=\"relative-path\">GetMember</a>, <a class=\"xref\" href=\"system.type#System_Type_GetMembers_\" data-linktype=\"relative-path\">GetMembers</a>, <a class=\"xref\" href=\"system.type#System_Type_GetConstructor_\" data-linktype=\"relative-path\">GetConstructor</a>, and <a class=\"xref\" href=\"system.type#System_Type_GetConstructors_\" data-linktype=\"relative-path\">GetConstructors</a> methods that take <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> as a parameter.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this property returns <code>null</code>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_UnderlyingSystemType\">\r\n    \r\n            <a id=\"System_Type_UnderlyingSystemType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">UnderlyingSystemType</div>        \r\n          </div>\r\n    \r\n            <p>Indicates the type provided by the common language runtime that represents this type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract Type UnderlyingSystemType { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>The underlying system type for the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"methods\">\r\n        <h2>Methods\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Type_Equals_System_Object_\">\r\n    \r\n            <a id=\"System_Type_Equals_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Equals(Object)</div>        \r\n          </div>\r\n    \r\n            <p>Determines if the underlying system type of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object is the same as the underlying system type of the specified <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override bool Equals (object o);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>o</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object whose underlying system type is to be compared with the underlying system type of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>. For the comparison to succeed, <code>o</code> must be able to be cast or converted to an object of type   <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the underlying system type of <code>o</code> is the same as the underlying system type of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>; otherwise, <code>false</code>. This method also returns <code>false</code> if: .  </p>\n<ul>\n<li><p><code>o</code> is <code>null</code>.  </p>\n</li>\n<li><p><code>o</code> cannot be cast or converted to a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object.</p>\n</li>\n</ul>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method overrides <a class=\"xref\" href=\"system.object#System_Object_Equals_\" data-linktype=\"relative-path\">Equals</a>. It casts <code>o</code> to an object of type <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> and calls the <a class=\"xref\" href=\"system.type#System_Type_Equals_System_Type_\" data-linktype=\"relative-path\">System.Type.Equals(Type)</a> method.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses Equals to compare various <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object instances with various <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a> instances.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.Equals#1\">using System;\nusing System.Collections.Generic;\nusing System.Reflection;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Type t =typeof(int);\n      Object obj1 = typeof(int).GetTypeInfo();\n      IsEqualTo(t, obj1);\n\n      Object obj2 = typeof(String);\n      IsEqualTo(t, obj2);\n      \n      t = typeof(Object);\n      Object obj3 = typeof(Object);\n      IsEqualTo(t, obj3);\n      \n      t = typeof(List&lt;&gt;);\n      Object obj4 = (new List&lt;String&gt;()).GetType();\n      IsEqualTo(t, obj4);\n      \n      t = typeof(Type);\n      Object obj5 = null;\n      IsEqualTo(t, obj5);\n   }\n   \n   private static void IsEqualTo(Type t, Object inst)\n   {\n      Type t2 = inst as Type;\n      if (t2 != null)\n         Console.WriteLine(&quot;{0} = {1}: {2}&quot;, t.Name, t2.Name,\n                           t.Equals(t2));\n      else\n         Console.WriteLine(&quot;Cannot cast the argument to a type.&quot;);\n\n      Console.WriteLine();                        \n   }\n}\n// The example displays the following output:\n//       Int32 = Int32: True\n//       \n//       Int32 = String: False\n//       \n//       Object = Object: True\n//       \n//       List`1 = List`1: False\n//       \n//       Cannot cast the argument to a type.\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.Equals#1\">Imports System.Collections.Generic\nImports System.Reflection\n\nModule Example\n   Public Sub Main()\n      Dim t As Type = GetType(Integer)\n      Dim obj1 As Object = GetType(Integer).GetTypeInfo()\n      IsEqualTo(t, obj1)\n\n      Dim obj2 As Object = GetType(String)\n      IsEqualTo(t, obj2)\n      \n      t = GetType(Object)\n      Dim obj3 As Object = GetType(Object)\n      IsEqualTo(t, obj3)\n      \n      t = GetType(List(Of ))\n      Dim obj4 As Object = (New List(Of String())).GetType()\n      IsEqualTo(t, obj4)\n      \n      t = GetType(Type)\n      Dim obj5 As Object = Nothing\n      IsEqualTo(t, obj5)\n   End Sub\n   \n   Private Sub IsEqualTo(t As Type, inst As Object)\n      Dim t2 As Type = TryCast(inst, Type)\n      If t2 IsNot Nothing Then\n         Console.WriteLine(&quot;{0} = {1}: {2}&quot;, t.Name, t2.Name,\n                           t.Equals(t2))\n      Else\n         Console.WriteLine(&quot;Cannot cast the argument to a type.&quot;)\n      End If\n      Console.WriteLine()                        \n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       Int32 = Int32: True\n&#39;       \n&#39;       Int32 = String: False\n&#39;       \n&#39;       Object = Object: True\n&#39;       \n&#39;       List`1 = List`1: False\n&#39;       \n&#39;       Cannot cast the argument to a type.\n</code></pre><p> Two things are particularly worth noting about the example:  </p>\n<ul>\n<li><p>The comparison of a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents an integer with a <a class=\"xref\" href=\"system.reflection.typeinfo\" data-linktype=\"relative-path\">TypeInfo</a> object that represents an integer return <code>true</code> because <a class=\"xref\" href=\"system.reflection.typeinfo\" data-linktype=\"relative-path\">TypeInfo</a> is derived from <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.  </p>\n</li>\n<li><p>The comparison of a  <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents a <a class=\"xref\" href=\"system.collections.generic.ilist-1\" data-linktype=\"relative-path\">IList&lt;T&gt;</a> object (an open generic type) with a <code>List(Of String)</code> object (a closed generic type) returns <code>false</code>.</p>\n</li>\n</ul>\n\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_Equals_System_Type_\">\r\n    \r\n            <a id=\"System_Type_Equals_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Equals(Type)</div>        \r\n          </div>\r\n    \r\n            <p>Determines if the underlying system type of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is the same as the underlying system type of the specified <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool Equals (Type o);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>o</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object whose underlying system type is to be compared with the underlying system type of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the underlying system type of <code>o</code> is the same as the underlying system type of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses <code>Equals</code> to compare two types.  </p>\n<pre><code class=\"lang-cs\" name=\"Classic Type.Equals1 Example#1\">\nusing System;\nusing System.Reflection;\n\nclass Example\n{\n    public static void Main()\n    {\n\n        Type a = typeof(System.String);\n        Type b = typeof(System.Int32);\n\n        Console.WriteLine(&quot;{0} == {1}: {2}&quot;, a, b, a.Equals(b));\n\n        // The Type objects in a and b are not equal,\n        // because they represent different types.\n\n        a = typeof(Example);\n        b = new Example().GetType();\n\n        Console.WriteLine(&quot;{0} is equal to {1}: {2}&quot;, a, b, a.Equals(b));\n\n        // The Type objects in a and b are equal,\n        // because they both represent type Example.\n\n        b = typeof(Type);\n\n        Console.WriteLine(&quot;typeof({0}).Equals(typeof({1})): {2}&quot;, a, b, a.Equals(b));\n\n        // The Type objects in a and b are not equal,\n        // because variable a represents type Example\n        // and variable b represents type Type.\n\n        //Console.ReadLine();\n\n    }\n}\n\n//\n/* This code example produces the following output:\n    System.String == System.Int32: False\n    Example is equal to Example: True\n    typeof(Example).Equals(typeof(System.Type)): False\n*/\n</code></pre><pre><code class=\"lang-vb\" name=\"Classic Type.Equals1 Example#1\">Imports System\nImports System.Reflection\n\n\n\nClass Example\n    \n    Public Shared Sub Main() \n        \n        Dim a As Type = GetType(System.String)\n        Dim b As Type = GetType(System.Int32)\n        \n        Console.WriteLine(&quot;{0} = {1}: {2}&quot;, a, b, a.Equals(b))\n        &#39; The Type objects in a and b are not equal,\n        &#39; because they represent different types.\n\n        a = GetType(Example)\n        b = New Example().GetType()\n        Console.WriteLine(&quot;{0} is equal to {1}: {2}&quot;, a, b, a.Equals(b))\n        &#39; The Type objects in a and b are equal,\n        &#39; because they both represent type Example.\n\n        b = GetType(Type)\n        Console.WriteLine(&quot;typeof({0}).Equals(typeof({1})): {2}&quot;, a, b, a.Equals(b))\n        &#39; The Type objects in a and b are not equal,\n        &#39; because variable a represents type Example\n        &#39; and variable b represents type Type.\n\n        &#39;Console.ReadLine()\n    \n    End Sub \nEnd Class\n&#39;\n&#39; This code example produces the following output:\n&#39;    System.String = System.Int32: False\n&#39;    Example is equal to Example: True\n&#39;    typeof(Example).Equals(typeof(System.Type)): False\n&#39;\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_FindInterfaces_System_Reflection_TypeFilter_System_Object_\">\r\n    \r\n            <a id=\"System_Type_FindInterfaces_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">FindInterfaces(TypeFilter,Object)</div>        \r\n          </div>\r\n    \r\n            <p>Returns an array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects representing a filtered list of interfaces implemented or inherited by the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>filter</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.typefilter\" data-linktype=\"relative-path\">TypeFilter</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The delegate that compares the interfaces against <code>filterCriteria</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>filterCriteria</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The search criteria that determines whether an interface should be included in the returned array.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects representing a filtered list of the interfaces implemented or inherited by the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, or an empty array of type <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> if no interfaces matching the filter are implemented or inherited by the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>filter</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.targetinvocationexception\" data-linktype=\"relative-path\">TargetInvocationException</a></div>\r\n                  </div>\r\n                  <p>A static initializer is invoked and throws an exception.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method can be overridden by a derived class.  </p>\n<p> The <a class=\"xref\" href=\"system.reflection.module#System_Reflection_Module_FilterTypeName\" data-linktype=\"relative-path\">System.Reflection.Module.FilterTypeName</a> and <a class=\"xref\" href=\"system.reflection.module#System_Reflection_Module_FilterTypeNameIgnoreCase\" data-linktype=\"relative-path\">System.Reflection.Module.FilterTypeNameIgnoreCase</a> delegates supplied by the <a class=\"xref\" href=\"system.reflection.module\" data-linktype=\"relative-path\">System.Reflection.Module</a> class may also be used, in lieu of the <a class=\"xref\" href=\"system.reflection.typefilter\" data-linktype=\"relative-path\">System.Reflection.TypeFilter</a> delegate.  </p>\n<p> All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.  </p>\n<p> This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned). No duplicate interfaces are returned.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, FindInterfaces searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints. If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type argument of a generic type, FindInterfaces searches all the interfaces implemented by the type, whether or not they match constraints.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> FindInterfaces can return generic interfaces, even on types that are not generic. For example, a nongeneric type might implement <code>IEnumerable&lt;int&gt;</code> (<code>IEnumerable(Of Integer)</code> in Visual Basic).</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example finds the specified interface implemented or inherited by the specified type, and then displays the interface names.  </p>\n<pre><code class=\"lang-vb\" name=\"Type_FindInterfaces#1\">\nImports System\nImports System.Xml\nImports System.Reflection\nImports Microsoft.VisualBasic\n\nPublic Class MyFindInterfacesSample\n    Public Shared Sub Main()\n        Try\n            Dim myXMLDoc As New XmlDocument()\n            myXMLDoc.LoadXml(&quot;&lt;book genre=&#39;novel&#39; ISBN=&#39;1-861001-57-5&#39;&gt;&quot; _\n                &amp; &quot;&lt;title&gt;Pride And Prejudice&lt;/title&gt;&quot; &amp; &quot;&lt;/book&gt;&quot;)\n            Dim myType As Type = myXMLDoc.GetType()\n\n            &#39; Specify the TypeFilter delegate that compares the \n            &#39; interfaces against filter criteria.\n            Dim myFilter As New TypeFilter(AddressOf MyInterfaceFilter)\n            Dim myInterfaceList() As String = _\n                {&quot;System.Collections.IEnumerable&quot;, _\n                &quot;System.Collections.ICollection&quot;}\n            Dim index As Integer\n            For index = 0 To myInterfaceList.Length - 1\n                Dim myInterfaces As Type() = _\n                    myType.FindInterfaces(myFilter, myInterfaceList(index))\n                If myInterfaces.Length &gt; 0 Then\n                    Console.WriteLine(ControlChars.Cr &amp; _\n                        &quot;{0} implements the interface {1}.&quot;, _\n                        myType, myInterfaceList(index))\n                    Dim j As Integer\n                    For j = 0 To myInterfaces.Length - 1\n                        Console.WriteLine(&quot;Interfaces supported: {0}&quot;, _\n                            myInterfaces(j).ToString())\n                    Next j\n                Else\n                    Console.WriteLine(ControlChars.Cr &amp; _\n                        &quot;{0} does not implement the interface {1}.&quot;, _\n                        myType, myInterfaceList(index))\n                End If\n            Next index\n        Catch e As ArgumentNullException\n            Console.WriteLine(&quot;ArgumentNullException: &quot; &amp; e.Message)\n        Catch e As TargetInvocationException\n            Console.WriteLine(&quot;TargetInvocationException: &quot; &amp; e.Message)\n        Catch e As Exception\n            Console.WriteLine(&quot;Exception: &quot; &amp; e.Message)\n        End Try\n    End Sub &#39;Main\n    Public Shared Function MyInterfaceFilter(ByVal typeObj As Type, _\n        ByVal criteriaObj As [Object]) As Boolean\n        If typeObj.ToString() = criteriaObj.ToString() Then\n            Return True\n        Else\n            Return False\n        End If\n    End Function &#39;MyInterfaceFilter \nEnd Class &#39;MyFindInterfacesSample\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_FindInterfaces#1\">#using &lt;system.xml.dll&gt;\n\nusing namespace System;\nusing namespace System::Xml;\nusing namespace System::Reflection;\npublic ref class MyFindInterfacesSample\n{\npublic:\n    static bool MyInterfaceFilter(Type^ typeObj, Object^ criteriaObj)\n    {\n        if(typeObj-&gt;ToString()-&gt;Equals(criteriaObj-&gt;ToString()))\n            return true;\n        else\n            return false;\n   }\n};\n\nint main()\n{\n    try\n    {\n        XmlDocument^ myXMLDoc = gcnew XmlDocument;\n        myXMLDoc-&gt;LoadXml(&quot;&lt;book genre=&#39;novel&#39; ISBN=&#39;1-861001-57-5&#39;&gt;&quot; \n            + &quot;&lt;title&gt;Pride And Prejudice&lt;/title&gt; &lt;/book&gt;&quot;);\n        Type^ myType = myXMLDoc-&gt;GetType();\n      \n        // Specify the TypeFilter delegate that compares the interfaces \n        // against filter criteria.\n        TypeFilter^ myFilter = gcnew TypeFilter( \n            MyFindInterfacesSample::MyInterfaceFilter);\n        array&lt;String^&gt;^myInterfaceList = {&quot;System.Collections.IEnumerable&quot;,\n            &quot;System.Collections.ICollection&quot;};\n        for(int index = 0; index &lt; myInterfaceList-&gt;Length; index++)\n        {\n            array&lt;Type^&gt;^myInterfaces = myType-&gt;FindInterfaces( \n                myFilter, myInterfaceList[index]);\n            if(myInterfaces-&gt;Length &gt; 0)\n            {\n                Console::WriteLine(&quot;<br>{0} implements the interface {1}.&quot;, \n                    myType, myInterfaceList[index]);\n                for(int j = 0; j &lt; myInterfaces-&gt;Length; j++)\n                Console::WriteLine(&quot;Interfaces supported: {0}.&quot;,\n                    myInterfaces[j]);\n            }\n            else\n                Console::WriteLine(\n                    &quot;<br>{0} does not implement the interface {1}.&quot;, \n                    myType, myInterfaceList[index]);\n\n        }\n    }\n    catch(ArgumentNullException^ e) \n    {\n        Console::WriteLine(&quot;ArgumentNullException: {0}&quot;, e-&gt;Message);\n    }\n    catch(TargetInvocationException^ e) \n    {\n        Console::WriteLine(&quot;TargetInvocationException: {0}&quot;, e-&gt;Message);\n    }\n    catch(Exception^ e) \n    {\n        Console::WriteLine(&quot;Exception: {0}&quot;, e-&gt;Message);\n    }\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_FindInterfaces#1\">using System;\nusing System.Xml;\nusing System.Reflection;\n\npublic class MyFindInterfacesSample \n{\n    public static void Main()\n    {\n        try\n        {\n            XmlDocument myXMLDoc = new XmlDocument();\n            myXMLDoc.LoadXml(&quot;&lt;book genre=&#39;novel&#39; ISBN=&#39;1-861001-57-5&#39;&gt;&quot; +\n                &quot;&lt;title&gt;Pride And Prejudice&lt;/title&gt;&quot; + &quot;&lt;/book&gt;&quot;);\n            Type myType = myXMLDoc.GetType();\n\n            // Specify the TypeFilter delegate that compares the \n            // interfaces against filter criteria.\n            TypeFilter myFilter = new TypeFilter(MyInterfaceFilter);\n            String[] myInterfaceList = new String[2] \n                {&quot;System.Collections.IEnumerable&quot;, \n                &quot;System.Collections.ICollection&quot;};\n            for(int index=0; index &lt; myInterfaceList.Length; index++)\n            {\n                Type[] myInterfaces = myType.FindInterfaces(myFilter, \n                    myInterfaceList[index]);\n                if (myInterfaces.Length &gt; 0) \n                {\n                    Console.WriteLine(&quot;<br>{0} implements the interface {1}.&quot;,\n                        myType, myInterfaceList[index]);\t\n                    for(int j =0;j &lt; myInterfaces.Length;j++)\n                        Console.WriteLine(&quot;Interfaces supported: {0}.&quot;, \n                            myInterfaces[j].ToString());\n                }\n                else\n                    Console.WriteLine(\n                        &quot;<br>{0} does not implement the interface {1}.&quot;, \n                        myType,myInterfaceList[index]);\t\n            }\n        }\n        catch(ArgumentNullException e)\n        {\n            Console.WriteLine(&quot;ArgumentNullException: &quot; + e.Message);\n        }\n        catch(TargetInvocationException e)\n        {\n            Console.WriteLine(&quot;TargetInvocationException: &quot; + e.Message);\n        }\n        catch(Exception e)\n        {\n            Console.WriteLine(&quot;Exception: &quot; + e.Message);\n        }\n    }\n      \n    public static bool MyInterfaceFilter(Type typeObj,Object criteriaObj)\n    {\n        if(typeObj.ToString() == criteriaObj.ToString())\n            return true;\n        else\n            return false;\n    }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_FindMembers_System_Reflection_MemberTypes_System_Reflection_BindingFlags_System_Reflection_MemberFilter_System_Object_\">\r\n    \r\n            <a id=\"System_Type_FindMembers_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">FindMembers(MemberTypes,BindingFlags,MemberFilter,Object)</div>        \r\n          </div>\r\n    \r\n            <p>Returns a filtered array of <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a> objects of the specified member type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>memberType</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.membertypes\" data-linktype=\"relative-path\">MemberTypes</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An object that indicates the type of member to search for.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>bindingAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted.  </p>\n<p> -or-  </p>\n<p> Zero, to return <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>filter</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.memberfilter\" data-linktype=\"relative-path\">MemberFilter</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The delegate that does the comparisons, returning <code>true</code> if the member currently being inspected matches the <code>filterCriteria</code> and <code>false</code> otherwise. You can use the <code>FilterAttribute</code>, <code>FilterName</code>, and <code>FilterNameIgnoreCase</code> delegates supplied by this class. The first uses the fields of <code>FieldAttributes</code>, <code>MethodAttributes</code>, and <code>MethodImplAttributes</code> as search criteria, and the other two delegates use <code>String</code> objects as the search criteria.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>filterCriteria</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The search criteria that determines whether a member is returned in the array of <code>MemberInfo</code> objects.  </p>\n<p> The fields of <code>FieldAttributes</code>, <code>MethodAttributes</code>, and <code>MethodImplAttributes</code> can be used in conjunction with the <code>FilterAttribute</code> delegate supplied by this class.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a>[]</div>\r\n                  </div>\r\n                  <p>A filtered array of <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a> objects of the specified member type.  </p>\n<p> -or-  </p>\n<p> An empty array of type <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a>, if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> does not have members of type <code>memberType</code> that match the filter criteria.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>filter</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method can be overridden by a derived class.  </p>\n<p> Members include properties, methods, fields, events, and so on.  </p>\n<p> The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which members to include in the search:  </p>\n<ul>\n<li><p>You must specify either <code>BindingFlags.Instance</code> or <code>BindingFlags.Static</code> in order to get a return.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.Instance</code> to include instance members in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.Static</code> to include static members in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.Public</code> to include public members in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.NonPublic</code> to include non-public members (that is, private, internal, and protected members) in the search.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> modifier flags can be used to change how the search works:  </p>\n</li>\n<li><p><code>BindingFlags.DeclaredOnly</code> to search only the members declared on the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, not members that were simply inherited.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.  </p>\n<p>Valid values for <a class=\"xref\" href=\"system.type#System_Type_MemberType_\" data-linktype=\"relative-path\">MemberType</a> are defined in <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a>. If no such members are found, an empty array is returned.  </p>\n<p>To get the class initializer (.cctor) using this method, you must specify <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (<a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a><code>Or</code><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> in Visual Basic). You can also get the class initializer using the <a class=\"xref\" href=\"system.type#System_Type_TypeInitializer_\" data-linktype=\"relative-path\">TypeInitializer</a> property.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter of a generic type or generic method, FindMembers processes any members declared by the class constraint and the interface constraints of the type parameter.</p>\n</li>\n</ul>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example finds all the members in a class that match the specified search criteria, and then displays the matched members.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_FindMembers#1\">using namespace System;\nusing namespace System::Reflection;\nref class MyFindMembersClass\n{\npublic:\n   static void Test()\n   {\n      Object^ objTest = gcnew Object;\n      Type^ objType = objTest-&gt;GetType();\n      array&lt;MemberInfo^&gt;^arrayMemberInfo;\n      try\n      {\n         \n         //Find all static or public methods in the Object class that match the specified name.\n         arrayMemberInfo = objType-&gt;FindMembers( MemberTypes::Method, static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Static | BindingFlags::Instance), gcnew MemberFilter( DelegateToSearchCriteria ), &quot;ReferenceEquals&quot; );\n         for ( int index = 0; index &lt; arrayMemberInfo-&gt;Length; index++ )\n            Console::WriteLine( &quot;Result of FindMembers -&nbsp;&nbsp;&nbsp;&nbsp; {0}&quot;, String::Concat( arrayMemberInfo[ index ], &quot;<br>&quot; ) );\n      }\n      catch ( Exception^ e ) \n      {\n         Console::WriteLine( &quot;Exception : {0}&quot;, e );\n      }\n\n   }\n\n   static bool DelegateToSearchCriteria( MemberInfo^ objMemberInfo, Object^ objSearch )\n   {\n      \n      // Compare the name of the member function with the filter criteria.\n      if ( objMemberInfo-&gt;Name-&gt;Equals( objSearch-&gt;ToString() ) )\n            return true;\n      else\n            return false;\n   }\n\n};\n\nint main()\n{\n   MyFindMembersClass::Test();\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_FindMembers#1\">using System;\nusing System.Reflection;\n\nclass MyFindMembersClass\n{\n    public static void Main()\n    {\n        Object objTest = new Object();\n        Type objType = objTest.GetType ();\n        MemberInfo[] arrayMemberInfo;\n        try\n        {\n            //Find all static or public methods in the Object class that match the specified name.\n            arrayMemberInfo = objType.FindMembers(MemberTypes.Method,\n                BindingFlags.Public | BindingFlags.Static| BindingFlags.Instance,\n                new MemberFilter(DelegateToSearchCriteria),\n                &quot;ReferenceEquals&quot;);\n\n            for(int index=0;index &lt; arrayMemberInfo.Length ;index++)\n                Console.WriteLine (&quot;Result of FindMembers -&nbsp;&nbsp;&nbsp;&nbsp;&quot;+ arrayMemberInfo[index].ToString() +&quot;<br>&quot;);                 \n        }\n        catch (Exception e)\n        {\n            Console.WriteLine (&quot;Exception : &quot; + e.ToString() );            \n        }           \n    }\n    public static bool DelegateToSearchCriteria(MemberInfo objMemberInfo, Object objSearch)\n    {\n        // Compare the name of the member function with the filter criteria.\n        if(objMemberInfo.Name.ToString() == objSearch.ToString())\n            return true;\n        else \n            return false;\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_FindMembers#1\">\nImports System\nImports System.Reflection\nImports Microsoft.VisualBasic\n\nClass MyFindMembersClass\n\n    Public Shared Sub Main()\n        Dim objTest As New Object()\n        Dim objType As Type = objTest.GetType()\n        Dim arrayMemberInfo() As MemberInfo\n        Try\n            &#39;Find all static or public methods in the Object \n            &#39;class that match the specified name.\n            arrayMemberInfo = objType.FindMembers(MemberTypes.Method, _\n                              BindingFlags.Public Or BindingFlags.Static _\n                              Or BindingFlags.Instance, _\n                              New MemberFilter(AddressOf DelegateToSearchCriteria), _\n                              &quot;ReferenceEquals&quot;)\n\n            Dim index As Integer\n            For index = 0 To arrayMemberInfo.Length - 1\n                Console.WriteLine(&quot;Result of FindMembers -&quot; + ControlChars.Tab + _\n                               arrayMemberInfo(index).ToString() + ControlChars.Cr)\n            Next index\n        Catch e As Exception\n            Console.WriteLine(&quot;Exception : &quot; + e.ToString())\n        End Try\n    End Sub &#39;Main\n\n    Public Shared Function DelegateToSearchCriteria _\n                            (ByVal objMemberInfo As MemberInfo, _\n                             ByVal objSearch As Object) As Boolean\n        &#39; Compare the name of the member function with the filter criteria.\n        If objMemberInfo.Name.ToString() = objSearch.ToString() Then\n            Return True\n        Else\n            Return False\n        End If\n    End Function &#39;DelegateToSearchCriteria \nEnd Class &#39;MyFindMembersClass\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetArrayRank\">\r\n    \r\n            <a id=\"System_Type_GetArrayRank_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetArrayRank()</div>        \r\n          </div>\r\n    \r\n            <p>Gets the number of dimensions in an array.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual int GetArrayRank ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </div>\r\n                  <p>An integer that contains the number of dimensions in the current type.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p>The current type is not an array.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example displays the number of dimensions in an array.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_GetArrayRank#1\">using namespace System;\nint main()\n{\n   try\n   {\n      array&lt;Int32, 3&gt;^myArray = gcnew array&lt;Int32,3&gt;(3,4,5);\n      Type^ myType = myArray-&gt;GetType();\n      Console::WriteLine( &quot;myArray has {0} dimensions.&quot;, myType-&gt;GetArrayRank() );\n   }\n   catch ( NotSupportedException^ e ) \n   {\n      Console::WriteLine( &quot;NotSupportedException raised.&quot; );\n      Console::WriteLine( &quot;Source: {0}&quot;, e-&gt;Source );\n      Console::WriteLine( &quot;Message: {0}&quot;, e-&gt;Message );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception raised.&quot; );\n      Console::WriteLine( &quot;Source: {0}&quot;, e-&gt;Source );\n      Console::WriteLine( &quot;Message: {0}&quot;, e-&gt;Message );\n   }\n\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_GetArrayRank#1\">using System;\n\nclass MyArrayRankSample\n{\n    public static void Main()\n    {\n        try\n        {\n            int[,,] myArray = new int[,,] {{{12,2,35},{300,78,33}},{{92,42,135},{30,7,3}}};\n            Type myType = myArray.GetType();\n\n            Console.WriteLine(&quot;Contents of myArray: {{{12,2,35},{300,78,33}},{{92,42,135},{30,7,3}}}&quot;);\n            Console.WriteLine(&quot;myArray has {0} dimensions.&quot;, myType.GetArrayRank());\n        }\n        catch(NotSupportedException e)\n        {\n            Console.WriteLine(&quot;NotSupportedException raised.&quot;);\n            Console.WriteLine(&quot;Source: &quot; + e.Source);\n            Console.WriteLine(&quot;Message: &quot; + e.Message);\n        }\n        catch(Exception e)\n        {\n            Console.WriteLine(&quot;Exception raised.&quot;);\n            Console.WriteLine(&quot;Source: &quot; + e.Source);\n            Console.WriteLine(&quot;Message: &quot; + e.Message);\n        }      \n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetArrayRank#1\">Imports System\nImports Microsoft.VisualBasic\n\nClass MyArrayRankSample\n    Public Shared Sub Main()\n        Try\n            Dim myArray(,,) As Integer = {{{12, 2, 35}, {300, 78, 33}}, {{92, 42, 135}, {30, 7, 3}}}\n            Dim myType As Type = myArray.GetType()\n            Console.WriteLine(&quot;Contents of myArray: {{{12,2,35},{300,78,33}},{{92,42,135},{30,7,3}}}&quot;)\n            Console.WriteLine(&quot;myArray has {0} dimensions.&quot;, myType.GetArrayRank())\n        Catch e As NotSupportedException\n            Console.WriteLine(&quot;NotSupportedException raised.&quot;)\n            Console.WriteLine((&quot;Source: &quot; + e.Source))\n            Console.WriteLine((&quot;Message: &quot; + e.Message))\n        Catch e As Exception\n            Console.WriteLine(&quot;Exception raised.&quot;)\n            Console.WriteLine((&quot;Source: &quot; + e.Source))\n            Console.WriteLine((&quot;Message: &quot; + e.Message))\n        End Try\n    End Sub &#39;Main \nEnd Class &#39;MyArrayRankSample\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetAttributeFlagsImpl\">\r\n    \r\n            <a id=\"System_Type_GetAttributeFlagsImpl_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetAttributeFlagsImpl()</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, implements the <span class=\"xref\">stem.Type.Attributes*</span> property and gets a bitmask indicating the attributes associated with the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">TypeAttributes</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"system.reflection.typeattributes\" data-linktype=\"relative-path\">TypeAttributes</a> object representing the attribute set of the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetConstructor_System_Type___\">\r\n    \r\n            <a id=\"System_Type_GetConstructor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetConstructor(Type[])</div>        \r\n          </div>\r\n    \r\n            <p>Searches for a public instance constructor whose parameters match the types in the specified array.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.ConstructorInfo GetConstructor (Type[] types);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>types</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects representing the number, order, and type of the parameters for the desired constructor.  </p>\n<p> -or-  </p>\n<p> An empty array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects, to get a constructor that takes no parameters. Such an empty array is provided by the <code>static</code> field <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a></div>\r\n                  </div>\r\n                  <p>An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>types</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One of the elements in <code>types</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>types</code> is multidimensional.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method overload looks for public instance constructors and cannot be used to obtain a class initializer (.cctor). To get a class initializer, use an overload that takes <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a>, and specify <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (<a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a><code>Or</code><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> in Visual Basic). You can also get the class initializer using the <a class=\"xref\" href=\"system.type#System_Type_TypeInitializer_\" data-linktype=\"relative-path\">TypeInitializer</a> property.  </p>\n<p> If the requested constructor is non-public, this method returns <code>null</code>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  </p>\n</div>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a> with the type parameters replaced by the appropriate type arguments. If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method always returns <code>null</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example obtains the type of <code>MyClass</code>, gets the <a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a> object, and displays the constructor signature.  </p>\n<pre><code class=\"lang-vb\" name=\"Type_GetConstructor#1\">Imports System\nImports System.Reflection\nImports System.Security\nImports Microsoft.VisualBasic\n\nPublic Class MyClass1\n\n    Public Sub New()\n    End Sub &#39;New\n\n    Public Sub New(ByVal i As Integer)\n    End Sub &#39;New\n\n    Public Shared Sub Main()\n        Try\n            Dim myType As Type = GetType(MyClass1)\n            Dim types(0) As Type\n            types(0) = GetType(Int32)\n            &#39; Get the constructor that takes an integer as a parameter.\n            Dim constructorInfoObj As ConstructorInfo = myType.GetConstructor(types)\n            If Not (constructorInfoObj Is Nothing) Then\n                Console.WriteLine(&quot;The constructor of MyClass that takes an integer as a parameter is: &quot;)\n                Console.WriteLine(constructorInfoObj.ToString())\n            Else\n                Console.WriteLine(&quot;The constructor of MyClass that takes no &quot; + &quot;parameters is not available.&quot;)\n            End If\n\n        Catch e As Exception\n            Console.WriteLine(&quot;Exception caught.&quot;)\n            Console.WriteLine((&quot;Source: &quot; + e.Source))\n            Console.WriteLine((&quot;Message: &quot; + e.Message))\n        End Try\n    End Sub &#39;Main\nEnd Class &#39;MyClass1\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_GetConstructor#1\">\nusing System;\nusing System.Reflection;\nusing System.Security;\n\npublic class MyClass1\n{\n    public MyClass1(){}\n    public MyClass1(int i){}\n\n    public static void Main()\n    {\n        try\n        {\n            Type myType = typeof(MyClass1);\n            Type[] types = new Type[1];\n            types[0] = typeof(int);\n            // Get the constructor that takes an integer as a parameter.\n            ConstructorInfo constructorInfoObj = myType.GetConstructor(types);\n            if (constructorInfoObj != null)\n            {\n                Console.WriteLine(&quot;The constructor of MyClass1 that takes an &quot; + \n                    &quot;integer as a parameter is: &quot;); \n                Console.WriteLine(constructorInfoObj.ToString());\n            }\n            else\n            {\n                Console.WriteLine(&quot;The constructor of MyClass1 that takes an integer &quot; +\n                    &quot;as a parameter is not available.&quot;); \n            }\n        }\n        catch(Exception e)\n        {\n            Console.WriteLine(&quot;Exception caught.&quot;);\n            Console.WriteLine(&quot;Source: &quot; + e.Source);\n            Console.WriteLine(&quot;Message: &quot; + e.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetConstructor#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Security;\npublic ref class MyClass1\n{\npublic:\n   MyClass1(){}\n\n   MyClass1( int i ){}\n\n};\n\nint main()\n{\n   try\n   {\n      Type^ myType = MyClass1::typeid;\n      array&lt;Type^&gt;^types = gcnew array&lt;Type^&gt;(1);\n      types[ 0 ] = int::typeid;\n      \n      // Get the constructor that takes an integer as a parameter.\n      ConstructorInfo^ constructorInfoObj = myType-&gt;GetConstructor( types );\n      if ( constructorInfoObj != nullptr )\n      {\n         Console::WriteLine( &quot;The constructor of MyClass1 that takes an integer as a parameter is: &quot; );\n         Console::WriteLine( constructorInfoObj );\n      }\n      else\n      {\n         Console::WriteLine( &quot;The constructor of MyClass1 that takes an integer as a parameter is not available.&quot; );\n      }\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception caught.&quot; );\n      Console::WriteLine( &quot;Source: {0}&quot;, e-&gt;Source );\n      Console::WriteLine( &quot;Message: {0}&quot;, e-&gt;Message );\n   }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetConstructor_System_Reflection_BindingFlags_System_Reflection_Binder_System_Type___System_Reflection_ParameterModifier___\">\r\n    \r\n            <a id=\"System_Type_GetConstructor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetConstructor(BindingFlags,Binder,Type[],ParameterModifier[])</div>        \r\n          </div>\r\n    \r\n            <p>Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>bindingAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted.  </p>\n<p> -or-  </p>\n<p> Zero, to return <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>binder</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  </p>\n<p> -or-  </p>\n<p> A null reference (<code>Nothing</code> in Visual Basic), to use the <span class=\"xref\">stem.Type.DefaultBinder*</span>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>types</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.  </p>\n<p> -or-  </p>\n<p> An empty array of the type <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.  </p>\n<p> -or-  </p>\n<p> <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>modifiers</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the parameter type array. The default binder does not process this parameter.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a> object representing the constructor that matches the specified requirements, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>types</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One of the elements in <code>types</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>types</code> is multidimensional.  </p>\n<p> -or-  </p>\n<p> <code>modifiers</code> is multidimensional.  </p>\n<p> -or-  </p>\n<p> <code>types</code> and <code>modifiers</code> do not have the same length.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If an exact match does not exist, the <code>binder</code> will attempt to coerce the parameter types specified in the <code>types</code> array in order to select a match. If the <code>binder</code> is unable to select a match, then <code>null</code> is returned.  </p>\n<p> The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which constructors to include in the search:  </p>\n<ul>\n<li><p>You must specify either <code>BindingFlags.Instance</code> or <code>BindingFlags.Static</code> in order to get a return.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.Public</code> to include public constructors in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.NonPublic</code> to include non-public constructors (that is, private, internal, and protected constructors) in the search.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.  </p>\n<p>To get the class initializer (.cctor) using this method overload, you must specify <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (<a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a><code>Or</code><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> in Visual Basic). You can also get the class initializer using the <a class=\"xref\" href=\"system.type#System_Type_TypeInitializer_\" data-linktype=\"relative-path\">TypeInitializer</a> property.  </p>\n</li>\n</ul>\n<div class=\"NOTE\"><h5>Note</h5><p> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  </p>\n</div>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a> with the type parameters replaced by the appropriate type arguments. If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method always returns <code>null</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following program obtains the type of <code>MyClass1</code> class, gets the <a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a> object matching the specified binding flags, and displays the signature of the constructor.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_GetConstructor2#1\">using System;\nusing System.Reflection;\nusing System.Security;\n\n\npublic class MyClass1\n{\n    public MyClass1(int i){}\n    public static void Main()\n    {\n        try\n        {\n            Type myType = typeof(MyClass1);\n            Type[] types = new Type[1];\n            types[0] = typeof(int);\n            // Get the constructor that is public and takes an integer parameter.\n            ConstructorInfo constructorInfoObj = myType.GetConstructor(\n                BindingFlags.Instance | BindingFlags.Public, null, types, null);\n            if (constructorInfoObj != null )\n            {\n                Console.WriteLine(&quot;The constructor of MyClass1 that is public &quot; +\n                    &quot;and takes an integer as a parameter is:&quot;);\n                Console.WriteLine(constructorInfoObj.ToString());\n            }\n            else\n            {\n                Console.WriteLine(&quot;The constructor of the MyClass1 that is public &quot; +\n                    &quot;and takes an integer as a parameter is not available.&quot;);\n            }\n        }\n        catch(ArgumentNullException e)\n        {\n            Console.WriteLine(&quot;ArgumentNullException: &quot; + e.Message);\n        }\n        catch(ArgumentException e)\n        {\n            Console.WriteLine(&quot;ArgumentException: &quot; + e.Message);\n        }\n        catch(SecurityException e)\n        {\n            Console.WriteLine(&quot;SecurityException: &quot; + e.Message);\n        }\n        catch(Exception e)\n        {\n            Console.WriteLine(&quot;Exception: &quot; + e.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetConstructor2#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Security;\npublic ref class MyClass1\n{\npublic:\n   MyClass1( int i ){}\n\n};\n\nint main()\n{\n   try\n   {\n      Type^ myType = MyClass1::typeid;\n      array&lt;Type^&gt;^types = gcnew array&lt;Type^&gt;(1);\n      types[ 0 ] = int::typeid;\n      \n      // Get the constructor that is public and takes an integer parameter.\n      ConstructorInfo^ constructorInfoObj = myType-&gt;GetConstructor( static_cast&lt;BindingFlags&gt;(BindingFlags::Instance | BindingFlags::Public), nullptr, types, nullptr );\n      if ( constructorInfoObj != nullptr )\n      {\n         Console::WriteLine( &quot;The constructor of MyClass1 that is public and takes an integer as a parameter is:&quot; );\n         Console::WriteLine( constructorInfoObj );\n      }\n      else\n      {\n         Console::WriteLine( &quot;The constructor of the MyClass1 that is public and takes an integer as a parameter is not available.&quot; );\n      }\n   }\n   catch ( ArgumentNullException^ e ) \n   {\n      Console::WriteLine( &quot;ArgumentNullException: {0}&quot;, e-&gt;Message );\n   }\n   catch ( ArgumentException^ e ) \n   {\n      Console::WriteLine( &quot;ArgumentException: {0}&quot;, e-&gt;Message );\n   }\n   catch ( SecurityException^ e ) \n   {\n      Console::WriteLine( &quot;SecurityException: {0}&quot;, e-&gt;Message );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception: {0}&quot;, e-&gt;Message );\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetConstructor2#1\">Imports System\nImports System.Reflection\nImports System.Security\n\n\nPublic Class MyClass1\n    Public Sub New(ByVal i As Integer)\n    End Sub &#39;New\n\n    Public Shared Sub Main()\n        Try\n            Dim myType As Type = GetType(MyClass1)\n            Dim types(0) As Type\n            types(0) = GetType(Integer)\n            &#39; Get the constructor that is public and takes an integer parameter.\n            Dim constructorInfoObj As ConstructorInfo = _\n                     myType.GetConstructor(BindingFlags.Instance Or _\n                     BindingFlags.Public, Nothing, types, Nothing)\n            If Not (constructorInfoObj Is Nothing) Then\n                Console.WriteLine(&quot;The constructor of MyClass1 that is &quot; + _\n                               &quot;public and takes an integer as a parameter is &quot;)\n                Console.WriteLine(constructorInfoObj.ToString())\n            Else\n                Console.WriteLine(&quot;The constructor of MyClass1 that is &quot; + _\n                  &quot;public and takes an integer as a parameter is not available.&quot;)\n            End If\n        Catch e As ArgumentNullException\n            Console.WriteLine(&quot;ArgumentNullException: &quot; + e.Message)\n        Catch e As ArgumentException\n            Console.WriteLine(&quot;ArgumentException: &quot; + e.Message)\n        Catch e As SecurityException\n            Console.WriteLine(&quot;SecurityException: &quot; + e.Message)\n        Catch e As Exception\n            Console.WriteLine(&quot;Exception: &quot; + e.Message)\n        End Try\n    End Sub\nEnd Class\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetConstructor_System_Reflection_BindingFlags_System_Reflection_Binder_System_Reflection_CallingConventions_System_Type___System_Reflection_ParameterModifier___\">\r\n    \r\n            <a id=\"System_Type_GetConstructor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetConstructor(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])</div>        \r\n          </div>\r\n    \r\n            <p>Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>bindingAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted.  </p>\n<p> -or-  </p>\n<p> Zero, to return <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>binder</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  </p>\n<p> -or-  </p>\n<p> A null reference (<code>Nothing</code> in Visual Basic), to use the <span class=\"xref\">stem.Type.DefaultBinder*</span>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>callConvention</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.callingconventions\" data-linktype=\"relative-path\">CallingConventions</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>types</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.  </p>\n<p> -or-  </p>\n<p> An empty array of the type <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>modifiers</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <code>types</code> array. The default binder does not process this parameter.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a></div>\r\n                  </div>\r\n                  <p>An object representing the constructor that matches the specified requirements, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>types</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One of the elements in <code>types</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>types</code> is multidimensional.  </p>\n<p> -or-  </p>\n<p> <code>modifiers</code> is multidimensional.  </p>\n<p> -or-  </p>\n<p> <code>types</code> and <code>modifiers</code> do not have the same length.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Although the default binder does not process <a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a> (the <code>modifiers</code> parameter), you can use the abstract <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">System.Reflection.Binder</a> class to write a custom binder that does process <code>modifiers</code>. <code>ParameterModifier</code> is only used when calling through COM interop, and only parameters that are passed by reference are handled.  </p>\n<p> If an exact match does not exist, the <code>binder</code> will attempt to coerce the parameter types specified in the <code>types</code> array in order to select a match. If the <code>binder</code> is unable to select a match, then <code>null</code> is returned.  </p>\n<p> The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which constructors to include in the search:  </p>\n<ul>\n<li><p>You must specify either <code>BindingFlags.Instance</code> or <code>BindingFlags.Static</code> in order to get a return.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.Public</code> to include public constructors in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.NonPublic</code> to include non-public constructors (that is, private, internal, and protected constructors) in the search.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.  </p>\n<p>To get the class initializer (.cctor) using this method, you must specify <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (<a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a><code>Or</code><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> in Visual Basic). You can also get the class initializer using the <a class=\"xref\" href=\"system.type#System_Type_TypeInitializer_\" data-linktype=\"relative-path\">TypeInitializer</a> property.  </p>\n<p>The following table shows what members of a base class are returned by the <code>Get</code> methods when reflecting on a type.  </p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>Member Type</th>\n<th>Static</th>\n<th>Non-Static</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Constructor</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Field</td>\n<td>No</td>\n<td>Yes. A field is always hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Event</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n<tr>\n<td>Method</td>\n<td>No</td>\n<td>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Nested Type</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Property</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  </p>\n</li>\n<li><p>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  </p>\n</li>\n<li><p>Custom attributes are not part of the common type system.  </p>\n</li>\n</ol>\n<div class=\"NOTE\"><h5>Note</h5><p> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  </p>\n</div>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a> with the type parameters replaced by the appropriate type arguments. If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method always returns <code>null</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example obtains the type of <code>MyClass1</code>, gets the <a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a> object that matches the specified binding flags, and displays the constructor signature.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_GetConstructor3#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Security;\npublic ref class MyClass1\n{\npublic:\n   MyClass1( int i ){}\n\n};\n\nint main()\n{\n   try\n   {\n      Type^ myType = MyClass1::typeid;\n      array&lt;Type^&gt;^types = gcnew array&lt;Type^&gt;(1);\n      types[ 0 ] = int::typeid;\n      \n      // Get the public instance constructor that takes an integer parameter.\n      ConstructorInfo^ constructorInfoObj = myType-&gt;GetConstructor( static_cast&lt;BindingFlags&gt;(BindingFlags::Instance | BindingFlags::Public), nullptr, CallingConventions::HasThis, types, nullptr );\n      if ( constructorInfoObj != nullptr )\n      {\n         Console::WriteLine( &quot;The constructor of MyClass1 that is a public instance method and takes an integer as a parameter is: &quot; );\n         Console::WriteLine( constructorInfoObj );\n      }\n      else\n      {\n         Console::WriteLine( &quot;The constructor of MyClass1 that is a public instance method and takes an integer as a parameter is not available.&quot; );\n      }\n   }\n   catch ( ArgumentNullException^ e ) \n   {\n      Console::WriteLine( &quot;ArgumentNullException: {0}&quot;, e-&gt;Message );\n   }\n   catch ( ArgumentException^ e ) \n   {\n      Console::WriteLine( &quot;ArgumentException: {0}&quot;, e-&gt;Message );\n   }\n   catch ( SecurityException^ e ) \n   {\n      Console::WriteLine( &quot;SecurityException: {0}&quot;, e-&gt;Message );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception: {0}&quot;, e-&gt;Message );\n   }\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_GetConstructor3#1\">using System;\nusing System.Reflection;\nusing System.Security;\n\npublic class MyClass1\n{\n    public MyClass1(int i){}\n    public static void Main()\n    {\n        try\n        {\n            Type  myType = typeof(MyClass1);\n            Type[] types = new Type[1];\n            types[0] = typeof(int);\n            // Get the public instance constructor that takes an integer parameter.\n            ConstructorInfo constructorInfoObj = myType.GetConstructor(\n                BindingFlags.Instance | BindingFlags.Public, null,\n                CallingConventions.HasThis, types, null);\n            if(constructorInfoObj != null)\n            {\n                Console.WriteLine(&quot;The constructor of MyClass1 that is a public &quot; +\n                    &quot;instance method and takes an integer as a parameter is: &quot;);\n                Console.WriteLine(constructorInfoObj.ToString());\n            }\n            else\n            {\n                Console.WriteLine(&quot;The constructor of MyClass1 that is a public instance &quot; +\n                    &quot;method and takes an integer as a parameter is not available.&quot;);\n            }\n        }\n        catch(ArgumentNullException e)\n        {\n            Console.WriteLine(&quot;ArgumentNullException: &quot; + e.Message);\n        }\n        catch(ArgumentException e)\n        {\n            Console.WriteLine(&quot;ArgumentException: &quot; + e.Message);\n        }\n        catch(SecurityException e)\n        {\n            Console.WriteLine(&quot;SecurityException: &quot; + e.Message);\n        }\n        catch(Exception e)\n        {\n            Console.WriteLine(&quot;Exception: &quot; + e.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetConstructor3#1\">Public Class MyClass1\n    Public Sub New(ByVal i As Integer)\n    End Sub\n    Public Shared Sub Main()\n        Try\n            Dim myType As Type = GetType(MyClass1)\n            Dim types(0) As Type\n            types(0) = GetType(Integer)\n            &#39; Get the public instance constructor that takes an integer parameter.\n            Dim constructorInfoObj As ConstructorInfo = _\n                        myType.GetConstructor(BindingFlags.Instance Or _\n                        BindingFlags.Public, Nothing, _\n                        CallingConventions.HasThis, types, Nothing)\n            If Not (constructorInfoObj Is Nothing) Then\n                Console.WriteLine(&quot;The constructor of MyClass1 that &quot; + _\n                                  &quot;is a public instance method and takes an &quot; + _\n                                  &quot;integer as a parameter is: &quot;)\n                Console.WriteLine(constructorInfoObj.ToString())\n            Else\n                Console.WriteLine(&quot;The constructor MyClass1 that &quot; + _\n                                  &quot;is a public instance method and takes an &quot; + _\n                                  &quot;integer as a parameter is not available.&quot;)\n            End If\n        Catch e As ArgumentNullException\n            Console.WriteLine(&quot;ArgumentNullException: &quot; + e.Message)\n        Catch e As ArgumentException\n            Console.WriteLine(&quot;ArgumentException: &quot; + e.Message)\n        Catch e As SecurityException\n            Console.WriteLine(&quot;SecurityException: &quot; + e.Message)\n        Catch e As Exception\n            Console.WriteLine(&quot;Exception: &quot; + e.Message)\n        End Try\n    End Sub\nEnd Class\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetConstructorImpl_System_Reflection_BindingFlags_System_Reflection_Binder_System_Reflection_CallingConventions_System_Type___System_Reflection_ParameterModifier___\">\r\n    \r\n            <a id=\"System_Type_GetConstructorImpl_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetConstructorImpl(BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>bindingAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted.  </p>\n<p> -or-  </p>\n<p> Zero, to return <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>binder</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  </p>\n<p> -or-  </p>\n<p> A null reference (<code>Nothing</code> in Visual Basic), to use the <span class=\"xref\">stem.Type.DefaultBinder*</span>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>callConvention</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.callingconventions\" data-linktype=\"relative-path\">CallingConventions</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>types</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects representing the number, order, and type of the parameters for the constructor to get.  </p>\n<p> -or-  </p>\n<p> An empty array of the type <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>modifiers</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <code>types</code> array. The default binder does not process this parameter.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a> object representing the constructor that matches the specified requirements, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>types</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One of the elements in <code>types</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>types</code> is multidimensional.  </p>\n<p> -or-  </p>\n<p> <code>modifiers</code> is multidimensional.  </p>\n<p> -or-  </p>\n<p> <code>types</code> and <code>modifiers</code> do not have the same length.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The current type is a <a class=\"xref\" href=\"system.reflection.emit.typebuilder\" data-linktype=\"relative-path\">TypeBuilder</a> or <a class=\"xref\" href=\"system.reflection.emit.generictypeparameterbuilder\" data-linktype=\"relative-path\">GenericTypeParameterBuilder</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Although the default binder does not process <a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a> (the <code>modifiers</code> parameter), you can use the abstract <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">System.Reflection.Binder</a> class to write a custom binder that does process <code>modifiers</code>. <code>ParameterModifier</code> is only used when calling through COM interop, and only parameters that are passed by reference are handled.  </p>\n<p> If an exact match does not exist, the <code>binder</code> will attempt to coerce the parameter types specified in the <code>types</code> array in order to select a match. If the <code>binder</code> is unable to select a match, then <code>null</code> is returned.  </p>\n<p> The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which constructors to include in the search:  </p>\n<ul>\n<li><p>You must specify either <code>BindingFlags.Instance</code> or <code>BindingFlags.Static</code> in order to get a return.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.Public</code> to include public constructors in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.NonPublic</code> to include non-public constructors (that is, private, internal, and protected constructors) in the search.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.  </p>\n<p>This method implements <a class=\"xref\" href=\"system.type#System_Type_GetConstructor_\" data-linktype=\"relative-path\">GetConstructor</a>.</p>\n</li>\n</ul>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetConstructors\">\r\n    \r\n            <a id=\"System_Type_GetConstructors_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetConstructors()</div>        \r\n          </div>\r\n    \r\n            <p>Returns all the public constructors defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.ConstructorInfo[] GetConstructors ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a> objects representing all the public instance constructors defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, but not including the type initializer (static constructor). If no public instance constructors are defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, or if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, an empty array of type <a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a> is returned.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The GetConstructors method does not return constructors in a particular order, such as declaration order. Your code must not depend on the order in which constructors are returned, because that order varies.  </p>\n<p> The following table shows what members of a base class are returned by the <code>Get</code> methods when reflecting on a type.  </p>\n<table>\n<thead>\n<tr>\n<th>Member Type</th>\n<th>Static</th>\n<th>Non-Static</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Constructor</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Field</td>\n<td>No</td>\n<td>Yes. A field is always hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Event</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n<tr>\n<td>Method</td>\n<td>No</td>\n<td>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Nested Type</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Property</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  </p>\n</li>\n<li><p>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  </p>\n</li>\n<li><p>Custom attributes are not part of the common type system.  </p>\n<p>This method overload calls the <a class=\"xref\" href=\"system.type#System_Type_GetConstructors_System_Reflection_BindingFlags_\" data-linktype=\"relative-path\">GetConstructors(BindingFlags)</a> method overload, with <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (<a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a><code>Or</code><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> in Visual Basic). It will not find class initializers (.cctor). To find class initializers, use an overload that takes <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a>, and specify <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (<a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a><code>Or</code><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> in Visual Basic). You can also get the class initializer using the <a class=\"xref\" href=\"system.type#System_Type_TypeInitializer_\" data-linktype=\"relative-path\">TypeInitializer</a> property.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a> objects with the type parameters replaced by the appropriate type arguments. For example, if class <code>C&lt;T&gt;</code> has a constructor <code>C(T t1)</code> (<code>Sub New(ByVal t1 As T)</code> in Visual Basic), calling GetConstructors on <code>C&lt;int&gt;</code> returns a <a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a> that represents <code>C(int t1)</code> in C# (<code>Sub New(ByVal t1 As Integer)</code> in Visual Basic).  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a generic type parameter, the GetConstructors method returns an empty array.</p>\n</li>\n</ol>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>This example shows the output of the GetConstructors overload from a class that has two instance constructors and one static constructor.  </p>\n<pre><code class=\"lang-vb\" name=\"Classic Type.GetConstructors Example#1\">Imports System\nImports System.Reflection\n\nPublic Class t\n    \n    Public Sub New()\n    End Sub\n    \n    Shared Sub New()\n    End Sub\n    \n    Public Sub New(i As Integer)\n    End Sub\n     \n    Public Shared Sub Main()\n        Dim p As ConstructorInfo() = GetType(t).GetConstructors()\n        Console.WriteLine(p.Length)\n        \n        Dim i As Integer\n        For i = 0 To p.Length - 1\n            Console.WriteLine(p(i).IsStatic)\n        Next i\n    End Sub\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"Classic Type.GetConstructors Example#1\"> using System;\n using System.Reflection;\n \n public class t {\n     public t() {}\n     static t() {}\n     public t(int i) {}\n \n     public static void Main() {\n         ConstructorInfo[] p = typeof(t).GetConstructors();\n         Console.WriteLine(p.Length);\n \n         for (int i=0;i&lt;p.Length;i++) {\n             Console.WriteLine(p[i].IsStatic);\n         }\n     }\n }\n</code></pre><pre><code class=\"lang-cpp\" name=\"Classic Type.GetConstructors Example#1\">using namespace System;\nusing namespace System::Reflection;\npublic ref class t\n{\npublic:\n   t(){}\n\n   static t(){}\n\n   t( int /*i*/ ){}\n\n};\n\nint main()\n{\n   array&lt;ConstructorInfo^&gt;^p = t::typeid-&gt;GetConstructors();\n   Console::WriteLine( p-&gt;Length );\n   for ( int i = 0; i &lt; p-&gt;Length; i++ )\n   {\n      Console::WriteLine( p[ i ]-&gt;IsStatic );\n\n   }\n}\n</code></pre><p> The output of this code is:  </p>\n<p> 2  </p>\n<p> False  </p>\n<p> False  </p>\n<p> Because the GetConstructors overload uses only <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> and <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a>, the static constructor is neither counted by the <code>for</code> expression nor evaluated by <code>IsStatic</code>.  </p>\n<p> To find static constructors, use the <a class=\"xref\" href=\"system.type#System_Type_GetConstructors_System_Reflection_BindingFlags_\" data-linktype=\"relative-path\">GetConstructors(BindingFlags)</a> overload, and pass the combination (logical <code>OR</code>) of <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a>, <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a>, <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a>, <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a>, as shown in the following code example:  </p>\n<pre><code class=\"lang-vb\" name=\"Classic Type.GetConstructors Example#2\">Imports System\nImports System.Reflection\n\nPublic Class t\n    \n    Public Sub New()\n    End Sub\n    \n    Shared Sub New()\n    End Sub\n    \n    Public Sub New(i As Integer)\n    End Sub\n     \n    Public Shared Sub Main()\n        Dim p As ConstructorInfo() = GetType(T).GetConstructors( _\n           BindingFlags.Public Or _\n           BindingFlags.Static Or _\n           BindingFlags.NonPublic Or _\n           BindingFlags.Instance)\n        Console.WriteLine(p.Length)\n        \n        Dim i As Integer\n        For i = 0 To p.Length - 1\n            Console.WriteLine(p(i).IsStatic)\n        Next i\n    End Sub\nEnd Class\n</code></pre><pre><code class=\"lang-cpp\" name=\"Classic Type.GetConstructors Example#2\">using namespace System;\nusing namespace System::Reflection;\npublic ref class t\n{\npublic:\n   t(){}\n\n   t( int /*i*/ ){}\n\n   static t(){}\n\n};\n\nint main()\n{\n   array&lt;ConstructorInfo^&gt;^p = t::typeid-&gt;GetConstructors( static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Static | BindingFlags::NonPublic | BindingFlags::Instance) );\n   Console::WriteLine( p-&gt;Length );\n   for ( int i = 0; i &lt; p-&gt;Length; i++ )\n   {\n      Console::WriteLine( p[ i ]-&gt;IsStatic );\n   }\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Classic Type.GetConstructors Example#2\"> using System;\n using System.Reflection;\n  \n public class t {\n     public t() {}\n     static t() {}\n     public t(int i) {}\n \n     public static void Main() {\n         ConstructorInfo[] p = typeof(t).GetConstructors(\n            BindingFlags.Public | BindingFlags.Static |\n            BindingFlags.NonPublic | BindingFlags.Instance);\n         Console.WriteLine(p.Length);\n \n         for (int i=0;i&lt;p.Length;i++) {\n             Console.WriteLine(p[i].IsStatic);\n         }\n     }\n }\n</code></pre><p> Now the output is:  </p>\n<p> 3  </p>\n<p> False  </p>\n<p> True  </p>\n<p> False</p>\n\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetConstructors_System_Reflection_BindingFlags_\">\r\n    \r\n            <a id=\"System_Type_GetConstructors_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetConstructors(BindingFlags)</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, searches for the constructors defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, using the specified <code>BindingFlags</code>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>bindingAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted.  </p>\n<p> -or-  </p>\n<p> Zero, to return <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a> objects representing all constructors defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> that match the specified binding constraints, including the type initializer if it is defined. Returns an empty array of type <a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a> if no constructors are defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, if none of the defined constructors match the binding constraints, or if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The GetConstructors method does not return constructors in a particular order, such as declaration order. Your code must not depend on the order in which constructors are returned, because that order varies.  </p>\n<p> <code>bindingAttr</code> can be used to specify whether to return only public constructors or both public and non-public constructors.  </p>\n<p> If an exact match does not exist, the <code>binder</code> will attempt to coerce the parameter types specified in the <code>types</code> array in order to select a match. If the <code>binder</code> is unable to select a match, then <code>null</code> is returned.  </p>\n<p> The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which constructors to include in the search:  </p>\n<ul>\n<li><p>You must specify either <code>BindingFlags.Instance</code> or <code>BindingFlags.Static</code> in order to get a return.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.Public</code> to include public constructors in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.NonPublic</code> to include non-public constructors (that is, private, internal, and protected constructors) in the search. Constructors of base classes are not returned.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.  </p>\n<p>To get the class initializer (.cctor) using this method overload, you must specify <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (<a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a><code>Or</code><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> in Visual Basic). You can also get the class initializer using the <a class=\"xref\" href=\"system.type#System_Type_TypeInitializer_\" data-linktype=\"relative-path\">TypeInitializer</a> property.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a> objects with the type parameters replaced by the appropriate type arguments. For example, if class <code>C&lt;T&gt;</code> has a constructor <code>C(T t1)</code> (<code>Sub New(ByVal t1 As T)</code> in Visual Basic), calling <a class=\"xref\" href=\"system.type#System_Type_GetConstructors_\" data-linktype=\"relative-path\">GetConstructors</a> on <code>C&lt;int&gt;</code> returns a <a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a> that represents <code>C(int t1)</code> in C# (<code>Sub New(ByVal t1 As Integer)</code> in Visual Basic).  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a generic type parameter, the <a class=\"xref\" href=\"system.type#System_Type_GetConstructors_\" data-linktype=\"relative-path\">GetConstructors</a> method returns an empty array.</p>\n</li>\n</ul>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>This example shows the output of the <a class=\"xref\" href=\"system.type#System_Type_GetConstructors\" data-linktype=\"relative-path\">GetConstructors()</a> overload from a class that has two instance constructors and one static constructor.  </p>\n<pre><code class=\"lang-vb\" name=\"Classic Type.GetConstructors Example#1\">Imports System\nImports System.Reflection\n\nPublic Class t\n    \n    Public Sub New()\n    End Sub\n    \n    Shared Sub New()\n    End Sub\n    \n    Public Sub New(i As Integer)\n    End Sub\n     \n    Public Shared Sub Main()\n        Dim p As ConstructorInfo() = GetType(t).GetConstructors()\n        Console.WriteLine(p.Length)\n        \n        Dim i As Integer\n        For i = 0 To p.Length - 1\n            Console.WriteLine(p(i).IsStatic)\n        Next i\n    End Sub\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"Classic Type.GetConstructors Example#1\"> using System;\n using System.Reflection;\n \n public class t {\n     public t() {}\n     static t() {}\n     public t(int i) {}\n \n     public static void Main() {\n         ConstructorInfo[] p = typeof(t).GetConstructors();\n         Console.WriteLine(p.Length);\n \n         for (int i=0;i&lt;p.Length;i++) {\n             Console.WriteLine(p[i].IsStatic);\n         }\n     }\n }\n</code></pre><pre><code class=\"lang-cpp\" name=\"Classic Type.GetConstructors Example#1\">using namespace System;\nusing namespace System::Reflection;\npublic ref class t\n{\npublic:\n   t(){}\n\n   static t(){}\n\n   t( int /*i*/ ){}\n\n};\n\nint main()\n{\n   array&lt;ConstructorInfo^&gt;^p = t::typeid-&gt;GetConstructors();\n   Console::WriteLine( p-&gt;Length );\n   for ( int i = 0; i &lt; p-&gt;Length; i++ )\n   {\n      Console::WriteLine( p[ i ]-&gt;IsStatic );\n\n   }\n}\n</code></pre><p> The output of this code is:  </p>\n<p> 2  </p>\n<p> False  </p>\n<p> False  </p>\n<p> Because the <a class=\"xref\" href=\"system.type#System_Type_GetConstructors_\" data-linktype=\"relative-path\">GetConstructors</a> overload uses only <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> and <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a>, the static constructor is neither counted by the <code>for</code> expression nor evaluated by <code>IsStatic</code>.  </p>\n<p> To find static constructors, use the GetConstructors overload, and pass it the combination (logical OR) of <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a>, <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a>, <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a>, <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a>, as shown in the following code example:  </p>\n<pre><code class=\"lang-vb\" name=\"Classic Type.GetConstructors Example#2\">Imports System\nImports System.Reflection\n\nPublic Class t\n    \n    Public Sub New()\n    End Sub\n    \n    Shared Sub New()\n    End Sub\n    \n    Public Sub New(i As Integer)\n    End Sub\n     \n    Public Shared Sub Main()\n        Dim p As ConstructorInfo() = GetType(T).GetConstructors( _\n           BindingFlags.Public Or _\n           BindingFlags.Static Or _\n           BindingFlags.NonPublic Or _\n           BindingFlags.Instance)\n        Console.WriteLine(p.Length)\n        \n        Dim i As Integer\n        For i = 0 To p.Length - 1\n            Console.WriteLine(p(i).IsStatic)\n        Next i\n    End Sub\nEnd Class\n</code></pre><pre><code class=\"lang-cpp\" name=\"Classic Type.GetConstructors Example#2\">using namespace System;\nusing namespace System::Reflection;\npublic ref class t\n{\npublic:\n   t(){}\n\n   t( int /*i*/ ){}\n\n   static t(){}\n\n};\n\nint main()\n{\n   array&lt;ConstructorInfo^&gt;^p = t::typeid-&gt;GetConstructors( static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Static | BindingFlags::NonPublic | BindingFlags::Instance) );\n   Console::WriteLine( p-&gt;Length );\n   for ( int i = 0; i &lt; p-&gt;Length; i++ )\n   {\n      Console::WriteLine( p[ i ]-&gt;IsStatic );\n   }\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Classic Type.GetConstructors Example#2\"> using System;\n using System.Reflection;\n  \n public class t {\n     public t() {}\n     static t() {}\n     public t(int i) {}\n \n     public static void Main() {\n         ConstructorInfo[] p = typeof(t).GetConstructors(\n            BindingFlags.Public | BindingFlags.Static |\n            BindingFlags.NonPublic | BindingFlags.Instance);\n         Console.WriteLine(p.Length);\n \n         for (int i=0;i&lt;p.Length;i++) {\n             Console.WriteLine(p[i].IsStatic);\n         }\n     }\n }\n</code></pre><p> Now the output is:  </p>\n<p> 3  </p>\n<p> False  </p>\n<p> True  </p>\n<p> False</p>\n\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetDefaultMembers\">\r\n    \r\n            <a id=\"System_Type_GetDefaultMembers_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetDefaultMembers()</div>        \r\n          </div>\r\n    \r\n            <p>Searches for the members defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> whose <a class=\"xref\" href=\"system.reflection.defaultmemberattribute\" data-linktype=\"relative-path\">DefaultMemberAttribute</a> is set.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a> objects representing all default members of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.  </p>\n<p> -or-  </p>\n<p> An empty array of type <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a>, if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> does not have default members.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The GetDefaultMembers method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.  </p>\n<p> This method can be overridden by a derived class.  </p>\n<p> Members include properties, methods, fields, events, and so on.  </p>\n<p> The following table shows what members of a base class are returned by the <code>Get</code> methods when reflecting on a type.  </p>\n<table>\n<thead>\n<tr>\n<th>Member Type</th>\n<th>Static</th>\n<th>Non-Static</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Constructor</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Field</td>\n<td>No</td>\n<td>Yes. A field is always hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Event</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n<tr>\n<td>Method</td>\n<td>No</td>\n<td>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Nested Type</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Property</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  </p>\n</li>\n<li><p>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  </p>\n</li>\n<li><p>Custom attributes are not part of the common type system.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a> objects with the type parameters replaced by the appropriate type arguments. For example, if class <code>C&lt;T&gt;</code> has a property <code>P</code> that returns <code>T</code>, calling GetDefaultMembers on <code>C&lt;int&gt;</code> returns <code>int P</code> in C# (<code>Property P As Integer</code> in Visual Basic).  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a> if there is no class constraint.</p>\n</li>\n</ol>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example obtains the default member information of <code>MyClass</code> and displays the default members.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_GetDefaultMembers#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::IO;\n\n[DefaultMemberAttribute(&quot;Age&quot;)]\npublic ref class MyClass\n{\npublic:\n   void Name( String^ s ){}\n\n\n   property int Age \n   {\n      int get()\n      {\n         return 20;\n      }\n\n   }\n\n};\n\nint main()\n{\n   try\n   {\n      Type^ myType = MyClass::typeid;\n      array&lt;MemberInfo^&gt;^memberInfoArray = myType-&gt;GetDefaultMembers();\n      if ( memberInfoArray-&gt;Length &gt; 0 )\n      {\n         System::Collections::IEnumerator^ myEnum = memberInfoArray-&gt;GetEnumerator();\n         while ( myEnum-&gt;MoveNext() )\n         {\n            MemberInfo^ memberInfoObj = safe_cast&lt;MemberInfo^&gt;(myEnum-&gt;Current);\n            Console::WriteLine( &quot;The default member name is: {0}&quot;, memberInfoObj );\n         }\n      }\n      else\n      {\n         Console::WriteLine( &quot;No default members are available.&quot; );\n      }\n   }\n   catch ( InvalidOperationException^ e ) \n   {\n      Console::WriteLine( &quot;InvalidOperationException: {0}&quot;, e-&gt;Message );\n   }\n   catch ( IOException^ e ) \n   {\n      Console::WriteLine( &quot;IOException: {0}&quot;, e-&gt;Message );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception: {0}&quot;, e-&gt;Message );\n   }\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_GetDefaultMembers#1\">\nusing System;\nusing System.Reflection;\nusing System.IO;\n\n[DefaultMemberAttribute(&quot;Age&quot;)]   \npublic class MyClass\n{\n    public void Name(String s) {}\n    public int Age\n    {\n        get\n        {\n            return 20;\n        }\n    }\n    public static void Main()\n    {\n        try\n        {\n            Type  myType = typeof(MyClass);\n            MemberInfo[] memberInfoArray = myType.GetDefaultMembers();\n            if (memberInfoArray.Length &gt; 0)\n            {\n                foreach(MemberInfo memberInfoObj in memberInfoArray)\n                {\n                    Console.WriteLine(&quot;The default member name is: &quot; + memberInfoObj.ToString());\n                }\n            }\n            else\n            {\n                Console.WriteLine(&quot;No default members are available.&quot;); \n            }\n        }\n        catch(InvalidOperationException e)\n        {\n            Console.WriteLine(&quot;InvalidOperationException: &quot; + e.Message);\n        }\n        catch(IOException e)\n        {\n            Console.WriteLine(&quot;IOException: &quot; + e.Message);\n        }\n        catch(Exception e)\n        {\n            Console.WriteLine(&quot;Exception: &quot; + e.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetDefaultMembers#1\">Imports System\nImports System.Reflection\nImports System.IO\nImports Microsoft.VisualBasic\n\n&lt;DefaultMemberAttribute(&quot;Age&quot;)&gt; Public Class [MyClass]\n\n    Public Sub Name(ByVal s As String)\n    End Sub &#39;Name\n\n    Public ReadOnly Property Age() As Integer\n        Get\n            Return 20\n        End Get\n    End Property\n\n    Public Shared Sub Main()\n        Try\n            Dim myType As Type = GetType([MyClass])\n            Dim memberInfoArray As MemberInfo() = myType.GetDefaultMembers()\n            If memberInfoArray.Length &gt; 0 Then\n                Dim memberInfoObj As MemberInfo\n                For Each memberInfoObj In memberInfoArray\n                    Console.WriteLine(&quot;The default member name is: &quot; + memberInfoObj.ToString())\n                Next memberInfoObj\n            Else\n                Console.WriteLine(&quot;No default members are available.&quot;)\n            End If\n        Catch e As InvalidOperationException\n            Console.WriteLine(&quot;InvalidOperationException: &quot; + e.Message)\n        Catch e As IOException\n            Console.WriteLine(&quot;IOException: &quot; + e.Message)\n        Catch e As Exception\n            Console.WriteLine(&quot;Exception: &quot; + e.Message)\n        End Try\n    End Sub &#39;Main\nEnd Class &#39;[MyClass]\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetElementType\">\r\n    \r\n            <a id=\"System_Type_GetElementType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetElementType()</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, returns the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> of the object encompassed or referred to by the current array, pointer or reference type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract Type GetElementType ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>The <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> of the object encompassed or referred to by the current array, pointer, or reference type, or <code>null</code> if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method returns <code>null</code> for the <a class=\"xref\" href=\"system.array\" data-linktype=\"relative-path\">Array</a> class.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example demonstrates using the <code>GetElementType</code> method.  </p>\n<pre><code class=\"lang-cs\" name=\"TestGetElementType#1\">using System;\nclass TestGetElementType \n{\n    public static void Main() \n    {\n        int[] array = {1,2,3};\n        Type t = array.GetType();\n        Type t2 = t.GetElementType();\n        Console.WriteLine(&quot;The element type of {0} is {1}.&quot;,array, t2.ToString());\n        TestGetElementType newMe = new TestGetElementType();\n        t = newMe.GetType();\n        t2 = t.GetElementType();\n        Console.WriteLine(&quot;The element type of {0} is {1}.&quot;, newMe, t2==null? &quot;null&quot; : t2.ToString());\n    }\n}\n\n/* This code produces the following output:\n\nThe element type of System.Int32[] is System.Int32.\nThe element type of TestGetElementType is null.\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"TestGetElementType#1\">Imports System\n\nClass TestGetElementType\n\n    Public Shared Sub Main()\n        Dim array As Integer() = {1, 2, 3}\n        Dim t As Type = array.GetType()\n        Dim t2 As Type = t.GetElementType()\n        Console.WriteLine(&quot;The element type of {0} is {1}.&quot;, array, t2.ToString())\n        Dim newMe As New TestGetElementType()\n        t = newMe.GetType()\n        t2 = t.GetElementType()\n        If t2 Is Nothing Then\n            Console.WriteLine(&quot;The element type of {0} is {1}.&quot;, newMe, &quot;null&quot;)\n        Else\n            Console.WriteLine(&quot;The element type of {0} is {1}.&quot;, newMe, t2.ToString())\n        End If\n    End Sub &#39;Main\nEnd Class &#39;TestGetElementType\n\n&#39; This code produces the following output:\n&#39;\n&#39;The element type of System.Int32[] is System.Int32.\n&#39;The element type of TestGetElementType is null.\n</code></pre><pre><code class=\"lang-cpp\" name=\"TestGetElementType#1\">using namespace System;\npublic ref class TestGetElementType{};\n\nint main()\n{\n   array&lt;Int32&gt;^array = {1,2,3};\n   Type^ t = array-&gt;GetType();\n   Type^ t2 = t-&gt;GetElementType();\n   Console::WriteLine( &quot;The element type of {0} is {1}.&quot;, array, t2 );\n   TestGetElementType^ newMe = gcnew TestGetElementType;\n   t = newMe-&gt;GetType();\n   t2 = t-&gt;GetElementType();\n   Console::WriteLine( &quot;The element type of {0} is {1}.&quot;, newMe, t2 == nullptr ? &quot;null&quot; : t2-&gt;ToString() );\n}\n\n/* This code produces the following output:\n\nThe element type of System.Int32[] is System.Int32.\nThe element type of TestGetElementType is null.\n */\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetEnumName_System_Object_\">\r\n    \r\n            <a id=\"System_Type_GetEnumName_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetEnumName(Object)</div>        \r\n          </div>\r\n    \r\n            <p>Returns the name of the constant that has the specified value, for the current enumeration type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual string GetEnumName (object value);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>value</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The value whose name is to be retrieved.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </div>\r\n                  <p>The name of the member of the current enumeration type that has the specified value, or <code>null</code> if no such constant is found.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p>The current type is not an enumeration.  </p>\n<p> -or-  </p>\n<p> <code>value</code> is neither of the current type nor does it have the same underlying type as the current type.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>value</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetEnumNames\">\r\n    \r\n            <a id=\"System_Type_GetEnumNames_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetEnumNames()</div>        \r\n          </div>\r\n    \r\n            <p>Returns the names of the members of the current enumeration type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual string[] GetEnumNames ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>[]</div>\r\n                  </div>\r\n                  <p>An array that contains the names of the members of the enumeration.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p>The current type is not an enumeration.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants. If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetEnumUnderlyingType\">\r\n    \r\n            <a id=\"System_Type_GetEnumUnderlyingType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetEnumUnderlyingType()</div>        \r\n          </div>\r\n    \r\n            <p>Returns the underlying type of the current enumeration type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual Type GetEnumUnderlyingType ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>The underlying type of the current enumeration.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p>The current type is not an enumeration.  </p>\n<p> -or-  </p>\n<p> The enumeration type is not valid, because it contains more than one instance field.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>By default, the underlying type of an enumeration in C# and Visual Basic is <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a>. Other integer types can be specified.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetEnumValues\">\r\n    \r\n            <a id=\"System_Type_GetEnumValues_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetEnumValues()</div>        \r\n          </div>\r\n    \r\n            <p>Returns an array of the values of the constants in the current enumeration type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual Array GetEnumValues ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.array\" data-linktype=\"relative-path\">Array</a></div>\r\n                  </div>\r\n                  <p>An array that contains the values. The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p>The current type is not an enumeration.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetEvent_System_String_\">\r\n    \r\n            <a id=\"System_Type_GetEvent_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetEvent(String)</div>        \r\n          </div>\r\n    \r\n            <p>Returns the <a class=\"xref\" href=\"system.reflection.eventinfo\" data-linktype=\"relative-path\">EventInfo</a> object representing the specified public event.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.EventInfo GetEvent (string name);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of an event that is declared or inherited by the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.eventinfo\" data-linktype=\"relative-path\">EventInfo</a></div>\r\n                  </div>\r\n                  <p>The object representing the specified public event that is declared or inherited by the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>An event is considered public to reflection if it has at least one method or accessor that is public. Otherwise the event is considered private, and you must use <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (in Visual Basic, combine the values using <code>Or</code>) to get it.  </p>\n<p> The search for <code>name</code> is case-sensitive. The search includes public static and public instance events.  </p>\n<p> The following table shows what members of a base class are returned by the <code>Get</code> methods when reflecting on a type.  </p>\n<table>\n<thead>\n<tr>\n<th>Member Type</th>\n<th>Static</th>\n<th>Non-Static</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Constructor</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Field</td>\n<td>No</td>\n<td>Yes. A field is always hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Event</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n<tr>\n<td>Method</td>\n<td>No</td>\n<td>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Nested Type</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Property</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  </p>\n</li>\n<li><p>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  </p>\n</li>\n<li><p>Custom attributes are not part of the common type system.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.eventinfo\" data-linktype=\"relative-path\">EventInfo</a> with the type parameters replaced by the appropriate type arguments.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</p>\n</li>\n</ol>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates an <a class=\"xref\" href=\"system.reflection.eventinfo\" data-linktype=\"relative-path\">EventInfo</a> object and gets the event for a button class for the specified event.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_GetEvent#1\">using System;\nusing System.Reflection;\nusing System.Security;\n\nclass MyEventExample\n{\n    public static void Main()\n    {  \n        try\n        {\n\n            Type myType = typeof(System.Windows.Forms.Button);\n            EventInfo myEvent = myType.GetEvent(&quot;Click&quot;);\n            if(myEvent != null)\n            {\n                Console.WriteLine(&quot;Looking for the Click event in the Button class.&quot;);\n                Console.WriteLine(myEvent.ToString());\n            }\n            else\n                Console.WriteLine(&quot;The Click event is not available in the Button class.&quot;);\n        }\n        catch(SecurityException e)\n        {\n            Console.WriteLine(&quot;An exception occurred.&quot;);\n            Console.WriteLine(&quot;Message :&quot;+e.Message);\n        }\n        catch(ArgumentNullException e)\n        {\n            Console.WriteLine(&quot;An exception occurred.&quot;);\n            Console.WriteLine(&quot;Message :&quot;+e.Message);\n        }\n        catch(Exception e)\n        {\n            Console.WriteLine(&quot;The following exception was raised : {0}&quot;,e.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetEvent#1\">Imports System\nImports System.Reflection\nImports System.Security\nImports Microsoft.VisualBasic\n\n&#39; Compile this sample using the following command line:\n&#39; vbc type_getevent.vb /r:&quot;System.Windows.Forms.dll&quot; /r:&quot;System.dll&quot;\n\nClass MyEventExample\n    Public Shared Sub Main()\n        Try\n            Dim myType As Type = GetType(System.Windows.Forms.Button)\n            Dim myEvent As EventInfo = myType.GetEvent(&quot;Click&quot;)\n            If Not (myEvent Is Nothing) Then\n                Console.WriteLine(ControlChars.Cr + &quot;Looking for the Click event in the Button class.&quot;)\n                Console.WriteLine(ControlChars.Cr + myEvent.ToString())\n            Else\n                Console.WriteLine(&quot;The Click event is not available with the Button class.&quot;)\n            End If\n        Catch e As SecurityException\n            Console.WriteLine(&quot;An exception occurred.&quot;)\n            Console.WriteLine(&quot;Message :&quot; + e.Message)\n        Catch e As ArgumentNullException\n            Console.WriteLine(&quot;An exception occurred.&quot;)\n            Console.WriteLine(&quot;Message :&quot; + e.Message)\n        Catch e As Exception\n            Console.WriteLine(&quot;The following exception was raised : {0}&quot;, e.Message)\n        End Try\n    End Sub &#39;Main\nEnd Class &#39;MyEventExample\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetEvent#1\">#using &lt;system.dll&gt;\n#using &lt;system.windows.forms.dll&gt;\n#using &lt;system.drawing.dll&gt;\n\nusing namespace System;\nusing namespace System::Reflection;\nusing namespace System::Security;\n\nint main()\n{\n   try\n   {\n      Type^ myType = System::Windows::Forms::Button::typeid;\n      EventInfo^ myEvent = myType-&gt;GetEvent( &quot;Click&quot; );\n      if ( myEvent != nullptr )\n      {\n         Console::WriteLine( &quot;Looking for the Click event in the Button class.&quot; );\n         Console::WriteLine( myEvent );\n      }\n      else\n            Console::WriteLine( &quot;The Click event is not available in the Button class.&quot; );\n   }\n   catch ( SecurityException^ e ) \n   {\n      Console::WriteLine( &quot;An exception occurred.&quot; );\n      Console::WriteLine( &quot;Message : {0}&quot;, e-&gt;Message );\n   }\n   catch ( ArgumentNullException^ e ) \n   {\n      Console::WriteLine( &quot;An exception occurred.&quot; );\n      Console::WriteLine( &quot;Message : {0}&quot;, e-&gt;Message );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;The following exception was raised : {0}&quot;, e-&gt;Message );\n   }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetEvent_System_String_System_Reflection_BindingFlags_\">\r\n    \r\n            <a id=\"System_Type_GetEvent_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetEvent(String,BindingFlags)</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, returns the <a class=\"xref\" href=\"system.reflection.eventinfo\" data-linktype=\"relative-path\">EventInfo</a> object representing the specified event, using the specified binding constraints.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of an event which is declared or inherited by the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>bindingAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted.  </p>\n<p> -or-  </p>\n<p> Zero, to return <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.eventinfo\" data-linktype=\"relative-path\">EventInfo</a></div>\r\n                  </div>\r\n                  <p>The object representing the specified event that is declared or inherited by the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which events to include in the search:  </p>\n<ul>\n<li><p>You must specify either <code>BindingFlags.Instance</code> or <code>BindingFlags.Static</code> in order to get a return.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.Public</code> to include public events in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.NonPublic</code> to include non-public events (that is, private, internal, and protected events) in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.FlattenHierarchy</code> to include <code>public</code> and <code>protected</code> static members up the hierarchy; <code>private</code> static members in inherited classes are not included.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> modifier flags can be used to change how the search works:  </p>\n</li>\n<li><p><code>BindingFlags.IgnoreCase</code> to ignore the case of <code>name</code>.  </p>\n</li>\n<li><p><code>BindingFlags.DeclaredOnly</code> to search only the events declared on the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, not events that were simply inherited.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.  </p>\n<p>An event is considered public to reflection if it has at least one method or accessor that is public. Otherwise the event is considered private, and you must use <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (in Visual Basic, combine the values using <code>Or</code>) to get it.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.eventinfo\" data-linktype=\"relative-path\">EventInfo</a> with the type parameters replaced by the appropriate type arguments.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</p>\n</li>\n</ul>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example uses the GetEvent method to search a type for a public or non-public event named &quot;Click&quot; that is not <code>static</code> (<code>Shared</code> in Visual Basic).  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_GetEvent1#1\">#using &lt;System.dll&gt;\n#using &lt;System.Windows.Forms.dll&gt;\n#using &lt;System.Drawing.dll&gt;\n\nusing namespace System;\nusing namespace System::Reflection;\nusing namespace System::Security;\nusing namespace System::Windows::Forms;\n\nint main()\n{\n   try\n   {\n      // Creates a bitmask based on BindingFlags.\n      BindingFlags myBindingFlags = static_cast&lt;BindingFlags&gt;(BindingFlags::Instance | BindingFlags::Public | BindingFlags::NonPublic);\n      Type^ myTypeBindingFlags = System::Windows::Forms::Button::typeid;\n      EventInfo^ myEventBindingFlags = myTypeBindingFlags-&gt;GetEvent( &quot;Click&quot;, myBindingFlags );\n      if ( myEventBindingFlags != nullptr )\n      {\n         Console::WriteLine( &quot;Looking for the Click event in the Button class with the specified BindingFlags.&quot; );\n         Console::WriteLine( myEventBindingFlags );\n      }\n      else\n            Console::WriteLine( &quot;The Click event is not available with the Button class.&quot; );\n   }\n   catch ( SecurityException^ e ) \n   {\n      Console::WriteLine( &quot;An exception occurred.&quot; );\n      Console::WriteLine( &quot;Message : {0}&quot;, e-&gt;Message );\n   }\n   catch ( ArgumentNullException^ e ) \n   {\n      Console::WriteLine( &quot;An exception occurred.&quot; );\n      Console::WriteLine( &quot;Message : {0}&quot;, e-&gt;Message );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;The following exception was raised : {0}&quot;, e-&gt;Message );\n   }\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_GetEvent1#1\">using System;\nusing System.Reflection;\nusing System.Security;\n\nclass MyEventExample\n{\n    public static void Main()\n    {  \n        try\n        {\n\n            // Creates a bitmask based on BindingFlags.\n            BindingFlags myBindingFlags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;\n            Type myTypeBindingFlags = typeof(System.Windows.Forms.Button);\n            EventInfo myEventBindingFlags = myTypeBindingFlags.GetEvent(&quot;Click&quot;, myBindingFlags);\n            if(myEventBindingFlags != null)\n            {\n                Console.WriteLine(&quot;Looking for the Click event in the Button class with the specified BindingFlags.&quot;);\n                Console.WriteLine(myEventBindingFlags.ToString());\n            }\n            else\n                Console.WriteLine(&quot;The Click event is not available with the Button class.&quot;);\n        }\n        catch(SecurityException e)\n        {\n            Console.WriteLine(&quot;An exception occurred.&quot;);\n            Console.WriteLine(&quot;Message :&quot;+e.Message);\n        }\n        catch(ArgumentNullException e)\n        {\n            Console.WriteLine(&quot;An exception occurred.&quot;);\n            Console.WriteLine(&quot;Message :&quot;+e.Message);\n        }\n        catch(Exception e)\n        {\n            Console.WriteLine(&quot;The following exception was raised : {0}&quot;,e.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetEvent1#1\">Imports System\nImports System.Reflection\nImports System.Security\nImports Microsoft.VisualBasic\n\n&#39; Compile this sample using the following command line:\n&#39; vbc type_getevent.vb /r:&quot;System.Windows.Forms.dll&quot; /r:&quot;System.dll&quot;\n\nClass MyEventExample\n    Public Shared Sub Main()\n        Try\n            &#39; Creates a bitmask comprising  BindingFlags.\n            Dim myBindingFlags As BindingFlags = BindingFlags.Instance Or BindingFlags.Public _\n                                                 Or BindingFlags.NonPublic\n            Dim myTypeBindingFlags As Type = GetType(System.Windows.Forms.Button)\n            Dim myEventBindingFlags As EventInfo = myTypeBindingFlags.GetEvent(&quot;Click&quot;, myBindingFlags)\n            If myEventBindingFlags IsNot Nothing Then\n                Console.WriteLine(&quot;Looking for the Click event in the Button class with the specified BindingFlags.&quot;)\n                Console.WriteLine(myEventBindingFlags.ToString())\n            Else\n                Console.WriteLine(&quot;The Click event is not available with the Button class.&quot;)\n            End If\n        Catch e As SecurityException\n            Console.WriteLine(&quot;An exception occurred.&quot;)\n            Console.WriteLine(&quot;Message :&quot; + e.Message)\n        Catch e As ArgumentNullException\n            Console.WriteLine(&quot;An exception occurred.&quot;)\n            Console.WriteLine(&quot;Message :&quot; + e.Message)\n        Catch e As Exception\n            Console.WriteLine(&quot;The following exception was raised : {0}&quot;, e.Message)\n        End Try\n    End Sub &#39;Main\nEnd Class &#39;MyEventExample\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetEvents\">\r\n    \r\n            <a id=\"System_Type_GetEvents_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetEvents()</div>        \r\n          </div>\r\n    \r\n            <p>Returns all the public events that are declared or inherited by the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual System.Reflection.EventInfo[] GetEvents ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.eventinfo\" data-linktype=\"relative-path\">EventInfo</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.eventinfo\" data-linktype=\"relative-path\">EventInfo</a> objects representing all the public events which are declared or inherited by the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.  </p>\n<p> -or-  </p>\n<p> An empty array of type <a class=\"xref\" href=\"system.reflection.eventinfo\" data-linktype=\"relative-path\">EventInfo</a>, if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> does not have public events.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>An event is considered public to reflection if it has at least one method or accessor that is public. Otherwise the event is considered private, and you must use <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (in Visual Basic, combine the values using <code>Or</code>) to get it.  </p>\n<p> The GetEvents method does not return events in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which events are returned, because that order varies.  </p>\n<p> This method can be overridden by a derived class.  </p>\n<p> The following table shows what members of a base class are returned by the <code>Get</code> methods when reflecting on a type.  </p>\n<table>\n<thead>\n<tr>\n<th>Member Type</th>\n<th>Static</th>\n<th>Non-Static</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Constructor</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Field</td>\n<td>No</td>\n<td>Yes. A field is always hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Event</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n<tr>\n<td>Method</td>\n<td>No</td>\n<td>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Nested Type</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Property</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  </p>\n</li>\n<li><p>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  </p>\n</li>\n<li><p>Custom attributes are not part of the common type system.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.eventinfo\" data-linktype=\"relative-path\">EventInfo</a> objects with the type parameters replaced by the appropriate type arguments.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</p>\n</li>\n</ol>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example obtains an array of <a class=\"xref\" href=\"system.reflection.eventinfo\" data-linktype=\"relative-path\">EventInfo</a> objects, gets all the events for a <code>Button</code> class, and displays the event names. To compile the Visual Basic example, use the following command line:  </p>\n<p> <code>vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll</code>  </p>\n<pre><code class=\"lang-vb\" name=\"Type_GetEvents1#1\">Imports System\nImports System.Reflection\nImports System.Security\nImports Microsoft.VisualBasic\n\n&#39; Compile this sample using the following command line:\n&#39; vbc type_getevents.vb /r:&quot;System.Windows.Forms.dll&quot; /r:&quot;System.dll&quot;\n\nClass EventsSample\n\n    Public Shared Sub Main()\n        Try\n            &#39; Creates a bitmask based on BindingFlags.\n            Dim myBindingFlags As BindingFlags = BindingFlags.Instance Or BindingFlags.Public\n            Dim myTypeEvent As Type = GetType(System.Windows.Forms.Button)\n            Dim myEventsBindingFlags As EventInfo() = myTypeEvent.GetEvents(myBindingFlags)\n            Console.WriteLine(ControlChars.Cr + &quot;The events on the Button class with the specified BindingFlags are : &quot;)\n            Dim index As Integer\n            For index = 0 To myEventsBindingFlags.Length - 1\n                Console.WriteLine(myEventsBindingFlags(index).ToString())\n            Next index\n        Catch e As SecurityException\n            Console.WriteLine((&quot;SecurityException :&quot; + e.Message))\n        Catch e As ArgumentNullException\n            Console.WriteLine((&quot;ArgumentNullException : &quot; + e.Message))\n        Catch e As Exception\n            Console.WriteLine((&quot;Exception : &quot; + e.Message))\n        End Try\n    End Sub &#39;Main\nEnd Class &#39;EventsSample\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetEvents1#1\">#using &lt;System.dll&gt;\n#using &lt;System.Windows.Forms.dll&gt;\n#using &lt;System.Drawing.dll&gt;\n\nusing namespace System;\nusing namespace System::Reflection;\nusing namespace System::Security;\n\nint main()\n{\n   try\n   {\n      Type^ myType = System::Windows::Forms::Button::typeid;\n      array&lt;EventInfo^&gt;^myEvents = myType-&gt;GetEvents();\n      Console::WriteLine( &quot;The events on the Button class are: &quot; );\n      for ( int index = 0; index &lt; myEvents-&gt;Length; index++ )\n      {\n         Console::WriteLine( myEvents[ index ] );\n\n      }\n   }\n   catch ( SecurityException^ e ) \n   {\n      Console::WriteLine( &quot;SecurityException: {0}&quot;, e-&gt;Message );\n   }\n   catch ( ArgumentNullException^ e ) \n   {\n      Console::WriteLine( &quot;ArgumentNullException: {0}&quot;, e-&gt;Message );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception: {0}&quot;, e-&gt;Message );\n   }\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_GetEvents1#1\">using System;\nusing System.Reflection;\nusing System.Security;\n\nclass EventsSample\n{\n    public static void Main()\n    { \n        try\n        {\n            // Creates a bitmask based on BindingFlags.\n            BindingFlags myBindingFlags = BindingFlags.Instance | BindingFlags.Public;  \n            Type myTypeEvent = typeof(System.Windows.Forms.Button);\n            EventInfo[] myEventsBindingFlags = myTypeEvent.GetEvents(myBindingFlags);\n            Console.WriteLine(&quot;<br>The events on the Button class with the specified BindingFlags are : &quot;);\n            for (int index = 0; index &lt; myEventsBindingFlags.Length; index++)\n            {\n                Console.WriteLine(myEventsBindingFlags[index].ToString());\n            }\n        }\n        catch(SecurityException e)\n        {\n            Console.WriteLine(&quot;SecurityException :&quot; + e.Message);\n        }\n        catch(ArgumentNullException e)\n        {\n            Console.WriteLine(&quot;ArgumentNullException : &quot; + e.Message);\n        }\n        catch(Exception e)\n        {\n            Console.WriteLine(&quot;Exception : &quot; + e.Message);\n        }\n    }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetEvents_System_Reflection_BindingFlags_\">\r\n    \r\n            <a id=\"System_Type_GetEvents_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetEvents(BindingFlags)</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, searches for events that are declared or inherited by the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, using the specified binding constraints.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>bindingAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted.  </p>\n<p> -or-  </p>\n<p> Zero, to return <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.eventinfo\" data-linktype=\"relative-path\">EventInfo</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.eventinfo\" data-linktype=\"relative-path\">EventInfo</a> objects representing all events that are declared or inherited by the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> that match the specified binding constraints.  </p>\n<p> -or-  </p>\n<p> An empty array of type <a class=\"xref\" href=\"system.reflection.eventinfo\" data-linktype=\"relative-path\">EventInfo</a>, if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> does not have events, or if none of the events match the binding constraints.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The GetEvents method does not return events in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which events are returned, because that order varies.  </p>\n<p> The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which events to include in the search:  </p>\n<ul>\n<li><p>You must specify either <code>BindingFlags.Instance</code> or <code>BindingFlags.Static</code> in order to get a return.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.Public</code> to include public events in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.NonPublic</code> to include non-public events (that is, private, internal, and protected events) in the search. Only protected and internal events on base classes are returned; private events on base classes are not returned.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.FlattenHierarchy</code> to include <code>public</code> and <code>protected</code> static members up the hierarchy; <code>private</code> static members in inherited classes are not included.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> modifier flags can be used to change how the search works:  </p>\n</li>\n<li><p><code>BindingFlags.DeclaredOnly</code> to search only the events declared on the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, not events that were simply inherited.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.  </p>\n<p>An event is considered public to reflection if it has at least one method or accessor that is public. Otherwise the event is considered private, and you must use <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (in Visual Basic, combine the values using <code>Or</code>) to get it.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.eventinfo\" data-linktype=\"relative-path\">EventInfo</a> objects with the type parameters replaced by the appropriate type arguments.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</p>\n</li>\n</ul>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example obtains an array of <a class=\"xref\" href=\"system.reflection.eventinfo\" data-linktype=\"relative-path\">EventInfo</a> objects that match the specified binding flags, gets all the events for a <code>Button</code> class, and displays the event names. To compile the Visual Basic example, use the following command line:  </p>\n<p> <code>vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll</code>  </p>\n<pre><code class=\"lang-cs\" name=\"Type_GetEvents2#1\">using System;\nusing System.Reflection;\nusing System.Security;\n\nclass EventsSample\n{\n    public static void Main()\n    { \n        try\n        {\n            // Create a bitmask based on BindingFlags.\n            BindingFlags myBindingFlags = BindingFlags.Instance | BindingFlags.Public;  \n            Type myTypeEvent = typeof(System.Windows.Forms.Button);\n            EventInfo[] myEventsBindingFlags = myTypeEvent.GetEvents(myBindingFlags);\n            Console.WriteLine(&quot;<br>The events on the Button class with the specified BindingFlags are:&quot;);\n            for (int index = 0; index &lt; myEventsBindingFlags.Length; index++)\n            {\n                Console.WriteLine(myEventsBindingFlags[index].ToString());\n            }\n        }\n        catch(SecurityException e)\n        {\n            Console.WriteLine(&quot;SecurityException:&quot; + e.Message);\n        }\n        catch(ArgumentNullException e)\n        {\n            Console.WriteLine(&quot;ArgumentNullException: &quot; + e.Message);\n        }\n        catch(Exception e)\n        {\n            Console.WriteLine(&quot;Exception: &quot; + e.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetEvents2#1\">#using &lt;System.dll&gt;\n#using &lt;System.Windows.Forms.dll&gt;\n#using &lt;System.Drawing.dll&gt;\n\nusing namespace System;\nusing namespace System::Reflection;\nusing namespace System::Security;\n\nint main()\n{\n   try\n   {\n      \n      // Create a bitmask based on BindingFlags.\n      BindingFlags myBindingFlags = static_cast&lt;BindingFlags&gt;(BindingFlags::Instance | BindingFlags::Public);\n      Type^ myTypeEvent = System::Windows::Forms::Button::typeid;\n      array&lt;EventInfo^&gt;^myEventsBindingFlags = myTypeEvent-&gt;GetEvents( myBindingFlags );\n      Console::WriteLine( &quot;<br>The events on the Button class with the specified BindingFlags are:&quot; );\n      for ( int index = 0; index &lt; myEventsBindingFlags-&gt;Length; index++ )\n      {\n         Console::WriteLine( myEventsBindingFlags[ index ] );\n\n      }\n   }\n   catch ( SecurityException^ e ) \n   {\n      Console::WriteLine( &quot;SecurityException: {0}&quot;, e-&gt;Message );\n   }\n   catch ( ArgumentNullException^ e ) \n   {\n      Console::WriteLine( &quot;ArgumentNullException: {0}&quot;, e-&gt;Message );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception: {0}&quot;, e-&gt;Message );\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetEvents2#1\">Imports System\nImports System.Reflection\nImports System.Security\nImports System.Windows.Forms\nImports Microsoft.VisualBasic\n\nClass EventsSample\n\n    Public Shared Sub Main()\n        Try\n            &#39; Create a bitmask based on BindingFlags.\n            Dim myBindingFlags As BindingFlags = BindingFlags.Instance Or BindingFlags.Public\n            Dim myTypeEvent As Type = GetType(System.Windows.Forms.Button)\n            Dim myEventsBindingFlags As EventInfo() = myTypeEvent.GetEvents(myBindingFlags)\n            Console.WriteLine(ControlChars.Cr + &quot;The events on the Button class with the specified BindingFlags are:&quot;)\n            Dim index As Integer\n            For index = 0 To myEventsBindingFlags.Length - 1\n                Console.WriteLine(myEventsBindingFlags(index).ToString())\n            Next index\n        Catch e As SecurityException\n            Console.WriteLine(&quot;SecurityException:&quot; + e.Message)\n        Catch e As ArgumentNullException\n            Console.WriteLine(&quot;ArgumentNullException: &quot; + e.Message)\n        Catch e As Exception\n            Console.WriteLine(&quot;Exception: &quot; + e.Message)\n        End Try\n    End Sub &#39;Main\nEnd Class &#39;EventsSample\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetField_System_String_\">\r\n    \r\n            <a id=\"System_Type_GetField_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetField(String)</div>        \r\n          </div>\r\n    \r\n            <p>Searches for the public field with the specified name.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.FieldInfo GetField (string name);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the data field to get.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.fieldinfo\" data-linktype=\"relative-path\">FieldInfo</a></div>\r\n                  </div>\r\n                  <p>An object representing the public field with the specified name, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>This <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object is a <a class=\"xref\" href=\"system.reflection.emit.typebuilder\" data-linktype=\"relative-path\">TypeBuilder</a> whose <span class=\"xref\">stem.Reflection.Emit.TypeBuilder.CreateType*</span> method has not yet been called.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The search for <code>name</code> is case-sensitive. The search includes public static and public instance fields.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.fieldinfo\" data-linktype=\"relative-path\">FieldInfo</a> with the type parameters replaced by the appropriate type arguments.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example gets the <code>Type</code> object for the specified class, obtains the <a class=\"xref\" href=\"system.reflection.fieldinfo\" data-linktype=\"relative-path\">FieldInfo</a> object for the field, and displays the value of the field.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_GetField#1\">\nusing System;\nusing System.Reflection;\n\npublic class MyFieldClassA\n{\n    public string Field = &quot;A Field&quot;;\n}\n\npublic class MyFieldClassB\n{\n    private string field = &quot;B Field&quot;;\n    public string Field \n    {\n        get\n        {\n            return field;\n        }\n        set\n        {\n            if (field!=value)\n            {\n                field=value;\n            }\n        }\n    }\n}\n\npublic class MyFieldInfoClass\n{\n    public static void Main()\n    {\n        MyFieldClassB myFieldObjectB = new MyFieldClassB();\n        MyFieldClassA myFieldObjectA = new MyFieldClassA();\n\n        Type myTypeA = typeof(MyFieldClassA);\n        FieldInfo myFieldInfo = myTypeA.GetField(&quot;Field&quot;);\n\n        Type myTypeB = typeof(MyFieldClassB);\n        FieldInfo myFieldInfo1 = myTypeB.GetField(&quot;field&quot;, \n            BindingFlags.NonPublic | BindingFlags.Instance);\n\n        Console.WriteLine(&quot;The value of the public field is: &#39;{0}&#39;&quot;, \n            myFieldInfo.GetValue(myFieldObjectA));\n        Console.WriteLine(&quot;The value of the private field is: &#39;{0}&#39;&quot;, \n            myFieldInfo1.GetValue(myFieldObjectB));\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetField#1\">\nImports System\nImports System.Reflection\nImports Microsoft.VisualBasic\n\nPublic Class MyFieldClassA\n    Public Field As String = &quot;A Field&quot;\nEnd Class &#39;MyFieldClassA\n\nPublic Class MyFieldClassB\n    Private myField As String = &quot;B Field&quot;\n\n    Public Property Field() As String\n        Get\n            Return myField\n        End Get\n        Set(ByVal Value As String)\n            If myField &lt;&gt; value Then\n                myField = value\n            End If\n        End Set\n    End Property\nEnd Class &#39;MyFieldClassB\n\n\nPublic Class MyFieldInfoClass\n\n    Public Shared Sub Main()\n        Dim myFieldObjectB As New MyFieldClassB()\n        Dim myFieldObjectA As New MyFieldClassA()\n\n        Dim myTypeA As Type = GetType(MyFieldClassA)\n        Dim myFieldInfo As FieldInfo = myTypeA.GetField(&quot;Field&quot;)\n\n        Dim myTypeB As Type = GetType(MyFieldClassB)\n        Dim myFieldInfo1 As FieldInfo = myTypeB.GetField(&quot;myField&quot;, _\n            BindingFlags.NonPublic Or BindingFlags.Instance)\n\n        Console.WriteLine(&quot;The value of the public field is: &#39;{0}&#39;&quot;, _\n            myFieldInfo.GetValue(myFieldObjectA))\n        Console.WriteLine(&quot;The value of the private field is: &#39;{0}&#39;&quot;, _\n            myFieldInfo1.GetValue(myFieldObjectB))\n    End Sub &#39;Main\n\nEnd Class &#39;MyFieldInfoClass\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetField#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Security;\npublic ref class MyFieldClassA\n{\npublic:\n   String^ field;\n   MyFieldClassA()\n   {\n      field = &quot;A Field&quot;;\n   }\n\n\n   property String^ Field \n   {\n      String^ get()\n      {\n         return field;\n      }\n\n      void set( String^ value )\n      {\n         if ( field != value )\n         {\n            field = value;\n         }\n      }\n\n   }\n\n};\n\npublic ref class MyFieldClassB\n{\npublic:\n   String^ field;\n   MyFieldClassB()\n   {\n      field = &quot;B Field&quot;;\n   }\n\n\n   property String^ Field \n   {\n      String^ get()\n      {\n         return field;\n      }\n\n      void set( String^ value )\n      {\n         if ( field != value )\n         {\n            field = value;\n         }\n      }\n\n   }\n\n};\n\nint main()\n{\n   try\n   {\n      MyFieldClassB^ myFieldObjectB = gcnew MyFieldClassB;\n      MyFieldClassA^ myFieldObjectA = gcnew MyFieldClassA;\n      Type^ myTypeA = Type::GetType( &quot;MyFieldClassA&quot; );\n      FieldInfo^ myFieldInfo = myTypeA-&gt;GetField( &quot;field&quot; );\n      Type^ myTypeB = Type::GetType( &quot;MyFieldClassB&quot; );\n      FieldInfo^ myFieldInfo1 = myTypeB-&gt;GetField( &quot;field&quot;, static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Instance) );\n      Console::WriteLine( &quot;The value of the field is : {0} &quot;, myFieldInfo-&gt;GetValue( myFieldObjectA ) );\n      Console::WriteLine( &quot;The value of the field is : {0} &quot;, myFieldInfo1-&gt;GetValue( myFieldObjectB ) );\n   }\n   catch ( SecurityException^ e ) \n   {\n      Console::WriteLine( &quot;Exception Raised!&quot; );\n      Console::WriteLine( &quot;Message : {0}&quot;, e-&gt;Message );\n   }\n   catch ( ArgumentNullException^ e ) \n   {\n      Console::WriteLine( &quot;Exception Raised!&quot; );\n      Console::WriteLine( &quot;Message : {0}&quot;, e-&gt;Message );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception Raised!&quot; );\n      Console::WriteLine( &quot;Message : {0}&quot;, e-&gt;Message );\n   }\n\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetField_System_String_System_Reflection_BindingFlags_\">\r\n    \r\n            <a id=\"System_Type_GetField_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetField(String,BindingFlags)</div>        \r\n          </div>\r\n    \r\n            <p>Searches for the specified field, using the specified binding constraints.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the data field to get.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>bindingAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted.  </p>\n<p> -or-  </p>\n<p> Zero, to return <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.fieldinfo\" data-linktype=\"relative-path\">FieldInfo</a></div>\r\n                  </div>\r\n                  <p>An object representing the field that matches the specified requirements, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The following table shows what members of a base class are returned by the <code>Get</code> methods when reflecting on a type.  </p>\n<table>\n<thead>\n<tr>\n<th>Member Type</th>\n<th>Static</th>\n<th>Non-Static</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Constructor</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Field</td>\n<td>No</td>\n<td>Yes. A field is always hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Event</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n<tr>\n<td>Method</td>\n<td>No</td>\n<td>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Nested Type</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Property</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  </p>\n</li>\n<li><p>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  </p>\n</li>\n<li><p>Custom attributes are not part of the common type system.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which fields to include in the search:  </p>\n</li>\n</ol>\n<ul>\n<li><p>You must specify either <code>BindingFlags.Instance</code> or <code>BindingFlags.Static</code> in order to get a return.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.Public</code> to include public fields in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.NonPublic</code> to include non-public fields (that is, private, internal, and protected fields) in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.FlattenHierarchy</code> to include <code>public</code> and <code>protected</code> static members up the hierarchy; <code>private</code> static members in inherited classes are not included.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> modifier flags can be used to change how the search works:  </p>\n</li>\n<li><p><code>BindingFlags.IgnoreCase</code> to ignore the case of <code>name</code>.  </p>\n</li>\n<li><p><code>BindingFlags.DeclaredOnly</code> to search only the fields declared on the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, not fields that were simply inherited.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.fieldinfo\" data-linktype=\"relative-path\">FieldInfo</a> with the type parameters replaced by the appropriate type arguments.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</p>\n</li>\n</ul>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example gets the <code>Type</code> object for the specified class, obtains the <a class=\"xref\" href=\"system.reflection.fieldinfo\" data-linktype=\"relative-path\">FieldInfo</a> object for the field that matches the specified binding flags, and displays the value of the field.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_GetField#2\">\nusing System;\nusing System.Reflection;\n\npublic class MyFieldClassA\n{\n    public string Field = &quot;A Field&quot;;\n}\n\npublic class MyFieldClassB\n{\n    private string field = &quot;B Field&quot;;\n    public string Field \n    {\n        get\n        {\n            return field;\n        }\n        set\n        {\n            if (field!=value)\n            {\n                field=value;\n            }\n        }\n    }\n}\n\npublic class MyFieldInfoClass\n{\n    public static void Main()\n    {\n        MyFieldClassB myFieldObjectB = new MyFieldClassB();\n        MyFieldClassA myFieldObjectA = new MyFieldClassA();\n\n        Type myTypeA = typeof(MyFieldClassA);\n        FieldInfo myFieldInfo = myTypeA.GetField(&quot;Field&quot;);\n\n        Type myTypeB = typeof(MyFieldClassB);\n        FieldInfo myFieldInfo1 = myTypeB.GetField(&quot;field&quot;, \n            BindingFlags.NonPublic | BindingFlags.Instance);\n\n        Console.WriteLine(&quot;The value of the public field is: &#39;{0}&#39;&quot;, \n            myFieldInfo.GetValue(myFieldObjectA));\n        Console.WriteLine(&quot;The value of the private field is: &#39;{0}&#39;&quot;, \n            myFieldInfo1.GetValue(myFieldObjectB));\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetField#2\">\nImports System\nImports System.Reflection\nImports Microsoft.VisualBasic\n\nPublic Class MyFieldClassA\n    Public Field As String = &quot;A Field&quot;\nEnd Class &#39;MyFieldClassA\n\nPublic Class MyFieldClassB\n    Private myField As String = &quot;B Field&quot;\n\n    Public Property Field() As String\n        Get\n            Return myField\n        End Get\n        Set(ByVal Value As String)\n            If myField &lt;&gt; value Then\n                myField = value\n            End If\n        End Set\n    End Property\nEnd Class &#39;MyFieldClassB\n\n\nPublic Class MyFieldInfoClass\n\n    Public Shared Sub Main()\n        Dim myFieldObjectB As New MyFieldClassB()\n        Dim myFieldObjectA As New MyFieldClassA()\n\n        Dim myTypeA As Type = GetType(MyFieldClassA)\n        Dim myFieldInfo As FieldInfo = myTypeA.GetField(&quot;Field&quot;)\n\n        Dim myTypeB As Type = GetType(MyFieldClassB)\n        Dim myFieldInfo1 As FieldInfo = myTypeB.GetField(&quot;myField&quot;, _\n            BindingFlags.NonPublic Or BindingFlags.Instance)\n\n        Console.WriteLine(&quot;The value of the public field is: &#39;{0}&#39;&quot;, _\n            myFieldInfo.GetValue(myFieldObjectA))\n        Console.WriteLine(&quot;The value of the private field is: &#39;{0}&#39;&quot;, _\n            myFieldInfo1.GetValue(myFieldObjectB))\n    End Sub &#39;Main\n\nEnd Class &#39;MyFieldInfoClass\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetField#2\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Security;\npublic ref class MyFieldClassA\n{\npublic:\n   String^ field;\n   MyFieldClassA()\n   {\n      field = &quot;A Field&quot;;\n   }\n\n\n   property String^ Field \n   {\n      String^ get()\n      {\n         return field;\n      }\n\n      void set( String^ value )\n      {\n         if ( field != value )\n         {\n            field = value;\n         }\n      }\n\n   }\n\n};\n\npublic ref class MyFieldClassB\n{\npublic:\n   String^ field;\n   MyFieldClassB()\n   {\n      field = &quot;B Field&quot;;\n   }\n\n\n   property String^ Field \n   {\n      String^ get()\n      {\n         return field;\n      }\n\n      void set( String^ value )\n      {\n         if ( field != value )\n         {\n            field = value;\n         }\n      }\n\n   }\n\n};\n\nint main()\n{\n   try\n   {\n      MyFieldClassB^ myFieldObjectB = gcnew MyFieldClassB;\n      MyFieldClassA^ myFieldObjectA = gcnew MyFieldClassA;\n      Type^ myTypeA = Type::GetType( &quot;MyFieldClassA&quot; );\n      FieldInfo^ myFieldInfo = myTypeA-&gt;GetField( &quot;field&quot; );\n      Type^ myTypeB = Type::GetType( &quot;MyFieldClassB&quot; );\n      FieldInfo^ myFieldInfo1 = myTypeB-&gt;GetField( &quot;field&quot;, static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Instance) );\n      Console::WriteLine( &quot;The value of the field is : {0} &quot;, myFieldInfo-&gt;GetValue( myFieldObjectA ) );\n      Console::WriteLine( &quot;The value of the field is : {0} &quot;, myFieldInfo1-&gt;GetValue( myFieldObjectB ) );\n   }\n   catch ( SecurityException^ e ) \n   {\n      Console::WriteLine( &quot;Exception Raised!&quot; );\n      Console::WriteLine( &quot;Message : {0}&quot;, e-&gt;Message );\n   }\n   catch ( ArgumentNullException^ e ) \n   {\n      Console::WriteLine( &quot;Exception Raised!&quot; );\n      Console::WriteLine( &quot;Message : {0}&quot;, e-&gt;Message );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception Raised!&quot; );\n      Console::WriteLine( &quot;Message : {0}&quot;, e-&gt;Message );\n   }\n\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetFields\">\r\n    \r\n            <a id=\"System_Type_GetFields_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetFields()</div>        \r\n          </div>\r\n    \r\n            <p>Returns all the public fields of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.FieldInfo[] GetFields ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.fieldinfo\" data-linktype=\"relative-path\">FieldInfo</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.fieldinfo\" data-linktype=\"relative-path\">FieldInfo</a> objects representing all the public fields defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.  </p>\n<p> -or-  </p>\n<p> An empty array of type <a class=\"xref\" href=\"system.reflection.fieldinfo\" data-linktype=\"relative-path\">FieldInfo</a>, if no public fields are defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The GetFields method does not return fields in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which fields are returned, because that order varies.  </p>\n<p> The following table shows what members of a base class are returned by the <code>Get</code> methods when reflecting on a type.  </p>\n<table>\n<thead>\n<tr>\n<th>Member Type</th>\n<th>Static</th>\n<th>Non-Static</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Constructor</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Field</td>\n<td>No</td>\n<td>Yes. A field is always hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Event</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n<tr>\n<td>Method</td>\n<td>No</td>\n<td>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Nested Type</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Property</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  </p>\n</li>\n<li><p>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  </p>\n</li>\n<li><p>Custom attributes are not part of the common type system.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.fieldinfo\" data-linktype=\"relative-path\">FieldInfo</a> objects with the type parameters replaced by the appropriate type arguments.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</p>\n</li>\n</ol>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example shows a use of the <code>GetFields()</code> method.  </p>\n<pre><code class=\"lang-cs\" name=\"FieldInfo_IsSpecialName#1\">using System;\nusing System.Reflection;\nusing System.ComponentModel.Design;\n\n\nclass FieldInfo_IsSpecialName\n{\n    public static void Main()\n    {     \n        try\n        {\n            // Get the type handle of a specified class.\n            Type myType = typeof(ViewTechnology);\n         \n            // Get the fields of the specified class.\n            FieldInfo[] myField = myType.GetFields();\n\n            Console.WriteLine(&quot;<br>Displaying fields that have SpecialName attributes:<br>&quot;);\n            for(int i = 0; i &lt; myField.Length; i++)\n            {\n                // Determine whether or not each field is a special name.\n                if(myField[i].IsSpecialName)\n                {\n                    Console.WriteLine(&quot;The field {0} has a SpecialName attribute.&quot;,\n                        myField[i].Name);\n                }\n            }\n        }\n        catch(Exception e)\n        {\n            Console.WriteLine(&quot;Exception : {0} &quot; , e.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"FieldInfo_IsSpecialName#1\">Imports System\nImports System.Reflection\nImports System.ComponentModel.Design\nImports Microsoft.VisualBasic\n\nClass FieldInfo_IsSpecialName\n\n    Public Shared Sub Main()\n        Try\n            &#39; Get the type handle of a specified class.\n            Dim myType As Type = GetType(ViewTechnology)\n\n            &#39; Get the fields of a specified class.\n            Dim myField As FieldInfo() = myType.GetFields()\n\n            Console.WriteLine(ControlChars.Cr + &quot;Displaying fields that have SpecialName attributes:&quot; + ControlChars.Cr)\n            Dim i As Integer\n            For i = 0 To myField.Length - 1\n                &#39; Determine whether or not each field is a special name.\n                If myField(i).IsSpecialName Then\n                    Console.WriteLine(&quot;The field {0} has a SpecialName attribute.&quot;, myField(i).Name)\n                End If\n            Next i\n        Catch e As Exception\n            Console.WriteLine(&quot;Exception : {0} &quot;, e.Message.ToString())\n        End Try\n    End Sub &#39;Main\nEnd Class &#39;FieldInfo_IsSpecialName\n</code></pre><pre><code class=\"lang-cpp\" name=\"FieldInfo_IsSpecialName#1\">#using &lt;system.dll&gt;\n\nusing namespace System;\nusing namespace System::Reflection;\nusing namespace System::ComponentModel::Design;\n\nint main()\n{\n   try\n   {\n      // Get the type handle of a specified class.\n      Type^ myType = ViewTechnology::typeid;\n\n      // Get the fields of the specified class.\n      array&lt;FieldInfo^&gt;^myField = myType-&gt;GetFields();\n      Console::WriteLine( &quot;<br>Displaying fields that have SpecialName attributes:<br>&quot; );\n      for ( int i = 0; i &lt; myField-&gt;Length; i++ )\n      {\n         // Determine whether or not each field is a special name.\n         if ( myField[ i ]-&gt;IsSpecialName )\n         {\n            Console::WriteLine( &quot;The field {0} has a SpecialName attribute.&quot;, myField[ i ]-&gt;Name );\n         }\n      }\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception : {0} &quot;, e-&gt;Message );\n   }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetFields_System_Reflection_BindingFlags_\">\r\n    \r\n            <a id=\"System_Type_GetFields_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetFields(BindingFlags)</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, searches for the fields defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, using the specified binding constraints.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>bindingAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted.  </p>\n<p> -or-  </p>\n<p> Zero, to return <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.fieldinfo\" data-linktype=\"relative-path\">FieldInfo</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.fieldinfo\" data-linktype=\"relative-path\">FieldInfo</a> objects representing all fields defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> that match the specified binding constraints.  </p>\n<p> -or-  </p>\n<p> An empty array of type <a class=\"xref\" href=\"system.reflection.fieldinfo\" data-linktype=\"relative-path\">FieldInfo</a>, if no fields are defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, or if none of the defined fields match the binding constraints.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <a class=\"xref\" href=\"system.type#System_Type_GetFields_\" data-linktype=\"relative-path\">GetFields</a> method does not return fields in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which fields are returned, because that order varies.  </p>\n<p> The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which fields to include in the search:  </p>\n<ul>\n<li><p>You must specify either <code>BindingFlags.Instance</code> or <code>BindingFlags.Static</code> in order to get a return.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.Public</code> to include public fields in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.NonPublic</code> to include non-public fields (that is, private, internal, and protected fields) in the search. Only protected and internal fields on base classes are returned; private fields on base classes are not returned.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.FlattenHierarchy</code> to include <code>public</code> and <code>protected</code> static members up the hierarchy; <code>private</code> static members in inherited classes are not included.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> modifier flags can be used to change how the search works:  </p>\n</li>\n<li><p><code>BindingFlags.DeclaredOnly</code> to search only the fields declared on the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, not fields that were simply inherited.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.fieldinfo\" data-linktype=\"relative-path\">FieldInfo</a> objects with the type parameters replaced by the appropriate type arguments.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</p>\n</li>\n</ul>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example shows a use of the <code>GetFields(BindingFlags)</code> method.  </p>\n<pre><code class=\"lang-cs\" name=\"Classic MethodBase.Attributes Example#1\">\nusing System;\nusing System.Reflection;\n \nclass AttributesSample\n{\n    public void Mymethod (int int1m, out string str2m, ref string str3m)\n    {\n        str2m = &quot;in Mymethod&quot;;\n    }\n \n    public static int Main(string[] args)\n    {      \n        Console.WriteLine (&quot;Reflection.MethodBase.Attributes Sample&quot;);\n       \n        // Get the type.\n        Type MyType = Type.GetType(&quot;AttributesSample&quot;);\n \n        // Get the method Mymethod on the type.\n        MethodBase Mymethodbase = MyType.GetMethod(&quot;Mymethod&quot;);\n \n        // Display the method name.\n        Console.WriteLine(&quot;Mymethodbase = &quot; + Mymethodbase);\n \n        // Get the MethodAttribute enumerated value.\n        MethodAttributes Myattributes = Mymethodbase.Attributes;\n \n        // Display the flags that are set.\n        PrintAttributes(typeof(System.Reflection.MethodAttributes), (int) Myattributes);\n        return 0;\n    }\n \n \n    public static void PrintAttributes(Type attribType, int iAttribValue)\n    {\n        if (!attribType.IsEnum)\n        { \n            Console.WriteLine(&quot;This type is not an enum.&quot;); \n            return; \n        }\n \n        FieldInfo[] fields = attribType.GetFields(BindingFlags.Public | BindingFlags.Static);\n        for (int i = 0; i &lt; fields.Length; i++)\n        {\n            int fieldvalue = (Int32)fields[i].GetValue(null);\n            if ((fieldvalue &amp; iAttribValue) == fieldvalue)\n            {\n                Console.WriteLine(fields[i].Name);\n            }\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Classic MethodBase.Attributes Example#1\">Imports System\nImports System.Reflection\nImports Microsoft.VisualBasic\n\nClass AttributesSample\n\n    Public Sub Mymethod(ByVal int1m As Integer, ByRef str2m As String, ByRef str3m As String)\n        str2m = &quot;in Mymethod&quot;\n    End Sub &#39;Mymethod\n\n    Public Shared Function Main(ByVal args() As String) As Integer\n        Console.WriteLine(&quot;Reflection.MethodBase.Attributes Sample&quot;)\n\n        &#39; Get the type.\n        Dim MyType As Type = Type.GetType(&quot;AttributesSample&quot;)\n\n        &#39; Get the method Mymethod on the type.\n        Dim Mymethodbase As MethodBase = MyType.GetMethod(&quot;Mymethod&quot;)\n\n        &#39; Display the method name.\n        Console.WriteLine(&quot;Mymethodbase = {0}.&quot;, Mymethodbase)\n\n        &#39; Get the MethodAttribute enumerated value.\n        Dim Myattributes As MethodAttributes = Mymethodbase.Attributes\n\n        &#39; Display the flags that are set.\n        PrintAttributes(GetType(System.Reflection.MethodAttributes), CInt(Myattributes))\n        Return 0\n    End Function &#39;Main\n\n    Public Shared Sub PrintAttributes(ByVal attribType As Type, ByVal iAttribValue As Integer)\n        If Not attribType.IsEnum Then\n            Console.WriteLine(&quot;This type is not an enum.&quot;)\n            Return\n        End If\n        Dim fields As FieldInfo() = attribType.GetFields((BindingFlags.Public Or BindingFlags.Static))\n        Dim i As Integer\n        For i = 0 To fields.Length - 1\n            Dim fieldvalue As Integer = CType(fields(i).GetValue(Nothing), Int32)\n            If (fieldvalue And iAttribValue) = fieldvalue Then\n                Console.WriteLine(fields(i).Name)\n            End If\n        Next i\n    End Sub &#39;PrintAttributes\nEnd Class &#39;AttributesSample\n</code></pre><pre><code class=\"lang-cpp\" name=\"Classic MethodBase.Attributes Example#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Runtime::InteropServices;\npublic ref class AttributesSample\n{\npublic:\n   void Mymethod( int int1m, [Out]interior_ptr&lt;String^&gt; str2m, interior_ptr&lt;String^&gt; str3m )\n   {\n       *str2m = &quot;in Mymethod&quot;;\n   }\n};\n\nvoid PrintAttributes( Type^ attribType, int iAttribValue )\n{\n   if (  !attribType-&gt;IsEnum )\n   {\n      Console::WriteLine( &quot;This type is not an enum.&quot; );\n      return;\n   }\n\n   array&lt;FieldInfo^&gt;^fields = attribType-&gt;GetFields( static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Static) );\n   for ( int i = 0; i &lt; fields-&gt;Length; i++ )\n   {\n      int fieldvalue = safe_cast&lt;Int32&gt;(fields[ i ]-&gt;GetValue( nullptr ));\n      if ( (fieldvalue &amp; iAttribValue) == fieldvalue )\n      {\n         Console::WriteLine( fields[ i ]-&gt;Name );\n      }\n   }\n}\n\nint main()\n{\n   Console::WriteLine( &quot;Reflection.MethodBase.Attributes Sample&quot; );\n\n   // Get the type.\n   Type^ MyType = Type::GetType( &quot;AttributesSample&quot; );\n\n   // Get the method Mymethod on the type.\n   MethodBase^ Mymethodbase = MyType-&gt;GetMethod( &quot;Mymethod&quot; );\n\n   // Display the method name.\n   Console::WriteLine( &quot;Mymethodbase = {0}&quot;, Mymethodbase );\n\n   // Get the MethodAttribute enumerated value.\n   MethodAttributes Myattributes = Mymethodbase-&gt;Attributes;\n\n   // Display the flags that are set.\n   PrintAttributes( System::Reflection::MethodAttributes::typeid, (int)Myattributes );\n   return 0;\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetGenericArguments\">\r\n    \r\n            <a id=\"System_Type_GetGenericArguments_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetGenericArguments()</div>        \r\n          </div>\r\n    \r\n            <p>Returns an array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual Type[] GetGenericArguments ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects that represent the type arguments of a generic type. Returns an empty array if the current type is not a generic type.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The invoked method is not supported in the base class. Derived classes must provide an implementation.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The array elements are returned in the order in which they appear in the list of type arguments for the generic type.  </p>\n<ul>\n<li><p>If the current type is a closed constructed type (that is, the <a class=\"xref\" href=\"system.type#System_Type_ContainsGenericParameters_\" data-linktype=\"relative-path\">ContainsGenericParameters</a> property returns <code>false</code>), the array returned by the GetGenericArguments method contains the types that have been assigned to the generic type parameters of the generic type definition.  </p>\n</li>\n<li><p>If the current type is a generic type definition, the array contains the type parameters.  </p>\n</li>\n<li><p>If the current type is an open constructed type (that is, the <a class=\"xref\" href=\"system.type#System_Type_ContainsGenericParameters_\" data-linktype=\"relative-path\">ContainsGenericParameters</a> property returns <code>true</code>) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters. Use the <a class=\"xref\" href=\"system.type#System_Type_IsGenericParameter_\" data-linktype=\"relative-path\">IsGenericParameter</a> property to tell them apart. For a demonstration of this scenario, see the code example for the <a class=\"xref\" href=\"system.type#System_Type_ContainsGenericParameters_\" data-linktype=\"relative-path\">ContainsGenericParameters</a> property.  </p>\n<p>For a list of the invariant conditions for terms used in generic reflection, see the <a class=\"xref\" href=\"system.type#System_Type_IsGenericType_\" data-linktype=\"relative-path\">IsGenericType</a> property remarks.</p>\n</li>\n</ul>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example uses the GetGenericArguments method to display the type arguments of a constructed type and the type parameters of its generic type definition.  </p>\n<p> This code example is part of a larger example provided for the <a class=\"xref\" href=\"system.type#System_Type_IsGenericTypeDefinition_\" data-linktype=\"relative-path\">IsGenericTypeDefinition</a> property. See the larger example for sample output.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.IsGenericTypeDefinition#2\">        if (t.IsGenericType)\n        {\n            // If this is a generic type, display the type arguments.\n            //\n            Type[] typeArguments = t.GetGenericArguments();\n\n            Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;List type arguments ({0}):&quot;, \n                typeArguments.Length);\n\n            foreach (Type tParam in typeArguments)\n            {\n                // If this is a type parameter, display its\n                // position.\n                //\n                if (tParam.IsGenericParameter)\n                {\n                    Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}&nbsp;&nbsp;&nbsp;&nbsp;(unassigned - parameter position {1})&quot;,\n                        tParam,\n                        tParam.GenericParameterPosition);\n                }\n                else\n                {\n                    Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;, tParam);\n                }\n            }\n        }\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.IsGenericTypeDefinition#2\">        If t.IsGenericType Then\n            &#39; If this is a generic type, display the type arguments.\n            &#39;\n            Dim typeArguments As Type() = t.GetGenericArguments()\n            \n            Console.WriteLine(vbTab &amp; &quot;List type arguments (&quot; _\n                &amp; typeArguments.Length &amp; &quot;):&quot;)\n            \n            For Each tParam As Type In typeArguments\n                &#39; If this is a type parameter, display its position.\n                &#39;\n                If tParam.IsGenericParameter Then\n                    Console.WriteLine(vbTab &amp; vbTab &amp; tParam.ToString() _\n                        &amp; vbTab &amp; &quot;(unassigned - parameter position &quot; _\n                        &amp; tParam.GenericParameterPosition &amp; &quot;)&quot;)\n                Else\n                    Console.WriteLine(vbTab &amp; vbTab &amp; tParam.ToString())\n                End If\n            Next tParam\n        End If\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Type.IsGenericTypeDefinition#2\">      if ( t-&gt;IsGenericType )\n      {\n         \n         // If this is a generic type, display the type arguments.\n         //\n         array&lt;Type^&gt;^typeArguments = t-&gt;GetGenericArguments();\n         Console::WriteLine( L&quot;&nbsp;&nbsp;&nbsp;&nbsp;List type arguments ({0}):&quot;,\n            typeArguments-&gt;Length );\n         System::Collections::IEnumerator^ myEnum =\n            typeArguments-&gt;GetEnumerator();\n         while ( myEnum-&gt;MoveNext() )\n         {\n            Type^ tParam = safe_cast&lt;Type^&gt;(myEnum-&gt;Current);\n            \n            // If this is a type parameter, display its\n            // position.\n            //\n            if ( tParam-&gt;IsGenericParameter )\n            {\n               Console::WriteLine(\n                  L&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}&nbsp;&nbsp;&nbsp;&nbsp;(unassigned - parameter position {1})&quot;,\n                  tParam, tParam-&gt;GenericParameterPosition );\n            }\n            else\n            {\n               Console::WriteLine( L&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;, tParam );\n            }\n         }\n      }\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetGenericParameterConstraints\">\r\n    \r\n            <a id=\"System_Type_GetGenericParameterConstraints_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetGenericParameterConstraints()</div>        \r\n          </div>\r\n    \r\n            <p>Returns an array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects that represent the constraints on the current generic type parameter.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual Type[] GetGenericParameterConstraints ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects that represent the constraints on the current generic type parameter.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object is not a generic type parameter. That is, the <span class=\"xref\">stem.Type.IsGenericParameter*</span> property returns <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Each constraint on a generic type parameter is expressed as a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object. Use the <a class=\"xref\" href=\"system.type#System_Type_IsClass_\" data-linktype=\"relative-path\">IsClass</a> property to determine whether a constraint is the base class constraint; if the property returns <code>false</code>, the constraint is an interface constraint. If a type parameter has no class constraint and no interface constraints, an empty array is returned.  </p>\n<p> For a list of the invariant conditions for terms used in generic reflection, see the <a class=\"xref\" href=\"system.type#System_Type_IsGenericType_\" data-linktype=\"relative-path\">IsGenericType</a> property remarks.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example defines a generic type <code>Test</code> with two type parameters that have different constraints. When the program executes, the constraints are examined using the <a class=\"xref\" href=\"system.type#System_Type_GenericParameterAttributes_\" data-linktype=\"relative-path\">GenericParameterAttributes</a> property and the GetGenericParameterConstraints method.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Type.GetGenericParameterConstraints#1\">Imports System\nImports System.Reflection\n\n&#39; Define a sample interface to use as an interface constraint.\nPublic Interface ITest\nEnd Interface \n\n&#39; Define a base type to use as a base class constraint.\nPublic Class Base\nEnd Class \n\n&#39; Define the generic type to examine. The first generic type parameter,\n&#39; T, derives from the class Base and implements ITest. This demonstrates\n&#39; a base class constraint and an interface constraint. The second generic \n&#39; type parameter, U, must be a reference type (Class) and must have a \n&#39; default constructor (New). This demonstrates special constraints.\n&#39;\nPublic Class Test(Of T As {Base, ITest}, U As {New, Class}) \nEnd Class\n\n&#39; Define a type that derives from Base and implements ITtest. This type\n&#39; satisfies the constraints on T in class Test.\nPublic Class Derived\n    Inherits Base\n    Implements ITest\nEnd Class \n\nPublic Class Example\n    \n    Public Shared Sub Main() \n        &#39; To get the generic type definition, omit the type\n        &#39; arguments but retain the comma to indicate the number\n        &#39; of type arguments. \n        &#39;\n        Dim def As Type = GetType(Test(Of ,))\n        Console.WriteLine(vbCrLf &amp; &quot;Examining generic type {0}&quot;, def)\n        \n        &#39; Get the type parameters of the generic type definition,\n        &#39; and display them.\n        &#39;\n        Dim defparams() As Type = def.GetGenericArguments()\n        For Each tp As Type In defparams\n\n            Console.WriteLine(vbCrLf &amp; &quot;Type parameter: {0}&quot;, tp.Name)\n            Console.WriteLine(vbTab &amp; ListGenericParameterAttributes(tp))\n            \n            &#39; List the base class and interface constraints. The\n            &#39; constraints do not appear in any particular order. An\n            &#39; empty array is returned if there are no constraints.\n            &#39;\n            Dim tpConstraints As Type() = _\n                tp.GetGenericParameterConstraints()\n            For Each tpc As Type In  tpConstraints\n                Console.WriteLine(vbTab &amp; tpc.ToString())\n            Next tpc\n        Next tp\n    \n    End Sub \n    \n    &#39; List the variance and special constraint flags.\n    &#39;\n    Private Shared Function ListGenericParameterAttributes(ByVal t As Type) As String \n        Dim retval As String\n        Dim gpa As GenericParameterAttributes = t.GenericParameterAttributes\n\n        &#39; Select the variance flags.\n        Dim variance As GenericParameterAttributes = _\n            gpa And GenericParameterAttributes.VarianceMask\n        \n        If variance = GenericParameterAttributes.None Then\n            retval = &quot;No variance flag;&quot;\n        Else\n            If (variance And GenericParameterAttributes.Covariant) &lt;&gt; 0 Then\n                retval = &quot;Covariant;&quot;\n            Else\n                retval = &quot;Contravariant;&quot;\n            End If\n        End If \n\n        &#39; Select the constraint flags.\n        Dim constraints As GenericParameterAttributes = _\n            gpa And GenericParameterAttributes.SpecialConstraintMask\n        \n        If constraints = GenericParameterAttributes.None Then\n            retval &amp;= &quot; no special constraints.&quot;\n        Else\n            If (constraints And GenericParameterAttributes.ReferenceTypeConstraint) &lt;&gt; 0 Then\n                retval &amp;= &quot; ReferenceTypeConstraint&quot;\n            End If\n            If (constraints And GenericParameterAttributes.NotNullableValueTypeConstraint) &lt;&gt; 0 Then\n                retval &amp;= &quot; NotNullableValueTypeConstraint&quot;\n            End If\n            If (constraints And GenericParameterAttributes.DefaultConstructorConstraint) &lt;&gt; 0 Then\n                retval &amp;= &quot; DefaultConstructorConstraint&quot;\n            End If\n        End If \n        Return retval\n    \n    End Function \nEnd Class \n&#39; This example produces the following output:\n&#39;\n&#39;Examining generic type Test`2[T,U]\n&#39;\n&#39;Type parameter: T\n&#39;        No variance flag; no special constraints.\n&#39;        Base\n&#39;        ITest\n&#39;\n&#39;Type parameter: U\n&#39;        No variance flag; ReferenceTypeConstraint DefaultConstructorConstraint\n&#39; \n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.GetGenericParameterConstraints#1\">using System;\nusing System.Reflection;\n\n// Define a sample interface to use as an interface constraint.\npublic interface ITest {}\n\n// Define a base type to use as a base class constraint.\npublic class Base {}\n\n// Define the generic type to examine. The first generic type parameter,\n// T, derives from the class Base and implements ITest. This demonstrates\n// a base class constraint and an interface constraint. The second generic \n// type parameter, U, must be a reference type (class) and must have a \n// default constructor (new()). This demonstrates special constraints.\n//\npublic class Test&lt;T,U&gt; \n    where T : Base, ITest \n    where U : class, new() {}\n\n// Define a type that derives from Base and implements ITest. This type\n// satisfies the constraints on T in class Test.\npublic class Derived : Base, ITest {}\n\npublic class Example\n{\n    public static void Main()\n    {\n        // To get the generic type definition, omit the type\n        // arguments but retain the comma to indicate the number\n        // of type arguments. \n        //\n        Type def = typeof(Test&lt;,&gt;);\n        Console.WriteLine(&quot;\\r<br>Examining generic type {0}&quot;, def);\n\n        // Get the type parameters of the generic type definition,\n        // and display them.\n        //\n        Type[] defparams = def.GetGenericArguments();\n        foreach (Type tp in defparams)\n        {\n            Console.WriteLine(&quot;\\r<br>Type parameter: {0}&quot;, tp.Name);\n            Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;, \n                ListGenericParameterAttributes(tp));\n\n            // List the base class and interface constraints. The\n            // constraints are returned in no particular order. If \n            // there are no class or interface constraints, an empty\n            // array is returned.\n            //\n            Type[] tpConstraints = tp.GetGenericParameterConstraints();\n            foreach (Type tpc in tpConstraints)\n            {\n                Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;, tpc);\n            }\n        }\n    }\n\n    // List the variance and special constraint flags. \n    //\n    private static string ListGenericParameterAttributes(Type t)\n    {\n        string retval;\n        GenericParameterAttributes gpa = t.GenericParameterAttributes;\n        GenericParameterAttributes variance = gpa &amp; \n            GenericParameterAttributes.VarianceMask;\n\n        // Select the variance flags.\n        if (variance == GenericParameterAttributes.None)\n            retval = &quot;No variance flag;&quot;;\n        else\n        {\n            if ((variance &amp; GenericParameterAttributes.Covariant) != 0)\n                retval = &quot;Covariant;&quot;;\n            else\n                retval = &quot;Contravariant;&quot;;\n        }\n\n        // Select \n        GenericParameterAttributes constraints = gpa &amp; \n            GenericParameterAttributes.SpecialConstraintMask;\n\n        if (constraints == GenericParameterAttributes.None)\n            retval += &quot; No special constraints&quot;;\n        else\n        {\n            if ((constraints &amp; GenericParameterAttributes.ReferenceTypeConstraint) != 0)\n                retval += &quot; ReferenceTypeConstraint&quot;;\n            if ((constraints &amp; GenericParameterAttributes.NotNullableValueTypeConstraint) != 0)\n                retval += &quot; NotNullableValueTypeConstraint&quot;;\n            if ((constraints &amp; GenericParameterAttributes.DefaultConstructorConstraint) != 0)\n                retval += &quot; DefaultConstructorConstraint&quot;;\n        }\n\n        return retval;\n    }\n}\n/* This example produces the following output:\n\nExamining generic type Test`2[T,U]\n\nType parameter: T\n        No variance flag; no special constraints.\n        Base\n        ITest\n\nType parameter: U\n        No variance flag; ReferenceTypeConstraint DefaultConstructorConstraint\n */\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Type.GetGenericParameterConstraints#1\">using namespace System;\nusing namespace System::Collections;\nusing namespace System::Reflection;\n\n// Define a sample interface to use as an interface constraint.\ninterface class ITest{};\n\n// Define a base type to use as a class constraint.\npublic ref class Base{};\n\n// Define the generic type to examine. The first generic type parameter,\n// T, derives from the class Base and implements ITest. This demonstrates\n// a base class constraint and an interface constraint. In the .NET\n// Framework version 2.0, C++ has no way of expressing special constraints.\n// See the C# example code.\n//\ngeneric &lt;typename T, typename U&gt;\n   where T :  Base, ITest\nref class Test {};\n\n// Define a type that derives from Base and implements interface\n// ITest. This type satisfies the constraint on T in class Test.\npublic ref class Derived: public Base, public ITest {};\n\npublic ref class Example\n{\npublic:\n   static void Main()\n   {\n      // Create a constructed type from Test&lt;T,U&gt;, and from it\n      // get the generic type definition.\n      //\n      Type^ def = Test::typeid;\n      Console::WriteLine( L&quot;\\r<br>Examining generic type {0}&quot;, def );\n      \n      // Get the type parameters of the generic type definition,\n      // and display them.\n      //\n      for each (Type^ tp in def-&gt;GetGenericArguments())\n      {\n         Console::WriteLine( L&quot;\\r<br>Type parameter: {0}&quot;, tp);\n         Console::WriteLine( L&quot;&nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;, \n            ListGenericParameterAttributes( tp ) );\n         \n         // List the base class and interface constraints. The\n         // constraints do not appear in any particular order. If\n         // there are no class or interface constraints, an empty\n         // array is returned.\n         //\n         for each (Type^ constraint in tp-&gt;GetGenericParameterConstraints())\n         {\n            Console::WriteLine( L&quot;&nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;, constraint );\n         }\n      }\n   }\n\nprivate:\n\n   // List the variance and special constraint flags. \n   //\n   static String^ ListGenericParameterAttributes( Type^ t )\n   {\n      String^ retval;\n      GenericParameterAttributes gpa = t-&gt;GenericParameterAttributes;\n\n      // Select the variance flag.\n      GenericParameterAttributes variance =\n         static_cast&lt;GenericParameterAttributes&gt;(\n            gpa &amp; GenericParameterAttributes::VarianceMask );\n\n      if ( variance == GenericParameterAttributes::None )\n            retval = L&quot;No variance flag;&quot;;\n      else\n      {\n         if ( (variance &amp; GenericParameterAttributes::Covariant) !=\n               GenericParameterAttributes::None )\n            retval = L&quot;Covariant;&quot;;\n         else\n            retval = L&quot;Contravariant;&quot;;\n      }\n\n      // Select the special constraint flags.\n      GenericParameterAttributes constraints =\n         static_cast&lt;GenericParameterAttributes&gt;(\n            gpa &amp; GenericParameterAttributes::SpecialConstraintMask);\n\n      if ( constraints == GenericParameterAttributes::None )\n            retval = String::Concat( retval, L&quot; No special constraints&quot; );\n      else\n      {\n         if ( (constraints &amp; GenericParameterAttributes::ReferenceTypeConstraint) !=\n               GenericParameterAttributes::None )\n            retval = String::Concat( retval, L&quot; ReferenceTypeConstraint&quot; );\n\n         if ( (constraints &amp; GenericParameterAttributes::NotNullableValueTypeConstraint) !=\n               GenericParameterAttributes::None )\n            retval = String::Concat( retval, L&quot; NotNullableValueTypeConstraint&quot; );\n\n         if ( (constraints &amp; GenericParameterAttributes::DefaultConstructorConstraint) !=\n               GenericParameterAttributes::None )\n            retval = String::Concat( retval, L&quot; DefaultConstructorConstraint&quot; );\n      }\n\n      return retval;\n   }\n};\n\nint main()\n{\n   Example::Main();\n}\n\n/* This example produces the following output:\n\nExamining generic type Test`2[T,U]\n\nType parameter: T\n        No variance flag; No special constraints\n        Base\n        ITest\n\nType parameter: U\n        No variance flag; No special constraints\n */\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetGenericTypeDefinition\">\r\n    \r\n            <a id=\"System_Type_GetGenericTypeDefinition_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetGenericTypeDefinition()</div>        \r\n          </div>\r\n    \r\n            <p>Returns a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents a generic type definition from which the current generic type can be constructed.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual Type GetGenericTypeDefinition ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object representing a generic type from which the current type can be constructed.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The current type is not a generic type.  That is, <span class=\"xref\">stem.Type.IsGenericType*</span> returns <code>false</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The invoked method is not supported in the base class. Derived classes must provide an implementation.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A generic type definition is a template from which other types can be constructed. For example, from the generic type definition <code>G&lt;T&gt;</code> (expressed in C# syntax; <code>G(Of T)</code> in Visual Basic or <code>generic &lt;typename T&gt; ref class G</code> in C++) you can construct and instantiate the type <code>G&lt;int&gt;</code> (<code>G(Of Integer)</code> in Visual Basic). Given a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object representing this constructed type, the GetGenericTypeDefinition method returns the generic type definition.  </p>\n<p> If two constructed types are created from the same generic type definition, using the same type arguments, the GetGenericTypeDefinition method returns the same <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object for both types.  </p>\n<p> If you call the GetGenericTypeDefinition method on a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that already represents a generic type definition, it returns the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.  </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> An array of generic types is not itself generic. In the C# code <code>A&lt;int&gt;[] v;</code> or the Visual Basic code <code>Dim v() As A(Of Integer)</code>, the type of variable <code>v</code> is not generic. Use <a class=\"xref\" href=\"system.type#System_Type_IsGenericType_\" data-linktype=\"relative-path\">IsGenericType</a> to determine whether a type is generic before calling GetGenericTypeDefinition.  </p>\n</div>\n<p> For a list of the invariant conditions for terms used in generic reflection, see the <a class=\"xref\" href=\"system.type#System_Type_IsGenericType_\" data-linktype=\"relative-path\">IsGenericType</a> property remarks.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example creates an instance of a constructed type by using ordinary instance creation and then uses the <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> and GetGenericTypeDefinition methods to retrieve the constructed type and the generic type definition. This example uses the generic <a class=\"xref\" href=\"system.collections.generic.dictionary-2\" data-linktype=\"relative-path\">Dictionary&lt;TKey,TValue&gt;</a> type; the constructed type represents a <a class=\"xref\" href=\"system.collections.generic.dictionary-2\" data-linktype=\"relative-path\">Dictionary&lt;TKey,TValue&gt;</a> of <code>Test</code> objects with string keys.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Type.GetGenericTypeDefinition#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Collections::Generic;\n\npublic ref class Test\n{\npublic:\n   static void Main()\n   {\n      Console::Write( L&quot;\\r<br>--- Get the generic type that &quot; );\n      Console::WriteLine( L&quot;defines a constructed type.&quot; );\n     \n      // Create a Dictionary of Test objects, using strings for the\n      // keys.\n      Dictionary&lt; String^,Test^ &gt;^ d = gcnew Dictionary&lt; String^,Test^ &gt;;\n      \n      // Get a Type object representing the constructed type.\n      //\n      Type^ constructed = d-&gt;GetType();\n      DisplayTypeInfo( constructed );\n      Type^ myGeneric = constructed-&gt;GetGenericTypeDefinition();\n      DisplayTypeInfo( myGeneric );\n   }\n\nprivate:\n   static void DisplayTypeInfo( Type^ t )\n   {\n      Console::WriteLine( L&quot;\\r<br>{0}&quot;, t );\n      Console::WriteLine( L&quot;&nbsp;&nbsp;&nbsp;&nbsp;Is this a generic type definition? {0}&quot;,\n         t-&gt;IsGenericTypeDefinition );\n      Console::WriteLine( L&quot;&nbsp;&nbsp;&nbsp;&nbsp;Is it a generic type? {0}&quot;,\n         t-&gt;IsGenericType );\n      array&lt;Type^&gt;^typeArguments = t-&gt;GetGenericArguments();\n      Console::WriteLine( L&quot;&nbsp;&nbsp;&nbsp;&nbsp;List type arguments ({0}):&quot;,\n         typeArguments-&gt;Length );\n      System::Collections::IEnumerator^ myEnum =\n         typeArguments-&gt;GetEnumerator();\n      while ( myEnum-&gt;MoveNext() )\n      {\n         Type^ tParam = safe_cast&lt;Type^&gt;(myEnum-&gt;Current);\n         Console::WriteLine( L&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;, tParam );\n      }\n   }\n};\n\nint main()\n{\n   Test::Main();\n}\n\n/* This example produces the following output:\n\n--- Get the generic type that defines a constructed type.\n\nSystem.Collections.Generic.Dictionary`2[System.String,Test]\n        Is this a generic type definition? False\n        Is it a generic type? True\n        List type arguments (2):\n                System.String\n                Test\n\nSystem.Collections.Generic.Dictionary`2[TKey,TValue]\n        Is this a generic type definition? True\n        Is it a generic type? True\n        List type arguments (2):\n                TKey\n                TValue\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.GetGenericTypeDefinition#1\">Imports System\nImports System.Reflection\nImports System.Collections.Generic\nImports Microsoft.VisualBasic\n\n\nPublic Class Test\n    Public Shared Sub Main() \n        Console.WriteLine(vbCrLf &amp; &quot;--- Get the generic type that defines a constructed type.&quot;)\n        \n        &#39; Create a Dictionary of Test objects, using strings for the\n        &#39; keys.\n        Dim d As New Dictionary(Of String, Test)\n        \n        &#39; Get a Type object representing the constructed type.\n        &#39;\n        Dim constructed As Type = d.GetType()\n        DisplayTypeInfo(constructed)\n        \n        Dim generic As Type = constructed.GetGenericTypeDefinition()\n        DisplayTypeInfo(generic)\n    End Sub &#39;Main\n    \n    Private Shared Sub DisplayTypeInfo(ByVal t As Type) \n        Console.WriteLine(vbCrLf &amp; t.ToString())\n        Console.WriteLine(vbTab &amp; &quot;Is this a generic type definition? &quot; _\n            &amp; t.IsGenericTypeDefinition)\n        Console.WriteLine(vbTab &amp; &quot;Is it a generic type? &quot; _\n            &amp; t.IsGenericType)\n        Dim typeArguments As Type() = t.GetGenericArguments()\n        Console.WriteLine(vbTab &amp; &quot;List type arguments (&quot; _\n            &amp; typeArguments.Length &amp; &quot;):&quot;)\n        For Each tParam As Type In typeArguments\n            Console.WriteLine(vbTab &amp; vbTab &amp; tParam.ToString())\n        Next tParam\n    End Sub &#39;DisplayTypeInfo\nEnd Class &#39;Test\n\n&#39; This example produces the following output:\n&#39;\n&#39;--- Get the generic type that defines a constructed type.\n&#39;\n&#39;System.Collections.Generic.Dictionary`2[System.String,Test]\n&#39;        Is this a generic type definition? False\n&#39;        Is it a generic type? True\n&#39;        List type arguments (2):\n&#39;                System.String\n&#39;                Test\n&#39;\n&#39;System.Collections.Generic.Dictionary`2[TKey,TValue]\n&#39;        Is this a generic type definition? True\n&#39;        Is it a generic type? True\n&#39;        List type arguments (2):\n&#39;                TKey\n&#39;                TValue\n&#39; \n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.GetGenericTypeDefinition#1\">using System;\nusing System.Reflection;\nusing System.Collections.Generic;\n\npublic class Test\n{\n    public static void Main()\n    {\n        Console.WriteLine(&quot;\\r<br>--- Get the generic type that defines a constructed type.&quot;);\n\n        // Create a Dictionary of Test objects, using strings for the\n        // keys.       \n        Dictionary&lt;string, Test&gt; d = new Dictionary&lt;string, Test&gt;();\n\n        // Get a Type object representing the constructed type.\n        //\n        Type constructed = d.GetType();\n        DisplayTypeInfo(constructed);\n\n        Type generic = constructed.GetGenericTypeDefinition();\n        DisplayTypeInfo(generic);\n    }\n\n    private static void DisplayTypeInfo(Type t)\n    {\n        Console.WriteLine(&quot;\\r<br>{0}&quot;, t);\n        Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;Is this a generic type definition? {0}&quot;, \n            t.IsGenericTypeDefinition);\n        Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;Is it a generic type? {0}&quot;, \n            t.IsGenericType);\n        Type[] typeArguments = t.GetGenericArguments();\n        Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;List type arguments ({0}):&quot;, typeArguments.Length);\n        foreach (Type tParam in typeArguments)\n        {\n            Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;, tParam);\n        }\n    }\n}\n\n/* This example produces the following output:\n\n--- Get the generic type that defines a constructed type.\n\nSystem.Collections.Generic.Dictionary`2[System.String,Test]\n        Is this a generic type definition? False\n        Is it a generic type? True\n        List type arguments (2):\n                System.String\n                Test\n\nSystem.Collections.Generic.Dictionary`2[TKey,TValue]\n        Is this a generic type definition? True\n        Is it a generic type? True\n        List type arguments (2):\n                TKey\n                TValue\n */\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetHashCode\">\r\n    \r\n            <a id=\"System_Type_GetHashCode_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetHashCode()</div>        \r\n          </div>\r\n    \r\n            <p>Returns the hash code for this instance.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override int GetHashCode ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </div>\r\n                  <p>The hash code for this instance.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method overrides <a class=\"xref\" href=\"system.object#System_Object_GetHashCode_\" data-linktype=\"relative-path\">GetHashCode</a>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example displays the hash code of the <code>System.Windows.Forms.Button</code> class.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_GetHashCode_GetFields#1\">#using &lt;system.dll&gt;\n#using &lt;system.windows.forms.dll&gt;\n#using &lt;System.Drawing.dll&gt;\n\nusing namespace System;\nusing namespace System::Security;\nusing namespace System::Reflection;\n\nint main()\n{\n   Type^ myType = System::Net::IPAddress::typeid;\n   array&lt;FieldInfo^&gt;^myFields = myType-&gt;GetFields( static_cast&lt;BindingFlags&gt;(BindingFlags::Static | BindingFlags::NonPublic) );\n   Console::WriteLine( &quot;<br>The IPAddress class has the following nonpublic fields: &quot; );\n   System::Collections::IEnumerator^ myEnum = myFields-&gt;GetEnumerator();\n   while ( myEnum-&gt;MoveNext() )\n   {\n      FieldInfo^ myField = safe_cast&lt;FieldInfo^&gt;(myEnum-&gt;Current);\n      Console::WriteLine( myField );\n   }\n\n   Type^ myType1 = System::Net::IPAddress::typeid;\n   array&lt;FieldInfo^&gt;^myFields1 = myType1-&gt;GetFields();\n   Console::WriteLine( &quot;<br>The IPAddress class has the following public fields: &quot; );\n   System::Collections::IEnumerator^ myEnum2 = myFields1-&gt;GetEnumerator();\n   while ( myEnum2-&gt;MoveNext() )\n   {\n      FieldInfo^ myField = safe_cast&lt;FieldInfo^&gt;(myEnum2-&gt;Current);\n      Console::WriteLine( myField );\n   }\n\n   try\n   {\n      Console::WriteLine( &quot;The HashCode of the System::Windows::Forms::Button type is: {0}&quot;, System::Windows::Forms::Button::typeid-&gt;GetHashCode() );\n   }\n   catch ( SecurityException^ e ) \n   {\n      Console::WriteLine( &quot;An exception occurred.&quot; );\n      Console::WriteLine( &quot;Message: {0}&quot;, e-&gt;Message );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;An exception occurred.&quot; );\n      Console::WriteLine( &quot;Message: {0}&quot;, e-&gt;Message );\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetHashCode_GetFields#1\">Imports System\nImports System.Security\nImports System.Reflection\nImports Microsoft.VisualBasic\n\n&#39; Compile this sample using the following command line:\n&#39; vbc type_gethashcode_getfields.vb /r:&quot;System.Windows.Forms.dll&quot; /r:&quot;System.dll&quot;\n\nClass FieldsSample\n\n    Public Shared Sub Main()\n        Dim myType As Type = GetType(System.Net.IPAddress)\n        Dim myFields As FieldInfo() = myType.GetFields((BindingFlags.Static Or BindingFlags.NonPublic))\n        Console.WriteLine(ControlChars.Lf &amp; &quot;The IPAddress class has the following nonpublic fields: &quot;)\n        Dim myField As FieldInfo\n        For Each myField In myFields\n            Console.WriteLine(myField.ToString())\n        Next myField\n        Dim myType1 As Type = GetType(System.Net.IPAddress)\n        Dim myFields1 As FieldInfo() = myType1.GetFields()\n        Console.WriteLine(ControlChars.Lf &amp; &quot;The IPAddress class has the following public fields: &quot;)\n        Dim myField1 As FieldInfo\n        For Each myField1 In myFields1\n            Console.WriteLine(myField.ToString())\n        Next myField1\n        Try\n            Console.WriteLine(&quot;The HashCode of the System.Windows.Forms.Button type is: {0}&quot;, GetType(System.Windows.Forms.Button).GetHashCode())\n        Catch e As SecurityException\n            Console.WriteLine(&quot;An exception occurred.&quot;)\n            Console.WriteLine((&quot;Message: &quot; &amp; e.Message))\n        Catch e As Exception\n            Console.WriteLine(&quot;An exception occurred.&quot;)\n            Console.WriteLine((&quot;Message: &quot; &amp; e.Message))\n        End Try\n    End Sub &#39;Main\nEnd Class &#39;FieldsSample\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_GetHashCode_GetFields#1\">using System;\nusing System.Security;\nusing System.Reflection;\n\nclass FieldsSample\n{\n    public static void Main()\t\t\t\t\t\t  \n    {\n        Type myType = typeof(System.Net.IPAddress);\n        FieldInfo [] myFields = myType.GetFields(BindingFlags.Static | BindingFlags.NonPublic);\n        Console.WriteLine (&quot;<br>The IPAddress class has the following nonpublic fields: &quot;);\n        foreach (FieldInfo myField in myFields) \n        {\n            Console.WriteLine(myField.ToString());\n        }\n        Type myType1 = typeof(System.Net.IPAddress);\n        FieldInfo [] myFields1 = myType1.GetFields();\n        Console.WriteLine (&quot;<br>The IPAddress class has the following public fields: &quot;);\n        foreach (FieldInfo myField in myFields1) \n        {\n            Console.WriteLine(myField.ToString());\n        }\n        try\n        {\n            Console.WriteLine(&quot;The HashCode of the System.Windows.Forms.Button type is: {0}&quot;,\n                typeof(System.Windows.Forms.Button).GetHashCode());\n        }\t\t\n        catch(SecurityException e)\n        {\n            Console.WriteLine(&quot;An exception occurred.&quot;);\n            Console.WriteLine(&quot;Message: &quot;+e.Message);\n        }\n        catch(Exception e)\n        {\n            Console.WriteLine(&quot;An exception occurred.&quot;);\n            Console.WriteLine(&quot;Message: &quot;+e.Message);\n\n        }\t\t\n    }\n}\t\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetInterface_System_String_\">\r\n    \r\n            <a id=\"System_Type_GetInterface_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetInterface(String)</div>        \r\n          </div>\r\n    \r\n            <p>Searches for the interface with the specified name.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public Type GetInterface (string name);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the interface to get. For generic interfaces, this is the mangled name.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>An object representing the interface with the specified name, implemented or inherited by the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a></div>\r\n                  </div>\r\n                  <p>The current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type that implements the same generic interface with different type arguments.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The search for <code>name</code> is case-sensitive.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> with the type parameters replaced by the appropriate type arguments.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> For generic interfaces, the <code>name</code> parameter is the mangled name, ending with a grave accent (`) and the number of type parameters. This is true for both generic interface definitions and constructed generic interfaces. For example, to find <code>IExample&lt;T&gt;</code> (<code>IExample(Of T)</code> in Visual Basic) or <code>IExample&lt;string&gt;</code> (<code>IExample(Of String)</code> in Visual Basic), search for <code>&quot;IExample</code>1&quot;`.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example uses the GetInterface method to search the <a class=\"xref\" href=\"system.collections.hashtable\" data-linktype=\"relative-path\">Hashtable</a> class for the <a class=\"xref\" href=\"system.runtime.serialization.ideserializationcallback\" data-linktype=\"relative-path\">IDeserializationCallback</a> interface, and lists the methods of the interface.  </p>\n<p> The code example also demonstrates the <a class=\"xref\" href=\"system.type#System_Type_GetInterface_System_String_System_Boolean_\" data-linktype=\"relative-path\">GetInterface(String,Boolean)</a> method overload and the <a class=\"xref\" href=\"system.type#System_Type_GetInterfaceMap_\" data-linktype=\"relative-path\">GetInterfaceMap</a> method.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_GetInterface#1\">int main()\n{\n   Hashtable^ hashtableObj = gcnew Hashtable;\n   Type^ objType = hashtableObj-&gt;GetType();\n   array&lt;MemberInfo^&gt;^arrayMemberInfo;\n   array&lt;MethodInfo^&gt;^arrayMethodInfo;\n   try\n   {\n      // Get the methods implemented in &#39;IDeserializationCallback&#39; interface.\n      arrayMethodInfo = objType-&gt;GetInterface( &quot;IDeserializationCallback&quot; )-&gt;GetMethods();\n      Console::WriteLine( &quot;<br>Methods of &#39;IDeserializationCallback&#39; Interface :&quot; );\n      for ( int index = 0; index &lt; arrayMethodInfo-&gt;Length; index++ )\n         Console::WriteLine( arrayMethodInfo[ index ] );\n      \n      // Get FullName for interface by using Ignore case search.\n      Console::WriteLine( &quot;<br>Methods of &#39;IEnumerable&#39; Interface&quot; );\n      arrayMethodInfo = objType-&gt;GetInterface( &quot;ienumerable&quot;, true )-&gt;GetMethods();\n      for ( int index = 0; index &lt; arrayMethodInfo-&gt;Length; index++ )\n         Console::WriteLine( arrayMethodInfo[ index ] );\n      \n      //Get the Interface methods for &#39;IDictionary*&#39; interface\n      InterfaceMapping interfaceMappingObj;\n      interfaceMappingObj = objType-&gt;GetInterfaceMap( IDictionary::typeid );\n      arrayMemberInfo = interfaceMappingObj.InterfaceMethods;\n      Console::WriteLine( &quot;<br>Hashtable class Implements the following IDictionary Interface methods :&quot; );\n      for ( int index = 0; index &lt; arrayMemberInfo-&gt;Length; index++ )\n         Console::WriteLine( arrayMemberInfo[ index ] );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception : {0}&quot;, e );\n   }\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_GetInterface#1\">    public static void Main()\n    {\n        Hashtable hashtableObj = new Hashtable();\n        Type objType = hashtableObj.GetType();\n        MemberInfo[] arrayMemberInfo;\n        MethodInfo[] arrayMethodInfo;\n        try\n        {   \n            // Get the methods implemented in &#39;IDeserializationCallback&#39; interface.\n            arrayMethodInfo =objType.GetInterface(&quot;IDeserializationCallback&quot;).GetMethods();\n            Console.WriteLine (&quot;<br>Methods of &#39;IDeserializationCallback&#39; Interface :&quot;);\n            for(int index=0;index &lt; arrayMethodInfo.Length ;index++)\n                Console.WriteLine (arrayMethodInfo[index].ToString() ); \n\n            // Get FullName for interface by using Ignore case search.\n            Console.WriteLine (&quot;<br>Methods of &#39;IEnumerable&#39; Interface&quot;);\n            arrayMethodInfo = objType.GetInterface(&quot;ienumerable&quot;,true).GetMethods();\n            for(int index=0;index &lt; arrayMethodInfo.Length ;index++)\n               Console.WriteLine (arrayMethodInfo[index].ToString()); \n           \n            //Get the Interface methods for &#39;IDictionary&#39; interface\n            InterfaceMapping interfaceMappingObj;\n            interfaceMappingObj = objType.GetInterfaceMap(typeof(IDictionary));\n            arrayMemberInfo = interfaceMappingObj.InterfaceMethods;\n            Console.WriteLine (&quot;<br>Hashtable class Implements the following IDictionary Interface methods :&quot;);\n            for(int index=0; index &lt; arrayMemberInfo.Length; index++)\n                Console.WriteLine (arrayMemberInfo[index].ToString() ); \n        }\n        catch (Exception e)\n        {\n            Console.WriteLine (&quot;Exception : &quot; + e.ToString());            \n        }                 \n    }\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetInterface#1\">   Public Shared Sub Main()\n      Dim hashtableObj As New Hashtable()\n      Dim objType As Type = hashtableObj.GetType()\n      Dim arrayMemberInfo() As MemberInfo\n      Dim arrayMethodInfo() As MethodInfo\n      Try\n         &#39; Get the methods implemented in &#39;IDeserializationCallback&#39; interface.\n         arrayMethodInfo = objType.GetInterface(&quot;IDeserializationCallback&quot;).GetMethods()\n         Console.WriteLine(ControlChars.Cr + &quot;Methods of &#39;IDeserializationCallback&#39; Interface :&quot;)\n         Dim index As Integer\n         For index = 0 To arrayMethodInfo.Length - 1\n            Console.WriteLine(arrayMethodInfo(index).ToString())\n         Next index\n         &#39; Get FullName for interface by using Ignore case search.\n         Console.WriteLine(ControlChars.Cr + &quot;Methods of &#39;IEnumerable&#39; Interface&quot;)\n         arrayMethodInfo = objType.GetInterface(&quot;ienumerable&quot;, True).GetMethods()\n         For index = 0 To arrayMethodInfo.Length - 1\n            Console.WriteLine(arrayMethodInfo(index).ToString())\n         Next index\n         &#39;Get the Interface methods for &#39;IDictionary&#39; interface\n         Dim interfaceMappingObj As InterfaceMapping\n         interfaceMappingObj = objType.GetInterfaceMap(GetType(IDictionary))\n         arrayMemberInfo = interfaceMappingObj.InterfaceMethods\n         Console.WriteLine(ControlChars.Cr + &quot;Hashtable class Implements the following IDictionary Interface methods :&quot;)\n         For index = 0 To arrayMemberInfo.Length - 1\n            Console.WriteLine(arrayMemberInfo(index).ToString())\n         Next index\n      Catch e As Exception\n         Console.WriteLine((&quot;Exception : &quot; + e.ToString()))\n      End Try\n   End Sub &#39;Main\nEnd Class &#39;MyInterfaceClass \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetInterface_System_String_System_Boolean_\">\r\n    \r\n            <a id=\"System_Type_GetInterface_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetInterface(String,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract Type GetInterface (string name, bool ignoreCase);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the interface to get. For generic interfaces, this is the mangled name.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>ignoreCase</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to ignore the case of that part of <code>name</code> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).  </p>\n<p> -or-  </p>\n<p> <code>false</code> to perform a case-sensitive search for all parts of <code>name</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>An object representing the interface with the specified name, implemented or inherited by the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a></div>\r\n                  </div>\r\n                  <p>The current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type that implements the same generic interface with different type arguments.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <code>ignoreCase</code> parameter applies only to the simple interface name, not to the namespace. The portion of <code>name</code> that specifies the namespace must have the correct case, or the interface will not be found. For example, the string &quot;System.icomparable&quot; finds the <a class=\"xref\" href=\"system.icomparable\" data-linktype=\"relative-path\">IComparable</a> interface, but the string &quot;system.icomparable&quot; does not.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> with the type parameters replaced by the appropriate type arguments.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> For generic interfaces, the <code>name</code> parameter is the mangled name, ending with a grave accent (`) and the number of type parameters. This is true for both generic interface definitions and constructed generic interfaces. For example, to find <code>IExample&lt;T&gt;</code> (<code>IExample(Of T)</code> in Visual Basic) or <code>IExample&lt;string&gt;</code> (<code>IExample(Of String)</code> in Visual Basic), search for <code>&quot;IExample</code>1&quot;`.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example uses the GetInterface method to perform a case-insensitive search of the <a class=\"xref\" href=\"system.collections.hashtable\" data-linktype=\"relative-path\">Hashtable</a> class for the <a class=\"xref\" href=\"system.collections.ienumerable\" data-linktype=\"relative-path\">IEnumerable</a> interface.  </p>\n<p> The code example also demonstrates the <a class=\"xref\" href=\"system.type#System_Type_GetInterface_System_String_\" data-linktype=\"relative-path\">GetInterface(String)</a> method overload and the <a class=\"xref\" href=\"system.type#System_Type_GetInterfaceMap_\" data-linktype=\"relative-path\">GetInterfaceMap</a> method.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_GetInterface#2\">int main()\n{\n   Hashtable^ hashtableObj = gcnew Hashtable;\n   Type^ objType = hashtableObj-&gt;GetType();\n   array&lt;MemberInfo^&gt;^arrayMemberInfo;\n   array&lt;MethodInfo^&gt;^arrayMethodInfo;\n   try\n   {\n      // Get the methods implemented in &#39;IDeserializationCallback&#39; interface.\n      arrayMethodInfo = objType-&gt;GetInterface( &quot;IDeserializationCallback&quot; )-&gt;GetMethods();\n      Console::WriteLine( &quot;<br>Methods of &#39;IDeserializationCallback&#39; Interface :&quot; );\n      for ( int index = 0; index &lt; arrayMethodInfo-&gt;Length; index++ )\n         Console::WriteLine( arrayMethodInfo[ index ] );\n      \n      // Get FullName for interface by using Ignore case search.\n      Console::WriteLine( &quot;<br>Methods of &#39;IEnumerable&#39; Interface&quot; );\n      arrayMethodInfo = objType-&gt;GetInterface( &quot;ienumerable&quot;, true )-&gt;GetMethods();\n      for ( int index = 0; index &lt; arrayMethodInfo-&gt;Length; index++ )\n         Console::WriteLine( arrayMethodInfo[ index ] );\n      \n      //Get the Interface methods for &#39;IDictionary*&#39; interface\n      InterfaceMapping interfaceMappingObj;\n      interfaceMappingObj = objType-&gt;GetInterfaceMap( IDictionary::typeid );\n      arrayMemberInfo = interfaceMappingObj.InterfaceMethods;\n      Console::WriteLine( &quot;<br>Hashtable class Implements the following IDictionary Interface methods :&quot; );\n      for ( int index = 0; index &lt; arrayMemberInfo-&gt;Length; index++ )\n         Console::WriteLine( arrayMemberInfo[ index ] );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception : {0}&quot;, e );\n   }\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_GetInterface#2\">    public static void Main()\n    {\n        Hashtable hashtableObj = new Hashtable();\n        Type objType = hashtableObj.GetType();\n        MemberInfo[] arrayMemberInfo;\n        MethodInfo[] arrayMethodInfo;\n        try\n        {   \n            // Get the methods implemented in &#39;IDeserializationCallback&#39; interface.\n            arrayMethodInfo =objType.GetInterface(&quot;IDeserializationCallback&quot;).GetMethods();\n            Console.WriteLine (&quot;<br>Methods of &#39;IDeserializationCallback&#39; Interface :&quot;);\n            for(int index=0;index &lt; arrayMethodInfo.Length ;index++)\n                Console.WriteLine (arrayMethodInfo[index].ToString() ); \n\n            // Get FullName for interface by using Ignore case search.\n            Console.WriteLine (&quot;<br>Methods of &#39;IEnumerable&#39; Interface&quot;);\n            arrayMethodInfo = objType.GetInterface(&quot;ienumerable&quot;,true).GetMethods();\n            for(int index=0;index &lt; arrayMethodInfo.Length ;index++)\n               Console.WriteLine (arrayMethodInfo[index].ToString()); \n           \n            //Get the Interface methods for &#39;IDictionary&#39; interface\n            InterfaceMapping interfaceMappingObj;\n            interfaceMappingObj = objType.GetInterfaceMap(typeof(IDictionary));\n            arrayMemberInfo = interfaceMappingObj.InterfaceMethods;\n            Console.WriteLine (&quot;<br>Hashtable class Implements the following IDictionary Interface methods :&quot;);\n            for(int index=0; index &lt; arrayMemberInfo.Length; index++)\n                Console.WriteLine (arrayMemberInfo[index].ToString() ); \n        }\n        catch (Exception e)\n        {\n            Console.WriteLine (&quot;Exception : &quot; + e.ToString());            \n        }                 \n    }\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetInterface#2\">   Public Shared Sub Main()\n      Dim hashtableObj As New Hashtable()\n      Dim objType As Type = hashtableObj.GetType()\n      Dim arrayMemberInfo() As MemberInfo\n      Dim arrayMethodInfo() As MethodInfo\n      Try\n         &#39; Get the methods implemented in &#39;IDeserializationCallback&#39; interface.\n         arrayMethodInfo = objType.GetInterface(&quot;IDeserializationCallback&quot;).GetMethods()\n         Console.WriteLine(ControlChars.Cr + &quot;Methods of &#39;IDeserializationCallback&#39; Interface :&quot;)\n         Dim index As Integer\n         For index = 0 To arrayMethodInfo.Length - 1\n            Console.WriteLine(arrayMethodInfo(index).ToString())\n         Next index\n         &#39; Get FullName for interface by using Ignore case search.\n         Console.WriteLine(ControlChars.Cr + &quot;Methods of &#39;IEnumerable&#39; Interface&quot;)\n         arrayMethodInfo = objType.GetInterface(&quot;ienumerable&quot;, True).GetMethods()\n         For index = 0 To arrayMethodInfo.Length - 1\n            Console.WriteLine(arrayMethodInfo(index).ToString())\n         Next index\n         &#39;Get the Interface methods for &#39;IDictionary&#39; interface\n         Dim interfaceMappingObj As InterfaceMapping\n         interfaceMappingObj = objType.GetInterfaceMap(GetType(IDictionary))\n         arrayMemberInfo = interfaceMappingObj.InterfaceMethods\n         Console.WriteLine(ControlChars.Cr + &quot;Hashtable class Implements the following IDictionary Interface methods :&quot;)\n         For index = 0 To arrayMemberInfo.Length - 1\n            Console.WriteLine(arrayMemberInfo(index).ToString())\n         Next index\n      Catch e As Exception\n         Console.WriteLine((&quot;Exception : &quot; + e.ToString()))\n      End Try\n   End Sub &#39;Main\nEnd Class &#39;MyInterfaceClass \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetInterfaceMap_System_Type_\">\r\n    \r\n            <a id=\"System_Type_GetInterfaceMap_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetInterfaceMap(Type)</div>        \r\n          </div>\r\n    \r\n            <p>Returns an interface mapping for the specified interface type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>interfaceType</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The interface type to retrieve a mapping for.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.interfacemapping\" data-linktype=\"relative-path\">InterfaceMapping</a></div>\r\n                  </div>\r\n                  <p>An object that represents the interface mapping for <code>interfaceType</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>interfaceType</code> is not implemented by the current type.  </p>\n<p> -or-  </p>\n<p> The <code>interfaceType</code> parameter does not refer to an interface.  </p>\n<p> -or-  </p>\n<p> <code>interfaceType</code> is a generic interface, and the current type is an array type.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>interfaceType</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a generic type parameter; that is, <span class=\"xref\">stem.Type.IsGenericParameter*</span> is <code>true</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The invoked method is not supported in the base class. Derived classes must provide an implementation.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The interface map denotes how an interface is mapped into the actual members on a class that implements that interface.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <a class=\"xref\" href=\"system.reflection.interfacemapping\" data-linktype=\"relative-path\">InterfaceMapping</a> returned by this method.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example calls the GetInterfaceMap method to determine how the <a class=\"xref\" href=\"system.iformatprovider\" data-linktype=\"relative-path\">IFormatProvider</a> interface maps to <a class=\"xref\" href=\"system.globalization.cultureinfo\" data-linktype=\"relative-path\">CultureInfo</a> methods, and how the <a class=\"xref\" href=\"system.iappdomainsetup\" data-linktype=\"relative-path\">IAppDomainSetup</a> interface maps to <a class=\"xref\" href=\"system.appdomainsetup\" data-linktype=\"relative-path\">AppDomainSetup</a> properties. Note that, because the <a class=\"xref\" href=\"system.iappdomainsetup\" data-linktype=\"relative-path\">IAppDomainSetup</a> interface defines a set of properties, the returned <a class=\"xref\" href=\"system.reflection.interfacemapping\" data-linktype=\"relative-path\">InterfaceMapping</a> object includes separate <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> objects for a property&#39;s get and set accessors.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Type.GetInterfaceMap#1\">Imports System.Globalization\nImports System.Reflection\n\nModule Example\n   Public Sub Main()\n      Dim int() As Type = { GetType(IFormatProvider), GetType(IAppDomainSetup) }\n      Dim impl() As Type = { GetType(CultureInfo), GetType(AppDomainSetup) }\n      \n      For ctr As Integer = 0 To int.Length - 1\n         ShowInterfaceMapping(int(ctr), impl(ctr))\n      Next\n   End Sub\n   \n   Private Sub ShowInterfaceMapping(intType As Type, implType As Type)\n      Dim map As InterfaceMapping = implType.GetInterfaceMap(intType)\n      Console.WriteLine(&quot;Mapping of {0} to {1}: &quot;, map.InterfaceType, map.TargetType)\n      For ctr As Integer = 0 To map.InterfaceMethods.Length - 1\n         Dim im As MethodInfo = map.InterfaceMethods(ctr)\n         Dim tm As MethodInfo = map.TargetMethods(ctr)\n         Console.WriteLine(&quot;   {0} --&gt; {1}&quot;, im.Name,tm.Name)\n      Next\n      Console.WriteLine()\n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;    Mapping of System.IFormatProvider to System.Globalization.CultureInfo:\n&#39;       GetFormat --&gt; GetFormat\n&#39;\n&#39;    Mapping of System.IAppDomainSetup to System.AppDomainSetup:\n&#39;       get_ApplicationBase --&gt; get_ApplicationBase\n&#39;       set_ApplicationBase --&gt; set_ApplicationBase\n&#39;       get_ApplicationName --&gt; get_ApplicationName\n&#39;       set_ApplicationName --&gt; set_ApplicationName\n&#39;       get_CachePath --&gt; get_CachePath\n&#39;       set_CachePath --&gt; set_CachePath\n&#39;       get_ConfigurationFile --&gt; get_ConfigurationFile\n&#39;       set_ConfigurationFile --&gt; set_ConfigurationFile\n&#39;       get_DynamicBase --&gt; get_DynamicBase\n&#39;       set_DynamicBase --&gt; set_DynamicBase\n&#39;       get_LicenseFile --&gt; get_LicenseFile\n&#39;       set_LicenseFile --&gt; set_LicenseFile\n&#39;       get_PrivateBinPath --&gt; get_PrivateBinPath\n&#39;       set_PrivateBinPath --&gt; set_PrivateBinPath\n&#39;       get_PrivateBinPathProbe --&gt; get_PrivateBinPathProbe\n&#39;       set_PrivateBinPathProbe --&gt; set_PrivateBinPathProbe\n&#39;       get_ShadowCopyDirectories --&gt; get_ShadowCopyDirectories\n&#39;       set_ShadowCopyDirectories --&gt; set_ShadowCopyDirectories\n&#39;       get_ShadowCopyFiles --&gt; get_ShadowCopyFiles\n&#39;       set_ShadowCopyFiles --&gt; set_ShadowCopyFiles\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.GetInterfaceMap#1\">using System;\nusing System.Globalization;\nusing System.Reflection;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Type[] interf = { typeof(IFormatProvider), typeof(IAppDomainSetup) };\n      Type[] impl = { typeof(CultureInfo), typeof(AppDomainSetup) };\n\n      for (int ctr = 0; ctr &lt; interf.Length; ctr++)\n         ShowInterfaceMapping(interf[ctr], impl[ctr]);\n   }\n\n   private static void ShowInterfaceMapping(Type intType, Type implType)\n   {\n      InterfaceMapping map = implType.GetInterfaceMap(intType);\n      Console.WriteLine(&quot;Mapping of {0} to {1}: &quot;, map.InterfaceType, map.TargetType);\n      for (int ctr = 0; ctr &lt; map.InterfaceMethods.Length; ctr++) {\n         MethodInfo im = map.InterfaceMethods[ctr];\n         MethodInfo tm = map.TargetMethods[ctr];\n         Console.WriteLine(&quot;   {0} --&gt; {1}&quot;, im.Name,tm.Name);\n      }\n      Console.WriteLine();\n   }\n}\n// The example displays the following output:\n//    Mapping of System.IFormatProvider to System.Globalization.CultureInfo:\n//       GetFormat --&gt; GetFormat\n//\n//    Mapping of System.IAppDomainSetup to System.AppDomainSetup:\n//       get_ApplicationBase --&gt; get_ApplicationBase\n//       set_ApplicationBase --&gt; set_ApplicationBase\n//       get_ApplicationName --&gt; get_ApplicationName\n//       set_ApplicationName --&gt; set_ApplicationName\n//       get_CachePath --&gt; get_CachePath\n//       set_CachePath --&gt; set_CachePath\n//       get_ConfigurationFile --&gt; get_ConfigurationFile\n//       set_ConfigurationFile --&gt; set_ConfigurationFile\n//       get_DynamicBase --&gt; get_DynamicBase\n//       set_DynamicBase --&gt; set_DynamicBase\n//       get_LicenseFile --&gt; get_LicenseFile\n//       set_LicenseFile --&gt; set_LicenseFile\n//       get_PrivateBinPath --&gt; get_PrivateBinPath\n//       set_PrivateBinPath --&gt; set_PrivateBinPath\n//       get_PrivateBinPathProbe --&gt; get_PrivateBinPathProbe\n//       set_PrivateBinPathProbe --&gt; set_PrivateBinPathProbe\n//       get_ShadowCopyDirectories --&gt; get_ShadowCopyDirectories\n//       set_ShadowCopyDirectories --&gt; set_ShadowCopyDirectories\n//       get_ShadowCopyFiles --&gt; get_ShadowCopyFiles\n//       set_ShadowCopyFiles --&gt; set_ShadowCopyFiles\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetInterfaces\">\r\n    \r\n            <a id=\"System_Type_GetInterfaces_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetInterfaces()</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, gets all the interfaces implemented or inherited by the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract Type[] GetInterfaces ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects representing all the interfaces implemented or inherited by the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.  </p>\n<p> -or-  </p>\n<p> An empty array of type <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, if no interfaces are implemented or inherited by the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.targetinvocationexception\" data-linktype=\"relative-path\">TargetInvocationException</a></div>\r\n                  </div>\r\n                  <p>A static initializer is invoked and throws an exception.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The GetInterfaces method does not return interfaces in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which interfaces are returned, because that order varies.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects with the type parameters replaced by the appropriate type arguments.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example gets the type of the specified class and displays all the interfaces that the type implements or inherits. To compile the Visual Basic example, use the following compiler commands:  </p>\n<p> <code>vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll</code>  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_GetInterfaces1#1\">using namespace System;\nusing namespace System::Collections::Generic;\n\nvoid main()\n{\n    Console::WriteLine(&quot;\\r<br>Interfaces implemented by Dictionary&lt;int, String^&gt;:\\r<br>&quot;);\n     \n    for each (Type^ tinterface in Dictionary&lt;int, String^&gt;::typeid-&gt;GetInterfaces())\n    {\n        Console::WriteLine(tinterface-&gt;ToString());\n    }\n\n    //Console::ReadLine()      // Uncomment this line for Visual Studio. \n}\n\n/* This example produces output similar to the following:\n\nInterfaces implemented by Dictionary&lt;int, String^&gt;:\n\nSystem.Collections.Generic.IDictionary`2[System.Int32,System.String]\nSystem.Collections.Generic.ICollection`1[System.Collections.Generic.KeyValuePair`2[System.Int32,System.String]]\nSystem.Collections.Generic.IEnumerable`1[System.Collections.Generic.KeyValuePair`2[System.Int32,System.String]]\nSystem.Collection.IEnumerable\nSystem.Collection.IDictionary\nSystem.Collection.ICollection\nSystem.Runtime.Serialization.ISerializable\nSystem.Runtime.Serialization.IDeserializationCallback\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetInterfaces1#1\">Imports System.Collections.Generic\n\nPublic Class Example\n\n    Shared Sub Main()\n\n        Console.WriteLine(vbCrLf &amp; _\n            &quot;Interfaces implemented by Dictionary(Of Integer, String):&quot; &amp; vbCrLf)\n        \n        For Each tinterface As Type In GetType(Dictionary(Of Integer, String)).GetInterfaces()\n\n            Console.WriteLine(tinterface.ToString())\n\n        Next\n\n        &#39;Console.ReadLine()      &#39; Uncomment this line for Visual Studio. \n    End Sub\nEnd Class\n\n&#39; This example produces output similar to the following:\n&#39;\n&#39;Interfaces implemented by Dictionary(Of Integer, String):\n&#39;System.Collections.Generic.IDictionary`2[System.Int32,System.String]\n&#39;System.Collections.Generic.ICollection`1[System.Collections.Generic.KeyValuePair`2[System.Int32,System.String]]\n&#39;System.Collections.Generic.IEnumerable`1[System.Collections.Generic.KeyValuePair`2[System.Int32,System.String]]\n&#39;System.Collection.IEnumerable\n&#39;System.Collection.IDictionary\n&#39;System.Collection.ICollection\n&#39;System.Runtime.Serialization.ISerializable\n&#39;System.Runtime.Serialization.IDeserializationCallback\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_GetInterfaces1#1\">using System;\nusing System.Collections.Generic;\n\npublic class Example\n{\n    static void Main()\n    {\n        Console.WriteLine(&quot;\\r<br>Interfaces implemented by Dictionary&lt;int, string&gt;:\\r<br>&quot;);\n        \n        foreach (Type tinterface in typeof(Dictionary&lt;int, string&gt;).GetInterfaces())\n        {\n            Console.WriteLine(tinterface.ToString());\n        }\n\n        //Console.ReadLine()      // Uncomment this line for Visual Studio. \n    }\n}\n\n/* This example produces output similar to the following:\n\nInterfaces implemented by Dictionary&lt;int, string&gt;:\n\nSystem.Collections.Generic.IDictionary`2[System.Int32,System.String]\nSystem.Collections.Generic.ICollection`1[System.Collections.Generic.KeyValuePair`2[System.Int32,System.String]]\nSystem.Collections.Generic.IEnumerable`1[System.Collections.Generic.KeyValuePair`2[System.Int32,System.String]]\nSystem.Collection.IEnumerable\nSystem.Collection.IDictionary\nSystem.Collection.ICollection\nSystem.Runtime.Serialization.ISerializable\nSystem.Runtime.Serialization.IDeserializationCallback\n */\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetMember_System_String_\">\r\n    \r\n            <a id=\"System_Type_GetMember_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetMember(String)</div>        \r\n          </div>\r\n    \r\n            <p>Searches for the public members with the specified name.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.MemberInfo[] GetMember (string name);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the public members to get.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a> objects representing the public members with the specified name, if found; otherwise, an empty array.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The search for <code>name</code> is case-sensitive. The search includes public static and public instance members.  </p>\n<p> Members include properties, methods, fields, events, and so on.  </p>\n<p> The GetMember method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.  </p>\n<p> This method overload will not find class initializers (.cctor). To find class initializers, use an overload that takes <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a>, and specify <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (<a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a><code>Or</code><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> in Visual Basic). You can also get the class initializer using the <a class=\"xref\" href=\"system.type#System_Type_TypeInitializer_\" data-linktype=\"relative-path\">TypeInitializer</a> property.  </p>\n<p> The following table shows what members of a base class are returned by the <code>Get</code> methods when reflecting on a type.  </p>\n<table>\n<thead>\n<tr>\n<th>Member Type</th>\n<th>Static</th>\n<th>Non-Static</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Constructor</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Field</td>\n<td>No</td>\n<td>Yes. A field is always hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Event</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n<tr>\n<td>Method</td>\n<td>No</td>\n<td>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Nested Type</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Property</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  </p>\n</li>\n<li><p>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  </p>\n</li>\n<li><p>Custom attributes are not part of the common type system.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a> with the type parameters replaced by the appropriate type arguments.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a> if there is no class constraint.  </p>\n</li>\n</ol>\n<div class=\"NOTE\"><h5>Note</h5><p> For generic methods, do not include the type arguments in <code>name</code>. For example, the C# code <code>GetMember(&quot;MyMethod&lt;int&gt;&quot;)</code> searches for a member with the text name &quot;<code>MyMethod&lt;int&gt;</code>&quot;, rather than for a method named <code>MyMethod</code> that has one generic argument of type <code>int</code>.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example displays all the members of the <code>String</code> class that start with the letter C.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_GetMember#1\">\nusing System;\nusing System.Security;\nusing System.Reflection;\n\npublic class MyMemberSample \n{\n    public static void Main()\n    {\n        MyMemberSample myClass = new MyMemberSample();\n        try\n        {\n            myClass.GetMemberInfo();\n            myClass.GetPublicStaticMemberInfo();\t\n            myClass.GetPublicInstanceMethodMemberInfo();\t\n        }      \n        catch(ArgumentNullException e)\n        {\n            Console.WriteLine(&quot;ArgumentNullException occurred.&quot;);\n            Console.WriteLine(&quot;Source: &quot; + e.Source);\n            Console.WriteLine(&quot;Message: &quot; + e.Message);\n        }\n        catch(NotSupportedException e)\n        {\n            Console.WriteLine(&quot;NotSupportedException occurred.&quot;);\n            Console.WriteLine(&quot;Source: &quot; + e.Source);\n            Console.WriteLine(&quot;Message: &quot; + e.Message);\n        }\n        catch(SecurityException e)\n        {\n            Console.WriteLine(&quot;SecurityException occurred.&quot;);\n            Console.WriteLine(&quot;Source: &quot; + e.Source);\n            Console.WriteLine(&quot;Message: &quot; + e.Message);\n        }\n        catch(Exception e)\n        {\n            Console.WriteLine(&quot;Exception occurred.&quot;);\n            Console.WriteLine(&quot;Source: &quot; + e.Source);\n            Console.WriteLine(&quot;Message: &quot; + e.Message);\n        }\n    }\n\n    public void GetMemberInfo()\n    {\n        String myString = &quot;GetMember_String&quot;;\n\n        Type myType = myString.GetType();\n        // Get the members for myString starting with the letter C.\n        MemberInfo[] myMembers = myType.GetMember(&quot;C*&quot;);\n        if(myMembers.Length &gt; 0)\n        {\n            Console.WriteLine(&quot;<br>The member(s) starting with the letter C for type {0}:&quot;, myType);\n            for(int index=0; index &lt; myMembers.Length; index++)\n                Console.WriteLine(&quot;Member {0}: {1}&quot;, index + 1, myMembers[index].ToString());\n        }\n        else\n            Console.WriteLine(&quot;No members match the search criteria.&quot;);    \n    }\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetMember#1\">using namespace System;\nusing namespace System::Security;\nusing namespace System::Reflection;\n\n// forward declarations:\nvoid GetMemberInfo();\nvoid GetPublicStaticMemberInfo();\nvoid GetPublicInstanceMethodMemberInfo();\nint main()\n{\n   try\n   {\n      GetMemberInfo();\n      GetPublicStaticMemberInfo();\n      GetPublicInstanceMethodMemberInfo();\n   }\n   catch ( ArgumentNullException^ e ) \n   {\n      Console::WriteLine( &quot;ArgumentNullException occurred.&quot; );\n      Console::WriteLine( &quot;Source: {0}&quot;, e-&gt;Source );\n      Console::WriteLine( &quot;Message: {0}&quot;, e-&gt;Message );\n   }\n   catch ( NotSupportedException^ e ) \n   {\n      Console::WriteLine( &quot;NotSupportedException occurred.&quot; );\n      Console::WriteLine( &quot;Source: {0}&quot;, e-&gt;Source );\n      Console::WriteLine( &quot;Message: {0}&quot;, e-&gt;Message );\n   }\n   catch ( SecurityException^ e ) \n   {\n      Console::WriteLine( &quot;SecurityException occurred.&quot; );\n      Console::WriteLine( &quot;Source: {0}&quot;, e-&gt;Source );\n      Console::WriteLine( &quot;Message: {0}&quot;, e-&gt;Message );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception occurred.&quot; );\n      Console::WriteLine( &quot;Source: {0}&quot;, e-&gt;Source );\n      Console::WriteLine( &quot;Message: {0}&quot;, e-&gt;Message );\n   }\n\n}\n\nvoid GetMemberInfo()\n{\n   String^ myString = &quot;GetMember_String&quot;;\n   Type^ myType = myString-&gt;GetType();\n   \n   // Get the members for myString starting with the letter C.\n   array&lt;MemberInfo^&gt;^myMembers = myType-&gt;GetMember( &quot;C*&quot; );\n   if ( myMembers-&gt;Length &gt; 0 )\n   {\n      Console::WriteLine( &quot;<br>The member(s) starting with the letter C for type {0}:&quot;, myType );\n      for ( int index = 0; index &lt; myMembers-&gt;Length; index++ )\n         Console::WriteLine( &quot;Member {0}: {1}&quot;, index + 1, myMembers[ index ] );\n   }\n   else\n      Console::WriteLine( &quot;No members match the search criteria.&quot; );\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetMember#1\">\nImports System\nImports System.Security\nImports System.Reflection\nImports Microsoft.VisualBasic\n\nPublic Class MyMemberSample\n\n    Public Shared Sub Main()\n        Dim [myClass] As New MyMemberSample()\n        Try\n            [myClass].GetMemberInfo()\n            [myClass].GetPublicStaticMemberInfo()\n            [myClass].GetPublicInstanceMethodMemberInfo()\n        Catch e As ArgumentNullException\n            Console.WriteLine(&quot;ArgumentNullException occurred.&quot;)\n            Console.WriteLine((&quot;Source: &quot; + e.Source))\n            Console.WriteLine((&quot;Message: &quot; + e.Message))\n        Catch e As NotSupportedException\n            Console.WriteLine(&quot;NotSupportedException occurred.&quot;)\n            Console.WriteLine((&quot;Source: &quot; + e.Source))\n            Console.WriteLine((&quot;Message: &quot; + e.Message))\n        Catch e As SecurityException\n            Console.WriteLine(&quot;SecurityException occurred.&quot;)\n            Console.WriteLine((&quot;Source: &quot; + e.Source))\n            Console.WriteLine((&quot;Message: &quot; + e.Message))\n        Catch e As Exception\n            Console.WriteLine(&quot;Exception occurred.&quot;)\n            Console.WriteLine((&quot;Source: &quot; + e.Source))\n            Console.WriteLine((&quot;Message: &quot; + e.Message))\n        End Try\n    End Sub &#39;Main\n\n\n    Public Sub GetMemberInfo()\n        Dim myString As [String] = &quot;GetMember_String&quot;\n        Dim myType As Type = myString.GetType()\n        &#39; Get the members for myString starting with the letter C.\n        Dim myMembers As MemberInfo() = myType.GetMember(&quot;C*&quot;)\n        If myMembers.Length &gt; 0 Then\n            Console.WriteLine(ControlChars.Cr + &quot;The member(s) starting with the letter C for type {0}:&quot;, myType)\n            Dim index As Integer\n            For index = 0 To myMembers.Length - 1\n                Console.WriteLine(&quot;Member {0}: {1}&quot;, index + 1, myMembers(index).ToString())\n            Next index\n        Else\n            Console.WriteLine(&quot;No members match the search criteria.&quot;)\n        End If\n    End Sub &#39;GetMemberInfo\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetMember_System_String_System_Reflection_BindingFlags_\">\r\n    \r\n            <a id=\"System_Type_GetMember_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetMember(String,BindingFlags)</div>        \r\n          </div>\r\n    \r\n            <p>Searches for the specified members, using the specified binding constraints.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the members to get.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>bindingAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted.  </p>\n<p> -or-  </p>\n<p> Zero, to return an empty array.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a> objects representing the public members with the specified name, if found; otherwise, an empty array.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method can be overridden by a derived class.  </p>\n<p> Members include properties, methods, fields, events, and so on.  </p>\n<p> The GetMember method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.  </p>\n<p> The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which members to include in the search:  </p>\n<ul>\n<li><p>You must specify either <code>BindingFlags.Instance</code> or <code>BindingFlags.Static</code> in order to get a return.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.Public</code> to include public members in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.NonPublic</code> to include non-public members (that is, private, internal, and protected members) in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.FlattenHierarchy</code> to include <code>public</code> and <code>protected</code> static members up the hierarchy; <code>private</code> static members in inherited classes are not included.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> modifier flags can be used to change how the search works:  </p>\n</li>\n<li><p><code>BindingFlags.IgnoreCase</code> to ignore the case of <code>name</code>.  </p>\n</li>\n<li><p><code>BindingFlags.DeclaredOnly</code> to search only the members declared on the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, not members that were simply inherited.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.  </p>\n<p>To get the class initializer (.cctor) using this method overload, you must specify &quot;.cctor&quot; for <code>name</code>, and <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (<a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a><code>Or</code><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> in Visual Basic) for <code>bindingAttr</code>. You can also get the class initializer using the <a class=\"xref\" href=\"system.type#System_Type_TypeInitializer_\" data-linktype=\"relative-path\">TypeInitializer</a> property.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a> with the type parameters replaced by the appropriate type arguments.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a> if there is no class constraint.  </p>\n</li>\n</ul>\n<div class=\"NOTE\"><h5>Note</h5><p> For generic methods, do not include the type arguments in <code>name</code>. For example, the C# code <code>GetMember(&quot;MyMethod&lt;int&gt;&quot;)</code> searches for a member with the text name &quot;<code>MyMethod&lt;int&gt;</code>&quot;, rather than for a method named <code>MyMethod</code> that has one generic argument of type <code>int</code>.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example displays all the public static members of the <code>myString</code> class that start with the letter C.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_GetMember#2\">    public void GetPublicStaticMemberInfo()\n    {\n        String myString = &quot;GetMember_String_BindingFlag&quot;;\n        Type myType = myString.GetType();\n        // Get the public static members for the class myString starting with the letter C.\n        MemberInfo[] myMembers = myType.GetMember(&quot;C*&quot;,\n            BindingFlags.Public |BindingFlags.Static);\n        if(myMembers.Length &gt; 0)\n        {\n            Console.WriteLine(&quot;<br>The public static member(s) starting with the letter C for type {0}:&quot;, myType);\n            for(int index=0; index &lt; myMembers.Length; index++)\n                Console.WriteLine(&quot;Member {0}: {1}&quot;, index + 1, myMembers[index].ToString());\n        }\n        else\n            Console.WriteLine(&quot;No members match the search criteria.&quot;);    \n    }\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetMember#2\">void GetPublicStaticMemberInfo()\n{\n   String^ myString = &quot;GetMember_String_BindingFlag&quot;;\n   Type^ myType = myString-&gt;GetType();\n   \n   // Get the public static members for the class myString starting with the letter C\n   array&lt;MemberInfo^&gt;^myMembers = myType-&gt;GetMember( &quot;C*&quot;, static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Static) );\n   if ( myMembers-&gt;Length &gt; 0 )\n   {\n      Console::WriteLine( &quot;<br>The public static member(s) starting with the letter C for type {0}:&quot;, myType );\n      for ( int index = 0; index &lt; myMembers-&gt;Length; index++ )\n         Console::WriteLine( &quot;Member {0}: {1}&quot;, index + 1, myMembers[ index ] );\n   }\n   else\n      Console::WriteLine( &quot;No members match the search criteria.&quot; );\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetMember#2\">    Public Sub GetPublicStaticMemberInfo()\n        Dim myString As [String] = &quot;GetMember_String_BindingFlag&quot;\n\n        Dim myType As Type = myString.GetType()\n        &#39; Get the public static members for the class myString starting with the letter C.\n        Dim myMembers As MemberInfo() = myType.GetMember(&quot;C*&quot;, BindingFlags.Public Or BindingFlags.Static)\n\n        If myMembers.Length &gt; 0 Then\n            Console.WriteLine(ControlChars.Cr + &quot;The public static member(s) starting with the letter C for type {0}:&quot;, myType)\n            Dim index As Integer\n            For index = 0 To myMembers.Length - 1\n                Console.WriteLine(&quot;Member {0}: {1}&quot;, index + 1, myMembers(index).ToString())\n            Next index\n        Else\n            Console.WriteLine(&quot;No members match the search criteria.&quot;)\n        End If\n    End Sub &#39;GetPublicStaticMemberInfo\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetMember_System_String_System_Reflection_MemberTypes_System_Reflection_BindingFlags_\">\r\n    \r\n            <a id=\"System_Type_GetMember_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetMember(String,MemberTypes,BindingFlags)</div>        \r\n          </div>\r\n    \r\n            <p>Searches for the specified members of the specified member type, using the specified binding constraints.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the members to get.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>type</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.membertypes\" data-linktype=\"relative-path\">MemberTypes</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The value to search for.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>bindingAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted.  </p>\n<p> -or-  </p>\n<p> Zero, to return an empty array.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a> objects representing the public members with the specified name, if found; otherwise, an empty array.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>A derived class must provide an implementation.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Members include properties, methods, fields, events, and so on.  </p>\n<p> The GetMember method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.  </p>\n<p> The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which members to include in the search:  </p>\n<ul>\n<li><p>You must specify either <code>BindingFlags.Instance</code> or <code>BindingFlags.Static</code> in order to get a return.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.Public</code> to include public members in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.NonPublic</code> to include non-public members (that is, private, internal, and protected members) in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.FlattenHierarchy</code> to include <code>public</code> and <code>protected</code> static members up the hierarchy; <code>private</code> static members in inherited classes are not included.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> modifier flags can be used to change how the search works:  </p>\n</li>\n<li><p><code>BindingFlags.IgnoreCase</code> to ignore the case of <code>name</code>.  </p>\n</li>\n<li><p><code>BindingFlags.DeclaredOnly</code> to search only the members declared on the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, not members that were simply inherited.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.  </p>\n<p>To get the class initializer (.cctor) using this method overload, you must specify &quot;.cctor&quot; for <code>name</code>, <a class=\"xref\" href=\"system.reflection.membertypes\" data-linktype=\"relative-path\">System.Reflection.MemberTypes</a> for <code>type</code>, and  <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (<a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a><code>Or</code><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> in Visual Basic) for <code>bindingAttr</code>. You can also get the class initializer using the <a class=\"xref\" href=\"system.type#System_Type_TypeInitializer_\" data-linktype=\"relative-path\">TypeInitializer</a> property.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a> with the type parameters replaced by the appropriate type arguments.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a> if there is no class constraint.  </p>\n</li>\n</ul>\n<div class=\"NOTE\"><h5>Note</h5><p> For generic methods, do not include the type arguments in <code>name</code>. For example, the C# code <code>GetMember(&quot;MyMethod&lt;int&gt;&quot;)</code> searches for a member with the text name &quot;<code>MyMethod&lt;int&gt;</code>&quot;, rather than for a method named <code>MyMethod</code> that has one generic argument of type <code>int</code>.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example displays all the methods of the <code>myString</code> class that start with the letter C.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_GetMember#3\">    public void GetPublicInstanceMethodMemberInfo()\n    {\n        String myString = &quot;GetMember_String_MemberType_BindingFlag&quot;;\n        Type myType = myString.GetType();\n        // Get the public instance methods for myString starting with the letter C.\n        MemberInfo[] myMembers = myType.GetMember(&quot;C*&quot;, MemberTypes.Method, \n            BindingFlags.Public | BindingFlags.Instance);\n        if(myMembers.Length &gt; 0)\n        {\n            Console.WriteLine(&quot;<br>The public instance method(s) starting with the letter C for type {0}:&quot;, myType);\n            for(int index=0; index &lt; myMembers.Length; index++)\n                Console.WriteLine(&quot;Member {0}: {1}&quot;, index + 1, myMembers[index].ToString());\n        }\n        else\n            Console.WriteLine(&quot;No members match the search criteria.&quot;);    \n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetMember#3\">void GetPublicInstanceMethodMemberInfo()\n{\n   String^ myString = &quot;GetMember_String_MemberType_BindingFlag&quot;;\n   Type^ myType = myString-&gt;GetType();\n   \n   // Get the public instance methods for myString starting with the letter C.\n   array&lt;MemberInfo^&gt;^myMembers = myType-&gt;GetMember( &quot;C*&quot;, MemberTypes::Method, static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Instance) );\n   if ( myMembers-&gt;Length &gt; 0 )\n   {\n      Console::WriteLine( &quot;<br>The public instance method(s) starting with the letter C for type {0}:&quot;, myType );\n      for ( int index = 0; index &lt; myMembers-&gt;Length; index++ )\n         Console::WriteLine( &quot;Member {0}: {1}&quot;, index + 1, myMembers[ index ] );\n   }\n   else\n      Console::WriteLine( &quot;No members match the search criteria.&quot; );\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetMember#3\">    Public Sub GetPublicInstanceMethodMemberInfo()\n        Dim myString As [String] = &quot;GetMember_String_MemberType_BindingFlag&quot;\n\n        Dim myType As Type = myString.GetType()\n        &#39; Get the public instance methods for myString starting with the letter C.\n        Dim myMembers As MemberInfo() = myType.GetMember(&quot;C*&quot;, MemberTypes.Method, BindingFlags.Public Or BindingFlags.Instance)\n        If myMembers.Length &gt; 0 Then\n            Console.WriteLine(ControlChars.Cr + &quot;The public instance method(s) starting with the letter C for type {0}:&quot;, myType)\n            Dim index As Integer\n            For index = 0 To myMembers.Length - 1\n                Console.WriteLine(&quot;Member {0}: {1}&quot;, index + 1, myMembers(index).ToString())\n            Next index\n        Else\n            Console.WriteLine(&quot;No members match the search criteria.&quot;)\n        End If\n    End Sub &#39;GetPublicInstanceMethodMemberInfo \nEnd Class &#39;MyMemberSample\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetMembers\">\r\n    \r\n            <a id=\"System_Type_GetMembers_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetMembers()</div>        \r\n          </div>\r\n    \r\n            <p>Returns all the public members of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.MemberInfo[] GetMembers ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a> objects representing all the public members of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.  </p>\n<p> -or-  </p>\n<p> An empty array of type <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a>, if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> does not have public members.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Members include properties, methods, fields, events, and so on.  </p>\n<p> The GetMembers method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.  </p>\n<p> This method overload calls the <a class=\"xref\" href=\"system.type#System_Type_GetMembers_System_Reflection_BindingFlags_\" data-linktype=\"relative-path\">GetMembers(BindingFlags)</a> method overload, with <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (<a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a><code>Or</code><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a><code>Or</code><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> in Visual Basic). It will not find class initializers (.cctor). To find class initializers, use an overload that takes <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a>, and specify <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (<a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a><code>Or</code><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> in Visual Basic). You can also get the class initializer using the <a class=\"xref\" href=\"system.type#System_Type_TypeInitializer_\" data-linktype=\"relative-path\">TypeInitializer</a> property.  </p>\n<p> The following table shows what members of a base class are returned by the <code>Get</code> methods when reflecting on a type.  </p>\n<table>\n<thead>\n<tr>\n<th>Member Type</th>\n<th>Static</th>\n<th>Non-Static</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Constructor</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Field</td>\n<td>No</td>\n<td>Yes. A field is always hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Event</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n<tr>\n<td>Method</td>\n<td>No</td>\n<td>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Nested Type</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Property</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  </p>\n</li>\n<li><p>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  </p>\n</li>\n<li><p>Custom attributes are not part of the common type system.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a> objects with the type parameters replaced by the appropriate type arguments.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a> if there is no class constraint.</p>\n</li>\n</ol>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates how to use the GetMembers method overload to collect information about all public members of a specified class.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_GetMembers1#1\">\nclass MyClass\n{\n   public int myInt = 0;\n   public string myString = null;\n\n   public MyClass()\n   {\n   }\n   public void Myfunction()\n   {\n   }\n}\n\nclass Type_GetMembers_BindingFlags\n{\n   public static void Main()\n   {\n      try\n      {\n         MyClass MyObject = new MyClass();\n         MemberInfo [] myMemberInfo; \n\n         // Get the type of the class &#39;MyClass&#39;.\n         Type myType = MyObject.GetType(); \n        \n         // Get the public instance members of the class &#39;MyClass&#39;. \n         myMemberInfo = myType.GetMembers(BindingFlags.Public|BindingFlags.Instance);\n    \n         Console.WriteLine( &quot;<br>The public instance members of class &#39;{0}&#39; are : <br>&quot;, myType); \n         for (int i =0 ; i &lt; myMemberInfo.Length ; i++)\n         {\n            // Display name and type of the member of &#39;MyClass&#39;.\n            Console.WriteLine( &quot;&#39;{0}&#39; is a {1}&quot;, myMemberInfo[i].Name, myMemberInfo[i].MemberType);\n         }\n\n      }\n      catch (SecurityException e)\n      {\n         Console.WriteLine(&quot;SecurityException : &quot; + e.Message ); \n      }      \n\n      //Output:\n      //The public instance members of class &#39;MyClass&#39; are :\n\n      //&#39;Myfunction&#39; is a Method\n      //&#39;ToString&#39; is a Method\n      //&#39;Equals&#39; is a Method\n      //&#39;GetHashCode&#39; is a Method\n      //&#39;GetType&#39; is a Method\n      //&#39;.ctor&#39; is a Constructor\n      //&#39;myInt&#39; is a Field\n      //&#39;myString&#39; is a Field\n\n   }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetMembers1#1\">ref class MyClass\n{\npublic:\n   int * myInt;\n   String^ myString;\n   MyClass(){}\n\n   void Myfunction(){}\n\n};\n\nint main()\n{\n   try\n   {\n      MyClass^ MyObject = gcnew MyClass;\n      array&lt;MemberInfo^&gt;^myMemberInfo;\n      \n      // Get the type of the class &#39;MyClass&#39;.\n      Type^ myType = MyObject-&gt;GetType();\n      \n      // Get the public instance members of the class &#39;MyClass&#39;.\n      myMemberInfo = myType-&gt;GetMembers( static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Instance) );\n      Console::WriteLine( &quot;<br>The public instance members of class &#39;{0}&#39; are : <br>&quot;, myType );\n      for ( int i = 0; i &lt; myMemberInfo-&gt;Length; i++ )\n      {\n         \n         // Display name and type of the member of &#39;MyClass&#39;.\n         Console::WriteLine( &quot;&#39;{0}&#39; is a {1}&quot;, myMemberInfo[ i ]-&gt;Name, myMemberInfo[ i ]-&gt;MemberType );\n\n      }\n   }\n   catch ( SecurityException^ e ) \n   {\n      Console::WriteLine( &quot;SecurityException : {0}&quot;, e-&gt;Message );\n   }\n\n\n      //Output:\n      //The public instance members of class &#39;MyClass&#39; are :\n\n      //&#39;Myfunction&#39; is a Method\n      //&#39;ToString&#39; is a Method\n      //&#39;Equals&#39; is a Method\n      //&#39;GetHashCode&#39; is a Method\n      //&#39;GetType&#39; is a Method\n      //&#39;.ctor&#39; is a Constructor\n      //&#39;myInt&#39; is a Field\n      //&#39;myString&#39; is a Field\n\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetMembers1#1\">Class [MyClass]\n   Public myInt As Integer = 0\n   Public myString As String = Nothing\n   \n   \n   Public Sub New()\n   End Sub &#39;New\n   \n   Public Sub Myfunction()\n   End Sub &#39;Myfunction\nEnd Class &#39;[MyClass]\n\nClass Type_GetMembers\n   \n   Public Shared Sub Main()\n      Try\n         Dim myObject As New [MyClass]()\n         Dim myMemberInfo() As MemberInfo\n         \n         &#39; Get the type of &#39;MyClass&#39;.\n         Dim myType As Type = myObject.GetType()\n         \n         &#39; Get the information related to all public member&#39;s of &#39;MyClass&#39;. \n         myMemberInfo = myType.GetMembers()\n         \n         Console.WriteLine(ControlChars.Cr + &quot;The members of class &#39;{0}&#39; are :&quot; + ControlChars.Cr, myType)\n         Dim i As Integer\n         For i = 0 To myMemberInfo.Length - 1\n            &#39; Display name and type of the concerned member.\n            Console.WriteLine(&quot;&#39;{0}&#39; is a {1}&quot;, myMemberInfo(i).Name, myMemberInfo(i).MemberType)\n         Next i\n\n      Catch e As SecurityException\n         Console.WriteLine((&quot;Exception : &quot; + e.Message.ToString()))\n      End Try\n   End Sub &#39;Main\nEnd Class &#39;Type_GetMembers\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetMembers_System_Reflection_BindingFlags_\">\r\n    \r\n            <a id=\"System_Type_GetMembers_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetMembers(BindingFlags)</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, searches for the members defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, using the specified binding constraints.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>bindingAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted.  </p>\n<p> -or-  </p>\n<p> Zero (<a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a>), to return an empty array.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a> objects representing all members defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> that match the specified binding constraints.  </p>\n<p> -or-  </p>\n<p> An empty array of type <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a>, if no members are defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, or if none of the defined members match the binding constraints.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Members include properties, methods, fields, events, and so on.  </p>\n<p> The GetMembers method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.  </p>\n<p> The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which members to include in the search:  </p>\n<ul>\n<li><p>You must specify either <code>BindingFlags.Instance</code> or <code>BindingFlags.Static</code> in order to get a return.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.Public</code> to include public members in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.NonPublic</code> to include non-public members (that is, private, internal, and protected members) in the search. Only protected and internal members on base classes are returned; private members on base classes are not returned.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.FlattenHierarchy</code> to include <code>public</code> and <code>protected</code> static members up the hierarchy; <code>private</code> static members in inherited classes are not included.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> modifier flags can be used to change how the search works:  </p>\n</li>\n<li><p><code>BindingFlags.DeclaredOnly</code> to search only the members declared on the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, not members that were simply inherited.  </p>\n<p>Calling this method with only the <code>Public</code> flag or only the <code>NonPublic</code> flag will return the specified members and does not require any other flags.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.  </p>\n<p>To get the class initializer (.cctor) using this method overload, you must specify <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (<a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a><code>Or</code><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> in Visual Basic). You can also get the class initializer using the <a class=\"xref\" href=\"system.type#System_Type_TypeInitializer_\" data-linktype=\"relative-path\">TypeInitializer</a> property.  </p>\n<p>If the current T:System.Type represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.memberinfo\" data-linktype=\"relative-path\">MemberInfo</a> objects with the type parameters replaced by the appropriate type arguments.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a> if there is no class constraint.</p>\n</li>\n</ul>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates how to use the GetMembers method overload to collect information about all public instance members of a specified class.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_GetMembers2#1\">\nclass MyClass\n{\n   public int myInt = 0;\n   public string myString = null;\n\n   public MyClass()\n   {\n   }\n   public void Myfunction()\n   {\n   }\n}\n\nclass Type_GetMembers_BindingFlags\n{\n   public static void Main()\n   {\n      try\n      {\n         MyClass MyObject = new MyClass();\n         MemberInfo [] myMemberInfo; \n\n         // Get the type of the class &#39;MyClass&#39;.\n         Type myType = MyObject.GetType(); \n        \n         // Get the public instance members of the class &#39;MyClass&#39;. \n         myMemberInfo = myType.GetMembers(BindingFlags.Public|BindingFlags.Instance);\n    \n         Console.WriteLine( &quot;<br>The public instance members of class &#39;{0}&#39; are : <br>&quot;, myType); \n         for (int i =0 ; i &lt; myMemberInfo.Length ; i++)\n         {\n            // Display name and type of the member of &#39;MyClass&#39;.\n            Console.WriteLine( &quot;&#39;{0}&#39; is a {1}&quot;, myMemberInfo[i].Name, myMemberInfo[i].MemberType);\n         }\n\n      }\n      catch (SecurityException e)\n      {\n         Console.WriteLine(&quot;SecurityException : &quot; + e.Message ); \n      }      \n\n      //Output:\n      //The public instance members of class &#39;MyClass&#39; are :\n\n      //&#39;Myfunction&#39; is a Method\n      //&#39;ToString&#39; is a Method\n      //&#39;Equals&#39; is a Method\n      //&#39;GetHashCode&#39; is a Method\n      //&#39;GetType&#39; is a Method\n      //&#39;.ctor&#39; is a Constructor\n      //&#39;myInt&#39; is a Field\n      //&#39;myString&#39; is a Field\n\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetMembers2#1\">Class [MyClass]\n   Public myInt As Integer = 0\n   Public myString As String = Nothing\n   \n   \n   Public Sub New()\n   End Sub &#39;New\n   \n   Public Sub Myfunction()\n   End Sub &#39;Myfunction\nEnd Class &#39;[MyClass]\n\nClass Type_GetMembers\n   \n   Public Shared Sub Main()\n      Try\n         Dim myObject As New [MyClass]()\n         Dim myMemberInfo() As MemberInfo\n         \n         &#39; Get the type of &#39;MyClass&#39;.\n         Dim myType As Type = myObject.GetType()\n         \n         &#39; Get the information related to all public member&#39;s of &#39;MyClass&#39;. \n         myMemberInfo = myType.GetMembers()\n         \n         Console.WriteLine(ControlChars.Cr + &quot;The members of class &#39;{0}&#39; are :&quot; + ControlChars.Cr, myType)\n         Dim i As Integer\n         For i = 0 To myMemberInfo.Length - 1\n            &#39; Display name and type of the concerned member.\n            Console.WriteLine(&quot;&#39;{0}&#39; is a {1}&quot;, myMemberInfo(i).Name, myMemberInfo(i).MemberType)\n         Next i\n\n      Catch e As SecurityException\n         Console.WriteLine((&quot;Exception : &quot; + e.Message.ToString()))\n      End Try\n   End Sub &#39;Main\nEnd Class &#39;Type_GetMembers\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetMembers2#1\">ref class MyClass\n{\npublic:\n   int * myInt;\n   String^ myString;\n   MyClass(){}\n\n   void Myfunction(){}\n\n};\n\nint main()\n{\n   try\n   {\n      MyClass^ MyObject = gcnew MyClass;\n      array&lt;MemberInfo^&gt;^myMemberInfo;\n      \n      // Get the type of the class &#39;MyClass&#39;.\n      Type^ myType = MyObject-&gt;GetType();\n      \n      // Get the public instance members of the class &#39;MyClass&#39;.\n      myMemberInfo = myType-&gt;GetMembers( static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Instance) );\n      Console::WriteLine( &quot;<br>The public instance members of class &#39;{0}&#39; are : <br>&quot;, myType );\n      for ( int i = 0; i &lt; myMemberInfo-&gt;Length; i++ )\n      {\n         \n         // Display name and type of the member of &#39;MyClass&#39;.\n         Console::WriteLine( &quot;&#39;{0}&#39; is a {1}&quot;, myMemberInfo[ i ]-&gt;Name, myMemberInfo[ i ]-&gt;MemberType );\n\n      }\n   }\n   catch ( SecurityException^ e ) \n   {\n      Console::WriteLine( &quot;SecurityException : {0}&quot;, e-&gt;Message );\n   }\n\n\n      //Output:\n      //The public instance members of class &#39;MyClass&#39; are :\n\n      //&#39;Myfunction&#39; is a Method\n      //&#39;ToString&#39; is a Method\n      //&#39;Equals&#39; is a Method\n      //&#39;GetHashCode&#39; is a Method\n      //&#39;GetType&#39; is a Method\n      //&#39;.ctor&#39; is a Constructor\n      //&#39;myInt&#39; is a Field\n      //&#39;myString&#39; is a Field\n\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetMethod_System_String_\">\r\n    \r\n            <a id=\"System_Type_GetMethod_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetMethod(String)</div>        \r\n          </div>\r\n    \r\n            <p>Searches for the public method with the specified name.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.MethodInfo GetMethod (string name);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the public method to get.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a></div>\r\n                  </div>\r\n                  <p>An object that represents the public method with the specified name, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a></div>\r\n                  </div>\r\n                  <p>More than one method is found with the specified name.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The search for <code>name</code> is case-sensitive. The search includes public static and public instance methods.  </p>\n<p> If a method is overloaded and has more than one public method, the GetMethod method throws an <a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a> exception. In the following example, an exception is thrown because there is more than one public overload of the <a class=\"xref\" href=\"system.int32#System_Int32_ToString_\" data-linktype=\"relative-path\">ToString</a> method.  On the other hand, because the <code>Person.ToString</code> method overrides  <a class=\"xref\" href=\"system.object#System_Object_ToString_\" data-linktype=\"relative-path\">ToString</a> and therefore is not overloaded, the GetMethod method is able to retrieve the <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> object.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.GetMethod#3\">using System;\nusing System.Reflection;\n\npublic class Person\n{\n   public String FirstName;\n   public String LastName;\n   \n   public override String ToString()\n   {\n      return (FirstName + &quot; &quot; + LastName).Trim();\n   }\n}\n\npublic class Example\n{\n   public static void Main()\n   {\n      Type t = typeof(Person);\n      RetrieveMethod(t, &quot;ToString&quot;);\n      \n      t = typeof(Int32);\n      RetrieveMethod(t, &quot;ToString&quot;);\n   }\n\n   private static void RetrieveMethod(Type t, String name)\n   {   \n      try {\n         MethodInfo m = t.GetMethod(name);\n         if (m != null) \n            Console.WriteLine(&quot;{0}.{1}: {2} method&quot;, m.ReflectedType.Name,\n                              m.Name, m.IsStatic ? &quot;Static&quot; : &quot;Instance&quot;);    \n         else\n            Console.WriteLine(&quot;{0}.ToString method not found&quot;, t.Name);\n      }\n      catch (AmbiguousMatchException) {\n         Console.WriteLine(&quot;{0}.{1} has multiple public overloads.&quot;, \n                           t.Name, name);\n      }\n   }\n}\n// The example displays the following output:\n//       Person.ToString: Instance method\n//       Int32.ToString has multiple public overloads.\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.GetMethod#3\">Imports System.Reflection\n\nPublic Class Person\n   Public FirstName As String\n   Public LastName As String\n   \n   Public Overrides Function ToString() As String\n      Return (FirstName + &quot; &quot; + LastName).Trim()\n   End Function\nEnd Class\n\nModule Example\n   Public Sub Main()\n      Dim t As Type = GetType(Person)\n      RetrieveMethod(t, &quot;ToString&quot;)\n      \n      t = GetType(Int32)\n      RetrieveMethod(t, &quot;ToString&quot;)\n   End Sub\n   \n   Private Sub RetrieveMethod(t As Type, name As String)   \n      Try\n         Dim m As MethodInfo = t.GetMethod(name)\n         If m IsNot Nothing Then\n            Console.WriteLine(&quot;{0}.{1}: {2} method&quot;, m.ReflectedType.Name,\n                              m.Name, If(m.IsStatic, &quot;Static&quot;, &quot;Instance&quot;))    \n         Else\n            Console.WriteLine(&quot;{0}.ToString method not found&quot;, t.Name)\n         End If   \n      Catch e As AmbiguousMatchException\n         Console.WriteLine(&quot;{0}.{1} has multiple public overloads.&quot;, \n                           t.Name, name)\n      End Try\n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       Person.ToString: Instance method\n&#39;       Int32.ToString has multiple public overloads.\n</code></pre><p> You can do one of the following to retrieve a specific method:  </p>\n<ul>\n<li><p>Call the <a class=\"xref\" href=\"system.type#System_Type_GetMethod_System_String_System_Reflection_BindingFlags_\" data-linktype=\"relative-path\">GetMethod(String,BindingFlags)</a> method and specify a <code>bindingAttr</code> argument that uniquely identifies the method. For example, if the exception is thrown because a type has a static and an instance overload, you can specify a  <code>bindingAttr</code> argument  of <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a><code>Or</code><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a>.  </p>\n</li>\n<li><p>Call an overload of the GetMethod method that includes a <code>types</code> parameter which defines the types of the method&#39;s parameters.  </p>\n</li>\n<li><p>Call the <a class=\"xref\" href=\"system.type#System_Type_GetMethods\" data-linktype=\"relative-path\">GetMethods()</a> method to retrieve an array containing all of the public methods belonging to a type. You can then iterate it to identify the duplicate methods named <code>name</code>.  </p>\n<p>If the current T:System.Type represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> with the type parameters replaced by the appropriate type arguments.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a> if there is no class constraint.  </p>\n</li>\n</ul>\n<div class=\"NOTE\"><h5>Note</h5><p> For generic methods, do not include the type arguments in <code>name</code>. For example, the C# code <code>GetMember(&quot;MyMethod&lt;int&gt;&quot;)</code> searches for a member with the text name &quot;<code>MyMethod&lt;int&gt;</code>&quot;, rather than for a method named <code>MyMethod</code> that has one generic argument of type <code>int</code>.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example gets a method named <code>MethodA</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_GetMethod1#1\">\nusing System;\nusing System.Reflection;\n\nclass Program\n{\n\n    // Method to get:\n    public void MethodA() { }\n\n\n    static void Main(string[] args)\n    {\n\n        // Get MethodA()\n        MethodInfo mInfo = typeof(Program).GetMethod(&quot;MethodA&quot;);\n        Console.WriteLine(&quot;Found method: {0}&quot;, mInfo);\n\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetMethod1#1\">using namespace System;\nusing namespace System::Reflection;\npublic ref class Program\n{\n\n    public:\n\n        // Method to get:\n        void MethodA() { }\n\n    };\n\n    int main()\n    {\n\n        // Get MethodA()\n        MethodInfo^ mInfo = Program::typeid-&gt;GetMethod(&quot;MethodA&quot;);\n        Console::WriteLine(&quot;Found method: {0}&quot;, mInfo );\n\n    }\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetMethod1#1\">\nImports System\nImports System.Reflection\n\nClass Program\n\n    &#39; Method to get:\n    Public Sub MethodA()\n    End Sub\n\n\n    Public Shared Sub Main(ByVal args() As String)\n\n        &#39; Get MethodA()\n        Dim mInfo As MethodInfo = GetType(Program).GetMethod(&quot;MethodA&quot;)\n        Console.WriteLine(&quot;Found method: {0}&quot;, mInfo)\n\n    End Sub\nEnd Class\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetMethod_System_String_System_Reflection_BindingFlags_\">\r\n    \r\n            <a id=\"System_Type_GetMethod_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetMethod(String,BindingFlags)</div>        \r\n          </div>\r\n    \r\n            <p>Searches for the specified method, using the specified binding constraints.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the method to get.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>bindingAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted.  </p>\n<p> -or-  </p>\n<p> Zero, to return <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a></div>\r\n                  </div>\r\n                  <p>An object representing the method that matches the specified requirements, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a></div>\r\n                  </div>\r\n                  <p>More than one method is found with the specified name and matching the specified binding constraints.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which methods to include in the search:  </p>\n<ul>\n<li><p>You must specify either <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> or <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> in order to get a return.  </p>\n</li>\n<li><p>Specify <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> to include public methods in the search.  </p>\n</li>\n<li><p>Specify <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> to include non-public methods (that is, private, internal, and protected methods) in the search.  </p>\n</li>\n<li><p>Specify <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> to include <code>public</code> and <code>protected</code> static members up the hierarchy; <code>private</code> static members in inherited classes are not included.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> modifier flags can be used to change how the search works:  </p>\n</li>\n<li><p><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> to ignore the case of <code>name</code>.  </p>\n</li>\n<li><p><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> to search only the methods declared on the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, not methods that were simply inherited.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.  </p>\n<p>If a method is overloaded and more than one overload meets the constraints specified by the <code>bindingAttr</code> argument, the method throws an <a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a> exception. In the following example, an exception is thrown because:  </p>\n</li>\n<li><p>The <code>TestClass</code> type has two public instance overloads of the <code>DisplayValue</code> method, <code>DisplayValue(String)</code> and <code>DisplayValue(String, Object[])</code>.  </p>\n</li>\n<li><p>The <code>TestClass</code> type has two public instance overloads of the <code>Equals</code> method,  one of which is inherited from <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>: <code>Equals(TestClass)</code> and <code>Equals(Object)</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.GetMethod#2\">using System;\nusing System.Reflection;\n\npublic class TestClass\n{\n   public void DisplayValue(String s)\n   {\n      Console.WriteLine(s);\n   }\n   \n   public void DisplayValue(String s, params Object[] values)\n   {\n      Console.WriteLine(s, values);\n   }\n   \n   public static bool Equals(TestClass t1, TestClass t2)\n   {\n      return Object.ReferenceEquals(t1, t2);\n   }\n   \n   public bool Equals(TestClass t) \n   {\n      return Object.ReferenceEquals(this, t);\n   }          \n}\n\npublic class Example\n{\n   public static void Main()\n   {\n      Type t = typeof(TestClass);\n      \n      RetrieveMethod(t, &quot;DisplayValue&quot;, BindingFlags.Public | BindingFlags.Instance);\n\n      RetrieveMethod(t, &quot;Equals&quot;, BindingFlags.Public | BindingFlags.Instance);\n      \n      RetrieveMethod(t, &quot;Equals&quot;, BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);\n      \n      RetrieveMethod(t, &quot;Equals&quot;, BindingFlags.Public | BindingFlags.Static);\n   }\n   \n   private static void RetrieveMethod(Type t, String name, BindingFlags flags)\n   {\n      try {\n         MethodInfo m = t.GetMethod(name, flags);\n         if (m != null) {\n            Console.Write(&quot;{0}.{1}(&quot;, t.Name, m.Name);\n            ParameterInfo[] parms= m.GetParameters();\n            for (int ctr = 0; ctr &lt;parms.Length; ctr++) {\n               Console.Write(parms[ctr].ParameterType.Name);\n               if (ctr &lt; parms.Length - 1) \n                  Console.Write(&quot;, &quot;);\n\n            }\n            Console.WriteLine(&quot;)&quot;);\n         }\n         else {\n            Console.WriteLine(&quot;Method not found&quot;);\n         }\n      }\n      catch (AmbiguousMatchException) {\n         Console.WriteLine(&quot;The following duplicate matches were found:&quot;);\n         MethodInfo[] methods = t.GetMethods(flags);\n         foreach (var method in methods) {\n            if (method.Name != name) continue;\n\n            Console.Write(&quot;   {0}.{1}(&quot;, t.Name, method.Name);\n            ParameterInfo[] parms = method.GetParameters();\n            for (int ctr = 0; ctr &lt; parms.Length; ctr++) {\n               Console.Write(parms[ctr].ParameterType.Name);\n               if (ctr &lt; parms.Length - 1) \n                  Console.Write(&quot;, &quot;);\n\n            }\n            Console.WriteLine(&quot;)&quot;);\n         } \n      }         \n      Console.WriteLine();\n   }\n}\n// The example displays the following output:\n//       The following duplicate matches were found:\n//          TestClass.DisplayValue(String)\n//          TestClass.DisplayValue(String, Object[])\n//       \n//       The following duplicate matches were found:\n//          TestClass.Equals(TestClass)\n//          TestClass.Equals(Object)\n//       \n//       TestClass.Equals(TestClass)\n//       \n//       TestClass.Equals(TestClass, TestClass)\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.GetMethod#2\">Imports System.Reflection\n\nPublic Class TestClass\n   Public Sub DisplayValue(s As String)\n      Console.WriteLine(s)\n   End Sub\n   \n   Public Sub DisplayValue(s As String, ParamArray values() As Object)\n      Console.WriteLine(s, values)\n   End Sub\n   \n   Public Overloads Shared Function Equals(t1 As TestClass, t2 As TestClass) As Boolean\n      Return Object.ReferenceEquals(t1, t2)\n   End Function\n   \n   Public Overloads Function Equals(t As TestClass) As Boolean\n      Return Object.ReferenceEquals(Me, t)\n   End Function          \nEnd Class\n\nModule Example\n   Public Sub Main()\n      Dim t As Type = GetType(TestClass)\n      \n      RetrieveMethod(t, &quot;DisplayValue&quot;, BindingFlags.Public Or BindingFlags.Instance)\n\n      RetrieveMethod(t, &quot;Equals&quot;, BindingFlags.Public Or BindingFlags.Instance)\n      \n      RetrieveMethod(t, &quot;Equals&quot;, BindingFlags.Public Or BindingFlags.Instance Or BindingFlags.DeclaredOnly)\n      \n      RetrieveMethod(t, &quot;Equals&quot;, BindingFlags.Public Or BindingFlags.Static)\n   End Sub\n   \n   Public Sub RetrieveMethod(t As Type, name As String, flags As BindingFlags)\n      Try\n         Dim m As MethodInfo = t.GetMethod(name, flags)\n         If m IsNot Nothing Then\n            Console.Write(&quot;{0}.{1}(&quot;, t.Name, m.Name)\n           Dim parms() As ParameterInfo = m.GetParameters()\n            For ctr As Integer = 0 To parms.Length - 1\n               Console.Write(parms(ctr).ParameterType.Name)\n               if ctr &lt; parms.Length - 1 Then \n                  Console.Write(&quot;, &quot;)\n               End If      \n            Next\n            Console.WriteLine(&quot;)&quot;)\n         Else\n            Console.WriteLine(&quot;Method not found&quot;)\n         End If\n      Catch e As AmbiguousMatchException\n         Console.WriteLine(&quot;The following duplicate matches were found:&quot;)\n         Dim methods() As MethodInfo = t.GetMethods(flags)\n         For Each method In methods\n            If method.Name &lt;&gt; name Then Continue For\n\n            Console.Write(&quot;   {0}.{1}(&quot;, t.Name, method.Name)\n            Dim parms() As ParameterInfo = method.GetParameters()\n            For ctr As Integer = 0 To parms.Length - 1\n               Console.Write(parms(ctr).ParameterType.Name)\n               if ctr &lt; parms.Length - 1 Then \n                  Console.Write(&quot;, &quot;)\n               End If      \n            Next\n            Console.WriteLine(&quot;)&quot;)\n         Next \n      End Try         \n      Console.WriteLine()\n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       The following duplicate matches were found:\n&#39;          TestClass.DisplayValue(String)\n&#39;          TestClass.DisplayValue(String, Object[])\n&#39;       \n&#39;       The following duplicate matches were found:\n&#39;          TestClass.Equals(TestClass)\n&#39;          TestClass.Equals(Object)\n&#39;       \n&#39;       TestClass.Equals(TestClass)\n&#39;       \n&#39;       TestClass.Equals(TestClass, TestClass)\n</code></pre><p>You can do one of the following to retrieve a specific method:  </p>\n</li>\n<li><p>Change the binding constraints. In the previous example, attempting to retrieve a public instance <code>Equals</code> method that is declared by the type and not inherited successfully retrieves <code>Equals(TestClass)</code>.  </p>\n</li>\n<li><p>Call an overload of the <a class=\"xref\" href=\"system.type#System_Type_GetMethod_\" data-linktype=\"relative-path\">GetMethod</a> method that includes a <code>types</code> parameter which defines the types of the method&#39;s parameters.  </p>\n</li>\n<li><p>Call the <a class=\"xref\" href=\"system.type#System_Type_GetMethods_System_Reflection_BindingFlags_\" data-linktype=\"relative-path\">GetMethods(BindingFlags)</a> method to retrieve an array containing all of the methods belonging to a type that have the specified binding attributes. You can then iterate it to identify the duplicate methods named <code>name</code>. This approach is illustrated in the previous example&#39;s handler for the <a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a> exception.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> with the type parameters replaced by the appropriate type arguments.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a> if there is no class constraint.  </p>\n</li>\n</ul>\n<div class=\"NOTE\"><h5>Note</h5><p> For generic methods, do not include the type arguments in <code>name</code>. For example, the C# code <code>GetMember(&quot;MyMethod&lt;int&gt;&quot;)</code> searches for a member with the text name &quot;<code>MyMethod&lt;int&gt;</code>&quot;, rather than for a method named <code>MyMethod</code> that has one generic argument of type <code>int</code>.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example gets the method that matches the specified binding flags.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_GetMethod2#1\">using namespace System;\nusing namespace System::Reflection;\npublic ref class Program\n{\n\n    public:\n\n        // Method to get:\n        void MethodA() { }\n\n    };\n\n    int main()\n    {\n\n        // Get MethodA()\n        MethodInfo^ mInfo = Program::typeid-&gt;GetMethod(&quot;MethodA&quot;,\n            static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Instance));\n        Console::WriteLine(&quot;Found method: {0}&quot;, mInfo );\n\n    }\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_GetMethod2#1\">\nusing System;\nusing System.Reflection;\n\nclass Program\n{\n\n    // Method to get:\n    public void MethodA() { }\n\n\n    static void Main(string[] args)\n    {\n\n        // Get MethodA()\n        MethodInfo mInfo = typeof(Program).GetMethod(&quot;MethodA&quot;,\n            BindingFlags.Public | BindingFlags.Instance);\n        Console.WriteLine(&quot;Found method: {0}&quot;, mInfo);\n\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetMethod2#1\">\nImports System\nImports System.Reflection\n\nClass Program\n\n    &#39; Method to get:\n    Public Sub MethodA()\n    End Sub\n\n\n    Public Shared Sub Main(ByVal args() As String)\n\n        &#39; Get MethodA()\n        Dim mInfo As MethodInfo = GetType(Program).GetMethod(&quot;MethodA&quot;, _\n        \tBindingFlags.Public Or BindingFlags.Instance)\n        Console.WriteLine(&quot;Found method: {0}&quot;, mInfo)\n\n    End Sub\nEnd Class\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetMethod_System_String_System_Type___\">\r\n    \r\n            <a id=\"System_Type_GetMethod_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetMethod(String,Type[])</div>        \r\n          </div>\r\n    \r\n            <p>Searches for the specified public method whose parameters match the specified argument types.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.MethodInfo GetMethod (string name, Type[] types);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the public method to get.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>types</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects representing the number, order, and type of the parameters for the method to get.  </p>\n<p> -or-  </p>\n<p> An empty array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects (as provided by the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> field) to get a method that takes no parameters.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a></div>\r\n                  </div>\r\n                  <p>An object representing the public method whose parameters match the specified argument types, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a></div>\r\n                  </div>\r\n                  <p>More than one method is found with the specified name and specified parameters.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>types</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One of the elements in <code>types</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>types</code> is multidimensional.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The search for <code>name</code> is case-sensitive. The search includes public static and public instance methods.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  </p>\n</div>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> with the type parameters replaced by the appropriate type arguments.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a> if there is no class constraint.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The <code>name</code> parameter cannot include type arguments. For example, the C# code <code>GetMethod(&quot;MyGenericMethod&lt;int&gt;&quot;)</code> searches for a method with the text name &quot;<code>MyGenericMethod&lt;int&gt;</code>&quot;, rather than for a method named <code>MyGenericMethod</code> that has one generic argument of type <code>int</code>. Instead, use <code>GetMethod(&quot;MyGenericMethod&quot;)</code> with the appropriate parameter in the <code>types</code> array.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example finds specific overloads of <code>MethodA</code>, specifying a variety of argument types.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/csprcslong-md.md&quot; -->Visual C# 2005<!--END INCLUDE --> example requires the <code>/unsafe</code> compiler option.  </p>\n</div>\n<pre><code class=\"lang-cpp\" name=\"Type_GetMethod4#1\">using namespace System;\nusing namespace System::Reflection;\n\npublic ref class Program\n{\n\npublic:\n    // Methods to get:\n\n    void MethodA(int i, int j) { }\n\n    void MethodA(array&lt;int&gt;^ iarry) { }\n\n    void MethodA(double *ip) { }\n\n    // Method that takes a managed reference parameter.\n    void MethodA(int% r) {}\n};\n\nint main()\n{\n    MethodInfo^ mInfo;\n\n\n    // Get MethodA(int i, int j)\n    mInfo = Program::typeid-&gt;GetMethod(&quot;MethodA&quot;, gcnew array&lt;Type^&gt; {int::typeid,int::typeid});\n    Console::WriteLine(&quot;Found method: {0}&quot;, mInfo );\n\n    // Get MethodA(array&lt;int&gt;^ iarry)\n    mInfo = Program::typeid-&gt;GetMethod(&quot;MethodA&quot;, gcnew array&lt;Type^&gt; {int::typeid-&gt;MakeArrayType()});\n    Console::WriteLine(&quot;Found method: {0}&quot;, mInfo );\n\n    // Get MethodA(double *ip)\n    mInfo = Program::typeid-&gt;GetMethod(&quot;MethodA&quot;, gcnew array&lt;Type^&gt; {double::typeid-&gt;MakePointerType()});\n    Console::WriteLine(&quot;Found method: {0}&quot;, mInfo );\n\n    // Get MethodA(int% r)\n    mInfo = Program::typeid-&gt;GetMethod(&quot;MethodA&quot;, gcnew array&lt;Type^&gt; {int::typeid-&gt;MakeByRefType()});\n    // Display the method information.\n    Console::WriteLine(&quot;Found method: {0}&quot;, mInfo );\n\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_GetMethod4#1\">\nusing System;\nusing System.Reflection;\n\nclass Program\n{\n    // Methods to get:\n\n    public void MethodA(int i, int j) { }\n\n    public void MethodA(int[] i) { }\n\n    public unsafe void MethodA(int* i) { }\n\n    public void MethodA(ref int r) {}\n\n    // Method that takes an out parameter:\n    public void MethodA(int i, out int o) { o = 100;}\n\n\n  static void Main(string[] args)\n  {\n    MethodInfo mInfo;\n\n    // Get MethodA(int i, int i)\n    mInfo = typeof(Program).GetMethod(&quot;MethodA&quot;,\n        new Type[] { typeof(int), typeof(int) });\n    Console.WriteLine(&quot;Found method: {0}&quot;, mInfo);\n\n    // Get MethodA(int[] i)\n    mInfo = typeof(Program).GetMethod(&quot;MethodA&quot;,\n        new Type[] { typeof(int[]) });\n    Console.WriteLine(&quot;Found method: {0}&quot;, mInfo);\n\n    // Get MethodA(int* i)\n    mInfo = typeof(Program).GetMethod(&quot;MethodA&quot;,\n        new Type[] { typeof(int).MakePointerType() });\n    Console.WriteLine(&quot;Found method: {0}&quot;, mInfo);\n\n    // Get MethodA(ref int r)\n    mInfo = typeof(Program).GetMethod(&quot;MethodA&quot;,\n        new Type[] { typeof(int).MakeByRefType() });\n    Console.WriteLine(&quot;Found method: {0}&quot;, mInfo);\n\n    // Get MethodA(int i, out int o)\n    mInfo = typeof(Program).GetMethod(&quot;MethodA&quot;,\n        new Type[] { typeof(int), typeof(int).MakeByRefType() });\n    Console.WriteLine(&quot;Found method: {0}&quot;, mInfo);\n\n  }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetMethod4#1\">\nImports System\nImports System.Reflection\nImports System.Runtime.InteropServices\n\nClass Program\n\n    &#39; Methods to get:\n\n    Public Overloads Sub MethodA(ByVal i As Integer, ByVal l As Long)\n\n    End Sub\n\n    Public Overloads Sub MethodA(ByVal i() As Integer)\n\n    End Sub\n\n    Public Overloads Sub MethodA(ByRef r As Integer)\n\n    End Sub\n\n    &#39; Method that takes an out parameter. Note that an Imports\n    &#39; reference is needed to System.Runtime.InteropServices \n    &#39; for the &lt;OutAttribute&gt;, which can be shortened to &lt;Out&gt;.\n    Public Overloads Sub MethodA(ByVal i As Integer, &lt;Out()&gt; ByRef o As Integer)\n        o = 100\n    End Sub\n\n    Public Shared Sub Main(ByVal args() As String)\n        Dim mInfo As MethodInfo\n\n        &#39; Get MethodA(i As Integer i, l As Long)\n        mInfo = GetType(Program).GetMethod(&quot;MethodA&quot;, New Type() {GetType(Integer), GetType(Long)})\n        Console.WriteLine(&quot;Found method: {0}&quot;, mInfo)\n\n        &#39; Get  MethodA(i As Integer())\n        mInfo = GetType(Program).GetMethod(&quot;MethodA&quot;, New Type() {GetType(Integer())})\n        Console.WriteLine(&quot;Found method: {0}&quot;, mInfo)\n\n        &#39; Get MethodA(ByRef r As Integer)\n        mInfo = GetType(Program).GetMethod(&quot;MethodA&quot;, New Type() {GetType(Integer).MakeByRefType})\n        Console.WriteLine(&quot;Found method: {0}&quot;, mInfo)\n\n        &#39; Get MethodA(i As Integer, ByRef r As Integer)\n        mInfo = GetType(Program).GetMethod(&quot;MethodA&quot;, New Type() {GetType(Integer), _\n            GetType(Integer).MakeByRefType})\n        Console.WriteLine(&quot;Found method: {0}&quot;, mInfo)\n\n    End Sub\nEnd Class\n</code></pre><p> The following example retrieves <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> objects that represent the <code>Add</code> methods  of a non-generic type (the <a class=\"xref\" href=\"system.collections.arraylist\" data-linktype=\"relative-path\">ArrayList</a> class), an open generic type (the <a class=\"xref\" href=\"system.collections.generic.list-1\" data-linktype=\"relative-path\">List&lt;T&gt;</a> class), and a closed generic type (the <code>List(Of String)</code> type.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Type.GetMethod#1\">Imports System.Collections\nImports System.Collections.Generic\nImports System.Reflection\n\nModule Example\n   Public Sub Main()\n      &#39; Get a Type object that represents a non-generic type.\n      GetAddMethod(GetType(ArrayList))\n      \n      Dim list As New List(Of String)()\n      &#39; Get a Type object that represents a constructed generic type.\n      Dim closed As Type = list.GetType()\n      GetAddMethod(closed)\n      \n      &#39; Get a Type object that represents an open generic type.\n      Dim open As Type = GetType(List(Of))\n      GetAddMethod(open)\n   End Sub\n   \n   Private Sub GetAddMethod(typ As Type)\n      Dim method As MethodInfo\n      &#39; Determine if this is a generic type.\n      If typ.IsGenericType Then\n         &#39; Is it an open generic type?\n         If typ.ContainsGenericParameters Then\n            method = typ.GetMethod(&quot;Add&quot;, typ.GetGenericArguments())\n         &#39; Get closed generic type arguments.\n         Else\n            method = typ.GetMethod(&quot;Add&quot;, typ.GenericTypeArguments)\n         End If\n      &#39; This is not a generic type.\n      Else\n         method = typ.GetMethod(&quot;Add&quot;, { GetType(Object) } )\n      End If\n      &#39; Test if an Add method was found.\n      If method Is Nothing Then \n         Console.WriteLine(&quot;No Add method found.&quot;)\n         Exit Sub\n      End If   \n\n      Dim t As Type = method.ReflectedType\n      Console.Write(&quot;{0}.{1}.{2}(&quot;, t.Namespace, t.Name, method.Name)\n      Dim params() As ParameterInfo = method.GetParameters()\n      For ctr As Integer = 0 To params.Length - 1\n         Console.Write(&quot;{0}{1}&quot;, params(ctr).ParameterType.Name, \n                       If(ctr &lt; params.Length - 1, &quot;, &quot;, &quot;&quot;))\n      Next\n      Console.WriteLine(&quot;)&quot;)\n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       System.Collections.ArrayList.Add(Object)\n&#39;       System.Collections.Generic.List`1.Add(String)\n&#39;       System.Collections.Generic.List`1.Add(T)\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.GetMethod#1\">using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Reflection;\n\npublic class Example\n{\n   public static void Main()\n   {\n      // Get a Type object that represents a non-generic type.\n      GetAddMethod(typeof(ArrayList));\n\n      var list = new List&lt;String&gt;();\n      // Get a Type object that represents a constructed generic type.\n      Type closed = list.GetType();\n      GetAddMethod(closed);\n      \n      // Get a Type object that represents an open generic type.\n      Type open = typeof(List&lt;&gt;);\n      GetAddMethod(open);\n   }\n\n   private static void GetAddMethod(Type typ)\n   {\n      MethodInfo method;\n      // Determine if this is a generic type.\n      if (typ.IsGenericType) {\n         // Is it an open generic type?\n         if (typ.ContainsGenericParameters)\n            method = typ.GetMethod(&quot;Add&quot;, typ.GetGenericArguments());\n         // Get closed generic type arguments.\n         else\n            method = typ.GetMethod(&quot;Add&quot;, typ.GenericTypeArguments);\n      }\n      // This is not a generic type.\n      else {\n         method = typ.GetMethod(&quot;Add&quot;, new Type[] { typeof(Object) } );\n      }\n\n      // Test if an Add method was found.\n      if (method == null) { \n         Console.WriteLine(&quot;No Add method found.&quot;);\n         return;\n      }   \n      \n      Type t = method.ReflectedType;\n      Console.Write(&quot;{0}.{1}.{2}(&quot;, t.Namespace, t.Name, method.Name);\n      ParameterInfo[] parms = method.GetParameters();\n      for (int ctr = 0; ctr &lt; parms.Length; ctr++)\n         Console.Write(&quot;{0}{1}&quot;, parms[ctr].ParameterType.Name, \n                       ctr &lt; parms.Length - 1 ? &quot;, &quot; : &quot;&quot;);\n\n      Console.WriteLine(&quot;)&quot;);\n   }   \n}\n// The example displays the following output:\n//       System.Collections.ArrayList.Add(Object)\n//       System.Collections.Generic.List`1.Add(String)\n//       System.Collections.Generic.List`1.Add(T)\n</code></pre><p> The example defines a <code>GetAddMethod</code> method that retrieves the appropriate <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> object. To provide the <code>types</code> argument for an open generic type, it calls the <a class=\"xref\" href=\"system.type#System_Type_GetGenericArguments_\" data-linktype=\"relative-path\">GetGenericArguments</a> method. To provide the <code>types</code> argument for a closed generic type, it retrieves the value of the <a class=\"xref\" href=\"system.type#System_Type_GenericTypeArguments_\" data-linktype=\"relative-path\">GenericTypeArguments</a> property.</p>\n\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetMethod_System_String_System_Type___System_Reflection_ParameterModifier___\">\r\n    \r\n            <a id=\"System_Type_GetMethod_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetMethod(String,Type[],ParameterModifier[])</div>        \r\n          </div>\r\n    \r\n            <p>Searches for the specified public method whose parameters match the specified argument types and modifiers.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the public method to get.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>types</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects representing the number, order, and type of the parameters for the method to get.  </p>\n<p> -or-  </p>\n<p> An empty array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects (as provided by the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> field) to get a method that takes no parameters.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>modifiers</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <code>types</code> array. To be only used when calling through COM interop, and only parameters that are passed by reference are handled. The default binder does not process this parameter.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a></div>\r\n                  </div>\r\n                  <p>An object representing the public method that matches the specified requirements, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a></div>\r\n                  </div>\r\n                  <p>More than one method is found with the specified name and specified parameters.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>types</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One of the elements in <code>types</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>types</code> is multidimensional.  </p>\n<p> -or-  </p>\n<p> <code>modifiers</code> is multidimensional.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Although the default binder does not process <a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a> (the <code>modifiers</code> parameter), you can use the abstract <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">System.Reflection.Binder</a> class to write a custom binder that does process <code>modifiers</code>. <code>ParameterModifier</code> is only used when calling through COM interop, and only parameters that are passed by reference are handled.  </p>\n<p> The search for <code>name</code> is case-sensitive. The search includes public static and public instance methods.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  </p>\n</div>\n<p> If the current T:System.Type represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> with the type parameters replaced by the appropriate type arguments.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a> if there is no class constraint.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> For generic methods, do not include the type arguments in <code>name</code>. For example, the C# code <code>GetMethod(&quot;MyMethod&lt;int&gt;&quot;)</code> searches for a member with the text name &quot;<code>MyMethod&lt;int&gt;</code>&quot;, rather than for a method named <code>MyMethod</code> that has one generic argument of type <code>int</code>. Instead, use <code>GetMethod(&quot;MyMethod&quot;)</code> with the appropriate parameter in the <code>types</code> array.</p>\n</div>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetMethod_System_String_System_Reflection_BindingFlags_System_Reflection_Binder_System_Type___System_Reflection_ParameterModifier___\">\r\n    \r\n            <a id=\"System_Type_GetMethod_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetMethod(String,BindingFlags,Binder,Type[],ParameterModifier[])</div>        \r\n          </div>\r\n    \r\n            <p>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the method to get.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>bindingAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted.  </p>\n<p> -or-  </p>\n<p> Zero, to return <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>binder</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  </p>\n<p> -or-  </p>\n<p> A null reference (<code>Nothing</code> in Visual Basic), to use the <span class=\"xref\">stem.Type.DefaultBinder*</span>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>types</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects representing the number, order, and type of the parameters for the method to get.  </p>\n<p> -or-  </p>\n<p> An empty array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects (as provided by the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> field) to get a method that takes no parameters.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>modifiers</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <code>types</code> array. To be only used when calling through COM interop, and only parameters that are passed by reference are handled. The default binder does not process this parameter.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a></div>\r\n                  </div>\r\n                  <p>An object representing the method that matches the specified requirements, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a></div>\r\n                  </div>\r\n                  <p>More than one method is found with the specified name and matching the specified binding constraints.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>types</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One of the elements in <code>types</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>types</code> is multidimensional.  </p>\n<p> -or-  </p>\n<p> <code>modifiers</code> is multidimensional.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Although the default binder does not process <a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a> (the <code>modifiers</code> parameter), you can use the abstract <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">System.Reflection.Binder</a> class to write a custom binder that does process <code>modifiers</code>. <code>ParameterModifier</code> is only used when calling through COM interop, and only parameters that are passed by reference are handled.  </p>\n<p> The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which methods to include in the search:  </p>\n<ul>\n<li><p>You must specify either <code>BindingFlags.Instance</code> or <code>BindingFlags.Static</code> in order to get a return.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.Public</code> to include public methods in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.NonPublic</code> to include nonpublic methods (that is, private, internal, and protected methods) in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.FlattenHierarchy</code> to include <code>public</code> and <code>protected</code> static members up the hierarchy; <code>private</code> static members in inherited classes are not included.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> modifier flags can be used to change how the search works:  </p>\n</li>\n<li><p><code>BindingFlags.IgnoreCase</code> to ignore the case of <code>name</code>.  </p>\n</li>\n<li><p><code>BindingFlags.DeclaredOnly</code> to search only the methods declared on the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, not methods that were simply inherited.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.  </p>\n</li>\n</ul>\n<div class=\"NOTE\"><h5>Note</h5><p> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  </p>\n</div>\n<p> If the current T:System.Type represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> with the type parameters replaced by the appropriate type arguments.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a> if there is no class constraint.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> For generic methods, do not include the type arguments in <code>name</code>. For example, the C# code <code>GetMember(&quot;MyMethod&lt;int&gt;&quot;)</code> searches for a member with the text name &quot;<code>MyMethod&lt;int&gt;</code>&quot;, rather than for a method named <code>MyMethod</code> that has one generic argument of type <code>int</code>.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example finds specific overloads of <code>MethodA</code>, specifying binding constraints and a variety of argument types.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/csprcslong-md.md&quot; -->Visual C# 2005<!--END INCLUDE --> example requires the <code>/unsafe</code> compiler option.  </p>\n</div>\n<pre><code class=\"lang-vb\" name=\"Type_GetMethod5#1\">\nImports System\nImports System.Reflection\nImports System.Runtime.InteropServices\n\nClass Program\n\n    &#39; Methods to get:\n    \n    Public Overloads Sub MethodA(ByVal i As Integer, ByVal l As Long)\n\n    End Sub\n\n    Public Overloads Sub MethodA(ByVal i() As Integer)\n\n    End Sub\n\n    Public Overloads Sub MethodA(ByRef r As Integer)\n\n    End Sub\n\n    &#39; Method that takes an out parameter. Note that an Imports\n    &#39; reference is needed to System.Runtime.InteropServices \n    &#39; for the &lt;OutAttribute&gt;, which can be shortened to &lt;Out&gt;.\n    Public Overloads Sub MethodA(ByVal i As Integer, &lt;Out()&gt; ByRef o As Integer)\n        o = 100\n    End Sub\n\n    Public Shared Sub Main(ByVal args() As String)\n        Dim mInfo As MethodInfo\n\n        &#39; Get MethodA(ByVal i As Integer, ByVal l As Long)\n        mInfo = GetType(Program).GetMethod(&quot;MethodA&quot;, _\n            BindingFlags.Public Or BindingFlags.Instance, _\n            Nothing, _\n            New Type() {GetType(System.Int32), _\n            GetType(System.Int64)}, _\n            Nothing)\n        Console.WriteLine(&quot;Found method: {0}&quot;, mInfo)\n\n        &#39; Get MethodA(ByVal i() As Integer)\n        mInfo = GetType(Program).GetMethod(&quot;MethodA&quot;, _\n            BindingFlags.Public Or BindingFlags.Instance, _\n            Nothing, _\n            New Type() {GetType(System.Int32())}, _\n            Nothing)\n        Console.WriteLine(&quot;Found method: {0}&quot;, mInfo)\n\n        &#39; Get MethodA(ByRef r As Integer)\n        mInfo = GetType(Program).GetMethod(&quot;MethodA&quot;, _\n            BindingFlags.Public Or BindingFlags.Instance, _\n            Nothing, _\n            New Type() {GetType(System.Int32).MakeByRefType}, _\n            Nothing)\n        Console.WriteLine(&quot;Found method: {0}&quot;, mInfo)\n\n        &#39; Get MethodA(ByVal i As Integer, &lt;Out()&gt; ByRef o As Integer)\n        mInfo = GetType(Program).GetMethod(&quot;MethodA&quot;, _\n            BindingFlags.Public Or BindingFlags.Instance, _\n            Nothing, _\n            New Type() {GetType(System.Int32), GetType(System.Int32).MakeByRefType}, _\n            Nothing)\n        Console.WriteLine(&quot;Found method: {0}&quot;, mInfo)\n\n    End Sub\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_GetMethod5#1\">\nusing System;\nusing System.Reflection;\n\nclass Program\n{\n    // Methods to get:\n\n    public void MethodA(int i, int j) { }\n\n    public void MethodA(int[] i) { }\n\n    public unsafe void MethodA(int* i) { }\n\n\n    public void MethodA(ref int r) {}\n\n    // Method that takes an out parameter.\n    public void MethodA(int i, out int o) { o = 100; }\n\n\n  static void Main(string[] args)\n  {\n    MethodInfo mInfo;\n\n    // Get MethodA(int i, int j)\n    mInfo = typeof(Program).GetMethod(&quot;MethodA&quot;,\n        BindingFlags.Public | BindingFlags.Instance,\n        null,\n        new Type[] { typeof(int), typeof(int) },\n        null);\n    Console.WriteLine(&quot;Found method: {0}&quot;, mInfo);\n\n    // Get MethodA(int[] i)\n    mInfo = typeof(Program).GetMethod(&quot;MethodA&quot;,\n        BindingFlags.Public | BindingFlags.Instance,\n        null,\n        new Type[] { typeof(int[]) },\n        null);\n    Console.WriteLine(&quot;Found method: {0}&quot;, mInfo);\n\n    // Get MethodA(int* i)\n    mInfo = typeof(Program).GetMethod(&quot;MethodA&quot;,\n        BindingFlags.Public | BindingFlags.Instance,\n        null,\n        new Type[] { typeof(int).MakePointerType() },\n        null);\n    Console.WriteLine(&quot;Found method: {0}&quot;, mInfo);\n\n    // Get MethodA(ref int r)\n    mInfo = typeof(Program).GetMethod(&quot;MethodA&quot;,\n        BindingFlags.Public | BindingFlags.Instance,\n        null,\n        new Type[] { typeof(int).MakeByRefType() },\n        null);\n    Console.WriteLine(&quot;Found method: {0}&quot;, mInfo);\n\n    // Get MethodA(int i, out int o)\n    mInfo = typeof(Program).GetMethod(&quot;MethodA&quot;,\n        BindingFlags.Public | BindingFlags.Instance,\n        null,\n        new Type[] { typeof(int), typeof(int).MakeByRefType() },\n        null);\n    Console.WriteLine(&quot;Found method: {0}&quot;, mInfo);\n\n  }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetMethod5#1\">using namespace System;\nusing namespace System::Reflection;\n\npublic ref class Program\n{\n\npublic:\n    // Methods to get:\n\n    void MethodA(int i, int j) { }\n\n    void MethodA(array&lt;int&gt;^ iarry) { }\n\n    void MethodA(double *ip) { }\n\n    // Method that takes a managed reference parameter.\n    void MethodA(int% r) {}\n};\n\nint main()\n{\n    MethodInfo^ mInfo;\n\n\n    // Get MethodA(int i, int j)\n    mInfo = Program::typeid-&gt;GetMethod(&quot;MethodA&quot;,\n        static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Instance),\n        nullptr,\n        gcnew array&lt;Type^&gt; {int::typeid, int::typeid},\n        nullptr);\n    Console::WriteLine(&quot;Found method: {0}&quot;, mInfo );\n\n    // Get  MethodA(array&lt;int&gt;^ iarry)\n    mInfo = Program::typeid-&gt;GetMethod(&quot;MethodA&quot;,\n        static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Instance),\n        nullptr,\n        gcnew array&lt;Type^&gt; {int::typeid-&gt;MakeArrayType()},\n        nullptr);\n    Console::WriteLine(&quot;Found method: {0}&quot;, mInfo );\n\n    // Get MethodA(double *ip)\n    mInfo = Program::typeid-&gt;GetMethod(&quot;MethodA&quot;,\n        static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Instance),\n        nullptr,\n        gcnew array&lt;Type^&gt; {double::typeid-&gt;MakePointerType()},\n        nullptr);\n    Console::WriteLine(&quot;Found method: {0}&quot;, mInfo );\n\n    // Get MethodA(int% r)\n    mInfo = Program::typeid-&gt;GetMethod(&quot;MethodA&quot;,\n        static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Instance),\n        nullptr,\n        gcnew array&lt;Type^&gt; {int::typeid-&gt;MakeByRefType()},\n        nullptr);\n    Console::WriteLine(&quot;Found method: {0}&quot;, mInfo );\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetMethod_System_String_System_Reflection_BindingFlags_System_Reflection_Binder_System_Reflection_CallingConventions_System_Type___System_Reflection_ParameterModifier___\">\r\n    \r\n            <a id=\"System_Type_GetMethod_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetMethod(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])</div>        \r\n          </div>\r\n    \r\n            <p>Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the method to get.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>bindingAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted.  </p>\n<p> -or-  </p>\n<p> Zero, to return <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>binder</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  </p>\n<p> -or-  </p>\n<p> A null reference (<code>Nothing</code> in Visual Basic), to use the <span class=\"xref\">stem.Type.DefaultBinder*</span>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>callConvention</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.callingconventions\" data-linktype=\"relative-path\">CallingConventions</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>types</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects representing the number, order, and type of the parameters for the method to get.  </p>\n<p> -or-  </p>\n<p> An empty array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects (as provided by the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> field) to get a method that takes no parameters.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>modifiers</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <code>types</code> array. To be only used when calling through COM interop, and only parameters that are passed by reference are handled. The default binder does not process this parameter.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a></div>\r\n                  </div>\r\n                  <p>An object representing the method that matches the specified requirements, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a></div>\r\n                  </div>\r\n                  <p>More than one method is found with the specified name and matching the specified binding constraints.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>types</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One of the elements in <code>types</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>types</code> is multidimensional.  </p>\n<p> -or-  </p>\n<p> <code>modifiers</code> is multidimensional.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Although the default binder does not process <a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a> (the <code>modifiers</code> parameter), you can use the abstract <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">System.Reflection.Binder</a> class to write a custom binder that does process <code>modifiers</code>. <code>ParameterModifier</code> is only used when calling through COM interop, and only parameters that are passed by reference are handled.  </p>\n<p> The following table shows what members of a base class are returned by the <code>GetXXX</code> methods when reflecting on a type.  </p>\n<table>\n<thead>\n<tr>\n<th>Member Type</th>\n<th>Static</th>\n<th>Non-Static</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Constructor</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Field</td>\n<td>No</td>\n<td>Yes. A field is always hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Event</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n<tr>\n<td>Method</td>\n<td>No</td>\n<td>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Nested Type</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Property</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  </p>\n</li>\n<li><p>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  </p>\n</li>\n<li><p>Custom attributes are not part of the common type system.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which methods to include in the search:  </p>\n</li>\n</ol>\n<ul>\n<li><p>You must specify either <code>BindingFlags.Instance</code> or <code>BindingFlags.Static</code> in order to get a return.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.Public</code> to include public methods in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.NonPublic</code> to include nonpublic methods (that is, private, internal, and protected methods) in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.FlattenHierarchy</code> to include <code>public</code> and <code>protected</code> static members up the hierarchy; <code>private</code> static members in inherited classes are not included.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> modifier flags can be used to change how the search works:  </p>\n</li>\n<li><p><code>BindingFlags.IgnoreCase</code> to ignore the case of <code>name</code>.  </p>\n</li>\n<li><p><code>BindingFlags.DeclaredOnly</code> to search only the methods declared on the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, not methods that were simply inherited.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.  </p>\n</li>\n</ul>\n<div class=\"NOTE\"><h5>Note</h5><p> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  </p>\n</div>\n<p> If the current T:System.Type represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> with the type parameters replaced by the appropriate type arguments.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a> if there is no class constraint.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> For generic methods, do not include the type arguments in <code>name</code>. For example, the C# code <code>GetMember(&quot;MyMethod&lt;int&gt;&quot;)</code> searches for a member with the text name &quot;<code>MyMethod&lt;int&gt;</code>&quot;, rather than for a method named <code>MyMethod</code> that has one generic argument of type <code>int</code>.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example finds specific overloads of <code>MethodA</code>, specifying binding constraints, calling conventions, and a variety of argument types.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/csprcslong-md.md&quot; -->Visual C# 2005<!--END INCLUDE --> example requires the <code>/unsafe</code> compiler option.  </p>\n</div>\n<pre><code class=\"lang-cs\" name=\"Type_GetMethod3#1\">\nusing System;\nusing System.Reflection;\n\nclass Program\n{\n    // Methods to get:\n\n    public void MethodA(int i, int j) { }\n\n    public void MethodA(int[] i) { }\n\n    public unsafe void MethodA(int* i) { }\n\n    public void MethodA(ref int r) {}\n\n    // Method that takes an out parameter:\n    public void MethodA(int i, out int o) { o = 100;}\n\n\n  static void Main(string[] args)\n  {\n    MethodInfo mInfo;\n\n    // Get MethodA(int i, int j)\n    mInfo = typeof(Program).GetMethod(&quot;MethodA&quot;,\n        BindingFlags.Public | BindingFlags.Instance,\n        null,\n        CallingConventions.Any,\n        new Type[] { typeof(int), typeof(int) },\n        null);\n    Console.WriteLine(&quot;Found method: {0}&quot;, mInfo);\n\n    // Get MethodA(int[] i)\n    mInfo = typeof(Program).GetMethod(&quot;MethodA&quot;,\n        BindingFlags.Public | BindingFlags.Instance,\n        null,\n        CallingConventions.Any,\n        new Type[] { typeof(int[]) },\n        null);\n    Console.WriteLine(&quot;Found method: {0}&quot;, mInfo);\n\n    // Get MethodA(int* i)\n    mInfo = typeof(Program).GetMethod(&quot;MethodA&quot;,\n        BindingFlags.Public | BindingFlags.Instance,\n        null,\n        CallingConventions.Any,\n        new Type[] { typeof(int).MakePointerType() },\n        null);\n    Console.WriteLine(&quot;Found method: {0}&quot;, mInfo);\n\n    // Get MethodA(ref int r)\n    mInfo = typeof(Program).GetMethod(&quot;MethodA&quot;,\n        BindingFlags.Public | BindingFlags.Instance,\n        null,\n        CallingConventions.Any,\n        new Type[] { typeof(int).MakeByRefType() },\n        null);\n    Console.WriteLine(&quot;Found method: {0}&quot;, mInfo);\n\n    // Get MethodA(int i, out int o)\n    mInfo = typeof(Program).GetMethod(&quot;MethodA&quot;,\n        BindingFlags.Public | BindingFlags.Instance,\n        null,\n        CallingConventions.Any,\n        new Type[] { typeof(int), typeof(int).MakeByRefType() },\n        null);\n    Console.WriteLine(&quot;Found method: {0}&quot;, mInfo);\n\n  }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetMethod3#1\">using namespace System;\nusing namespace System::Reflection;\n\npublic ref class Program\n{\n\npublic:\n    // Methods to get:\n\n    void MethodA(int i, int j) { }\n\n    void MethodA(array&lt;int&gt;^ iarry) { }\n\n    void MethodA(double *ip) { }\n\n    // Method that takes a managed reference paramter.\n    void MethodA(int% r) {}\n};\n\nint main()\n{\n    MethodInfo^ mInfo;\n\n\n    // Get MethodA(int i, int j)\n    mInfo = Program::typeid-&gt;GetMethod(&quot;MethodA&quot;,\n        BindingFlags::Public | BindingFlags::Instance,\n        nullptr,\n        CallingConventions::Any,\n        gcnew array&lt;Type^&gt; {int::typeid, int::typeid},\n        nullptr);\n    Console::WriteLine(&quot;Found method: {0}&quot;, mInfo );\n\n    // Get  MethodA(array&lt;int&gt;^ iarry)\n    mInfo = Program::typeid-&gt;GetMethod(&quot;MethodA&quot;,\n        BindingFlags::Public | BindingFlags::Instance,\n        nullptr,\n        CallingConventions::Any,\n        gcnew array&lt;Type^&gt; {int::typeid-&gt;MakeArrayType()},\n        nullptr);\n    Console::WriteLine(&quot;Found method: {0}&quot;, mInfo );\n\n    // Get MethodA(double *ip)\n    mInfo = Program::typeid-&gt;GetMethod(&quot;MethodA&quot;,\n        BindingFlags::Public | BindingFlags::Instance,\n        nullptr,\n        CallingConventions::Any,\n        gcnew array&lt;Type^&gt; {double::typeid-&gt;MakePointerType()},\n        nullptr);\n    Console::WriteLine(&quot;Found method: {0}&quot;, mInfo );\n\n    // Get MethodA(int% r)\n    mInfo = Program::typeid-&gt;GetMethod(&quot;MethodA&quot;,\n        BindingFlags::Public | BindingFlags::Instance,\n        nullptr,\n        CallingConventions::Any,\n        gcnew array&lt;Type^&gt; {int::typeid-&gt;MakeByRefType()},\n        nullptr);\n    Console::WriteLine(&quot;Found method: {0}&quot;, mInfo );\n\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetMethod3#1\">\nImports System\nImports System.Reflection\nImports System.Runtime.InteropServices\n\nClass Program\n\n    &#39; Methods to get:\n    \n    Public Overloads Sub MethodA(ByVal i As Integer, ByVal l As Long)\n\n    End Sub\n\n    Public Overloads Sub MethodA(ByVal i() As Integer)\n\n    End Sub\n\n    Public Overloads Sub MethodA(ByRef r As Integer)\n\n    End Sub\n\n    &#39; Method that takes an integer and an out parameter. Note that an\n    &#39; Imports reference is needed to System.Runtime.InteropServices\n    &#39; for the &lt;OutAttribute&gt;, which can be shortened to &lt;Out&gt;.\n    Public Overloads Sub MethodA(ByVal i As Integer, &lt;Out()&gt; ByRef o As Integer)\n        o = 100\n    End Sub\n\n    Public Shared Sub Main(ByVal args() As String)\n        Dim mInfo As MethodInfo\n\n        &#39; Get MethodA(ByVal i As Integer, ByVal l As Long)\n        mInfo = GetType(Program).GetMethod(&quot;MethodA&quot;, _\n            BindingFlags.Public Or BindingFlags.Instance, _\n            Nothing, _\n            CallingConventions.Any, _\n            New Type() {GetType(System.Int32), _\n            GetType(System.Int64)}, _\n            Nothing)\n        Console.WriteLine(&quot;Found method: {0}&quot;, mInfo)\n\n        &#39; Get  MethodA(ByVal i() As Integer)\n        mInfo = GetType(Program).GetMethod(&quot;MethodA&quot;, _\n            BindingFlags.Public Or BindingFlags.Instance, _\n            Nothing, _\n            CallingConventions.Any, _\n            New Type() {GetType(System.Int32())}, _\n            Nothing)\n        Console.WriteLine(&quot;Found method: {0}&quot;, mInfo)\n\n        &#39; Get MethodA(ByRef r As Integer)\n        mInfo = GetType(Program).GetMethod(&quot;MethodA&quot;, _\n        BindingFlags.Public Or BindingFlags.Instance, _\n        Nothing, _\n        CallingConventions.Any, _\n        New Type() {GetType(System.Int32).MakeByRefType}, _\n        Nothing)\n        Console.WriteLine(&quot;Found method: {0}&quot;, mInfo)\n\n        &#39; Get MethodA(ByVal i As Integer, &lt;Out()&gt; ByRef o As Integer)\n        mInfo = GetType(Program).GetMethod(&quot;MethodA&quot;, _\n        BindingFlags.Public Or BindingFlags.Instance, _\n        Nothing, _\n        CallingConventions.Any, _\n        New Type() {GetType(System.Int32), GetType(System.Int32).MakeByRefType}, _\n        Nothing)\n        Console.WriteLine(&quot;Found method: {0}&quot;, mInfo)\n\n    End Sub\nEnd Class\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetMethodImpl_System_String_System_Reflection_BindingFlags_System_Reflection_Binder_System_Reflection_CallingConventions_System_Type___System_Reflection_ParameterModifier___\">\r\n    \r\n            <a id=\"System_Type_GetMethodImpl_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetMethodImpl(String,BindingFlags,Binder,CallingConventions,Type[],ParameterModifier[])</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the method to get.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>bindingAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted.  </p>\n<p> -or-  </p>\n<p> Zero, to return <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>binder</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  </p>\n<p> -or-  </p>\n<p> A null reference (<code>Nothing</code> in Visual Basic), to use the <span class=\"xref\">stem.Type.DefaultBinder*</span>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>callConvention</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.callingconventions\" data-linktype=\"relative-path\">CallingConventions</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>types</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects representing the number, order, and type of the parameters for the method to get.  </p>\n<p> -or-  </p>\n<p> An empty array of the type <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.  </p>\n<p> -or-  </p>\n<p> <code>null</code>. If <code>types</code> is <code>null</code>, arguments are not matched.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>modifiers</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <code>types</code> array. The default binder does not process this parameter.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a></div>\r\n                  </div>\r\n                  <p>An object representing the method that matches the specified requirements, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a></div>\r\n                  </div>\r\n                  <p>More than one method is found with the specified name and matching the specified binding constraints.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>types</code> is multidimensional.  </p>\n<p> -or-  </p>\n<p> <code>modifiers</code> is multidimensional.  </p>\n<p> -or-  </p>\n<p> <code>types</code> and <code>modifiers</code> do not have the same length.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The current type is a <a class=\"xref\" href=\"system.reflection.emit.typebuilder\" data-linktype=\"relative-path\">TypeBuilder</a> or <a class=\"xref\" href=\"system.reflection.emit.generictypeparameterbuilder\" data-linktype=\"relative-path\">GenericTypeParameterBuilder</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Although the default binder does not process <a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a> (the <code>modifiers</code> parameter), you can use the abstract <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">System.Reflection.Binder</a> class to write a custom binder that does process <code>modifiers</code>. <code>ParameterModifier</code> is only used when calling through COM interop, and only parameters that are passed by reference are handled.  </p>\n<p> If <code>types</code> is <code>null</code>, arguments are not matched.  </p>\n<p> The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which methods to include in the search:  </p>\n<ul>\n<li><p>You must specify either <code>BindingFlags.Instance</code> or <code>BindingFlags.Static</code> in order to get a return.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.Public</code> to include public methods in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.NonPublic</code> to include non-public methods (that is, private, internal, and protected methods) in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.FlattenHierarchy</code> to include <code>public</code> and <code>protected</code> static members up the hierarchy; <code>private</code> static members in inherited classes are not included.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> modifier flags can be used to change how the search works:  </p>\n</li>\n<li><p><code>BindingFlags.IgnoreCase</code> to ignore the case of <code>name</code>.  </p>\n</li>\n<li><p><code>BindingFlags.DeclaredOnly</code> to search only the methods declared on the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, not methods that were simply inherited.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.</p>\n</li>\n</ul>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetMethods\">\r\n    \r\n            <a id=\"System_Type_GetMethods_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetMethods()</div>        \r\n          </div>\r\n    \r\n            <p>Returns all the public methods of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.MethodInfo[] GetMethods ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> objects representing all the public methods defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.  </p>\n<p> -or-  </p>\n<p> An empty array of type <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a>, if no public methods are defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The GetMethods method does not return methods in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which methods are returned, because that order varies.  </p>\n<p> Constructors are not included in the array of methods returned by this call. Make a separate call to <code>GetConstructors()</code> to get the constructor methods.  </p>\n<p> The following table shows what members of a base class are returned by the <code>Get</code> methods when reflecting on a type.  </p>\n<table>\n<thead>\n<tr>\n<th>Member Type</th>\n<th>Static</th>\n<th>Non-Static</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Constructor</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Field</td>\n<td>No</td>\n<td>Yes. A field is always hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Event</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n<tr>\n<td>Method</td>\n<td>No</td>\n<td>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Nested Type</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Property</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  </p>\n</li>\n<li><p>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  </p>\n</li>\n<li><p>Custom attributes are not part of the common type system.  </p>\n</li>\n</ol>\n<div class=\"NOTE\"><h5>Note</h5><p> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  </p>\n</div>\n<p> If the current T:System.Type represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> objects with the type parameters replaced by the appropriate type arguments.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a> if there is no class constraint.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetMethods_System_Reflection_BindingFlags_\">\r\n    \r\n            <a id=\"System_Type_GetMethods_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetMethods(BindingFlags)</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, searches for the methods defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, using the specified binding constraints.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>bindingAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted.  </p>\n<p> -or-  </p>\n<p> Zero, to return <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> objects representing all methods defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> that match the specified binding constraints.  </p>\n<p> -or-  </p>\n<p> An empty array of type <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a>, if no methods are defined for the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, or if none of the defined methods match the binding constraints.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The GetMethods method does not return methods in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which methods are returned, because that order varies.  </p>\n<p> The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which methods to include in the search:  </p>\n<ul>\n<li><p>You must specify either <code>BindingFlags.Instance</code> or <code>BindingFlags.Static</code> in order to get a return.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.Public</code> to include public methods in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.NonPublic</code> to include non-public methods (that is, private, internal, and protected methods) in the search. Only protected and internal methods on base classes are returned; private methods on base classes are not returned.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.FlattenHierarchy</code> to include <code>public</code> and <code>protected</code> static members up the hierarchy; <code>private</code> static members in inherited classes are not included.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> modifier flags can be used to change how the search works:  </p>\n</li>\n<li><p><code>BindingFlags.DeclaredOnly</code> to search only the methods declared on the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, not methods that were simply inherited.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.  </p>\n</li>\n</ul>\n<div class=\"NOTE\"><h5>Note</h5><p> You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  </p>\n</div>\n<p> If the current T:System.Type represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a> objects with the type parameters replaced by the appropriate type arguments.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a> if there is no class constraint.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates a class with two public methods and one protected method, creates a <code>Type</code> object corresponding to <code>MyTypeClass</code>, gets all public and non-public methods, and displays their names.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_GetMethods2#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Reflection::Emit;\n\n// Create a class having two public methods and one protected method.\npublic ref class MyTypeClass\n{\npublic:\n   void MyMethods(){}\n\n   int MyMethods1()\n   {\n      return 3;\n   }\n\n\nprotected:\n   String^ MyMethods2()\n   {\n      return &quot;hello&quot;;\n   }\n};\n\nvoid DisplayMethodInfo( array&lt;MethodInfo^&gt;^myArrayMethodInfo )\n{\n   // Display information for all methods.\n   for ( int i = 0; i &lt; myArrayMethodInfo-&gt;Length; i++ )\n   {\n      MethodInfo^ myMethodInfo = dynamic_cast&lt;MethodInfo^&gt;(myArrayMethodInfo[ i ]);\n      Console::WriteLine( &quot;<br>The name of the method is {0}.&quot;, myMethodInfo-&gt;Name );\n   }\n}\n\nint main()\n{\n   Type^ myType = MyTypeClass::typeid;\n   \n   // Get the public methods.\n   array&lt;MethodInfo^&gt;^myArrayMethodInfo = myType-&gt;GetMethods( static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Instance | BindingFlags::DeclaredOnly) );\n   Console::WriteLine( &quot;<br>The number of public methods is {0}-&gt;&quot;, myArrayMethodInfo-&gt;Length );\n   \n   // Display all the methods.\n   DisplayMethodInfo( myArrayMethodInfo );\n   \n   // Get the nonpublic methods.\n   array&lt;MethodInfo^&gt;^myArrayMethodInfo1 = myType-&gt;GetMethods( static_cast&lt;BindingFlags&gt;(BindingFlags::NonPublic | BindingFlags::Instance | BindingFlags::DeclaredOnly) );\n   Console::WriteLine( &quot;<br>The number of protected methods is {0}-&gt;&quot;, myArrayMethodInfo1-&gt;Length );\n   \n   // Display information for all methods.\n   DisplayMethodInfo( myArrayMethodInfo1 );\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetMethods2#1\">\nImports System\nImports System.Reflection\nImports System.Reflection.Emit\nImports Microsoft.VisualBasic\n\n&#39; Create a class having two public methods and one protected method.\nPublic Class MyTypeClass\n    Public Sub MyMethods()\n    End Sub &#39;MyMethods\n    Public Function MyMethods1() As Integer\n        Return 3\n    End Function &#39;MyMethods1\n    Protected Function MyMethods2() As [String]\n        Return &quot;hello&quot;\n    End Function &#39;MyMethods2\nEnd Class &#39;MyTypeClass\nPublic Class TypeMain\n    Public Shared Sub Main()\n\n        Dim myType As Type = GetType(MyTypeClass)\n        &#39; Get the public methods.\n        Dim myArrayMethodInfo As MethodInfo() = myType.GetMethods((BindingFlags.Public Or BindingFlags.Instance Or BindingFlags.DeclaredOnly))\n        Console.WriteLine((ControlChars.Cr + &quot;The number of public methods is &quot; &amp; myArrayMethodInfo.Length.ToString() &amp; &quot;.&quot;))\n        &#39; Display all the public methods.\n        DisplayMethodInfo(myArrayMethodInfo)\n        &#39; Get the nonpublic methods.\n        Dim myArrayMethodInfo1 As MethodInfo() = myType.GetMethods((BindingFlags.NonPublic Or BindingFlags.Instance Or BindingFlags.DeclaredOnly))\n        Console.WriteLine((ControlChars.Cr + &quot;The number of protected methods is &quot; &amp; myArrayMethodInfo1.Length.ToString() &amp; &quot;.&quot;))\n        &#39; Display all the nonpublic methods.\n        DisplayMethodInfo(myArrayMethodInfo1)\n    End Sub &#39;Main\n\n    Public Shared Sub DisplayMethodInfo(ByVal myArrayMethodInfo() As MethodInfo)\n        &#39; Display information for all methods.\n        Dim i As Integer\n        For i = 0 To myArrayMethodInfo.Length - 1\n            Dim myMethodInfo As MethodInfo = CType(myArrayMethodInfo(i), MethodInfo)\n            Console.WriteLine((ControlChars.Cr + &quot;The name of the method is &quot; &amp; myMethodInfo.Name &amp; &quot;.&quot;))\n        Next i\n    End Sub &#39;DisplayMethodInfo\nEnd Class &#39;TypeMain\t\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_GetMethods2#1\">\nusing System;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\n\t\t// Create a class having two public methods and one protected method.\npublic class MyTypeClass\n{\n    public void MyMethods()\n    {\n    }\n    public int MyMethods1() \n    {\n        return 3;\n    }\n    protected String MyMethods2()\n    {\n        return &quot;hello&quot;;\n    }\n}\npublic class TypeMain\n{\n    public static void Main() \n    {\n        Type myType =(typeof(MyTypeClass));\n        // Get the public methods.\n        MethodInfo[] myArrayMethodInfo = myType.GetMethods(BindingFlags.Public|BindingFlags.Instance|BindingFlags.DeclaredOnly);\n        Console.WriteLine(&quot;<br>The number of public methods is {0}.&quot;, myArrayMethodInfo.Length);\n        // Display all the methods.\n        DisplayMethodInfo(myArrayMethodInfo);\n        // Get the nonpublic methods.\n        MethodInfo[] myArrayMethodInfo1 = myType.GetMethods(BindingFlags.NonPublic|BindingFlags.Instance|BindingFlags.DeclaredOnly);\n        Console.WriteLine(&quot;<br>The number of protected methods is {0}.&quot;, myArrayMethodInfo1.Length);\n        // Display information for all methods.\n        DisplayMethodInfo(myArrayMethodInfo1);\t\t\n    }\n    public static void DisplayMethodInfo(MethodInfo[] myArrayMethodInfo)\n    {\n        // Display information for all methods.\n        for(int i=0;i&lt;myArrayMethodInfo.Length;i++)\n        {\n            MethodInfo myMethodInfo = (MethodInfo)myArrayMethodInfo[i];\n            Console.WriteLine(&quot;<br>The name of the method is {0}.&quot;, myMethodInfo.Name);\n        }\n    }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetNestedType_System_String_\">\r\n    \r\n            <a id=\"System_Type_GetNestedType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetNestedType(String)</div>        \r\n          </div>\r\n    \r\n            <p>Searches for the public nested type with the specified name.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public Type GetNestedType (string name);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the nested type to get.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>An object representing the public nested type with the specified name, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The search for <code>name</code> is case-sensitive.  </p>\n<p> Use the simple name of the nested class for <code>name</code>. Do not qualify it with the name of the outer class. For a generic nested class, use the mangled name  that is, append a grave accent and the number of generic arguments. For example, use the string &quot;Inner`1&quot; to get the generic nested class <code>Inner&lt;T&gt;</code> (<code>Inner(Of T)</code> in Visual Basic). Do not include language-specific syntax for type parameters.  </p>\n<p> The following table shows what members of a base class are returned by the <code>Get</code> methods when reflecting on a type.  </p>\n<table>\n<thead>\n<tr>\n<th>Member Type</th>\n<th>Static</th>\n<th>Non-Static</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Constructor</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Field</td>\n<td>No</td>\n<td>Yes. A field is always hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Event</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n<tr>\n<td>Method</td>\n<td>No</td>\n<td>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Nested Type</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Property</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  </p>\n</li>\n<li><p>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  </p>\n</li>\n<li><p>Custom attributes are not part of the common type system.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.  </p>\n<p>If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type.  </p>\n</li>\n</ol>\n<div class=\"NOTE\"><h5>Note</h5><p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <a href=\"../Topic/Ilasm.exe%20(IL%20Assembler).md\" data-linktype=\"relative-path\">Ilasm.exe (IL Assembler)</a>.  </p>\n</div>\n<p> For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <a class=\"xref\" href=\"system.type#System_Type_MakeGenericType_\" data-linktype=\"relative-path\">MakeGenericType</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetNestedType_System_String_System_Reflection_BindingFlags_\">\r\n    \r\n            <a id=\"System_Type_GetNestedType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetNestedType(String,BindingFlags)</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the nested type to get.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>bindingAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted.  </p>\n<p> -or-  </p>\n<p> Zero, to return <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>An object representing the nested type that matches the specified requirements, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Use the simple name of the nested class for <code>name</code>. Do not qualify it with the name of the outer class. For a generic nested class, use the mangled name  that is, append a grave accent and the number of generic parameters. For example, use the string &quot;Inner`1&quot; to get the generic nested class <code>Inner&lt;T&gt;</code> (<code>Inner(Of T)</code> in Visual Basic). Do not include language-specific syntax for type parameters.  </p>\n<p> The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which nested types to include in the search:  </p>\n<ul>\n<li><p>You must specify either <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> or <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> to get a return.  </p>\n</li>\n<li><p>Specify <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> to include public nested types in the search.  </p>\n</li>\n<li><p>Specify <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> to include non-public nested types (that is, private, internal, and protected nested types) in the search.  </p>\n<p>This method returns only the nested types of the current type. It does not search the base classes of the current type. To find types that are nested in base classes, you must walk the inheritance hierarchy, calling GetNestedType at each level.  </p>\n<p><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> and <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> are ignored.  </p>\n<p>Calling this method with only the <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> flag or only the <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> flag will return the specified nested types and does not require any other flags.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.  </p>\n<p>If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type.  </p>\n</li>\n</ul>\n<div class=\"NOTE\"><h5>Note</h5><p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <a href=\"../Topic/Ilasm.exe%20(IL%20Assembler).md\" data-linktype=\"relative-path\">Ilasm.exe (IL Assembler)</a>.  </p>\n</div>\n<p> For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <a class=\"xref\" href=\"system.type#System_Type_MakeGenericType_\" data-linktype=\"relative-path\">MakeGenericType</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetNestedTypes\">\r\n    \r\n            <a id=\"System_Type_GetNestedTypes_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetNestedTypes()</div>        \r\n          </div>\r\n    \r\n            <p>Returns the public types nested in the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public Type[] GetNestedTypes ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects representing the public types nested in the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> (the search is not recursive), or an empty array of type <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> if no public types are nested in the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The GetNestedTypes method does not return types in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which types are returned, because that order varies.  </p>\n<p> Only the public types immediately nested in the current type are returned; the search is not recursive.  </p>\n<p> The following table shows what members of a base class are returned by the <code>Get</code> methods when reflecting on a type.  </p>\n<table>\n<thead>\n<tr>\n<th>Member Type</th>\n<th>Static</th>\n<th>Non-Static</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Constructor</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Field</td>\n<td>No</td>\n<td>Yes. A field is always hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Event</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n<tr>\n<td>Method</td>\n<td>No</td>\n<td>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Nested Type</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Property</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  </p>\n</li>\n<li><p>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  </p>\n</li>\n<li><p>Custom attributes are not part of the common type system.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.  </p>\n<p>If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type.  </p>\n</li>\n</ol>\n<div class=\"NOTE\"><h5>Note</h5><p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <a href=\"../Topic/Ilasm.exe%20(IL%20Assembler).md\" data-linktype=\"relative-path\">Ilasm.exe (IL Assembler)</a>.  </p>\n</div>\n<p> For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <a class=\"xref\" href=\"system.type#System_Type_MakeGenericType_\" data-linktype=\"relative-path\">MakeGenericType</a>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example defines a nested class and a <code>struct</code> in <code>MyClass</code>, and then obtains objects of the nested types using the type of <code>MyClass</code>.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_GetNestedTypes#1\">using namespace System;\nusing namespace System::Reflection;\npublic ref class MyClass\n{\npublic:\n   ref class NestClass\n   {\n      public:\n         static int myPublicInt = 0;\n   };\n\n   ref struct NestStruct\n   {\n      public:\n         static int myPublicInt = 0;\n   };\n};\n\nint main()\n{\n   try\n   {\n      // Get the Type object corresponding to MyClass.\n      Type^ myType = MyClass::typeid;\n      \n      // Get an array of nested type objects in MyClass.\n      array&lt;Type^&gt;^nestType = myType-&gt;GetNestedTypes();\n      Console::WriteLine( &quot;The number of nested types is {0}.&quot;, nestType-&gt;Length );\n      System::Collections::IEnumerator^ myEnum = nestType-&gt;GetEnumerator();\n      while ( myEnum-&gt;MoveNext() )\n      {\n         Type^ t = safe_cast&lt;Type^&gt;(myEnum-&gt;Current);\n         Console::WriteLine( &quot;Nested type is {0}.&quot;, t );\n      }\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Error {0}&quot;, e-&gt;Message );\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetNestedTypes#1\">Imports System\nImports System.Reflection\n\nPublic Class MyClass1\n    Public Class NestClass\n        Public Shared myPublicInt As Integer = 0\n    End Class &#39;NestClass\n\n    Public Structure NestStruct\n        Public myPublicInt As Integer\n    End Structure &#39;NestStruct\nEnd Class &#39;MyClass1\n\nPublic Class MyMainClass\n    Public Shared Sub Main()\n        Try\n            &#39; Get the Type object corresponding to MyClass.\n            Dim myType As Type = GetType(MyClass1)\n            &#39; Get an array of nested type objects in MyClass.                 \n            Dim nestType As Type() = myType.GetNestedTypes()\n            Console.WriteLine(&quot;The number of nested types is {0}.&quot;, nestType.Length)\n            Dim t As Type\n            For Each t In nestType\n                Console.WriteLine(&quot;Nested type is {0}.&quot;, t.ToString())\n            Next t\n        Catch e As Exception\n            Console.WriteLine(&quot;Error&quot;, e.Message.ToString())\n        End Try\n    End Sub &#39;Main\nEnd Class &#39;MyMainClass\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_GetNestedTypes#1\">\nusing System;\nusing System.Reflection;\npublic class MyClass \n{\n    public class NestClass \n    {\n        public static int myPublicInt=0;\n    }\n    public struct NestStruct\n    {\n        public static int myPublicInt=0;\n    }\n}\n\npublic class MyMainClass \n{\n    public static void Main() \n    {\n        try\n        {\n            // Get the Type object corresponding to MyClass.\n            Type myType=typeof(MyClass);\n            // Get an array of nested type objects in MyClass. \n            Type[] nestType=myType.GetNestedTypes();\n            Console.WriteLine(&quot;The number of nested types is {0}.&quot;, nestType.Length);\n            foreach(Type t in nestType)\n                Console.WriteLine(&quot;Nested type is {0}.&quot;, t.ToString());\n        }\n        catch(Exception e)\n        {\n            Console.WriteLine(&quot;Error&quot;+e.Message);  \n        }         \n    }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetNestedTypes_System_Reflection_BindingFlags_\">\r\n    \r\n            <a id=\"System_Type_GetNestedTypes_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetNestedTypes(BindingFlags)</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, searches for the types nested in the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, using the specified binding constraints.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>bindingAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted.  </p>\n<p> -or-  </p>\n<p> Zero, to return <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects representing all the types nested in the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> that match the specified binding constraints (the search is not recursive), or an empty array of type <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, if no nested types are found that match the binding constraints.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The search for nested types is not recursive.  </p>\n<p> The GetNestedTypes method does not return types in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which types are returned, because that order varies.  </p>\n<p> The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which nested types to include in the search:  </p>\n<ul>\n<li><p>You must specify either <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> or <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> to get a return.  </p>\n</li>\n<li><p>Specify <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> to include public nested types in the search.  </p>\n</li>\n<li><p>Specify <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> to include non-public nested types (that is, private, internal, and protected nested types) in the search.  </p>\n<p>This method returns only the nested types of the current type. It does not search the base classes of the current type. To find types that are nested in base classes, you must walk the inheritance hierarchy, calling GetNestedTypes at each level.  </p>\n<p><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> and <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> are ignored.  </p>\n<p>Calling this method with only the <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> flag or only the <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> flag will return the specified nested types and does not require any other flags.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.  </p>\n<p>If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type.  </p>\n</li>\n</ul>\n<div class=\"NOTE\"><h5>Note</h5><p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <a href=\"../Topic/Ilasm.exe%20(IL%20Assembler).md\" data-linktype=\"relative-path\">Ilasm.exe (IL Assembler)</a>.  </p>\n</div>\n<p> For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <a class=\"xref\" href=\"system.type#System_Type_MakeGenericType_\" data-linktype=\"relative-path\">MakeGenericType</a>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates two nested public classes and two nested protected classes, and displays information for classes that match the specified binding constraints.  </p>\n<pre><code class=\"lang-vb\" name=\"Type_GetNestedClassesAbs#1\">Imports System.Reflection\n\n&#39; Create a class with three properties.\nPublic Class MyTypeClass\n    Public Class Myclass1\n    End Class \n\n    Public Class Myclass2\n    End Class \n\n    Protected Class MyClass3\n    End Class \n\n    Protected Class MyClass4\n    End Class \nEnd Class \n\nPublic Class TypeMain\n    Public Shared Sub Main()\n        Dim myType As Type = GetType(MyTypeClass)\n\n        &#39; Get the public nested classes.\n        Dim myTypeArray As Type() = myType.GetNestedTypes((BindingFlags.Public))\n        Console.WriteLine(&quot;The number of public nested classes is {0}.&quot;, myTypeArray.Length.ToString())\n        &#39; Display all the public nested classes.\n        DisplayTypeInfo(myTypeArray)\n        Console.WriteLine()\n        \n        &#39; Get the nonpublic nested classes.\n        Dim myTypeArray1 As Type() = myType.GetNestedTypes((BindingFlags.NonPublic))\n        Console.WriteLine(&quot;The number of protected nested classes is {0}.&quot;, myTypeArray1.Length.ToString())\n        &#39; Display  the information for all nested classes.\n        DisplayTypeInfo(myTypeArray1)\n    End Sub \n\n    Public Shared Sub DisplayTypeInfo(ByVal myArrayType() As Type)\n        &#39; Display the information for all nested classes.\n        For Each t In myArrayType\n            Console.WriteLine(&quot;The name of the nested class is {0}.&quot;, t.FullName)\n        Next \n    End Sub \nEnd Class  \n&#39; The example displays the following output:\n&#39;       The number of public nested classes is 2.\n&#39;       The name of the nested class is MyTypeClass+Myclass1.\n&#39;       The name of the nested class is MyTypeClass+Myclass2.\n&#39;       \n&#39;       The number of protected nested classes is 2.\n&#39;       The name of the nested class is MyTypeClass+MyClass3.\n&#39;       The name of the nested class is MyTypeClass+MyClass4.\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_GetNestedClassesAbs#1\">using System;\nusing System.Reflection;\n\n// Create a class with 2 nested public and 2 nested protected classes.\npublic class MyTypeClass\n{\n    public class Myclass1\n    {\n    }\n\n    public class Myclass2 \n    {\n    }\n\n    protected class MyClass3\n    {\n    }\n\n    protected class MyClass4\n    {\n    }\n}\n\npublic class TypeMain\n{\n    public static void Main() \n    {\n        Type myType = (typeof(MyTypeClass));\n        // Get the public nested classes.\n        Type[] myTypeArray = myType.GetNestedTypes(BindingFlags.Public);\n        Console.WriteLine(&quot;The number of nested public classes is {0}.&quot;, myTypeArray.Length);\n        // Display all the public nested classes.\n        DisplayTypeInfo(myTypeArray);\n        Console.WriteLine();\n        \n        // Get the nonpublic nested classes.\n        Type[] myTypeArray1 = myType.GetNestedTypes(BindingFlags.NonPublic|BindingFlags.Instance);\n        Console.WriteLine(&quot;The number of nested protected classes is {0}.&quot;, myTypeArray1.Length);\n        // Display all the nonpublic nested classes.\n        DisplayTypeInfo(myTypeArray1);\t\t\n    }\n\n    public static void DisplayTypeInfo(Type[] myArrayType)\n    {\n        // Display the information for all the nested classes.\n        foreach (var t in myArrayType)\n            Console.WriteLine(&quot;The name of the nested class is {0}.&quot;, t.FullName);\n    }\n}\n// The example displays the following output:\n//       The number of public nested classes is 2.\n//       The name of the nested class is MyTypeClass+Myclass1.\n//       The name of the nested class is MyTypeClass+Myclass2.\n//       \n//       The number of protected nested classes is 2.\n//       The name of the nested class is MyTypeClass+MyClass3.\n//       The name of the nested class is MyTypeClass+MyClass4.\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetNestedClassesAbs#1\">using namespace System;\nusing namespace System::Reflection;\n\n// Create a class with two nested public classes and two nested protected classes.\npublic ref class MyTypeClass\n{\n   public:\n      ref class Myclass1{};\n   \n   public:\n      ref class Myclass2{};\n   \n   protected:\n      ref class MyClass3{};\n   \n   protected:\n      ref class MyClass4{};\n};\n\nvoid DisplayTypeInfo(array&lt;Type^&gt;^ myArrayType)\n{\n   // Display the information for all the nested classes.\n   for each (Type^ t in myArrayType)\n      Console::WriteLine( &quot;The name of the nested class is {0}.&quot;, t-&gt;FullName);\n}\n\nint main()\n{\n   Type^ myType = MyTypeClass::typeid;\n   \n   // Get the public nested classes.\n   array&lt;Type^&gt;^myTypeArray = myType-&gt;GetNestedTypes( static_cast&lt;BindingFlags&gt;(BindingFlags::Public));\n   Console::WriteLine( &quot;The number of nested public classes is {0}.&quot;, myTypeArray-&gt;Length );\n  \n   // Display all the public nested classes.\n   DisplayTypeInfo( myTypeArray );\n   Console::WriteLine();\n   \n   // Get the nonpublic nested classes.\n   array&lt;Type^&gt;^myTypeArray1 = myType-&gt;GetNestedTypes( static_cast&lt;BindingFlags&gt;(BindingFlags::NonPublic));\n   Console::WriteLine( &quot;The number of nested protected classes is {0}.&quot;, myTypeArray1-&gt;Length );\n   \n   // Display all the nonpublic nested classes.\n   DisplayTypeInfo( myTypeArray1 );\n}\n// The example displays the following output:\n//       The number of public nested classes is 2.\n//       The name of the nested class is MyTypeClass+Myclass1.\n//       The name of the nested class is MyTypeClass+Myclass2.\n//       \n//       The number of protected nested classes is 2.\n//       The name of the nested class is MyTypeClass+MyClass3.\n//       The name of the nested class is MyTypeClass+MyClass4.\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetProperties\">\r\n    \r\n            <a id=\"System_Type_GetProperties_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetProperties()</div>        \r\n          </div>\r\n    \r\n            <p>Returns all the public properties of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.PropertyInfo[] GetProperties ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a> objects representing all public properties of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.  </p>\n<p> -or-  </p>\n<p> An empty array of type <a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a>, if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> does not have public properties.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Calling this overload is equivalent to calling the <a class=\"xref\" href=\"system.type#System_Type_GetProperties_System_Reflection_BindingFlags_\" data-linktype=\"relative-path\">GetProperties(BindingFlags)</a> overload with a <code>bindingAttr</code> argument equal to <code>BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public</code> in C# and  <code>BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public</code> in Visual Basic. It returns all public instance and static properties, both those defined by the type represented by the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object as well as those inherited from its base types.  </p>\n<p> A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (in Visual Basic, combine the values using <code>Or</code>) to get it.  </p>\n<p> The GetProperties method does not return properties in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which properties are returned, because that order varies.  </p>\n<p> The following table shows what members of a base class are returned by the <code>Get</code> methods when reflecting on a type.  </p>\n<table>\n<thead>\n<tr>\n<th>Member Type</th>\n<th>Static</th>\n<th>Non-Static</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Constructor</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Field</td>\n<td>No</td>\n<td>Yes. A field is always hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Event</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n<tr>\n<td>Method</td>\n<td>No</td>\n<td>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Nested Type</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Property</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  </p>\n</li>\n<li><p>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  </p>\n</li>\n<li><p>Custom attributes are not part of the common type system.  </p>\n<p>If the current T:System.Type represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a> objects with the type parameters replaced by the appropriate type arguments.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</p>\n</li>\n</ol>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example demonstrates the use of the <code>GetProperties</code> method.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_GetTypeCode#2\">            PropertyInfo[] myPropertyInfo;\n            // Get the properties of &#39;Type&#39; class object.\n            myPropertyInfo = Type.GetType(&quot;System.Type&quot;).GetProperties();\n            Console.WriteLine(&quot;Properties of System.Type are:&quot;);\n            for (int i = 0; i &lt; myPropertyInfo.Length; i++)\n            {\n                Console.WriteLine(myPropertyInfo[i].ToString());\n            }\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetTypeCode#2\">   array&lt;PropertyInfo^&gt;^myPropertyInfo;\n   \n   // Get the properties of &#39;Type&#39; class object.\n   myPropertyInfo = Type::GetType( &quot;System.Type&quot; )-&gt;GetProperties();\n   Console::WriteLine( &quot;Properties of System.Type are:&quot; );\n   for ( int i = 0; i &lt; myPropertyInfo-&gt;Length; i++ )\n   {\n      Console::WriteLine( myPropertyInfo[ i ] );\n\n   }\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetTypeCode#2\">         Dim myPropertyInfo() As PropertyInfo\n         &#39; Get the properties of &#39;Type&#39; class object.\n         myPropertyInfo = Type.GetType(&quot;System.Type&quot;).GetProperties()\n         Console.WriteLine(&quot;Properties of System.Type are:&quot;)\n         Dim i As Integer\n         For i = 0 To myPropertyInfo.Length - 1\n            Console.WriteLine(myPropertyInfo(i).ToString())\n         Next i\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetProperties_System_Reflection_BindingFlags_\">\r\n    \r\n            <a id=\"System_Type_GetProperties_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetProperties(BindingFlags)</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, searches for the properties of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, using the specified binding constraints.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>bindingAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted.  </p>\n<p> -or-  </p>\n<p> Zero, to return <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a> objects representing all properties of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> that match the specified binding constraints.  </p>\n<p> -or-  </p>\n<p> An empty array of type <a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a>, if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> does not have properties, or if none of the properties match the binding constraints.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (in Visual Basic, combine the values using <code>Or</code>) to get it.  </p>\n<p> The GetProperties method does not return properties in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which properties are returned, because that order varies.  </p>\n<p> The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which nested types to include in the search:  </p>\n<ul>\n<li><p>You must specify either <code>BindingFlags.Instance</code> or <code>BindingFlags.Static</code> in order to get a return.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.Public</code> to include public properties in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.NonPublic</code> to include non-public properties (that is, private, internal, and protected properties) in the search. Only protected and internal properties on base classes are returned; private properties on base classes are not returned.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.FlattenHierarchy</code> to include <code>public</code> and <code>protected</code> static members up the hierarchy; <code>private</code> static members in inherited classes are not included.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> modifier flags can be used to change how the search works:  </p>\n</li>\n<li><p><code>BindingFlags.DeclaredOnly</code> to search only the properties declared on the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, not properties that were simply inherited.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.  </p>\n<p>A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (in Visual Basic, combine the values using <code>Or</code>) to get it.  </p>\n<p>If the current T:System.Type represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a> objects with the type parameters replaced by the appropriate type arguments.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</p>\n</li>\n</ul>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example defines a class named <code>PropertyClass</code> that includes six properties: two are public, one is private, one is protected, one is internal (<code>Friend</code> in Visual Basic), and one is protected internal (<code>Protected Friend</code> in Visual Basic). It then displays some basic property information (the property name and type, whether it is read/write, and the visibility of its <code>get</code> and <code>set</code> accessors) for the properties that match the specified binding constraints.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_GetProperties2#1\">using System;\nusing System.Reflection;\n\n// Create a class having six properties.\npublic class PropertyClass\n{\n    public String Property1\n    {\n        get { return &quot;hello&quot;; }\n    }\n\n    public String Property2\n    {\n        get { return &quot;hello&quot;; }\n    }\n\n    protected String Property3\n    {\n        get { return &quot;hello&quot;; }\n    }\n\n    private Int32 Property4\n    {\n        get { return 32; }\n    }\n\n    internal String Property5\n    {\n       get { return &quot;value&quot;; }\n    }\n\n    protected internal String Property6\n    {\n       get { return &quot;value&quot;; }\n    }\n}\n\npublic class Example\n{\n    public static void Main() \n    {\n        Type t = typeof(PropertyClass);\n        // Get the public properties.\n        PropertyInfo[] propInfos = t.GetProperties(BindingFlags.Public|BindingFlags.Instance);\n        Console.WriteLine(&quot;The number of public properties: {0}.<br>&quot;,\n                          propInfos.Length);\n        // Display the public properties.\n        DisplayPropertyInfo(propInfos);\n\n        // Get the nonpublic properties.\n        PropertyInfo[] propInfos1 = t.GetProperties(BindingFlags.NonPublic|BindingFlags.Instance);\n        Console.WriteLine(&quot;The number of non-public properties: {0}.<br>&quot;,\n                          propInfos1.Length);\n        // Display all the nonpublic properties.\n        DisplayPropertyInfo(propInfos1);\n    }\n\n    public static void DisplayPropertyInfo(PropertyInfo[] propInfos)\n    {\n        // Display information for all properties.\n        foreach (var propInfo in propInfos) {\n            bool readable = propInfo.CanRead;\n            bool writable = propInfo.CanWrite;\n            \n            Console.WriteLine(&quot;   Property name: {0}&quot;, propInfo.Name);\n            Console.WriteLine(&quot;   Property type: {0}&quot;, propInfo.PropertyType);\n            Console.WriteLine(&quot;   Read-Write:    {0}&quot;, readable &amp; writable);\n            if (readable) {\n               MethodInfo getAccessor = propInfo.GetMethod;\n               Console.WriteLine(&quot;   Visibility:    {0}&quot;,\n                                 GetVisibility(getAccessor));\n            }\n            if (writable) {\n               MethodInfo setAccessor = propInfo.SetMethod;\n               Console.WriteLine(&quot;   Visibility:    {0}&quot;,\n                                 GetVisibility(setAccessor));\n            }\n            Console.WriteLine();\n        }\n    }\n\n    public static String GetVisibility(MethodInfo accessor)\n    {\n       if (accessor.IsPublic)\n          return &quot;Public&quot;;\n       else if (accessor.IsPrivate)\n          return &quot;Private&quot;;\n       else if (accessor.IsFamily)\n          return &quot;Protected&quot;;\n       else if (accessor.IsAssembly)\n          return &quot;Internal/Friend&quot;;\n       else\n          return &quot;Protected Internal/Friend&quot;;\n    }\n}\n// The example displays the following output:\n//       The number of public properties: 2.\n//\n//          Property name: Property1\n//          Property type: System.String\n//          Read-Write:    False\n//          Visibility:    Public\n//\n//          Property name: Property2\n//          Property type: System.String\n//          Read-Write:    False\n//          Visibility:    Public\n//\n//       The number of non-public properties: 4.\n//\n//          Property name: Property3\n//          Property type: System.String\n//          Read-Write:    False\n//          Visibility:    Protected\n//\n//          Property name: Property4\n//          Property type: System.Int32\n//          Read-Write:    False\n//          Visibility:    Private\n//\n//          Property name: Property5\n//          Property type: System.String\n//          Read-Write:    False\n//          Visibility:    Internal/Friend\n//\n//          Property name: Property6\n//          Property type: System.String\n//          Read-Write:    False\n//          Visibility:    Protected Internal/Friend\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetProperties2#1\">using namespace System;\nusing namespace System::Reflection;\n\n// Create a class having three properties.\npublic ref class PropertyClass\n{\n\npublic:\n   property String^ Property1\n   {\n      String^ get()\n      {\n         return &quot;hello&quot;;\n      }\n   }\n\n   property String^ Property2 \n   {\n      String^ get()\n      {\n         return &quot;hello&quot;;\n      }\n   }\n\nprotected:\n   property String^ Property3\n   {\n      String^ get()\n      {\n         return &quot;hello&quot;;\n      }\n   }\n\nprivate:\n   property int Property4\n   {\n      int get()\n      {\n         return 32;\n      }\n   }\n\ninternal:\n   property String^ Property5\n   {\n      String^ get()\n      {\n         return &quot;value&quot;;\n      }\n   }\n   \npublic protected:\n   property String^ Property6\n   {\n      String^ get()\n      {\n         return &quot;value&quot;;\n      }\n   }\n};\n\nString^ GetVisibility(MethodInfo^ accessor)\n{\n    if (accessor-&gt;IsPublic)\n       return &quot;Public&quot;;\n    else if (accessor-&gt;IsPrivate)\n       return &quot;Private&quot;;\n    else if (accessor-&gt;IsFamily)\n       return &quot;Protected&quot;;\n    else if (accessor-&gt;IsAssembly)\n       return &quot;Internal/Friend&quot;;\n    else\n       return &quot;Protected Internal/Friend&quot;;\n}\n\nvoid DisplayPropertyInfo(array&lt;PropertyInfo^&gt;^ propInfos )\n{\n   // Display information for all properties.\n   for each(PropertyInfo^ propInfo in propInfos) {\n      bool readable = propInfo-&gt;CanRead;\n      bool writable = propInfo-&gt;CanWrite;\n      \n      Console::WriteLine(&quot;   Property name: {0}&quot;, propInfo-&gt;Name);\n      Console::WriteLine(&quot;   Property type: {0}&quot;, propInfo-&gt;PropertyType);\n      Console::WriteLine(&quot;   Read-Write:    {0}&quot;, readable &amp;&amp; writable);\n      if (readable) {\n         MethodInfo^ getAccessor = propInfo-&gt;GetMethod;\n         Console::WriteLine(&quot;   Visibility:    {0}&quot;,\n                           GetVisibility(getAccessor));\n      }\n      if (writable) {\n         MethodInfo^ setAccessor = propInfo-&gt;SetMethod;\n         Console::WriteLine(&quot;   Visibility:    {0}&quot;,\n                            GetVisibility(setAccessor));\n      }\n      Console::WriteLine();\n   }\n}\n\nvoid main()\n{\n   Type^ myType = PropertyClass::typeid;\n   \n   // Get the public properties.\n   array&lt;PropertyInfo^&gt;^propInfos = myType-&gt;GetProperties( static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Instance) );\n   Console::WriteLine(&quot;The number of public properties: {0}.<br>&quot;,\n                      propInfos-&gt;Length);\n   // Display the public properties.\n   DisplayPropertyInfo( propInfos );\n   \n   // Get the non-public properties.\n   array&lt;PropertyInfo^&gt;^propInfos1 = myType-&gt;GetProperties( static_cast&lt;BindingFlags&gt;(BindingFlags::NonPublic | BindingFlags::Instance) );\n   Console::WriteLine(&quot;The number of non-public properties: {0}.<br>&quot;,\n                      propInfos1-&gt;Length);\n   // Display all the non-public properties.\n   DisplayPropertyInfo(propInfos1);\n}\n// The example displays the following output:\n//       The number of public properties: 2.\n//\n//          Property name: Property2\n//          Property type: System.String\n//          Read-Write:    False\n//          Visibility:    Public\n//\n//          Property name: Property1\n//          Property type: System.String\n//          Read-Write:    False\n//          Visibility:    Public\n//\n//       The number of non-public properties: 4.\n//\n//          Property name: Property6\n//          Property type: System.String\n//          Read-Write:    False\n//          Visibility:    Protected Internal/Friend\n//\n//          Property name: Property5\n//          Property type: System.String\n//          Read-Write:    False\n//          Visibility:    Internal/Friend\n//\n//          Property name: Property4\n//          Property type: System.Int32\n//          Read-Write:    False\n//          Visibility:    Private\n//\n//          Property name: Property3\n//          Property type: System.String\n//          Read-Write:    False\n//          Visibility:    Protected\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetProperties2#1\">Imports System.Reflection\n\n&#39; Create a class having six properties.\nPublic Class PropertyClass\n    Public ReadOnly Property Property1() As String\n        Get\n            Return &quot;hello&quot;\n        End Get\n    End Property\n\n    Public ReadOnly Property Property2() As String\n        Get\n            Return &quot;hello&quot;\n        End Get\n    End Property\n\n    Protected ReadOnly Property Property3() As String\n        Get\n            Return &quot;hello&quot;\n        End Get\n    End Property\n\n    Private ReadOnly Property Property4 As Integer\n        Get\n           Return 32\n        End Get\n    End Property\n\n    Friend ReadOnly Property Property5 As String\n       Get\n          Return &quot;value&quot;\n       End Get\n    End Property\n\n    Protected Friend ReadOnly Property Property6 As String\n       Get\n          Return &quot;value&quot;\n       End Get\n    End Property\nEnd Class\n\nPublic Module Example\n    Public Sub Main()\n        Dim t As Type = GetType(PropertyClass)\n        &#39; Get the public properties.\n        Dim propInfos As PropertyInfo() = t.GetProperties(BindingFlags.Public Or BindingFlags.Instance)\n        Console.WriteLine(&quot;The number of public properties: {0}&quot;,\n                          propInfos.Length)\n        Console.WriteLine()\n        &#39; Display the public properties.\n        DisplayPropertyInfo(propInfos)\n\n        &#39; Get the non-public properties.\n        Dim propInfos1 As PropertyInfo() = t.GetProperties(BindingFlags.NonPublic Or BindingFlags.Instance)\n        Console.WriteLine(&quot;The number of non-public properties: {0}&quot;,\n                          propInfos1.Length)\n        Console.WriteLine()\n        &#39; Display all the non-public properties.\n        DisplayPropertyInfo(propInfos1)\n    End Sub\n\n    Public Sub DisplayPropertyInfo(ByVal propInfos() As PropertyInfo)\n        &#39; Display information for all properties.\n        For Each propInfo In propInfos\n            Dim readable As Boolean = propInfo.CanRead\n            Dim writable As Boolean = propInfo.CanWrite\n            \n            Console.WriteLine(&quot;   Property name: {0}&quot;, propInfo.Name)\n            Console.WriteLine(&quot;   Property type: {0}&quot;, propInfo.PropertyType)\n            Console.WriteLine(&quot;   Read-Write:    {0}&quot;, readable And writable)\n            If readable Then\n               Dim getAccessor As MethodInfo = propInfo.GetMethod\n               Console.WriteLine(&quot;   Visibility:    {0}&quot;,\n                                 GetVisibility(getAccessor))\n            End If\n            If writable Then\n               Dim setAccessor As MethodInfo = propInfo.SetMethod\n               Console.WriteLine(&quot;   Visibility:    {0}&quot;,\n                                 GetVisibility(setAccessor))\n            End If\n            Console.WriteLine()\n        Next\n    End Sub\n    \n    Public Function GetVisibility(accessor As MethodInfo) As String\n       If accessor.IsPublic Then\n          Return &quot;Public&quot;\n       ElseIf accessor.IsPrivate Then\n          Return &quot;Private&quot;\n       Else If accessor.IsFamily Then\n          Return &quot;Protected&quot;\n       Else If accessor.IsAssembly Then\n          Return &quot;Internal/Friend&quot;\n       Else\n          Return &quot;Protected Internal/Friend&quot;\n       End If\n    End Function\nEnd Module\n&#39; The example displays the following output:\n&#39;       The number of public properties: 2\n&#39;\n&#39;          Property name: Property1\n&#39;          Property type: System.String\n&#39;          Read-Write:    False\n&#39;          Visibility:    Public\n&#39;\n&#39;          Property name: Property2\n&#39;          Property type: System.String\n&#39;          Read-Write:    False\n&#39;          Visibility:    Public\n&#39;\n&#39;       The number of non-public properties: 4\n&#39;\n&#39;          Property name: Property3\n&#39;          Property type: System.String\n&#39;          Read-Write:    False\n&#39;          Visibility:    Protected\n&#39;\n&#39;          Property name: Property4\n&#39;          Property type: System.Int32\n&#39;          Read-Write:    False\n&#39;          Visibility:    Private\n&#39;\n&#39;          Property name: Property5\n&#39;          Property type: System.String\n&#39;          Read-Write:    False\n&#39;          Visibility:    Internal/Friend\n&#39;\n&#39;          Property name: Property6\n&#39;          Property type: System.String\n&#39;          Read-Write:    False\n&#39;          Visibility:    Protected Internal/Friend\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetProperty_System_String_\">\r\n    \r\n            <a id=\"System_Type_GetProperty_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetProperty(String)</div>        \r\n          </div>\r\n    \r\n            <p>Searches for the public property with the specified name.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.PropertyInfo GetProperty (string name);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the public property to get.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a></div>\r\n                  </div>\r\n                  <p>An object representing the public property with the specified name, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a></div>\r\n                  </div>\r\n                  <p>More than one property is found with the specified name. See Remarks.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The search for <code>name</code> is case-sensitive. The search includes public static and public instance properties.  </p>\n<p> A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (in Visual Basic, combine the values using <code>Or</code>) to get it.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a> with the type parameters replaced by the appropriate type arguments.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.  </p>\n<p> Situations in which <a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a> occurs include the following:  </p>\n<ul>\n<li><p>A type contains two indexed properties that have the same name but different numbers of parameters. To resolve the ambiguity, use an overload of the <a class=\"xref\" href=\"system.type#System_Type_GetProperty_\" data-linktype=\"relative-path\">GetProperty</a> method that specifies parameter types.  </p>\n</li>\n<li><p>A derived type declares a property that hides an inherited property with the same name, by using the <code>new</code> modifier (<code>Shadows</code> in Visual Basic). To resolve the ambiguity, use the <a class=\"xref\" href=\"system.type#System_Type_GetProperty_System_String_System_Reflection_BindingFlags_\" data-linktype=\"relative-path\">GetProperty(String,BindingFlags)</a> method overload and add the <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> flag to restrict the search to members that are not inherited.  </p>\n</li>\n</ul>\n<h2 id=\"indexers-and-default-properties\">Indexers and Default Properties</h2>\n<p> <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/vbprvblong-md.md&quot; -->Visual Basic 2005<!--END INCLUDE -->, <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/csprcslong-md.md&quot; -->Visual C# 2005<!--END INCLUDE -->, and <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/vcprvclong-md.md&quot; -->Visual C++ 2005<!--END INCLUDE --> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable <code>myList</code> refers to an <a class=\"xref\" href=\"system.collections.arraylist\" data-linktype=\"relative-path\">ArrayList</a>, the syntax <code>myList[3]</code> (<code>myList(3)</code> in Visual Basic) retrieves the element with the index of 3. You can overload the property.  </p>\n<p> In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named &quot;Item&quot;. However, a class library developer can use the <a class=\"xref\" href=\"system.runtime.compilerservices.indexernameattribute\" data-linktype=\"relative-path\">IndexerNameAttribute</a> attribute to change the name of the indexer in the metadata. For example, the <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a> class has an indexer named <a class=\"xref\" href=\"system.string#System_String_Chars_\" data-linktype=\"relative-path\">Chars</a>. Indexed properties created using languages other than C# can have names other than Item, as well.  </p>\n<p> To determine whether a type has a default property, use the <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_GetCustomAttributes_System_Type_System_Boolean_\" data-linktype=\"relative-path\">GetCustomAttributes(Type,Boolean)</a> method to test for the <a class=\"xref\" href=\"system.reflection.defaultmemberattribute\" data-linktype=\"relative-path\">DefaultMemberAttribute</a> attribute. If the type has <a class=\"xref\" href=\"system.reflection.defaultmemberattribute\" data-linktype=\"relative-path\">DefaultMemberAttribute</a>, the <a class=\"xref\" href=\"system.reflection.defaultmemberattribute#System_Reflection_DefaultMemberAttribute_MemberName_\" data-linktype=\"relative-path\">MemberName</a> property returns the name of the default property.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example retrieves the <code>Type</code> object of a user-defined class, retrieves a property of that class, and displays the property name.  </p>\n<pre><code class=\"lang-vb\" name=\"Type_GetProperty1#1\">Imports System\nImports System.Reflection\nClass MyClass1\n    Private myProperty1 As Integer\n    &#39; Declare MyProperty.\n\n    Public Property MyProperty() As Integer\n        Get\n            Return myProperty1\n        End Get\n        Set(ByVal Value As Integer)\n            myProperty1 = Value\n        End Set\n    End Property\nEnd Class &#39;MyClass1\n\nPublic Class MyTypeClass\n    Public Shared Sub Main(ByVal args() As String)\n        Try\n            &#39; Get Type Object corresponding to MyClass.\n            Dim myType As Type = GetType(MyClass1)\n            &#39; Get PropertyInfo object by passing property name.\n            Dim myPropInfo As PropertyInfo = myType.GetProperty(&quot;MyProperty&quot;)\n            &#39; Display Name propety to console.\n            Console.WriteLine(&quot;The {0} property exists in MyClass.&quot;, myPropInfo.Name)\n        Catch e As NullReferenceException\n            Console.WriteLine(&quot;The property does not exist in MyClass.&quot;, e.Message.ToString())\n        End Try\n    End Sub &#39;Main\nEnd Class &#39;MyTypeClass \n</code></pre><pre><code class=\"lang-cs\" name=\"Type_GetProperty1#1\">\nusing System;\nusing System.Reflection;\n\nclass MyClass\n{\n    private int myProperty;\n    // Declare MyProperty.\n    public int MyProperty\n    {\n        get\n        {\n            return myProperty;\n        }\n        set\n        {\n            myProperty=value;\n        }\n    }\n}\npublic class MyTypeClass\n{\n    public static void Main(string[] args)\n    {\n        try\n        {\n            // Get the Type object corresponding to MyClass.\n            Type myType=typeof(MyClass);       \n            // Get the PropertyInfo object by passing the property name.\n            PropertyInfo myPropInfo = myType.GetProperty(&quot;MyProperty&quot;);\n            // Display the property name.\n            Console.WriteLine(&quot;The {0} property exists in MyClass.&quot;, myPropInfo.Name);\n        }\n        catch(NullReferenceException e)\n        {\n            Console.WriteLine(&quot;The property does not exist in MyClass.&quot; + e.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetProperty1#1\">using namespace System;\nusing namespace System::Reflection;\nref class MyClass\n{\nprivate:\n   int myProperty;\n\npublic:\n\n   property int MyProperty \n   {\n      // Declare MyProperty.\n      int get()\n      {\n         return myProperty;\n      }\n\n      void set( int value )\n      {\n         myProperty = value;\n      }\n   }\n};\n\nint main()\n{\n   try\n   {\n      // Get the Type object corresponding to MyClass.\n      Type^ myType = MyClass::typeid;\n      \n      // Get the PropertyInfo object by passing the property name.\n      PropertyInfo^ myPropInfo = myType-&gt;GetProperty( &quot;MyProperty&quot; );\n      \n      // Display the property name.\n      Console::WriteLine( &quot;The {0} property exists in MyClass.&quot;, myPropInfo-&gt;Name );\n   }\n   catch ( NullReferenceException^ e ) \n   {\n      Console::WriteLine( &quot;The property does not exist in MyClass. {0}&quot;, e-&gt;Message );\n   }\n}\n</code></pre><p> Internally, this property is referred to in the metadata by the name &quot;Item.&quot; Any attempt to get <code>PropertyInfo</code> using reflection must specify this internal name in order to correctly return the <code>PropertyInfo</code> property.</p>\n\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetProperty_System_String_System_Reflection_BindingFlags_\">\r\n    \r\n            <a id=\"System_Type_GetProperty_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetProperty(String,BindingFlags)</div>        \r\n          </div>\r\n    \r\n            <p>Searches for the specified property, using the specified binding constraints.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the property to get.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>bindingAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted.  </p>\n<p> -or-  </p>\n<p> Zero, to return <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a></div>\r\n                  </div>\r\n                  <p>An object representing the property that matches the specified requirements, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a></div>\r\n                  </div>\r\n                  <p>More than one property is found with the specified name and matching the specified binding constraints. See Remarks.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (in Visual Basic, combine the values using <code>Or</code>) to get it.  </p>\n<p> The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which properties to include in the search:  </p>\n<ul>\n<li><p>You must specify either <code>BindingFlags.Instance</code> or <code>BindingFlags.Static</code> in order to get a return.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.Public</code> to include public properties in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.NonPublic</code> to include non-public properties (that is, private, internal, and protected properties) in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.FlattenHierarchy</code> to include <code>public</code> and <code>protected</code> static members up the hierarchy; <code>private</code> static members in inherited classes are not included.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> modifier flags can be used to change how the search works:  </p>\n</li>\n<li><p><code>BindingFlags.IgnoreCase</code> to ignore the case of <code>name</code>.  </p>\n</li>\n<li><p><code>BindingFlags.DeclaredOnly</code> to search only the properties declared on the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, not properties that were simply inherited.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a> with the type parameters replaced by the appropriate type arguments.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.  </p>\n<p>Situations in which <a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a> occurs include the following:  </p>\n</li>\n<li><p>A type contains two indexed properties that have the same name but different numbers of parameters. To resolve the ambiguity, use an overload of the <a class=\"xref\" href=\"system.type#System_Type_GetProperty_\" data-linktype=\"relative-path\">GetProperty</a> method that specifies parameter types.  </p>\n</li>\n<li><p>A derived type declares a property that hides an inherited property with the same name, using the <code>new</code> modifier (<code>Shadows</code> in Visual Basic). To resolve the ambiguity, include <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> to restrict the search to members that are not inherited.  </p>\n</li>\n</ul>\n<h2 id=\"indexers-and-default-properties\">Indexers and Default Properties</h2>\n<p> <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/vbprvblong-md.md&quot; -->Visual Basic 2005<!--END INCLUDE -->, <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/csprcslong-md.md&quot; -->Visual C# 2005<!--END INCLUDE -->, and <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/vcprvclong-md.md&quot; -->Visual C++ 2005<!--END INCLUDE --> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable <code>myList</code> refers to an <a class=\"xref\" href=\"system.collections.arraylist\" data-linktype=\"relative-path\">ArrayList</a>, the syntax <code>myList[3]</code> (<code>myList(3)</code> in Visual Basic) retrieves the element with the index of 3. You can overload the property.  </p>\n<p> In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named &quot;Item&quot;. However, a class library developer can use the <a class=\"xref\" href=\"system.runtime.compilerservices.indexernameattribute\" data-linktype=\"relative-path\">IndexerNameAttribute</a> attribute to change the name of the indexer in the metadata. For example, the <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a> class has an indexer named <a class=\"xref\" href=\"system.string#System_String_Chars_\" data-linktype=\"relative-path\">Chars</a>. Indexed properties created using languages other than C# can have names other than Item, as well.  </p>\n<p> To determine whether a type has a default property, use the <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_GetCustomAttributes_System_Type_System_Boolean_\" data-linktype=\"relative-path\">GetCustomAttributes(Type,Boolean)</a> method to test for the <a class=\"xref\" href=\"system.reflection.defaultmemberattribute\" data-linktype=\"relative-path\">DefaultMemberAttribute</a> attribute. If the type has <a class=\"xref\" href=\"system.reflection.defaultmemberattribute\" data-linktype=\"relative-path\">DefaultMemberAttribute</a>, the <a class=\"xref\" href=\"system.reflection.defaultmemberattribute#System_Reflection_DefaultMemberAttribute_MemberName_\" data-linktype=\"relative-path\">MemberName</a> property returns the name of the default property.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example retrieves the type of a user-defined class, retrieves a property of that class and displays the property name in accordance with the specified binding constraints.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_GetProperty2#1\">using namespace System;\nusing namespace System::Reflection;\nref class MyClass\n{\nprivate:\n   int myProperty;\n\npublic:\n\n   property int MyProperty \n   {\n      // Declare MyProperty.\n      int get()\n      {\n         return myProperty;\n      }\n\n      void set( int value )\n      {\n         myProperty = value;\n      }\n   }\n};\n\nint main()\n{\n   try\n   {\n      // Get Type object of MyClass.\n      Type^ myType = MyClass::typeid;\n      \n      // Get the PropertyInfo by passing the property name and specifying the BindingFlags.\n      PropertyInfo^ myPropInfo = myType-&gt;GetProperty( &quot;MyProperty&quot;, static_cast&lt;BindingFlags&gt;(BindingFlags::Public | BindingFlags::Instance) );\n      \n      // Display Name propety to console.\n      Console::WriteLine( &quot;{0} is a property of MyClass.&quot;, myPropInfo-&gt;Name );\n   }\n   catch ( NullReferenceException^ e ) \n   {\n      Console::WriteLine( &quot;MyProperty does not exist in MyClass. {0}&quot;, e-&gt;Message );\n   }\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_GetProperty2#1\">\nusing System;\nusing System.Reflection;\nclass MyClass\n{\n    private int myProperty;\n    // Declare MyProperty.\n    public int MyProperty\n    {\n        get\n        {\n            return myProperty;\n        }\n        set\n        {\n            myProperty=value;\n        }\n    }\n}\npublic class MyTypeClass\n{\n    public static void Main(string[] args)\n    {\n        try\n        {\n            // Get Type object of MyClass.\n            Type myType=typeof(MyClass);       \n            // Get the PropertyInfo by passing the property name and specifying the BindingFlags.\n            PropertyInfo myPropInfo = myType.GetProperty(&quot;MyProperty&quot;, BindingFlags.Public | BindingFlags.Instance);\n            // Display Name propety to console.\n            Console.WriteLine(&quot;{0} is a property of MyClass.&quot;, myPropInfo.Name);\n        }\n        catch(NullReferenceException e)\n        {\n            Console.WriteLine(&quot;MyProperty does not exist in MyClass.&quot; +e.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetProperty2#1\">\nImports System\nImports System.Reflection\nModule Module1\n    Public Class MyClass1\n        Private myProperty1 As Integer\n        &#39; Declare MyProperty.\n        Public Property MyProperty() As Integer\n            Get\n                Return myProperty1\n            End Get\n            Set(ByVal Value As Integer)\n                myProperty1 = Value\n            End Set\n        End Property\n        Public Shared Sub Main()\n            Try\n                &#39; Get a Type object corresponding to MyClass.\n                Dim myType As Type = GetType(MyClass1)\n                &#39; Get a PropertyInfo object by passing property name and specifying BindingFlags.\n                Dim myPropInfo As PropertyInfo = myType.GetProperty(&quot;MyProperty&quot;, BindingFlags.Public Or BindingFlags.Instance)\n                &#39; Display the Name property.\n                Console.WriteLine(&quot;{0} is a property of MyClass.&quot;, myPropInfo.Name)\n            Catch e As NullReferenceException\n                Console.WriteLine(&quot;MyProperty does not exist in MyClass.&quot;, e.Message.ToString())\n            End Try\n        End Sub &#39;Main\n    End Class &#39;MyClass1\nEnd Module &#39;Module1\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetProperty_System_String_System_Type_\">\r\n    \r\n            <a id=\"System_Type_GetProperty_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetProperty(String,Type)</div>        \r\n          </div>\r\n    \r\n            <p>Searches for the public property with the specified name and return type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the public property to get.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>returnType</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The return type of the property.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a></div>\r\n                  </div>\r\n                  <p>An object representing the public property with the specified name, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a></div>\r\n                  </div>\r\n                  <p>More than one property is found with the specified name.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>, or <code>returnType</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (in Visual Basic, combine the values using <code>Or</code>) to get it.  </p>\n<p> The search for <code>name</code> is case-sensitive. The search includes public static and public instance properties.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a> with the type parameters replaced by the appropriate type arguments.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.  </p>\n<h2 id=\"indexers-and-default-properties\">Indexers and Default Properties</h2>\n<p> <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/vbprvblong-md.md&quot; -->Visual Basic 2005<!--END INCLUDE -->, <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/csprcslong-md.md&quot; -->Visual C# 2005<!--END INCLUDE -->, and <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/vcprvclong-md.md&quot; -->Visual C++ 2005<!--END INCLUDE --> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable <code>myList</code> refers to an <a class=\"xref\" href=\"system.collections.arraylist\" data-linktype=\"relative-path\">ArrayList</a>, the syntax <code>myList[3]</code> (<code>myList(3)</code> in Visual Basic) retrieves the element with the index of 3. You can overload the property.  </p>\n<p> In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named &quot;Item&quot;. However, a class library developer can use the <a class=\"xref\" href=\"system.runtime.compilerservices.indexernameattribute\" data-linktype=\"relative-path\">IndexerNameAttribute</a> attribute to change the name of the indexer in the metadata. For example, the <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a> class has an indexer named <a class=\"xref\" href=\"system.string#System_String_Chars_\" data-linktype=\"relative-path\">Chars</a>. Indexed properties created using languages other than C# can have names other than Item, as well.  </p>\n<p> To determine whether a type has a default property, use the <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_GetCustomAttributes_System_Type_System_Boolean_\" data-linktype=\"relative-path\">GetCustomAttributes(Type,Boolean)</a> method to test for the <a class=\"xref\" href=\"system.reflection.defaultmemberattribute\" data-linktype=\"relative-path\">DefaultMemberAttribute</a> attribute. If the type has <a class=\"xref\" href=\"system.reflection.defaultmemberattribute\" data-linktype=\"relative-path\">DefaultMemberAttribute</a>, the <a class=\"xref\" href=\"system.reflection.defaultmemberattribute#System_Reflection_DefaultMemberAttribute_MemberName_\" data-linktype=\"relative-path\">MemberName</a> property returns the name of the default property.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example defines a class with one property and retrieves the name and type of the property.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_GetProperty_Types#1\">\nusing System;\nusing System.Reflection;\n\nclass MyClass1\n{\n    String myMessage=&quot;Hello World.&quot;;\n    public string MyProperty1\n    {\n        get\n        {\t\t\t\n            return myMessage;\n        }\n        set\n        {\n            myMessage =value;\n        }\t\t\t\n    }\n}\nclass TestClass\n{\n    static void Main()\n    {\n        try\n        {\t\n            Type myType = typeof(MyClass1);\n            // Get the PropertyInfo object representing MyProperty1. \n            PropertyInfo myStringProperties1 = myType.GetProperty(&quot;MyProperty1&quot;,\n                typeof(string));\n            Console.WriteLine(&quot;The name of the first property of MyClass1 is {0}.&quot;, myStringProperties1.Name);\n            Console.WriteLine(&quot;The type of the first property of MyClass1 is {0}.&quot;, myStringProperties1.PropertyType);\n        }\n        catch(ArgumentNullException e)\n        {\n            Console.WriteLine(&quot;ArgumentNullException :&quot;+e.Message);\n\n        }\n        catch(AmbiguousMatchException e)\n        {\n            Console.WriteLine(&quot;AmbiguousMatchException :&quot;+e.Message);\n        }\n        catch(NullReferenceException e)\n        {\n            Console.WriteLine(&quot;Source : {0}&quot; , e.Source);\n            Console.WriteLine(&quot;Message : {0}&quot; , e.Message);\n        }\n\t//Output:\n\t//The name of the first property of MyClass1 is MyProperty1.\n\t//The type of the first property of MyClass1 is System.String.\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetProperty_Types#1\">using namespace System;\nusing namespace System::Reflection;\nref class MyClass1\n{\nprivate:\n   String^ myMessage;\n\npublic:\n\n   property String^ MyProperty1 \n   {\n      String^ get()\n      {\n         return myMessage;\n      }\n\n      void set( String^ value )\n      {\n         myMessage = value;\n      }\n   }\n};\n\nint main()\n{\n   try\n   {\n      Type^ myType = MyClass1::typeid;\n      \n      // Get the PropertyInfo Object* representing MyProperty1.\n      PropertyInfo^ myStringProperties1 = myType-&gt;GetProperty( &quot;MyProperty1&quot;, String::typeid );\n      Console::WriteLine( &quot;The name of the first property of MyClass1 is {0}.&quot;, myStringProperties1-&gt;Name );\n      Console::WriteLine( &quot;The type of the first property of MyClass1 is {0}.&quot;, myStringProperties1-&gt;PropertyType );\n   }\n   catch ( ArgumentNullException^ e ) \n   {\n      Console::WriteLine( &quot;ArgumentNullException : {0}&quot;, e-&gt;Message );\n   }\n   catch ( AmbiguousMatchException^ e ) \n   {\n      Console::WriteLine( &quot;AmbiguousMatchException : {0}&quot;, e-&gt;Message );\n   }\n   catch ( NullReferenceException^ e ) \n   {\n      Console::WriteLine( &quot;Source : {0}&quot;, e-&gt;Source );\n      Console::WriteLine( &quot;Message : {0}&quot;, e-&gt;Message );\n   }\n   //Output:\n   //The name of the first property of MyClass1 is MyProperty1.\n   //The type of the first property of MyClass1 is System.String.\n\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetProperty_Types#1\">Imports System\nImports System.Reflection\nClass MyClass1\n    Private myMessage As [String] = &quot;Hello World.&quot;\n    Public Property MyProperty1() As String\n        Get\n            Return myMessage\n        End Get\n        Set(ByVal Value As String)\n            myMessage = Value\n        End Set\n    End Property\nEnd Class &#39;MyClass1\n\nClass TestClass\n    Shared Sub Main()\n        Try\n            Dim myType As Type = GetType(MyClass1)\n            &#39; Get the PropertyInfo object representing MyProperty1. \n            Dim myStringProperties1 As PropertyInfo = myType.GetProperty(&quot;MyProperty1&quot;, GetType(String))\n            Console.WriteLine(&quot;The name of the first property of MyClass1 is {0}.&quot;, myStringProperties1.Name)\n            Console.WriteLine(&quot;The type of the first property of MyClass1 is {0}.&quot;, myStringProperties1.PropertyType.ToString())\n        Catch e As ArgumentNullException\n            Console.WriteLine(&quot;ArgumentNullException :&quot; + e.Message.ToString())\n        Catch e As AmbiguousMatchException\n            Console.WriteLine(&quot;AmbiguousMatchException :&quot; + e.Message.ToString())\n        Catch e As NullReferenceException\n            Console.WriteLine(&quot;Source : {0}&quot;, e.Source.ToString())\n            Console.WriteLine(&quot;Message : {0}&quot;, e.Message.ToString())\n        End Try\n\t&#39;Output:\n\t&#39;The name of the first property of MyClass1 is MyProperty1.\n\t&#39;The type of the first property of MyClass1 is System.String.\n\n    End Sub &#39;Main\nEnd Class &#39;TestClass\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetProperty_System_String_System_Type___\">\r\n    \r\n            <a id=\"System_Type_GetProperty_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetProperty(String,Type[])</div>        \r\n          </div>\r\n    \r\n            <p>Searches for the specified public property whose parameters match the specified argument types.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the public property to get.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>types</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.  </p>\n<p> -or-  </p>\n<p> An empty array of the type <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a></div>\r\n                  </div>\r\n                  <p>An object representing the public property whose parameters match the specified argument types, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a></div>\r\n                  </div>\r\n                  <p>More than one property is found with the specified name and matching the specified argument types.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>types</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>types</code> is multidimensional.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a></div>\r\n                  </div>\r\n                  <p>An element of <code>types</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (in Visual Basic, combine the values using <code>Or</code>) to get it.  </p>\n<p> The search for <code>name</code> is case-sensitive. The search includes public static and public instance properties.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a> with the type parameters replaced by the appropriate type arguments.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.  </p>\n<h2 id=\"indexers-and-default-properties\">Indexers and Default Properties</h2>\n<p> <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/vbprvblong-md.md&quot; -->Visual Basic 2005<!--END INCLUDE -->, <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/csprcslong-md.md&quot; -->Visual C# 2005<!--END INCLUDE -->, and <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/vcprvclong-md.md&quot; -->Visual C++ 2005<!--END INCLUDE --> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable <code>myList</code> refers to an <a class=\"xref\" href=\"system.collections.arraylist\" data-linktype=\"relative-path\">ArrayList</a>, the syntax <code>myList[3]</code> (<code>myList(3)</code> in Visual Basic) retrieves the element with the index of 3. You can overload the property.  </p>\n<p> In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named &quot;Item&quot;. However, a class library developer can use the <a class=\"xref\" href=\"system.runtime.compilerservices.indexernameattribute\" data-linktype=\"relative-path\">IndexerNameAttribute</a> attribute to change the name of the indexer in the metadata. For example, the <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a> class has an indexer named <a class=\"xref\" href=\"system.string#System_String_Chars_\" data-linktype=\"relative-path\">Chars</a>. Indexed properties created using languages other than C# can have names other than Item, as well.  </p>\n<p> To determine whether a type has a default property, use the <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_GetCustomAttributes_System_Type_System_Boolean_\" data-linktype=\"relative-path\">GetCustomAttributes(Type,Boolean)</a> method to test for the <a class=\"xref\" href=\"system.reflection.defaultmemberattribute\" data-linktype=\"relative-path\">DefaultMemberAttribute</a> attribute. If the type has <a class=\"xref\" href=\"system.reflection.defaultmemberattribute\" data-linktype=\"relative-path\">DefaultMemberAttribute</a>, the <a class=\"xref\" href=\"system.reflection.defaultmemberattribute#System_Reflection_DefaultMemberAttribute_MemberName_\" data-linktype=\"relative-path\">MemberName</a> property returns the name of the default property.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example retrieves the <code>Type</code> object of a user-defined class, retrieves the property of that class, and displays the property name and type of the property as specified by the arguments passed to <code>GetProperty</code>.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_GetProperty3#1\">using namespace System;\nusing namespace System::Reflection;\nref class MyClass1\n{\nprivate:\n   array&lt;int, 2&gt;^myArray;\n\npublic:\n\n   property int Item [int, int]\n   {\n\n      // Declare an indexer.\n      int get( int i, int j )\n      {\n         return myArray[ i,j ];\n      }\n\n      void set( int i, int j, int value )\n      {\n         myArray[ i,j ] = value;\n      }\n\n   }\n\n};\n\nint main()\n{\n   try\n   {\n      \n      // Get the Type object.\n      Type^ myType = MyClass1::typeid;\n      array&lt;Type^&gt;^myTypeArr = gcnew array&lt;Type^&gt;(2);\n      \n      // Create an instance of a Type array.\n      myTypeArr-&gt;SetValue( int::typeid, 0 );\n      myTypeArr-&gt;SetValue( int::typeid, 1 );\n      \n      // Get the PropertyInfo object for the indexed property Item, which has two integer parameters.\n      PropertyInfo^ myPropInfo = myType-&gt;GetProperty( &quot;Item&quot;, myTypeArr );\n      \n      // Display the property.\n      Console::WriteLine( &quot;The {0} property exists in MyClass1.&quot;, myPropInfo );\n   }\n   catch ( NullReferenceException^ e ) \n   {\n      Console::WriteLine( &quot;An exception occurred.&quot; );\n      Console::WriteLine( &quot;Source : {0}&quot;, e-&gt;Source );\n      Console::WriteLine( &quot;Message : {0}&quot;, e-&gt;Message );\n   }\n\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_GetProperty3#1\">\nusing System;\nusing System.Reflection;\nclass MyClass1\n{         \n    private int [,] myArray = {{1,2},{3,4}}; \n    // Declare an indexer.\n    public int this [int i,int j]   \n    {\n        get \n        {\n            return myArray[i,j];\n        }\n        set \n        {\n            myArray[i,j] = value;\n        }\n    }\n}\npublic class MyTypeClass\n{\n    public static void Main(string[] args)\n    {\n        try\n        { \n            // Get the Type object.\n            Type myType=typeof(MyClass1);       \n            Type[] myTypeArr = new Type[2];\n            // Create an instance of a Type array.\n            myTypeArr.SetValue(typeof(int),0);            \n            myTypeArr.SetValue(typeof(int),1);\n            // Get the PropertyInfo object for the indexed property Item, which has two integer parameters. \n            PropertyInfo myPropInfo = myType.GetProperty(&quot;Item&quot;, myTypeArr);\n            // Display the property.\n            Console.WriteLine(&quot;The {0} property exists in MyClass1.&quot;, myPropInfo.ToString());\n        }           \n        catch(NullReferenceException e)\n        {\n            Console.WriteLine(&quot;An exception occurred.&quot;);\n            Console.WriteLine(&quot;Source : {0}&quot; , e.Source);\n            Console.WriteLine(&quot;Message : {0}&quot; , e.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetProperty3#1\">Imports System\nImports System.Reflection\n\nModule Module1\n    Class MyClass1\n        Private myArray As Integer(,) = {{1, 2}, {3, 4}}\n        &#39; Declare an indexer.\n        Default Public Property Item(ByVal i As Integer, ByVal j As Integer) As Integer\n            Get\n                Return myArray(i, j)\n            End Get\n            Set(ByVal Value As Integer)\n\n                myArray(i, j) = Value\n            End Set\n        End Property\n    End Class &#39;MyClass1\n\n    Public Class MyTypeClass\n        Public Shared Sub Main()\n            Try\n                &#39; Get the Type Object.\n                Dim myType As Type = GetType(MyClass1)\n                Dim myTypeArr(1) As Type\n                &#39; Create an instance of a Type array.\n                myTypeArr.SetValue(GetType(Integer), 0)\n                myTypeArr.SetValue(GetType(Integer), 1)\n                &#39; Get the PropertyInfo object for the indexed property Item, which has two integer parameters. \n                Dim myPropInfo As PropertyInfo = myType.GetProperty(&quot;Item&quot;, myTypeArr)\n                &#39; Display the property.\n                Console.WriteLine(&quot;The {0} property exists in MyClass1.&quot;, myPropInfo.ToString())\n            Catch e As NullReferenceException\n                Console.WriteLine(&quot;An exception occurred.&quot;)\n                Console.WriteLine(&quot;Source : {0}&quot;, e.Source.ToString())\n                Console.WriteLine(&quot;Message : {0}&quot;, e.Message.ToString())\n            End Try\n        End Sub &#39;Main\n    End Class &#39;MyTypeClass\nEnd Module &#39;Module1\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetProperty_System_String_System_Type_System_Type___\">\r\n    \r\n            <a id=\"System_Type_GetProperty_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetProperty(String,Type,Type[])</div>        \r\n          </div>\r\n    \r\n            <p>Searches for the specified public property whose parameters match the specified argument types.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the public property to get.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>returnType</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The return type of the property.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>types</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.  </p>\n<p> -or-  </p>\n<p> An empty array of the type <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a></div>\r\n                  </div>\r\n                  <p>An object representing the public property whose parameters match the specified argument types, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a></div>\r\n                  </div>\r\n                  <p>More than one property is found with the specified name and matching the specified argument types.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>types</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>types</code> is multidimensional.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a></div>\r\n                  </div>\r\n                  <p>An element of <code>types</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (in Visual Basic, combine the values using <code>Or</code>) to get it.  </p>\n<p> The search for <code>name</code> is case-sensitive. The search includes public static and public instance properties.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a> with the type parameters replaced by the appropriate type arguments.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.  </p>\n<h2 id=\"indexers-and-default-properties\">Indexers and Default Properties</h2>\n<p> <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/vbprvblong-md.md&quot; -->Visual Basic 2005<!--END INCLUDE -->, <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/csprcslong-md.md&quot; -->Visual C# 2005<!--END INCLUDE -->, and <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/vcprvclong-md.md&quot; -->Visual C++ 2005<!--END INCLUDE --> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable <code>myList</code> refers to an <a class=\"xref\" href=\"system.collections.arraylist\" data-linktype=\"relative-path\">ArrayList</a>, the syntax <code>myList[3]</code> (<code>myList(3)</code> in Visual Basic) retrieves the element with the index of 3. You can overload the property.  </p>\n<p> In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named &quot;Item&quot;. However, a class library developer can use the <a class=\"xref\" href=\"system.runtime.compilerservices.indexernameattribute\" data-linktype=\"relative-path\">IndexerNameAttribute</a> attribute to change the name of the indexer in the metadata. For example, the <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a> class has an indexer named <a class=\"xref\" href=\"system.string#System_String_Chars_\" data-linktype=\"relative-path\">Chars</a>. Indexed properties created using languages other than C# can have names other than Item, as well.  </p>\n<p> To determine whether a type has a default property, use the <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_GetCustomAttributes_System_Type_System_Boolean_\" data-linktype=\"relative-path\">GetCustomAttributes(Type,Boolean)</a> method to test for the <a class=\"xref\" href=\"system.reflection.defaultmemberattribute\" data-linktype=\"relative-path\">DefaultMemberAttribute</a> attribute. If the type has <a class=\"xref\" href=\"system.reflection.defaultmemberattribute\" data-linktype=\"relative-path\">DefaultMemberAttribute</a>, the <a class=\"xref\" href=\"system.reflection.defaultmemberattribute#System_Reflection_DefaultMemberAttribute_MemberName_\" data-linktype=\"relative-path\">MemberName</a> property returns the name of the default property.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetProperty_System_String_System_Type_System_Type___System_Reflection_ParameterModifier___\">\r\n    \r\n            <a id=\"System_Type_GetProperty_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetProperty(String,Type,Type[],ParameterModifier[])</div>        \r\n          </div>\r\n    \r\n            <p>Searches for the specified public property whose parameters match the specified argument types and modifiers.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the public property to get.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>returnType</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The return type of the property.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>types</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.  </p>\n<p> -or-  </p>\n<p> An empty array of the type <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>modifiers</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <code>types</code> array. The default binder does not process this parameter.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a></div>\r\n                  </div>\r\n                  <p>An object representing the public property that matches the specified requirements, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a></div>\r\n                  </div>\r\n                  <p>More than one property is found with the specified name and matching the specified argument types and modifiers.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>types</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>types</code> is multidimensional.  </p>\n<p> -or-  </p>\n<p> <code>modifiers</code> is multidimensional.  </p>\n<p> -or-  </p>\n<p> <code>types</code> and <code>modifiers</code> do not have the same length.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a></div>\r\n                  </div>\r\n                  <p>An element of <code>types</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (in Visual Basic, combine the values using <code>Or</code>) to get it.  </p>\n<p> Although the default binder does not process <a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a> (the <code>modifiers</code> parameter), you can use the abstract <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">System.Reflection.Binder</a> class to write a custom binder that does process <code>modifiers</code>. <code>ParameterModifier</code> is only used when calling through COM interop, and only parameters that are passed by reference are handled.  </p>\n<p> The search for <code>name</code> is case-sensitive. The search includes public static and public instance properties.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a> with the type parameters replaced by the appropriate type arguments.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.  </p>\n<h2 id=\"indexers-and-default-properties\">Indexers and Default Properties</h2>\n<p> <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/vbprvblong-md.md&quot; -->Visual Basic 2005<!--END INCLUDE -->, <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/csprcslong-md.md&quot; -->Visual C# 2005<!--END INCLUDE -->, and <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/vcprvclong-md.md&quot; -->Visual C++ 2005<!--END INCLUDE --> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable <code>myList</code> refers to an <a class=\"xref\" href=\"system.collections.arraylist\" data-linktype=\"relative-path\">ArrayList</a>, the syntax <code>myList[3]</code> (<code>myList(3)</code> in Visual Basic) retrieves the element with the index of 3. You can overload the property.  </p>\n<p> In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named &quot;Item&quot;. However, a class library developer can use the <a class=\"xref\" href=\"system.runtime.compilerservices.indexernameattribute\" data-linktype=\"relative-path\">IndexerNameAttribute</a> attribute to change the name of the indexer in the metadata. For example, the <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a> class has an indexer named <a class=\"xref\" href=\"system.string#System_String_Chars_\" data-linktype=\"relative-path\">Chars</a>. Indexed properties created using languages other than C# can have names other than Item, as well.  </p>\n<p> To determine whether a type has a default property, use the <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_GetCustomAttributes_System_Type_System_Boolean_\" data-linktype=\"relative-path\">GetCustomAttributes(Type,Boolean)</a> method to test for the <a class=\"xref\" href=\"system.reflection.defaultmemberattribute\" data-linktype=\"relative-path\">DefaultMemberAttribute</a> attribute. If the type has <a class=\"xref\" href=\"system.reflection.defaultmemberattribute\" data-linktype=\"relative-path\">DefaultMemberAttribute</a>, the <a class=\"xref\" href=\"system.reflection.defaultmemberattribute#System_Reflection_DefaultMemberAttribute_MemberName_\" data-linktype=\"relative-path\">MemberName</a> property returns the name of the default property.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example obtains a <code>Type</code> object corresponding to <code>MyPropertyClass</code>, and the indexed property of this class is retrieved using the arguments passed to the <code>GetProperty</code> method.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_GetProperty5#1\">using namespace System;\nusing namespace System::Reflection;\npublic ref class MyPropertyClass\n{\nprivate:\n   array&lt;int, 2&gt;^ myPropertyArray;\n\npublic:\n\n   property int Item [int, int]\n   {\n      // Declare an indexer.\n      int get( int i, int j )\n      {\n         return myPropertyArray[ i,j ];\n      }\n\n      void set( int i, int j, int value )\n      {\n         myPropertyArray[ i,j ] = value;\n      }\n\n   }\n\n};\n\nint main()\n{\n   try\n   {\n      Type^ myType = MyPropertyClass::typeid;\n      array&lt;Type^&gt;^myTypeArray = gcnew array&lt;Type^&gt;(2);\n      \n      // Create an instance of the Type array representing the number, order\n      // and type of the parameters for the property.\n      myTypeArray-&gt;SetValue( int::typeid, 0 );\n      myTypeArray-&gt;SetValue( int::typeid, 1 );\n      \n      // Search for the indexed property whose parameters match the\n      // specified argument types and modifiers.\n      PropertyInfo^ myPropertyInfo = myType-&gt;GetProperty( &quot;Item&quot;, int::typeid, myTypeArray, nullptr );\n      Console::WriteLine( &quot;{0}.{1} has a property type of {2}&quot;, myType-&gt;FullName, myPropertyInfo-&gt;Name, myPropertyInfo-&gt;PropertyType );\n   }\n   catch ( Exception^ ex ) \n   {\n      Console::WriteLine( &quot;An exception occurred {0}&quot;, ex-&gt;Message );\n   }\n\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_GetProperty5#1\">using System;\nusing System.Reflection;\npublic class MyPropertyClass\n{\n    private int [,] myPropertyArray = new int[10,10]; \n    // Declare an indexer.\n    public int this [int i,int j]\n    {\n        get \n        {\n            return myPropertyArray[i,j];\n        }\n        set \n        {\n            myPropertyArray[i,j] = value;\n        }\n    }\n}\npublic class MyTypeClass\n{\n    public static void Main()\n    {\n        try\n        {\n            Type myType=typeof(MyPropertyClass);\n            Type[] myTypeArray = new Type[2];\n            // Create an instance of the Type array representing the number, order \n            // and type of the parameters for the property.\n            myTypeArray.SetValue(typeof(int),0);\n            myTypeArray.SetValue(typeof(int),1);\n            // Search for the indexed property whose parameters match the\n            // specified argument types and modifiers.\n            PropertyInfo myPropertyInfo = myType.GetProperty(&quot;Item&quot;,\n                typeof(int),myTypeArray,null);\n            Console.WriteLine(myType.FullName + &quot;.&quot; + myPropertyInfo.Name + \n                &quot; has a property type of &quot; + myPropertyInfo.PropertyType);\n         }\n        catch(Exception ex)\n        {\n            Console.WriteLine(&quot;An exception occurred &quot; + ex.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetProperty5#1\">Imports System\nImports System.Reflection\n\nPublic Class MyPropertyClass\n    Private myPropertyArray(9, 9) As Integer\n    &#39; Declare an indexer.\n    Default Public Property Item(ByVal i As Integer, ByVal j As Integer) As Integer\n        Get\n            Return myPropertyArray(i, j)\n        End Get\n        Set(ByVal Value As Integer)\n            myPropertyArray(i, j) = Value\n        End Set\n    End Property\nEnd Class &#39;MyPropertyClass\n\nPublic Class MyTypeClass\n    Public Shared Sub Main()\n        Try\n            Dim myType As Type = GetType(MyPropertyClass)\n            Dim myTypeArray(1) As Type\n            &#39; Create an instance of a Type array representing the number, order \n            &#39; and type of the parameters for the property.\n            myTypeArray.SetValue(GetType(Integer), 0)\n            myTypeArray.SetValue(GetType(Integer), 1)\n            &#39; Search for the indexed property whose parameters match the\n            &#39; specified argument types and modifiers.\n            Dim myPropertyInfo As PropertyInfo = myType.GetProperty(&quot;Item&quot;, _\n                  GetType(Integer), myTypeArray, Nothing)\n            Console.WriteLine(myType.FullName + &quot;.&quot; + myPropertyInfo.Name + _\n                  &quot; has a property  type of &quot; + myPropertyInfo.PropertyType.ToString())\n        Catch ex As Exception\n            Console.WriteLine(&quot;An exception occurred &quot; + ex.Message.ToString())\n        End Try\n    End Sub &#39;Main\nEnd Class &#39;MyTypeClass\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetProperty_System_String_System_Reflection_BindingFlags_System_Reflection_Binder_System_Type_System_Type___System_Reflection_ParameterModifier___\">\r\n    \r\n            <a id=\"System_Type_GetProperty_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetProperty(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])</div>        \r\n          </div>\r\n    \r\n            <p>Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the property to get.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>bindingAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted.  </p>\n<p> -or-  </p>\n<p> Zero, to return <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>binder</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  </p>\n<p> -or-  </p>\n<p> A null reference (<code>Nothing</code> in Visual Basic), to use the <span class=\"xref\">stem.Type.DefaultBinder*</span>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>returnType</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The return type of the property.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>types</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.  </p>\n<p> -or-  </p>\n<p> An empty array of the type <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>modifiers</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <code>types</code> array. The default binder does not process this parameter.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a></div>\r\n                  </div>\r\n                  <p>An object representing the property that matches the specified requirements, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a></div>\r\n                  </div>\r\n                  <p>More than one property is found with the specified name and matching the specified binding constraints.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>types</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>types</code> is multidimensional.  </p>\n<p> -or-  </p>\n<p> <code>modifiers</code> is multidimensional.  </p>\n<p> -or-  </p>\n<p> <code>types</code> and <code>modifiers</code> do not have the same length.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.nullreferenceexception\" data-linktype=\"relative-path\">NullReferenceException</a></div>\r\n                  </div>\r\n                  <p>An element of <code>types</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> &#124; <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> (in Visual Basic, combine the values using <code>Or</code>) to get it.  </p>\n<p> Although the default binder does not process <a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a> (the <code>modifiers</code> parameter), you can use the abstract <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">System.Reflection.Binder</a> class to write a custom binder that does process <code>modifiers</code>. <code>ParameterModifier</code> is only used when calling through COM interop, and only parameters that are passed by reference are handled.  </p>\n<p> The following table shows what members of a base class are returned by the <code>Get</code> methods when reflecting on a type.  </p>\n<table>\n<thead>\n<tr>\n<th>Member Type</th>\n<th>Static</th>\n<th>Non-Static</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Constructor</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Field</td>\n<td>No</td>\n<td>Yes. A field is always hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Event</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n<tr>\n<td>Method</td>\n<td>No</td>\n<td>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Nested Type</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Property</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  </p>\n</li>\n<li><p>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  </p>\n</li>\n<li><p>Custom attributes are not part of the common type system.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which properties to include in the search:  </p>\n</li>\n</ol>\n<ul>\n<li><p>You must specify either <code>BindingFlags.Instance</code> or <code>BindingFlags.Static</code> in order to get a return.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.Public</code> to include public properties in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.NonPublic</code> to include non-public properties (that is, private, internal, and protected properties) in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.FlattenHierarchy</code> to include <code>public</code> and <code>protected</code> static members up the hierarchy; <code>private</code> static members in inherited classes are not included.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> modifier flags can be used to change how the search works:  </p>\n</li>\n<li><p><code>BindingFlags.IgnoreCase</code> to ignore the case of <code>name</code>.  </p>\n</li>\n<li><p><code>BindingFlags.DeclaredOnly</code> to search only the properties declared on the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, not properties that were simply inherited.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a constructed generic type, this method returns the <a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a> with the type parameters replaced by the appropriate type arguments.  </p>\n<p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.  </p>\n</li>\n</ul>\n<h2 id=\"indexers-and-default-properties\">Indexers and Default Properties</h2>\n<p> <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/vbprvblong-md.md&quot; -->Visual Basic 2005<!--END INCLUDE -->, <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/csprcslong-md.md&quot; -->Visual C# 2005<!--END INCLUDE -->, and <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/vcprvclong-md.md&quot; -->Visual C++ 2005<!--END INCLUDE --> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable <code>myList</code> refers to an <a class=\"xref\" href=\"system.collections.arraylist\" data-linktype=\"relative-path\">ArrayList</a>, the syntax <code>myList[3]</code> (<code>myList(3)</code> in Visual Basic) retrieves the element with the index of 3. You can overload the property.  </p>\n<p> In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named &quot;Item&quot;. However, a class library developer can use the <a class=\"xref\" href=\"system.runtime.compilerservices.indexernameattribute\" data-linktype=\"relative-path\">IndexerNameAttribute</a> attribute to change the name of the indexer in the metadata. For example, the <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a> class has an indexer named <a class=\"xref\" href=\"system.string#System_String_Chars_\" data-linktype=\"relative-path\">Chars</a>. Indexed properties created using languages other than C# can have names other than Item, as well.  </p>\n<p> To determine whether a type has a default property, use the <a class=\"xref\" href=\"system.reflection.memberinfo#System_Reflection_MemberInfo_GetCustomAttributes_System_Type_System_Boolean_\" data-linktype=\"relative-path\">GetCustomAttributes(Type,Boolean)</a> method to test for the <a class=\"xref\" href=\"system.reflection.defaultmemberattribute\" data-linktype=\"relative-path\">DefaultMemberAttribute</a> attribute. If the type has <a class=\"xref\" href=\"system.reflection.defaultmemberattribute\" data-linktype=\"relative-path\">DefaultMemberAttribute</a>, the <a class=\"xref\" href=\"system.reflection.defaultmemberattribute#System_Reflection_DefaultMemberAttribute_MemberName_\" data-linktype=\"relative-path\">MemberName</a> property returns the name of the default property.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetPropertyImpl_System_String_System_Reflection_BindingFlags_System_Reflection_Binder_System_Type_System_Type___System_Reflection_ParameterModifier___\">\r\n    \r\n            <a id=\"System_Type_GetPropertyImpl_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetPropertyImpl(String,BindingFlags,Binder,Type,Type[],ParameterModifier[])</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the property to get.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>bindingAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted.  </p>\n<p> -or-  </p>\n<p> Zero, to return <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>binder</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.  </p>\n<p> -or-  </p>\n<p> A null reference (<code>Nothing</code> in Visual Basic), to use the <span class=\"xref\">stem.Type.DefaultBinder*</span>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>returnType</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The return type of the property.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>types</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects representing the number, order, and type of the parameters for the indexed property to get.  </p>\n<p> -or-  </p>\n<p> An empty array of the type <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>modifiers</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <code>types</code> array. The default binder does not process this parameter.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.propertyinfo\" data-linktype=\"relative-path\">PropertyInfo</a></div>\r\n                  </div>\r\n                  <p>An object representing the property that matches the specified requirements, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a></div>\r\n                  </div>\r\n                  <p>More than one property is found with the specified name and matching the specified binding constraints.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>types</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One of the elements in <code>types</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>types</code> is multidimensional.  </p>\n<p> -or-  </p>\n<p> <code>modifiers</code> is multidimensional.  </p>\n<p> -or-  </p>\n<p> <code>types</code> and <code>modifiers</code> do not have the same length.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The current type is a <a class=\"xref\" href=\"system.reflection.emit.typebuilder\" data-linktype=\"relative-path\">TypeBuilder</a>, <a class=\"xref\" href=\"system.reflection.emit.enumbuilder\" data-linktype=\"relative-path\">EnumBuilder</a>, or <a class=\"xref\" href=\"system.reflection.emit.generictypeparameterbuilder\" data-linktype=\"relative-path\">GenericTypeParameterBuilder</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Although the default binder does not process <a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a> (the <code>modifiers</code> parameter), you can use the abstract <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">System.Reflection.Binder</a> class to write a custom binder that does process <code>modifiers</code>. <code>ParameterModifier</code> is only used when calling through COM interop, and only parameters that are passed by reference are handled.  </p>\n<p> The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which properties to include in the search:  </p>\n<ul>\n<li><p>You must specify either <code>BindingFlags.Instance</code> or <code>BindingFlags.Static</code> in order to get a return.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.Public</code> to include public properties in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.NonPublic</code> to include non-public properties (that is, private, internal, and protected properties) in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.FlattenHierarchy</code> to include <code>public</code> and <code>protected</code> static members up the hierarchy; <code>private</code> static members in inherited classes are not included.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> modifier flags can be used to change how the search works:  </p>\n</li>\n<li><p><code>BindingFlags.IgnoreCase</code> to ignore the case of <code>name</code>.  </p>\n</li>\n<li><p><code>BindingFlags.DeclaredOnly</code> to search only the properties declared on the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, not properties that were simply inherited.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.</p>\n</li>\n</ul>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetType\">\r\n    \r\n            <a id=\"System_Type_GetType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetType()</div>        \r\n          </div>\r\n    \r\n            <p>Gets the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public Type GetType ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>The current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.targetinvocationexception\" data-linktype=\"relative-path\">TargetInvocationException</a></div>\r\n                  </div>\r\n                  <p>A class initializer is invoked and throws an exception.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetType_System_String_\">\r\n    \r\n            <a id=\"System_Type_GetType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetType(String)</div>        \r\n          </div>\r\n    \r\n            <p>Gets the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> with the specified name, performing a case-sensitive search.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static Type GetType (string typeName);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>typeName</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The assembly-qualified name of the type to get. See <span class=\"xref\">stem.Type.AssemblyQualifiedName*</span>. If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>The type with the specified name, if found; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>typeName</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.targetinvocationexception\" data-linktype=\"relative-path\">TargetInvocationException</a></div>\r\n                  </div>\r\n                  <p>A class initializer is invoked and throws an exception.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>typeName</code> represents a generic type that has a pointer type, a <code>ByRef</code> type, or <a class=\"xref\" href=\"system.void\" data-linktype=\"relative-path\">Void</a> as one of its type arguments.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents a generic type that has an incorrect number of type arguments.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.typeloadexception\" data-linktype=\"relative-path\">TypeLoadException</a></div>\r\n                  </div>\r\n                  <p><code>typeName</code> represents an array of <a class=\"xref\" href=\"system.typedreference\" data-linktype=\"relative-path\">TypedReference</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.fileloadexception\" data-linktype=\"relative-path\">FileLoadException</a></div>\r\n                  </div>\r\n                  <div class=\"alert NOTE\"><br> In the <a href=\"http://go.microsoft.com/fwlink/?LinkID=247912\" data-linktype=\"external\">.NET for Windows Store apps</a> or the <a href=\"../Topic/Cross-Platform%20Development%20with%20the%20Portable%20Class%20Library.md\" data-linktype=\"relative-path\">Portable Class Library</a>, catch the base class exception, <a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a>, instead.<br>\n</div>  \n\n<p> The assembly or one of its dependencies was found, but could not be loaded.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.badimageformatexception\" data-linktype=\"relative-path\">BadImageFormatException</a></div>\r\n                  </div>\r\n                  <p>The assembly or one of its dependencies is not valid.  </p>\n<p> -or-  </p>\n<p> Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>You can use the <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> method to obtain a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object for a type in another assembly, if you know its namespace-qualified name. <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> causes loading of the assembly specified in <code>typeName</code>. You can also load an assembly using the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_Load_\" data-linktype=\"relative-path\">Load</a> method, and then use the <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> or <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_GetTypes_\" data-linktype=\"relative-path\">GetTypes</a> methods of the <a class=\"xref\" href=\"system.reflection.assembly\" data-linktype=\"relative-path\">Assembly</a> class to get <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects. If a type is in an assembly known to your program at compile time, it is more efficient to use  in C#, <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> in Visual Basic, or  in C++.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> If <code>typeName</code> cannot be found, the call to the GetType method returns <code>null</code>. It does not throw an exception. To control whether an exception is thrown, call an overload of the GetType method that has a <code>throwOnError</code> parameter.  </p>\n</div>\n<p> GetTypeGetType only works on assemblies loaded from disk. If you call GetType to look up a type defined in a dynamic assembly defined using the <a class=\"xref\" href=\"system.reflection.emit\" data-linktype=\"relative-path\">System.Reflection.Emit</a> services, you might get inconsistent behavior. The behavior depends on whether the dynamic assembly is persistent, that is, created using the <code>RunAndSave</code> or <code>Save</code> access modes of the <a class=\"xref\" href=\"system.reflection.emit.assemblybuilderaccess\" data-linktype=\"relative-path\">System.Reflection.Emit.AssemblyBuilderAccess</a> enumeration. If the dynamic assembly is persistent and has been written to disk before <code>GetType</code> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly. If the assembly has not been saved to disk when <code>GetType</code> is called, the method returns <code>null</code>. <code>GetType</code> does not understand transient dynamic assemblies; therefore, calling <code>GetType</code> to retrieve a type in a transient dynamic assembly returns <code>null</code>.  </p>\n<p> To use <code>GetType</code> on a dynamic module, subscribe to the <a class=\"xref\" href=\"system.appdomain#System_AppDomain_AssemblyResolve\" data-linktype=\"relative-path\">System.AppDomain.AssemblyResolve</a> event and call <code>GetType</code> before saving. Otherwise, you will get two copies of the assembly in memory.  </p>\n<p> The following table shows what members of a base class are returned by the <code>Get</code> methods when reflecting on a type.  </p>\n<table>\n<thead>\n<tr>\n<th>Member Type</th>\n<th>Static</th>\n<th>Non-Static</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Constructor</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Field</td>\n<td>No</td>\n<td>Yes. A field is always hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Event</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n<tr>\n<td>Method</td>\n<td>No</td>\n<td>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Nested Type</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Property</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  </p>\n</li>\n<li><p>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  </p>\n</li>\n<li><p>Custom attributes are not part of the common type system.  </p>\n<p>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.  </p>\n<p><code>typeName</code> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification. See <a class=\"xref\" href=\"system.type#System_Type_AssemblyQualifiedName_\" data-linktype=\"relative-path\">AssemblyQualifiedName</a>.  </p>\n<p>If <code>typeName</code> includes the namespace but not the assembly name, this method searches only the calling object&#39;s assembly and Mscorlib.dll, in that order. If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly. If the assembly has a strong name, a complete assembly name is required.  </p>\n<p>The <a class=\"xref\" href=\"system.type#System_Type_AssemblyQualifiedName_\" data-linktype=\"relative-path\">AssemblyQualifiedName</a> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.  </p>\n</li>\n</ol>\n<div class=\"NOTE\"><h5>Note</h5><p> In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, &quot;ProcessorArchitecture=msil&quot;. However, it is not included in the string returned by the <a class=\"xref\" href=\"system.type#System_Type_AssemblyQualifiedName_\" data-linktype=\"relative-path\">AssemblyQualifiedName</a> property, for compatibility reasons. You can also load types by creating an <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> object and passing it to an appropriate overload of the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_Load_\" data-linktype=\"relative-path\">Load</a> method. You can then use the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_GetType_\" data-linktype=\"relative-path\">GetType</a> method to load types from the assembly. See also <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_ProcessorArchitecture_\" data-linktype=\"relative-path\">ProcessorArchitecture</a>.  </p>\n</div>\n<table>\n<thead>\n<tr>\n<th>Delimiter</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Backslash (\\)</td>\n<td>Escape character.</td>\n</tr>\n<tr>\n<td>Backtick (`)</td>\n<td>Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</td>\n</tr>\n<tr>\n<td>Brackets ([])</td>\n<td>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</td>\n</tr>\n<tr>\n<td>Comma (,)</td>\n<td>Precedes the Assembly name.</td>\n</tr>\n<tr>\n<td>Period (.)</td>\n<td>Denotes namespace identifiers.</td>\n</tr>\n<tr>\n<td>Plus sign (+)</td>\n<td>Precedes a nested class.</td>\n</tr>\n</tbody>\n</table>\n<p> For example, the fully qualified name for a class might look like this:  </p>\n<p><codecontentplaceholder>0</codecontentplaceholder><br> If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows:  </p>\n<p><codecontentplaceholder>1</codecontentplaceholder><br> A &quot;++&quot; becomes &quot;\\+\\+&quot;, and a &quot;\\&quot; becomes &quot;\\\\&quot;.  </p>\n<p> This qualified name can be persisted and later used to load the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>. To search for and load a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, use <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> either with the type name only or with the assembly qualified type name. <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> with the type name only will look for the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> in the caller&#39;s assembly and then in the System assembly. <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> with the assembly qualified type name will look for the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> in any assembly.  </p>\n<p> Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use <code>t.GetElementType().ToString()</code>, where <code>t</code> is the type.  </p>\n<p> Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the &#39;,&#39; separator are relevant, but spaces after the &#39;,&#39; separator are ignored.  </p>\n<p> The name of a generic type ends with a backtick (`) followed by digits representing the number of generic type arguments. The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope. For example, reflection returns the mangled names <code>Tuple</code>1<code>and</code>Tuple<code>2</code> from the generic methods <code>Tuple(Of T)</code> and <code>Tuple(Of T0, T1)</code> in Visual Basic, or <code>Tuple&lt;T&gt;</code> and Tuple<code>&lt;T0, T1&gt;</code> in Visual C#.  </p>\n<p> For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas. For example, a generic <a class=\"xref\" href=\"system.collections.generic.dictionary-2\" data-linktype=\"relative-path\">Dictionary&lt;TKey,TValue&gt;</a> has two type parameters. A <a class=\"xref\" href=\"system.collections.generic.dictionary-2\" data-linktype=\"relative-path\">Dictionary&lt;TKey,TValue&gt;</a> of <code>MyType</code> with keys of type <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a> might be represented as follows:  </p>\n<pre><code>System.Collections.Generic.Dictionary`2[System.String,MyType]\n</code></pre><p> To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets. Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments. For example, a <a class=\"xref\" href=\"system.collections.generic.dictionary-2\" data-linktype=\"relative-path\">Dictionary&lt;TKey,TValue&gt;</a> of <code>MyType</code> fromMyAssembly.dll, with keys of type <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>, might be specified as follows:  </p>\n<p><codecontentplaceholder>3</codecontentplaceholder>  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list. The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.  </p>\n</div>\n<p> Nullable types are a special case of generic types. For example, a nullable <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a> is represented by the string &quot;System.Nullable`1[System.Int32]&quot;.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> In C#, C++, and Visual Basic you can also get nullable types using type operators. For example, the nullable <a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a> type is returned by <code>typeof(Nullable&lt;bool&gt;)</code> in C#, by <code>Nullable&lt;Boolean&gt;::typeid</code> in C++, and by <code>GetType(Nullable(Of Boolean))</code> in Visual Basic.  </p>\n</div>\n<p> The following table shows the syntax you use with <code>GetType</code> for various types.  </p>\n<table>\n<thead>\n<tr>\n<th>To Get</th>\n<th>Use</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A nullable <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></td>\n<td><code>Type.GetType(&quot;System.Nullable</code>1[System.Int32]&quot;)`</td>\n</tr>\n<tr>\n<td>An unmanaged pointer to <code>MyType</code></td>\n<td><code>Type.GetType(&quot;MyType*&quot;)</code></td>\n</tr>\n<tr>\n<td>An unmanaged pointer to a pointer to <code>MyType</code></td>\n<td><code>Type.GetType(&quot;MyType**&quot;)</code></td>\n</tr>\n<tr>\n<td>A managed pointer or reference to <code>MyType</code></td>\n<td><code>Type.GetType(&quot;MyType&amp;&quot;)</code>. Note that unlike pointers, references are limited to one level.</td>\n</tr>\n<tr>\n<td>A parent class and a nested class</td>\n<td><code>Type.GetType(&quot;MyParentClass+MyNestedClass&quot;)</code></td>\n</tr>\n<tr>\n<td>A one-dimensional array with a lower bound of 0</td>\n<td><code>Type.GetType(&quot;MyType[]&quot;)</code></td>\n</tr>\n<tr>\n<td>A one-dimensional array with an unknown lower bound</td>\n<td><code>Type.GetType(&quot;MyType[*]&quot;)</code></td>\n</tr>\n<tr>\n<td>An n-dimensional array</td>\n<td>A comma (,) inside the brackets a total of n-1 times. For example, <code>System.Object[,,]</code> represents a three-dimensional <code>Object</code> array.</td>\n</tr>\n<tr>\n<td>An array of one-dimensional arrays</td>\n<td><code>Type.GetType(&quot;MyType[][]&quot;)</code></td>\n</tr>\n<tr>\n<td>A rectangular two-dimensional array with unknown lower bounds</td>\n<td><code>Type.GetType(&quot;MyType[,]&quot;)</code></td>\n</tr>\n<tr>\n<td>A generic type with one type argument</td>\n<td><code>Type.GetType(&quot;MyGenericType</code>1[MyType]&quot;)`</td>\n</tr>\n<tr>\n<td>A generic type with two type arguments</td>\n<td><code>Type.GetType(&quot;MyGenericType</code>2[MyType,AnotherType]&quot;)`</td>\n</tr>\n<tr>\n<td>A generic type with two assembly-qualified type arguments</td>\n<td><code>Type.GetType(&quot;MyGenericType</code>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]&quot;)`</td>\n</tr>\n<tr>\n<td>An assembly-qualified generic type with an assembly-qualified type argument</td>\n<td><code>Type.GetType(&quot;MyGenericType</code>1[[MyType,MyAssembly]],MyGenericTypeAssembly&quot;)`</td>\n</tr>\n<tr>\n<td>A generic type whose type argument is a generic type with two type arguments</td>\n<td><code>Type.GetType(&quot;MyGenericType</code>1[AnotherGenericType<code>2[MyType,AnotherType]]&quot;)</code></td>\n</tr>\n</tbody>\n</table>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example retrieves the type of <code>System.Int32</code> and uses that type object to display the <a class=\"xref\" href=\"system.type#System_Type_FullName_\" data-linktype=\"relative-path\">FullName</a> property of <code>System.Int32</code>.  </p>\n<pre><code class=\"lang-vb\" name=\"Type_GetType#1\">Class Example\n     Public Shared Sub Main()\n         Try\n             &#39; Get the type of the specified class.\n             Dim myType1 As Type = Type.GetType(&quot;System.Int32&quot;)\n             Console.WriteLine(&quot;The full name is {0}.&quot;, myType1.FullName)\n         Catch e As TypeLoadException\n             Console.WriteLine(&quot;{0}: Unable to load type System.Int32&quot;,\n                               e.GetType().Name)\n         End Try\n\n         Console.WriteLine()\n\n         Try\n             &#39; Since NoneSuch does not exist in this assembly, GetType throws a TypeLoadException.\n             Dim myType2 As Type = Type.GetType(&quot;NoneSuch&quot;, True)\n             Console.WriteLine(&quot;The full name is {0}.&quot;, myType2.FullName)\n         Catch e As TypeLoadException\n             Console.WriteLine(&quot;{0}: Unable to load type NoneSuch&quot;, e.GetType().Name)\n         End Try\n     End Sub\nEnd Class\n&#39; The example displays the following output:\n&#39;       The full name is System.Int32.\n&#39;\n&#39;       TypeLoadException: Unable to load type NoneSuch\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetType#1\">using namespace System;\n\nint main()\n{\n   try {\n      // Get the type of a specified class.\n      Type^ myType1 = Type::GetType( &quot;System.Int32&quot; );\n      Console::WriteLine( &quot;The full name is {0}.<br>&quot;, myType1-&gt;FullName );\n   }\n   catch ( TypeLoadException^ e ) {\n       Console::WriteLine(&quot;{0}: Unable to load type System.Int32&quot;,\n                          e-&gt;GetType()-&gt;Name);\n   }\n\n   try {\n      // Since NoneSuch does not exist in this assembly, GetType throws a TypeLoadException.\n      Type^ myType2 = Type::GetType( &quot;NoneSuch&quot;, true );\n      Console::WriteLine( &quot;The full name is {0}.&quot;, myType2-&gt;FullName );\n   }\n   catch ( TypeLoadException^ e ) {\n       Console::WriteLine(&quot;{0}: Unable to load type NoneSuch&quot;,\n                          e-&gt;GetType()-&gt;Name);\n   }\n\n}\n// The example displays the following output:\n//       The full name is System.Int32.\n//\n//       TypeLoadException: Unable to load type NoneSuch\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_GetType#1\">using System;\n\nclass Example\n{\n     public static void Main()\n     {\n         try {\n             // Get the type of a specified class.\n             Type myType1 = Type.GetType(&quot;System.Int32&quot;);\n             Console.WriteLine(&quot;The full name is {0}.<br>&quot;, myType1.FullName);\n         }\n         catch (TypeLoadException e)\n         {\n            Console.WriteLine(&quot;{0}: Unable to load type System.Int32&quot;, e.GetType().Name);\n         }\n\n         try {\n             // Since NoneSuch does not exist in this assembly, GetType throws a TypeLoadException.\n             Type myType2 = Type.GetType(&quot;NoneSuch&quot;, true);\n             Console.WriteLine(&quot;The full name is {0}.&quot;, myType2.FullName);\n         }\n         catch(TypeLoadException e) {\n            Console.WriteLine(&quot;{0}: Unable to load type NoneSuch&quot;, e.GetType().Name);\n         }\n     }\n}\n// The example displays the following output:\n//       The full name is System.Int32.\n//\n//       TypeLoadException: Unable to load type NoneSuch\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetType_System_String_System_Boolean_\">\r\n    \r\n            <a id=\"System_Type_GetType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetType(String,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Gets the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static Type GetType (string typeName, bool throwOnError);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>typeName</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The assembly-qualified name of the type to get. See <span class=\"xref\">stem.Type.AssemblyQualifiedName*</span>. If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>throwOnError</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to throw an exception if the type cannot be found; <code>false</code> to return <code>null</code>. Specifying <code>false</code> also suppresses some other exception conditions, but not all of them. See the Exceptions section.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>The type with the specified name. If the type is not found, the <code>throwOnError</code> parameter specifies whether <code>null</code> is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <code>throwOnError</code>. See the Exceptions section.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>typeName</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.targetinvocationexception\" data-linktype=\"relative-path\">TargetInvocationException</a></div>\r\n                  </div>\r\n                  <p>A class initializer is invoked and throws an exception.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.typeloadexception\" data-linktype=\"relative-path\">TypeLoadException</a></div>\r\n                  </div>\r\n                  <p><code>throwOnError</code> is <code>true</code> and the type is not found.  </p>\n<p> -or-  </p>\n<p> <code>throwOnError</code> is <code>true</code> and <code>typeName</code> contains invalid characters, such as an embedded tab.  </p>\n<p> -or-  </p>\n<p> <code>throwOnError</code> is <code>true</code> and <code>typeName</code> is an empty string.  </p>\n<p> -or-  </p>\n<p> <code>throwOnError</code> is <code>true</code> and <code>typeName</code> represents an array type with an invalid size.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents an array of <a class=\"xref\" href=\"system.typedreference\" data-linktype=\"relative-path\">TypedReference</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>throwOnError</code> is <code>true</code> and <code>typeName</code> contains invalid syntax. For example, &quot;MyType[,*,]&quot;.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents a generic type that has a pointer type, a <code>ByRef</code> type, or <a class=\"xref\" href=\"system.void\" data-linktype=\"relative-path\">Void</a> as one of its type arguments.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents a generic type that has an incorrect number of type arguments.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.filenotfoundexception\" data-linktype=\"relative-path\">FileNotFoundException</a></div>\r\n                  </div>\r\n                  <p><code>throwOnError</code> is <code>true</code> and the assembly or one of its dependencies was not found.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.fileloadexception\" data-linktype=\"relative-path\">FileLoadException</a></div>\r\n                  </div>\r\n                  <div class=\"alert NOTE\"><br> In the <a href=\"http://go.microsoft.com/fwlink/?LinkID=247912\" data-linktype=\"external\">.NET for Windows Store apps</a> or the <a href=\"../Topic/Cross-Platform%20Development%20with%20the%20Portable%20Class%20Library.md\" data-linktype=\"relative-path\">Portable Class Library</a>, catch the base class exception, <a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a>, instead.<br>\n</div>  \n\n<p> The assembly or one of its dependencies was found, but could not be loaded.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.badimageformatexception\" data-linktype=\"relative-path\">BadImageFormatException</a></div>\r\n                  </div>\r\n                  <p>The assembly or one of its dependencies is not valid.  </p>\n<p> -or-  </p>\n<p> Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>You can use the <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> method to obtain a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object for a type in another assembly, if the you know its namespace-qualified name. <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> causes loading of the assembly specified in <code>typeName</code>. You can also load an assembly using the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_Load_\" data-linktype=\"relative-path\">Load</a> method, and then use the <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> or <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_GetTypes_\" data-linktype=\"relative-path\">GetTypes</a> methods of the <a class=\"xref\" href=\"system.reflection.assembly\" data-linktype=\"relative-path\">Assembly</a> class to get <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects. If a type is in an assembly known to your program at compile time, it is more efficient to use <code>typeof</code> in C#, <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> in Visual Basic, or <code>typeid</code> in C++.  </p>\n<p> <code>GetType</code> only works on assemblies loaded from disk. If you call <code>GetType</code> to look up a type defined in a dynamic assembly defined using the <a class=\"xref\" href=\"system.reflection.emit\" data-linktype=\"relative-path\">System.Reflection.Emit</a> services, you might get inconsistent behavior. The behavior depends on whether the dynamic assembly is persistent, that is, created using the <code>RunAndSave</code> or <code>Save</code> access modes of the <a class=\"xref\" href=\"system.reflection.emit.assemblybuilderaccess\" data-linktype=\"relative-path\">System.Reflection.Emit.AssemblyBuilderAccess</a> enumeration. If the dynamic assembly is persistent and has been written to disk before <code>GetType</code> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly. If the assembly has not been saved to disk when <code>GetType</code> is called, the method returns <code>null</code>. <code>GetType</code> does not understand transient dynamic assemblies; therefore, calling <code>GetType</code> to retrieve a type in a transient dynamic assembly returns <code>null</code>.  </p>\n<p> To use <code>GetType</code> on a dynamic module, subscribe to the <a class=\"xref\" href=\"system.appdomain#System_AppDomain_AssemblyResolve\" data-linktype=\"relative-path\">System.AppDomain.AssemblyResolve</a> event and call <code>GetType</code> before saving. Otherwise, you will get two copies of the assembly in memory.  </p>\n<p> The <code>throwOnError</code> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section. Some exceptions are thrown regardless of the value of <code>throwOnError</code>. For example, if the type is found but cannot be loaded, a <a class=\"xref\" href=\"system.typeloadexception\" data-linktype=\"relative-path\">TypeLoadException</a> is thrown even if <code>throwOnError</code> is <code>false</code>.  </p>\n<p> The following table shows what members of a base class are returned by the <code>Get</code> methods when reflecting on a type.  </p>\n<table>\n<thead>\n<tr>\n<th>Member Type</th>\n<th>Static</th>\n<th>Non-Static</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Constructor</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Field</td>\n<td>No</td>\n<td>Yes. A field is always hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Event</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n<tr>\n<td>Method</td>\n<td>No</td>\n<td>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Nested Type</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Property</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  </p>\n</li>\n<li><p>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  </p>\n</li>\n<li><p>Custom attributes are not part of the common type system.  </p>\n<p>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.  </p>\n<p><code>typeName</code> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification. See <a class=\"xref\" href=\"system.type#System_Type_AssemblyQualifiedName_\" data-linktype=\"relative-path\">AssemblyQualifiedName</a>.  </p>\n<p>If <code>typeName</code> includes the namespace but not the assembly name, this method searches only the calling object&#39;s assembly and Mscorlib.dll, in that order. If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly. If the assembly has a strong name, a complete assembly name is required.  </p>\n<p>The <a class=\"xref\" href=\"system.type#System_Type_AssemblyQualifiedName_\" data-linktype=\"relative-path\">AssemblyQualifiedName</a> property returns a fully qualified type name including nested types, the assembly name, and generic arguments. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.  </p>\n</li>\n</ol>\n<div class=\"NOTE\"><h5>Note</h5><p> In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, &quot;ProcessorArchitecture=msil&quot;. However, it is not included in the string returned by the <a class=\"xref\" href=\"system.type#System_Type_AssemblyQualifiedName_\" data-linktype=\"relative-path\">AssemblyQualifiedName</a> property, for compatibility reasons. You can also load types by creating an <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> object and passing it to an appropriate overload of the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_Load_\" data-linktype=\"relative-path\">Load</a> method. You can then use the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_GetType_\" data-linktype=\"relative-path\">GetType</a> method to load types from the assembly. See also <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_ProcessorArchitecture_\" data-linktype=\"relative-path\">ProcessorArchitecture</a>.  </p>\n</div>\n<table>\n<thead>\n<tr>\n<th>Delimiter</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Backslash (\\)</td>\n<td>Escape character.</td>\n</tr>\n<tr>\n<td>Backtick (`)</td>\n<td>Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</td>\n</tr>\n<tr>\n<td>Brackets ([])</td>\n<td>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</td>\n</tr>\n<tr>\n<td>Comma (,)</td>\n<td>Precedes the Assembly name.</td>\n</tr>\n<tr>\n<td>Period (.)</td>\n<td>Denotes namespace identifiers.</td>\n</tr>\n<tr>\n<td>Plus sign (+)</td>\n<td>Precedes a nested class.</td>\n</tr>\n</tbody>\n</table>\n<p> For example, the fully qualified name for a class might look like this:  </p>\n<p><codecontentplaceholder>0</codecontentplaceholder><br> If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows:  </p>\n<p><codecontentplaceholder>1</codecontentplaceholder><br> A &quot;++&quot; becomes &quot;\\+\\+&quot;, and a &quot;\\&quot; becomes &quot;\\\\&quot;.  </p>\n<p> This qualified name can be persisted and later used to load the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>. To search for and load a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, use <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> either with the type name only or with the assembly qualified type name. <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> with the type name only will look for the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> in the caller&#39;s assembly and then in the System assembly. <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> with the assembly qualified type name will look for the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> in any assembly.  </p>\n<p> Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use <code>t.GetElementType().ToString()</code>, where <code>t</code> is the type.  </p>\n<p> Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the &#39;,&#39; separator are relevant, but spaces after the &#39;,&#39; separator are ignored.  </p>\n<p> The name of a generic type ends with a backtick (`) followed by digits representing the number of generic type arguments. The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope. For example, reflection returns the mangled names <code>Tuple</code>1<code>and</code>Tuple<code>2</code> from the generic methods <code>Tuple(Of T)</code> and <code>Tuple(Of T0, T1)</code> in Visual Basic, or <code>Tuple&lt;T&gt;</code> and Tuple<code>&lt;T0, T1&gt;</code> in Visual C#.  </p>\n<p> For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas. For example, a generic <a class=\"xref\" href=\"system.collections.generic.dictionary-2\" data-linktype=\"relative-path\">Dictionary&lt;TKey,TValue&gt;</a> has two type parameters. A <a class=\"xref\" href=\"system.collections.generic.dictionary-2\" data-linktype=\"relative-path\">Dictionary&lt;TKey,TValue&gt;</a> of <code>MyType</code> with keys of type <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a> might be represented as follows:  </p>\n<pre><code>System.Collections.Generic.Dictionary`2[System.String,MyType]\n</code></pre><p> To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets. Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments. For example, a <a class=\"xref\" href=\"system.collections.generic.dictionary-2\" data-linktype=\"relative-path\">Dictionary&lt;TKey,TValue&gt;</a> of <code>MyType</code> from MyAssembly.dll, with keys of type <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>, might be specified as follows:  </p>\n<p><codecontentplaceholder>3</codecontentplaceholder>  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list. The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.  </p>\n</div>\n<p> Nullable types are a special case of generic types. For example, a nullable <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a> is represented by the string &quot;System.Nullable`1[System.Int32]&quot;.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> In C#, C++, and Visual Basic you can also get nullable types using type operators. For example, the nullable <a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a> type is returned by <code>typeof(Nullable&lt;bool&gt;)</code> in C#, by <code>Nullable&lt;Boolean&gt;::typeid</code> in C++, and by <code>GetType(Nullable(Of Boolean))</code> in Visual Basic.  </p>\n</div>\n<p> The following table shows the syntax you use with <code>GetType</code> for various types.  </p>\n<table>\n<thead>\n<tr>\n<th>To Get</th>\n<th>Use</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A nullable <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></td>\n<td><code>Type.GetType(&quot;System.Nullable</code>1[System.Int32]&quot;)`</td>\n</tr>\n<tr>\n<td>An unmanaged pointer to <code>MyType</code></td>\n<td><code>Type.GetType(&quot;MyType*&quot;)</code></td>\n</tr>\n<tr>\n<td>An unmanaged pointer to a pointer to <code>MyType</code></td>\n<td><code>Type.GetType(&quot;MyType**&quot;)</code></td>\n</tr>\n<tr>\n<td>A managed pointer or reference to <code>MyType</code></td>\n<td><code>Type.GetType(&quot;MyType&amp;&quot;)</code>. Note that unlike pointers, references are limited to one level.</td>\n</tr>\n<tr>\n<td>A parent class and a nested class</td>\n<td><code>Type.GetType(&quot;MyParentClass+MyNestedClass&quot;)</code></td>\n</tr>\n<tr>\n<td>A one-dimensional array with a lower bound of 0</td>\n<td><code>Type.GetType(&quot;MyArray[]&quot;)</code></td>\n</tr>\n<tr>\n<td>A one-dimensional array with an unknown lower bound</td>\n<td><code>Type.GetType(&quot;MyArray[*]&quot;)</code></td>\n</tr>\n<tr>\n<td>An n-dimensional array</td>\n<td>A comma (,) inside the brackets a total of n-1 times. For example, <code>System.Object[,,]</code> represents a three-dimensional <code>Object</code> array.</td>\n</tr>\n<tr>\n<td>A two-dimensional array&#39;s array</td>\n<td><code>Type.GetType(&quot;MyArray[][]&quot;)</code></td>\n</tr>\n<tr>\n<td>A rectangular two-dimensional array with unknown lower bounds</td>\n<td><code>Type.GetType(&quot;MyArray[,]&quot;)</code></td>\n</tr>\n<tr>\n<td>A generic type with one type argument</td>\n<td><code>Type.GetType(&quot;MyGenericType</code>1[MyType]&quot;)`</td>\n</tr>\n<tr>\n<td>A generic type with two type arguments</td>\n<td><code>Type.GetType(&quot;MyGenericType</code>2[MyType,AnotherType]&quot;)`</td>\n</tr>\n<tr>\n<td>A generic type with two assembly-qualified type arguments</td>\n<td><code>Type.GetType(&quot;MyGenericType</code>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]&quot;)`</td>\n</tr>\n<tr>\n<td>An assembly-qualified generic type with an assembly-qualified type argument</td>\n<td><code>Type.GetType(&quot;MyGenericType</code>1[[MyType,MyAssembly]],MyGenericTypeAssembly&quot;)`</td>\n</tr>\n<tr>\n<td>A generic type whose type argument is a generic type with two type arguments</td>\n<td><code>Type.GetType(&quot;MyGenericType</code>1[AnotherGenericType<code>2[MyType,AnotherType]]&quot;)</code></td>\n</tr>\n</tbody>\n</table>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example retrieves the type of <code>System.Int32</code> and uses that type object to display the <a class=\"xref\" href=\"system.type#System_Type_FullName_\" data-linktype=\"relative-path\">FullName</a> property of <code>System.Int32</code>. If a type object refers to an assembly that does not exist, this example throws an exception.  </p>\n<pre><code class=\"lang-vb\" name=\"Type_GetType#1\">Class Example\n     Public Shared Sub Main()\n         Try\n             &#39; Get the type of the specified class.\n             Dim myType1 As Type = Type.GetType(&quot;System.Int32&quot;)\n             Console.WriteLine(&quot;The full name is {0}.&quot;, myType1.FullName)\n         Catch e As TypeLoadException\n             Console.WriteLine(&quot;{0}: Unable to load type System.Int32&quot;,\n                               e.GetType().Name)\n         End Try\n\n         Console.WriteLine()\n\n         Try\n             &#39; Since NoneSuch does not exist in this assembly, GetType throws a TypeLoadException.\n             Dim myType2 As Type = Type.GetType(&quot;NoneSuch&quot;, True)\n             Console.WriteLine(&quot;The full name is {0}.&quot;, myType2.FullName)\n         Catch e As TypeLoadException\n             Console.WriteLine(&quot;{0}: Unable to load type NoneSuch&quot;, e.GetType().Name)\n         End Try\n     End Sub\nEnd Class\n&#39; The example displays the following output:\n&#39;       The full name is System.Int32.\n&#39;\n&#39;       TypeLoadException: Unable to load type NoneSuch\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetType#1\">using namespace System;\n\nint main()\n{\n   try {\n      // Get the type of a specified class.\n      Type^ myType1 = Type::GetType( &quot;System.Int32&quot; );\n      Console::WriteLine( &quot;The full name is {0}.<br>&quot;, myType1-&gt;FullName );\n   }\n   catch ( TypeLoadException^ e ) {\n       Console::WriteLine(&quot;{0}: Unable to load type System.Int32&quot;,\n                          e-&gt;GetType()-&gt;Name);\n   }\n\n   try {\n      // Since NoneSuch does not exist in this assembly, GetType throws a TypeLoadException.\n      Type^ myType2 = Type::GetType( &quot;NoneSuch&quot;, true );\n      Console::WriteLine( &quot;The full name is {0}.&quot;, myType2-&gt;FullName );\n   }\n   catch ( TypeLoadException^ e ) {\n       Console::WriteLine(&quot;{0}: Unable to load type NoneSuch&quot;,\n                          e-&gt;GetType()-&gt;Name);\n   }\n\n}\n// The example displays the following output:\n//       The full name is System.Int32.\n//\n//       TypeLoadException: Unable to load type NoneSuch\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_GetType#1\">using System;\n\nclass Example\n{\n     public static void Main()\n     {\n         try {\n             // Get the type of a specified class.\n             Type myType1 = Type.GetType(&quot;System.Int32&quot;);\n             Console.WriteLine(&quot;The full name is {0}.<br>&quot;, myType1.FullName);\n         }\n         catch (TypeLoadException e)\n         {\n            Console.WriteLine(&quot;{0}: Unable to load type System.Int32&quot;, e.GetType().Name);\n         }\n\n         try {\n             // Since NoneSuch does not exist in this assembly, GetType throws a TypeLoadException.\n             Type myType2 = Type.GetType(&quot;NoneSuch&quot;, true);\n             Console.WriteLine(&quot;The full name is {0}.&quot;, myType2.FullName);\n         }\n         catch(TypeLoadException e) {\n            Console.WriteLine(&quot;{0}: Unable to load type NoneSuch&quot;, e.GetType().Name);\n         }\n     }\n}\n// The example displays the following output:\n//       The full name is System.Int32.\n//\n//       TypeLoadException: Unable to load type NoneSuch\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetType_System_String_System_Boolean_System_Boolean_\">\r\n    \r\n            <a id=\"System_Type_GetType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetType(String,Boolean,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Gets the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>typeName</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The assembly-qualified name of the type to get. See <span class=\"xref\">stem.Type.AssemblyQualifiedName*</span>. If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>throwOnError</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to throw an exception if the type cannot be found; <code>false</code> to return <code>null</code>.Specifying <code>false</code> also suppresses some other exception conditions, but not all of them. See the Exceptions section.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>ignoreCase</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to perform a case-insensitive search for <code>typeName</code>, <code>false</code> to perform a case-sensitive search for <code>typeName</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>The type with the specified name. If the type is not found, the <code>throwOnError</code> parameter specifies whether <code>null</code> is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <code>throwOnError</code>. See the Exceptions section.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>typeName</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.targetinvocationexception\" data-linktype=\"relative-path\">TargetInvocationException</a></div>\r\n                  </div>\r\n                  <p>A class initializer is invoked and throws an exception.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.typeloadexception\" data-linktype=\"relative-path\">TypeLoadException</a></div>\r\n                  </div>\r\n                  <p><code>throwOnError</code> is <code>true</code> and the type is not found.  </p>\n<p> -or-  </p>\n<p> <code>throwOnError</code> is <code>true</code> and <code>typeName</code> contains invalid characters, such as an embedded tab.  </p>\n<p> -or-  </p>\n<p> <code>throwOnError</code> is <code>true</code> and <code>typeName</code> is an empty string.  </p>\n<p> -or-  </p>\n<p> <code>throwOnError</code> is <code>true</code> and <code>typeName</code> represents an array type with an invalid size.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents an array of <a class=\"xref\" href=\"system.typedreference\" data-linktype=\"relative-path\">TypedReference</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>throwOnError</code> is <code>true</code> and <code>typeName</code> contains invalid syntax. For example, &quot;MyType[,*,]&quot;.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents a generic type that has a pointer type, a <code>ByRef</code> type, or <a class=\"xref\" href=\"system.void\" data-linktype=\"relative-path\">Void</a> as one of its type arguments.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents a generic type that has an incorrect number of type arguments.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.filenotfoundexception\" data-linktype=\"relative-path\">FileNotFoundException</a></div>\r\n                  </div>\r\n                  <p><code>throwOnError</code> is <code>true</code> and the assembly or one of its dependencies was not found.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.fileloadexception\" data-linktype=\"relative-path\">FileLoadException</a></div>\r\n                  </div>\r\n                  <p>The assembly or one of its dependencies was found, but could not be loaded.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.badimageformatexception\" data-linktype=\"relative-path\">BadImageFormatException</a></div>\r\n                  </div>\r\n                  <p>The assembly or one of its dependencies is not valid.  </p>\n<p> -or-  </p>\n<p> Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>You can use the <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> method to obtain a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object for a type in another assembly, if the you know its namespace-qualified name. <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> causes loading of the assembly specified in <code>typeName</code>. You can also load an assembly using the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_Load_\" data-linktype=\"relative-path\">Load</a>method, and then use the <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> or <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_GetTypes_\" data-linktype=\"relative-path\">GetTypes</a> methods of the <a class=\"xref\" href=\"system.reflection.assembly\" data-linktype=\"relative-path\">Assembly</a> class to get <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects. If a type is in an assembly known to your program at compile time, it is more efficient to use <code>typeof</code> in C#, <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> in Visual Basic, or <code>typeid</code> in C++.  </p>\n<p> <code>GetType</code> only works on assemblies loaded from disk. If you call <code>GetType</code> to look up a type defined in a dynamic assembly defined using the <a class=\"xref\" href=\"system.reflection.emit\" data-linktype=\"relative-path\">System.Reflection.Emit</a> services, you might get inconsistent behavior. The behavior depends on whether the dynamic assembly is persistent, that is, created using the <code>RunAndSave</code> or <code>Save</code> access modes of the <a class=\"xref\" href=\"system.reflection.emit.assemblybuilderaccess\" data-linktype=\"relative-path\">System.Reflection.Emit.AssemblyBuilderAccess</a> enumeration. If the dynamic assembly is persistent and has been written to disk before <code>GetType</code> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly. If the assembly has not been saved to disk when <code>GetType</code> is called, the method returns <code>null</code>. <code>GetType</code> does not understand transient dynamic assemblies; therefore, calling <code>GetType</code> to retrieve a type in a transient dynamic assembly returns <code>null</code>.  </p>\n<p> To use <code>GetType</code> on a dynamic module, subscribe to the <a class=\"xref\" href=\"system.appdomain#System_AppDomain_AssemblyResolve\" data-linktype=\"relative-path\">System.AppDomain.AssemblyResolve</a> event and call <code>GetType</code> before saving. Otherwise, you will get two copies of the assembly in memory.  </p>\n<p> The <code>throwOnError</code> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section. Some exceptions are thrown regardless of the value of <code>throwOnError</code>. For example, if the type is found but cannot be loaded, a <a class=\"xref\" href=\"system.typeloadexception\" data-linktype=\"relative-path\">TypeLoadException</a> is thrown even if <code>throwOnError</code> is <code>false</code>.  </p>\n<p> The following table shows what members of a base class are returned by the <code>Get</code> methods when reflecting on a type.  </p>\n<table>\n<thead>\n<tr>\n<th>Member Type</th>\n<th>Static</th>\n<th>Non-Static</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Constructor</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Field</td>\n<td>No</td>\n<td>Yes. A field is always hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Event</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n<tr>\n<td>Method</td>\n<td>No</td>\n<td>Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</td>\n</tr>\n<tr>\n<td>Nested Type</td>\n<td>No</td>\n<td>No</td>\n</tr>\n<tr>\n<td>Property</td>\n<td>Not applicable</td>\n<td>The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.</td>\n</tr>\n</tbody>\n</table>\n<ol>\n<li><p>Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  </p>\n</li>\n<li><p>For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  </p>\n</li>\n<li><p>Custom attributes are not part of the common type system.  </p>\n<p>Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.  </p>\n<p><code>typeName</code> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification. See <a class=\"xref\" href=\"system.type#System_Type_AssemblyQualifiedName_\" data-linktype=\"relative-path\">AssemblyQualifiedName</a>.  </p>\n<p>If <code>typeName</code> includes the namespace but not the assembly name, this method searches only the calling object&#39;s assembly and Mscorlib.dll, in that order. If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly. If the assembly has a strong name, a complete assembly name is required.  </p>\n<p>The <a class=\"xref\" href=\"system.type#System_Type_AssemblyQualifiedName_\" data-linktype=\"relative-path\">AssemblyQualifiedName</a> property returns a fully qualified type name including nested types, the assembly name, and type arguments. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.  </p>\n</li>\n</ol>\n<div class=\"NOTE\"><h5>Note</h5><p> In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, &quot;ProcessorArchitecture=msil&quot;. However, it is not included in the string returned by the <a class=\"xref\" href=\"system.type#System_Type_AssemblyQualifiedName_\" data-linktype=\"relative-path\">AssemblyQualifiedName</a> property, for compatibility reasons. You can also load types by creating an <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> object and passing it to an appropriate overload of the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_Load_\" data-linktype=\"relative-path\">Load</a> method. You can then use the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_GetType_\" data-linktype=\"relative-path\">GetType</a> method to load types from the assembly. See also <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_ProcessorArchitecture_\" data-linktype=\"relative-path\">ProcessorArchitecture</a>.  </p>\n</div>\n<table>\n<thead>\n<tr>\n<th>Delimiter</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Backslash (\\)</td>\n<td>Escape character.</td>\n</tr>\n<tr>\n<td>Backtick (`)</td>\n<td>Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</td>\n</tr>\n<tr>\n<td>Brackets ([])</td>\n<td>Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</td>\n</tr>\n<tr>\n<td>Comma (,)</td>\n<td>Precedes the Assembly name.</td>\n</tr>\n<tr>\n<td>Period (.)</td>\n<td>Denotes namespace identifiers.</td>\n</tr>\n<tr>\n<td>Plus sign (+)</td>\n<td>Precedes a nested class.</td>\n</tr>\n</tbody>\n</table>\n<p> For example, the fully qualified name for a class might look like this:  </p>\n<p><codecontentplaceholder>0</codecontentplaceholder><br> If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows:  </p>\n<p><codecontentplaceholder>1</codecontentplaceholder><br> A &quot;++&quot; becomes &quot;\\+\\+&quot;, and a &quot;\\&quot; becomes &quot;\\\\&quot;.  </p>\n<p> This qualified name can be persisted and later used to load the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>. To search for and load a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, use <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> either with the type name only or with the assembly qualified type name. <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> with the type name only will look for the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> in the caller&#39;s assembly and then in the System assembly. <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> with the assembly qualified type name will look for the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> in any assembly.  </p>\n<p> Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use <code>t.GetElementType().ToString()</code>, where <code>t</code> is the type.  </p>\n<p> Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the &#39;,&#39; separator are relevant, but spaces after the &#39;,&#39; separator are ignored.  </p>\n<p> The name of a generic type ends with a backtick (`) followed by digits representing the number of generic type arguments. The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope. For example, reflection returns the mangled names <code>Tuple</code>1<code>and</code>Tuple<code>2</code> from the generic methods <code>Tuple(Of T)</code> and <code>Tuple(Of T0, T1)</code> in Visual Basic, or <code>Tuple&lt;T&gt;</code> and Tuple<code>&lt;T0, T1&gt;</code> in Visual C#.  </p>\n<p> For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas. For example, a generic <a class=\"xref\" href=\"system.collections.generic.dictionary-2\" data-linktype=\"relative-path\">Dictionary&lt;TKey,TValue&gt;</a> has two type parameters. A <a class=\"xref\" href=\"system.collections.generic.dictionary-2\" data-linktype=\"relative-path\">Dictionary&lt;TKey,TValue&gt;</a> of <code>MyType</code> with keys of type <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a> might be represented as follows:  </p>\n<pre><code>System.Collections.Generic.Dictionary`2[System.String,MyType]\n</code></pre><p> To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets. Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments. For example, a <a class=\"xref\" href=\"system.collections.generic.dictionary-2\" data-linktype=\"relative-path\">Dictionary&lt;TKey,TValue&gt;</a> of <code>MyType</code> from MyAssembly.dll, with keys of type <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>, might be specified as follows:  </p>\n<p><codecontentplaceholder>3</codecontentplaceholder>  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list. The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.  </p>\n</div>\n<p> Nullable types are a special case of generic types. For example, a nullable <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a> is represented by the string &quot;System.Nullable`1[System.Int32]&quot;.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> In C#, C++, and Visual Basic you can also get nullable types using type operators. For example, the nullable <a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a> type is returned by <code>typeof(Nullable&lt;bool&gt;)</code> in C#, by <code>Nullable&lt;Boolean&gt;::typeid</code> in C++, and by <code>GetType(Nullable(Of Boolean))</code> in Visual Basic.  </p>\n</div>\n<p> The following table shows the syntax you use with <code>GetType</code> for various types.  </p>\n<table>\n<thead>\n<tr>\n<th>To Get</th>\n<th>Use</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>A nullable <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></td>\n<td><code>Type.GetType(&quot;System.Nullable</code>1[System.Int32]&quot;)`</td>\n</tr>\n<tr>\n<td>An unmanaged pointer to <code>MyType</code></td>\n<td><code>Type.GetType(&quot;MyType*&quot;)</code></td>\n</tr>\n<tr>\n<td>An unmanaged pointer to a pointer to <code>MyType</code></td>\n<td><code>Type.GetType(&quot;MyType**&quot;)</code></td>\n</tr>\n<tr>\n<td>A managed pointer or reference to <code>MyType</code></td>\n<td><code>Type.GetType(&quot;MyType&amp;&quot;)</code>. Note that unlike pointers, references are limited to one level.</td>\n</tr>\n<tr>\n<td>A parent class and a nested class</td>\n<td><code>Type.GetType(&quot;MyParentClass+MyNestedClass&quot;)</code></td>\n</tr>\n<tr>\n<td>A one-dimensional array with a lower bound of 0</td>\n<td><code>Type.GetType(&quot;MyArray[]&quot;)</code></td>\n</tr>\n<tr>\n<td>A one-dimensional array with an unknown lower bound</td>\n<td><code>Type.GetType(&quot;MyArray[*]&quot;)</code></td>\n</tr>\n<tr>\n<td>An n-dimensional array</td>\n<td>A comma (,) inside the brackets a total of n-1 times. For example, <code>System.Object[,,]</code> represents a three-dimensional <code>Object</code> array.</td>\n</tr>\n<tr>\n<td>A two-dimensional array&#39;s array</td>\n<td><code>Type.GetType(&quot;MyArray[][]&quot;)</code></td>\n</tr>\n<tr>\n<td>A rectangular two-dimensional array with unknown lower bounds</td>\n<td><code>Type.GetType(&quot;MyArray[,]&quot;)</code></td>\n</tr>\n<tr>\n<td>A generic type with one type argument</td>\n<td><code>Type.GetType(&quot;MyGenericType</code>1[MyType]&quot;)`</td>\n</tr>\n<tr>\n<td>A generic type with two type arguments</td>\n<td><code>Type.GetType(&quot;MyGenericType</code>2[MyType,AnotherType]&quot;)`</td>\n</tr>\n<tr>\n<td>A generic type with two assembly-qualified type arguments</td>\n<td><code>Type.GetType(&quot;MyGenericType</code>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]&quot;)`</td>\n</tr>\n<tr>\n<td>An assembly-qualified generic type with an assembly-qualified type argument</td>\n<td><code>Type.GetType(&quot;MyGenericType</code>1[[MyType,MyAssembly]],MyGenericTypeAssembly&quot;)`</td>\n</tr>\n<tr>\n<td>A generic type whose type argument is a generic type with two type arguments</td>\n<td><code>Type.GetType(&quot;MyGenericType</code>1[AnotherGenericType<code>2[MyType,AnotherType]]&quot;)</code></td>\n</tr>\n</tbody>\n</table>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetType_System_String_System_Func_System_Reflection_AssemblyName_System_Reflection_Assembly__System_Func_System_Reflection_Assembly_System_String_System_Boolean_System_Type__\">\r\n    \r\n            <a id=\"System_Type_GetType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetType(String,Func&lt;AssemblyName,Assembly&gt;,Func&lt;Assembly,String,Boolean,Type&gt;)</div>        \r\n          </div>\r\n    \r\n            <p>Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>typeName</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of the type to get. If the <code>typeResolver</code> parameter is provided, the type name can be any string that <code>typeResolver</code> is capable of resolving. If the <code>assemblyResolver</code> parameter is provided or if standard type resolution is used, <code>typeName</code> must be an assembly-qualified name (see <span class=\"xref\">stem.Type.AssemblyQualifiedName*</span>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>assemblyResolver</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.func-2\" data-linktype=\"relative-path\">Func</a>&lt;<a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a>,<a class=\"xref\" href=\"system.reflection.assembly\" data-linktype=\"relative-path\">Assembly</a>&gt;</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A method that locates and returns the assembly that is specified in <code>typeName</code>. The assembly name is passed to <code>assemblyResolver</code> as an <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> object. If <code>typeName</code> does not contain the name of an assembly, <code>assemblyResolver</code> is not called. If <code>assemblyResolver</code> is not supplied, standard assembly resolution is performed.  </p>\n<p> Caution   Do not pass methods from unknown or untrusted callers. Doing so could result in elevation of privilege for malicious code. Use only methods that you provide or that you are familiar with.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>typeResolver</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.func-4\" data-linktype=\"relative-path\">Func</a>&lt;<a class=\"xref\" href=\"system.reflection.assembly\" data-linktype=\"relative-path\">Assembly</a>,<a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>,<a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a>,<a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>&gt;</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A method that locates and returns the type that is specified by <code>typeName</code> from the assembly that is returned by <code>assemblyResolver</code> or by standard assembly resolution. If no assembly is provided, the <code>typeResolver</code> method can provide one. The method also takes a parameter that specifies whether to perform a case-insensitive search; <code>false</code> is passed to that parameter.  </p>\n<p> Caution   Do not pass methods from unknown or untrusted callers.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>The type with the specified name, or <code>null</code> if the type is not found.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>typeName</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.targetinvocationexception\" data-linktype=\"relative-path\">TargetInvocationException</a></div>\r\n                  </div>\r\n                  <p>A class initializer is invoked and throws an exception.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p>An error occurs when <code>typeName</code> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents a generic type that has a pointer type, a <code>ByRef</code> type, or <a class=\"xref\" href=\"system.void\" data-linktype=\"relative-path\">Void</a> as one of its type arguments.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents a generic type that has an incorrect number of type arguments.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.typeloadexception\" data-linktype=\"relative-path\">TypeLoadException</a></div>\r\n                  </div>\r\n                  <p><code>typeName</code> represents an array of <a class=\"xref\" href=\"system.typedreference\" data-linktype=\"relative-path\">TypedReference</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.fileloadexception\" data-linktype=\"relative-path\">FileLoadException</a></div>\r\n                  </div>\r\n                  <p>The assembly or one of its dependencies was found, but could not be loaded.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> contains an invalid assembly name.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> is a valid assembly name without a type name.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.badimageformatexception\" data-linktype=\"relative-path\">BadImageFormatException</a></div>\r\n                  </div>\r\n                  <p>The assembly or one of its dependencies is not valid.  </p>\n<p> -or-  </p>\n<p> The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Usage scenarios for this method and details about the <code>assemblyResolver</code> and <code>typeResolver</code> parameters can be found in the <a class=\"xref\" href=\"system.type#System_Type_GetType_System_String_System_Func_System_Reflection_AssemblyName_System_Reflection_Assembly__System_Func_System_Reflection_Assembly_System_String_System_Boolean_System_Type__System_Boolean_System_Boolean_\" data-linktype=\"relative-path\">GetType(String,Func&lt;AssemblyName,Assembly&gt;,Func&lt;Assembly,String,Boolean,Type&gt;,Boolean,Boolean)</a> method overload.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> If <code>typeName</code> cannot be found, the call to the GetType method returns <code>null</code>. It does not throw an exception. To control whether an exception is thrown, call an overload of the <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> method that has a <code>throwOnError</code> parameter.  </p>\n</div>\n<p> Calling this method overload is the same as calling the <a class=\"xref\" href=\"system.type#System_Type_GetType_System_String_System_Func_System_Reflection_AssemblyName_System_Reflection_Assembly__System_Func_System_Reflection_Assembly_System_String_System_Boolean_System_Type__System_Boolean_System_Boolean_\" data-linktype=\"relative-path\">GetType(String,Func&lt;AssemblyName,Assembly&gt;,Func&lt;Assembly,String,Boolean,Type&gt;,Boolean,Boolean)</a> method overload and specifying <code>false</code> for the <code>throwOnError</code> and <code>ignoreCase</code> parameters.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetType_System_String_System_Func_System_Reflection_AssemblyName_System_Reflection_Assembly__System_Func_System_Reflection_Assembly_System_String_System_Boolean_System_Type__System_Boolean_\">\r\n    \r\n            <a id=\"System_Type_GetType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetType(String,Func&lt;AssemblyName,Assembly&gt;,Func&lt;Assembly,String,Boolean,Type&gt;,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>typeName</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of the type to get. If the <code>typeResolver</code> parameter is provided, the type name can be any string that <code>typeResolver</code> is capable of resolving. If the <code>assemblyResolver</code> parameter is provided or if standard type resolution is used, <code>typeName</code> must be an assembly-qualified name (see <span class=\"xref\">stem.Type.AssemblyQualifiedName*</span>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>assemblyResolver</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.func-2\" data-linktype=\"relative-path\">Func</a>&lt;<a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a>,<a class=\"xref\" href=\"system.reflection.assembly\" data-linktype=\"relative-path\">Assembly</a>&gt;</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A method that locates and returns the assembly that is specified in <code>typeName</code>. The assembly name is passed to <code>assemblyResolver</code> as an <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> object. If <code>typeName</code> does not contain the name of an assembly, <code>assemblyResolver</code> is not called. If <code>assemblyResolver</code> is not supplied, standard assembly resolution is performed.  </p>\n<p> Caution   Do not pass methods from unknown or untrusted callers. Doing so could result in elevation of privilege for malicious code. Use only methods that you provide or that you are familiar with.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>typeResolver</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.func-4\" data-linktype=\"relative-path\">Func</a>&lt;<a class=\"xref\" href=\"system.reflection.assembly\" data-linktype=\"relative-path\">Assembly</a>,<a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>,<a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a>,<a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>&gt;</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A method that locates and returns the type that is specified by <code>typeName</code> from the assembly that is returned by <code>assemblyResolver</code> or by standard assembly resolution. If no assembly is provided, the method can provide one. The method also takes a parameter that specifies whether to perform a case-insensitive search; <code>false</code> is passed to that parameter.  </p>\n<p> Caution   Do not pass methods from unknown or untrusted callers.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>throwOnError</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to throw an exception if the type cannot be found; <code>false</code> to return <code>null</code>. Specifying <code>false</code> also suppresses some other exception conditions, but not all of them. See the Exceptions section.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>The type with the specified name. If the type is not found, the <code>throwOnError</code> parameter specifies whether <code>null</code> is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <code>throwOnError</code>. See the Exceptions section.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>typeName</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.targetinvocationexception\" data-linktype=\"relative-path\">TargetInvocationException</a></div>\r\n                  </div>\r\n                  <p>A class initializer is invoked and throws an exception.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.typeloadexception\" data-linktype=\"relative-path\">TypeLoadException</a></div>\r\n                  </div>\r\n                  <p><code>throwOnError</code> is <code>true</code> and the type is not found.  </p>\n<p> -or-  </p>\n<p> <code>throwOnError</code> is <code>true</code> and <code>typeName</code> contains invalid characters, such as an embedded tab.  </p>\n<p> -or-  </p>\n<p> <code>throwOnError</code> is <code>true</code> and <code>typeName</code> is an empty string.  </p>\n<p> -or-  </p>\n<p> <code>throwOnError</code> is <code>true</code> and <code>typeName</code> represents an array type with an invalid size.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents an array of <a class=\"xref\" href=\"system.typedreference\" data-linktype=\"relative-path\">TypedReference</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p>An error occurs when <code>typeName</code> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).  </p>\n<p> -or-  </p>\n<p> <code>throwOnError</code> is <code>true</code> and <code>typeName</code> contains invalid syntax (for example, &quot;MyType[,*,]&quot;).  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents a generic type that has a pointer type, a <code>ByRef</code> type, or <a class=\"xref\" href=\"system.void\" data-linktype=\"relative-path\">Void</a> as one of its type arguments.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents a generic type that has an incorrect number of type arguments.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.filenotfoundexception\" data-linktype=\"relative-path\">FileNotFoundException</a></div>\r\n                  </div>\r\n                  <p><code>throwOnError</code> is <code>true</code> and the assembly or one of its dependencies was not found.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> contains an invalid assembly name.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> is a valid assembly name without a type name.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.fileloadexception\" data-linktype=\"relative-path\">FileLoadException</a></div>\r\n                  </div>\r\n                  <p>The assembly or one of its dependencies was found, but could not be loaded.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.badimageformatexception\" data-linktype=\"relative-path\">BadImageFormatException</a></div>\r\n                  </div>\r\n                  <p>The assembly or one of its dependencies is not valid.  </p>\n<p> -or-  </p>\n<p> The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Usage scenarios for this method and details about the <code>assemblyResolver</code> and <code>typeResolver</code> parameters can be found in the <a class=\"xref\" href=\"system.type#System_Type_GetType_System_String_System_Func_System_Reflection_AssemblyName_System_Reflection_Assembly__System_Func_System_Reflection_Assembly_System_String_System_Boolean_System_Type__System_Boolean_System_Boolean_\" data-linktype=\"relative-path\">GetType(String,Func&lt;AssemblyName,Assembly&gt;,Func&lt;Assembly,String,Boolean,Type&gt;,Boolean,Boolean)</a> method overload.  </p>\n<p> Calling this method overload is the same as calling the <a class=\"xref\" href=\"system.type#System_Type_GetType_System_String_System_Func_System_Reflection_AssemblyName_System_Reflection_Assembly__System_Func_System_Reflection_Assembly_System_String_System_Boolean_System_Type__System_Boolean_System_Boolean_\" data-linktype=\"relative-path\">GetType(String,Func&lt;AssemblyName,Assembly&gt;,Func&lt;Assembly,String,Boolean,Type&gt;,Boolean,Boolean)</a> method overload and specifying <code>false</code> for the <code>ignoreCase</code> parameter.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetType_System_String_System_Func_System_Reflection_AssemblyName_System_Reflection_Assembly__System_Func_System_Reflection_Assembly_System_String_System_Boolean_System_Type__System_Boolean_System_Boolean_\">\r\n    \r\n            <a id=\"System_Type_GetType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetType(String,Func&lt;AssemblyName,Assembly&gt;,Func&lt;Assembly,String,Boolean,Type&gt;,Boolean,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>typeName</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of the type to get. If the <code>typeResolver</code> parameter is provided, the type name can be any string that <code>typeResolver</code> is capable of resolving. If the <code>assemblyResolver</code> parameter is provided or if standard type resolution is used, <code>typeName</code> must be an assembly-qualified name (see <span class=\"xref\">stem.Type.AssemblyQualifiedName*</span>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>assemblyResolver</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.func-2\" data-linktype=\"relative-path\">Func</a>&lt;<a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a>,<a class=\"xref\" href=\"system.reflection.assembly\" data-linktype=\"relative-path\">Assembly</a>&gt;</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A method that locates and returns the assembly that is specified in <code>typeName</code>. The assembly name is passed to <code>assemblyResolver</code> as an <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> object. If <code>typeName</code> does not contain the name of an assembly, <code>assemblyResolver</code> is not called. If <code>assemblyResolver</code> is not supplied, standard assembly resolution is performed.  </p>\n<p> Caution   Do not pass methods from unknown or untrusted callers. Doing so could result in elevation of privilege for malicious code. Use only methods that you provide or that you are familiar with.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>typeResolver</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.func-4\" data-linktype=\"relative-path\">Func</a>&lt;<a class=\"xref\" href=\"system.reflection.assembly\" data-linktype=\"relative-path\">Assembly</a>,<a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>,<a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a>,<a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>&gt;</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A method that locates and returns the type that is specified by <code>typeName</code> from the assembly that is returned by <code>assemblyResolver</code> or by standard assembly resolution. If no assembly is provided, the method can provide one. The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <code>ignoreCase</code> is passed to that parameter.  </p>\n<p> Caution   Do not pass methods from unknown or untrusted callers.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>throwOnError</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to throw an exception if the type cannot be found; <code>false</code> to return <code>null</code>. Specifying <code>false</code> also suppresses some other exception conditions, but not all of them. See the Exceptions section.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>ignoreCase</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to perform a case-insensitive search for <code>typeName</code>, <code>false</code> to perform a case-sensitive search for <code>typeName</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>The type with the specified name. If the type is not found, the <code>throwOnError</code> parameter specifies whether <code>null</code> is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <code>throwOnError</code>. See the Exceptions section.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>typeName</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.targetinvocationexception\" data-linktype=\"relative-path\">TargetInvocationException</a></div>\r\n                  </div>\r\n                  <p>A class initializer is invoked and throws an exception.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.typeloadexception\" data-linktype=\"relative-path\">TypeLoadException</a></div>\r\n                  </div>\r\n                  <p><code>throwOnError</code> is <code>true</code> and the type is not found.  </p>\n<p> -or-  </p>\n<p> <code>throwOnError</code> is <code>true</code> and <code>typeName</code> contains invalid characters, such as an embedded tab.  </p>\n<p> -or-  </p>\n<p> <code>throwOnError</code> is <code>true</code> and <code>typeName</code> is an empty string.  </p>\n<p> -or-  </p>\n<p> <code>throwOnError</code> is <code>true</code> and <code>typeName</code> represents an array type with an invalid size.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents an array of <a class=\"xref\" href=\"system.typedreference\" data-linktype=\"relative-path\">TypedReference</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p>An error occurs when <code>typeName</code> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).  </p>\n<p> -or-  </p>\n<p> <code>throwOnError</code> is <code>true</code> and <code>typeName</code> contains invalid syntax (for example, &quot;MyType[,*,]&quot;).  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents a generic type that has a pointer type, a <code>ByRef</code> type, or <a class=\"xref\" href=\"system.void\" data-linktype=\"relative-path\">Void</a> as one of its type arguments.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents a generic type that has an incorrect number of type arguments.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.filenotfoundexception\" data-linktype=\"relative-path\">FileNotFoundException</a></div>\r\n                  </div>\r\n                  <p><code>throwOnError</code> is <code>true</code> and the assembly or one of its dependencies was not found.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.fileloadexception\" data-linktype=\"relative-path\">FileLoadException</a></div>\r\n                  </div>\r\n                  <p>The assembly or one of its dependencies was found, but could not be loaded.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> contains an invalid assembly name.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> is a valid assembly name without a type name.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.badimageformatexception\" data-linktype=\"relative-path\">BadImageFormatException</a></div>\r\n                  </div>\r\n                  <p>The assembly or one of its dependencies is not valid.  </p>\n<p> -or-  </p>\n<p> The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Use this method overload and its associated overloads (<a class=\"xref\" href=\"system.type#System_Type_GetType_System_String_System_Func_System_Reflection_AssemblyName_System_Reflection_Assembly__System_Func_System_Reflection_Assembly_System_String_System_Boolean_System_Type__\" data-linktype=\"relative-path\">GetType(String,Func&lt;AssemblyName,Assembly&gt;,Func&lt;Assembly,String,Boolean,Type&gt;)</a> and <a class=\"xref\" href=\"system.type#System_Type_GetType_System_String_System_Func_System_Reflection_AssemblyName_System_Reflection_Assembly__System_Func_System_Reflection_Assembly_System_String_System_Boolean_System_Type__System_Boolean_\" data-linktype=\"relative-path\">GetType(String,Func&lt;AssemblyName,Assembly&gt;,Func&lt;Assembly,String,Boolean,Type&gt;,Boolean)</a>) to replace the default implementation of the <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> method with more flexible implementations. By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:  </p>\n<ul>\n<li><p>Control which version of an assembly a type is loaded from.  </p>\n</li>\n<li><p>Provide another place to look for a type name that does not include an assembly name.  </p>\n</li>\n<li><p>Load assemblies using partial assembly names.  </p>\n</li>\n<li><p>Return subclasses of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">System.Type</a> that are not created by the common language runtime (CLR).  </p>\n<p>For example, in version-tolerant serialization this method enables you to search for a &quot;best fit&quot; assembly by using a partial name. Other overloads of the <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> method require an assembly-qualified type name, which includes the version number.  </p>\n<p>Alternate implementations of the type system may need to return subclasses of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">System.Type</a> that are not created by the CLR; all types that are returned by other overloads of the <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> method are runtime types.  </p>\n</li>\n</ul>\n<p><a name=\"usage_notes\"></a>   </p>\n<h2 id=\"usage-notes\">Usage Notes</h2>\n<p> This method overload and its associated overloads parse <code>typeName</code> into the name of a type and the name of an assembly, and then resolve the names. Resolution of the assembly name occurs before resolution of the type name, because a type name must be resolved in the context of an assembly.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> If you are unfamiliar with the concept of assembly-qualified type names, see the <a class=\"xref\" href=\"system.type#System_Type_AssemblyQualifiedName_\" data-linktype=\"relative-path\">AssemblyQualifiedName</a> property.  </p>\n</div>\n<p> If <code>typeName</code> is not an assembly-qualified name, assembly resolution is skipped. Unqualified type names can be resolved in the context of Mscorlib.dll or the currently executing assembly, or you can optionally provide an assembly in the <code>typeResolver</code> parameter. The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the <a href=\"#mixed_name_resolution\" data-linktype=\"self-bookmark\">Mixed Name Resolution</a> section.  </p>\n<p> General usage notes:  </p>\n<ul>\n<li><p>Do not pass methods to <code>assemblyResolver</code> or <code>typeResolver</code> if they come from unknown or untrusted callers. Use only methods that you provide or that you are familiar with.  </p>\n<div class=\"CAUTION\"><h5>Caution</h5><p> Using methods from unknown or untrusted callers could result in elevation of privilege for malicious code.  </p>\n</div>\n</li>\n<li><p>If you omit the <code>assemblyResolver</code> and/or <code>typeResolver</code> parameters, the value of the <code>throwOnError</code> parameter is passed to the methods that perform the default resolution.  </p>\n</li>\n<li><p>If <code>throwOnError</code> is <code>true</code>, this method throws a <a class=\"xref\" href=\"system.typeloadexception\" data-linktype=\"relative-path\">TypeLoadException</a> when <code>typeResolver</code> returns <code>null</code>, and a <a class=\"xref\" href=\"system.io.filenotfoundexception\" data-linktype=\"relative-path\">FileNotFoundException</a> when <code>assemblyResolver</code> returns <code>null</code>.  </p>\n</li>\n<li><p>This method does not catch exceptions thrown by <code>assemblyResolver</code> and <code>typeResolver</code>. You are responsible for any exceptions that are thrown by the resolver methods.  </p>\n</li>\n</ul>\n<p><a name=\"resolving_assemblies\"></a>   </p>\n<h3 id=\"resolving-assemblies\">Resolving Assemblies</h3>\n<p> The <code>assemblyResolver</code> method receives an <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> object, which is produced by parsing the string assembly name that is included in <code>typeName</code>. If <code>typeName</code> does not contain an assembly name, <code>assemblyResolver</code> is not called and <code>null</code> is passed to <code>typeResolver</code>.  </p>\n<p> If <code>assemblyResolver</code> is not supplied, standard assembly probing is used to locate the assembly. If <code>assemblyResolver</code> is provided, the <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> method does not do standard probing; in that case you must ensure that your <code>assemblyResolver</code> can handle all the assemblies you pass to it.  </p>\n<p> The <code>assemblyResolver</code> method should return <code>null</code> if the assembly cannot be resolved. If <code>assemblyResolver</code> returns <code>null</code>, <code>typeResolver</code> is not called and no further processing occurs; additionally, if <code>throwOnError</code> is <code>true</code>, a <a class=\"xref\" href=\"system.io.filenotfoundexception\" data-linktype=\"relative-path\">FileNotFoundException</a> is thrown.  </p>\n<p> If the <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> that is passed to <code>assemblyResolver</code> is a partial name, one or more of its parts are <code>null</code>. For example, if it has no version, the <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_Version_\" data-linktype=\"relative-path\">Version</a> property is <code>null</code>. If the <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_Version_\" data-linktype=\"relative-path\">Version</a> property, the <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_CultureInfo_\" data-linktype=\"relative-path\">CultureInfo</a> property, and the <a class=\"xref\" href=\"system.reflection.assemblyname#System_Reflection_AssemblyName_GetPublicKeyToken_\" data-linktype=\"relative-path\">GetPublicKeyToken</a> method all return <code>null</code>, then only the simple name of the assembly was supplied. The <code>assemblyResolver</code> method can use or ignore all parts of the assembly name.  </p>\n<p> The effects of different assembly resolution options are displayed as a table in the <a href=\"#mixed_name_resolution\" data-linktype=\"self-bookmark\">Mixed Name Resolution</a> section, for simple and assembly-qualified type names.  </p>\n<p><a name=\"resolving_types\"></a>   </p>\n<h3 id=\"resolving-types\">Resolving Types</h3>\n<p> If <code>typeName</code> does not specify an assembly name, <code>typeResolver</code> is always called. If <code>typeName</code> specifies an assembly name, <code>typeResolver</code> is called only when the assembly name is successfully resolved. If <code>assemblyResolver</code> or standard assembly probing returns <code>null</code>, <code>typeResolver</code> is not called.  </p>\n<p> The <code>typeResolver</code> method receives three arguments:  </p>\n<ul>\n<li><p>The assembly to search or <code>null</code> if <code>typeName</code> does not contain an assembly name.  </p>\n</li>\n<li><p>The simple name of the type. In the case of a nested type, this is the outermost containing type. In the case of a generic type, this is the simple name of the generic type.  </p>\n</li>\n<li><p>A Boolean value that is <code>true</code> if the case of type names is to be ignored.  </p>\n<p>The implementation determines the way these arguments are used. The <code>typeResolver</code> method should return <code>null</code> if it cannot resolve the type. If <code>typeResolver</code> returns <code>null</code> and <code>throwOnError</code> is <code>true</code>, this overload of <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> throws a <a class=\"xref\" href=\"system.typeloadexception\" data-linktype=\"relative-path\">TypeLoadException</a>.  </p>\n<p>The effects of different type resolution options are displayed as a table in the <a href=\"#mixed_name_resolution\" data-linktype=\"self-bookmark\">Mixed Name Resolution</a> section, for simple and assembly-qualified type names.  </p>\n</li>\n</ul>\n<h4 id=\"resolving-nested-types\">Resolving Nested Types</h4>\n<p> If <code>typeName</code> is a nested type, only the name of the outermost containing type is passed to <code>typeResolver</code>. When <code>typeResolver</code> returns this type, the <a class=\"xref\" href=\"system.type#System_Type_GetNestedType_\" data-linktype=\"relative-path\">GetNestedType</a> method is called recursively until the innermost nested type has been resolved.  </p>\n<h4 id=\"resolving-generic-types\">Resolving Generic Types</h4>\n<p> The <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments. If a type argument is generic, <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> is called recursively to resolve its type arguments, and so on.  </p>\n<p> The combination of <code>assemblyResolver</code> and <code>typeResolver</code> that you provide must be capable of resolving all levels of this recursion. For example, suppose you supply an <code>assemblyResolver</code> that controls the loading of <code>MyAssembly</code>. Suppose you want to resolve the generic type <code>Dictionary&lt;string, MyType&gt;</code> (<code>Dictionary(Of String, MyType)</code> in Visual Basic). You might pass the following generic type name:  </p>\n<pre><code>&quot;System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]&quot;\n</code></pre><p> Notice that <code>MyType</code> is the only assembly-qualified type argument. The names of the <a class=\"xref\" href=\"system.collections.generic.dictionary-2\" data-linktype=\"relative-path\">Dictionary&lt;TKey,TValue&gt;</a> and <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a> classes are not assembly-qualified. Your <code>typeResolver</code> must be able handle either an assembly or <code>null</code>, because it will receive <code>null</code> for <a class=\"xref\" href=\"system.collections.generic.dictionary-2\" data-linktype=\"relative-path\">Dictionary&lt;TKey,TValue&gt;</a> and <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>. It can handle that case by calling an overload of the <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> method that takes a string, because both of the unqualified type names are in Mscorlib.dll:  </p>\n<pre><code class=\"lang-cs\" name=\"GetTypeOnSteroids#1\">        Type t = Type.GetType(test,\n                              (aName) =&gt; aName.Name == &quot;MyAssembly&quot; ? \n                                  Assembly.LoadFrom(@&quot;.\\MyPath\\v5.0\\MyAssembly.dll&quot;) : null,\n                              (assem, name, ignore) =&gt; assem == null ? \n                                  Type.GetType(name, false, ignore) : \n                                      assem.GetType(name, false, ignore)\n                             ); \n</code></pre><p> The <code>assemblyResolver</code> method is not called for the dictionary type and the string type, because those type names are not assembly-qualified.  </p>\n<p> Now suppose that instead of <code>System.String</code>, the first generic argument type is <code>YourType</code>, from <code>YourAssembly</code>:  </p>\n<pre><code>&quot;System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]&quot;\n</code></pre><p> Because this assembly is neither Mscorlib.dll nor the currently executing assembly, you cannot resolve <code>YourType</code> without an assembly-qualified name. Because your <code>assemblyResolve</code> will be called recursively, it must be able to handle this case. Instead of returning <code>null</code> for assemblies other than <code>MyAssembly</code>, it now performs an assembly load using the supplied <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> object.  </p>\n<pre><code class=\"lang-cs\" name=\"GetTypeOnSteroids#2\">        Type t2 = Type.GetType(test,\n                               (aName) =&gt; aName.Name == &quot;MyAssembly&quot; ? \n                                   Assembly.LoadFrom(@&quot;.\\MyPath\\v5.0\\MyAssembly.dll&quot;) : \n                                   Assembly.Load(aName),\n                               (assem, name, ignore) =&gt; assem == null ? \n                                   Type.GetType(name, false, ignore) : \n                                       assem.GetType(name, false, ignore), true\n                              ); \n</code></pre><p> Back to <a href=\"#usage_notes\" data-linktype=\"self-bookmark\">Usage Notes</a>.  </p>\n<h4 id=\"resolving-type-names-with-special-characters\">Resolving Type Names with Special Characters</h4>\n<p> Certain characters have special meanings in assembly-qualified names. If a simple type name contains these characters, the characters cause parsing errors when the simple name is part of an assembly-qualified name. To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> method. For example, if a type is named <code>Strange]Type</code>, the escape character must be added ahead of the square bracket as follows: <code>Strange\\]Type</code>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Names with such special characters cannot be created in Visual Basic or C#, but can be created by using Microsoft intermediate language (MSIL) or by emitting dynamic assemblies.  </p>\n</div>\n<p> The following table shows the special characters for type names.  </p>\n<table>\n<thead>\n<tr>\n<th>Character</th>\n<th>Meaning</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>, (comma)</td>\n<td>Delimiter for assembly-qualified names.</td>\n</tr>\n<tr>\n<td><a href=\"square brackets\" data-linktype=\"relative-path\"></a></td>\n<td>As a suffix pair, indicates an array type; as a delimiter pair, encloses generic argument lists and assembly-qualified names.</td>\n</tr>\n<tr>\n<td>&amp; (ampersand)</td>\n<td>As a suffix, indicates that a type is a reference type.</td>\n</tr>\n<tr>\n<td>* (asterisk)</td>\n<td>As a suffix, indicates that a type is a pointer type.</td>\n</tr>\n<tr>\n<td>+ (plus)</td>\n<td>Delimiter for nested types.</td>\n</tr>\n<tr>\n<td>\\ (backslash)</td>\n<td>Escape character.</td>\n</tr>\n</tbody>\n</table>\n<p> Properties such as <a class=\"xref\" href=\"system.type#System_Type_AssemblyQualifiedName_\" data-linktype=\"relative-path\">AssemblyQualifiedName</a> return correctly escaped strings. You must pass correctly escaped strings to the <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> method. In turn, the <a class=\"xref\" href=\"system.type#System_Type_GetType_\" data-linktype=\"relative-path\">GetType</a> method passes correctly escaped names to <code>typeResolver</code> and to the default type resolution methods. If you need to compare a name to an unescaped name in <code>typeResolver</code>, you must remove the escape characters.  </p>\n<p> Back to <a href=\"#usage_notes\" data-linktype=\"self-bookmark\">Usage Notes</a>.  </p>\n<p><a name=\"mixed_name_resolution\"></a>   </p>\n<h2 id=\"mixed-name-resolution\">Mixed Name Resolution</h2>\n<p> The following table summarizes the interactions between <code>assemblyResolver</code>, <code>typeResolver</code>, and default name resolution, for all combinations of type name and assembly name in <code>typeName</code>:  </p>\n<table>\n<thead>\n<tr>\n<th>Contents of type name</th>\n<th>Assembly resolver method</th>\n<th>Type resolver method</th>\n<th>Result</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>type, assembly</td>\n<td>null</td>\n<td>null</td>\n<td>Equivalent to calling the <a class=\"xref\" href=\"system.type#System_Type_GetType_System_String_System_Boolean_System_Boolean_\" data-linktype=\"relative-path\">System.Type.GetType(String,Boolean,Boolean)</a> method overload.</td>\n</tr>\n<tr>\n<td>type, assembly</td>\n<td>provided</td>\n<td>null</td>\n<td><code>assemblyResolver</code> returns the assembly or returns <code>null</code> if it cannot resolve the assembly. If the assembly is resolved, the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_GetType_System_String_System_Boolean_System_Boolean_\" data-linktype=\"relative-path\">System.Reflection.Assembly.GetType(String,Boolean,Boolean)</a> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type.</td>\n</tr>\n<tr>\n<td>type, assembly</td>\n<td>null</td>\n<td>provided</td>\n<td>Equivalent to converting the assembly name to an <a class=\"xref\" href=\"system.reflection.assemblyname\" data-linktype=\"relative-path\">AssemblyName</a> object and calling the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_Load_System_Reflection_AssemblyName_\" data-linktype=\"relative-path\">System.Reflection.Assembly.Load(AssemblyName)</a> method overload to get the assembly. If the assembly is resolved, it is passed to <code>typeResolver</code>; otherwise, <code>typeResolver</code> is not called and there is no further attempt to resolve the type.</td>\n</tr>\n<tr>\n<td>type, assembly</td>\n<td>provided</td>\n<td>provided</td>\n<td><code>assemblyResolver</code> returns the assembly or returns <code>null</code> if it cannot resolve the assembly. If the assembly is resolved, it is passed to <code>typeResolver</code>; otherwise, <code>typeResolver</code> is not called and there is no further attempt to resolve the type.</td>\n</tr>\n<tr>\n<td>type</td>\n<td>null, provided</td>\n<td>null</td>\n<td>Equivalent to calling the <a class=\"xref\" href=\"system.type#System_Type_GetType_System_String_System_Boolean_System_Boolean_\" data-linktype=\"relative-path\">System.Type.GetType(String,Boolean,Boolean)</a> method overload. Because the assembly name is not provided, only Mscorlib.dll and the currently executing assembly are searched. If <code>assemblyResolver</code> is provided, it is ignored.</td>\n</tr>\n<tr>\n<td>type</td>\n<td>null, provided</td>\n<td>provided</td>\n<td><code>typeResolver</code> is called, and <code>null</code> is passed for the assembly. <code>typeResolver</code> can provide a type from any assembly, including assemblies it loads for the purpose. If <code>assemblyResolver</code> is provided, it is ignored.</td>\n</tr>\n<tr>\n<td>assembly</td>\n<td>null, provided</td>\n<td>null, provided</td>\n<td>A <a class=\"xref\" href=\"system.io.fileloadexception\" data-linktype=\"relative-path\">FileLoadException</a> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name. This results in an invalid assembly name.</td>\n</tr>\n</tbody>\n</table>\n<p> Back to: <a href=\"#usage_notes\" data-linktype=\"self-bookmark\">Usage Notes</a>, <a href=\"#resolving_assemblies\" data-linktype=\"self-bookmark\">Resolving Assemblies</a>, <a href=\"#resolving_types\" data-linktype=\"self-bookmark\">Resolving Types</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetTypeArray_System_Object___\">\r\n    \r\n            <a id=\"System_Type_GetTypeArray_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetTypeArray(Object[])</div>        \r\n          </div>\r\n    \r\n            <p>Gets the types of the objects in the specified array.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static Type[] GetTypeArray (object[] args);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>args</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of objects whose types to determine.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </div>\r\n                  <p>An array of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects representing the types of the corresponding elements in <code>args</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>args</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> One or more of the elements in <code>args</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.targetinvocationexception\" data-linktype=\"relative-path\">TargetInvocationException</a></div>\r\n                  </div>\r\n                  <p>The class initializers are invoked and at least one throws an exception.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates how to use the GetTypeArray method to list the types of the elements of an array.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_GetTypeCode#3\">            Object[] myObject = new Object[3];\n            myObject[0] = 66;\n            myObject[1] = &quot;puri&quot;;\n            myObject[2] = 33.33;\n            // Get the array of &#39;Type&#39; class objects.\n            Type[] myTypeArray = Type.GetTypeArray(myObject);\n            Console.WriteLine(&quot;Full names of the &#39;Type&#39; objects in the array are:&quot;);\n            for(int h = 0; h &lt; myTypeArray.Length ; h++)\n            {\n                Console.WriteLine(myTypeArray[h].FullName);\n            }\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetTypeCode#3\">   array&lt;Object^&gt;^myObject = gcnew array&lt;Object^&gt;(3);\n   myObject[ 0 ] = 66;\n   myObject[ 1 ] = &quot;puri&quot;;\n   myObject[ 2 ] = 33.33;\n   \n   // Get the array of &#39;Type&#39; class objects.\n   array&lt;Type^&gt;^myTypeArray = Type::GetTypeArray( myObject );\n   Console::WriteLine( &quot;Full names of the &#39;Type&#39; objects in the array are:&quot; );\n   for ( int h = 0; h &lt; myTypeArray-&gt;Length; h++ )\n   {\n      Console::WriteLine( myTypeArray[ h ]-&gt;FullName );\n\n   }\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetTypeCode#3\">         Dim myObject(2) As Object\n         myObject(0) = 66\n         myObject(1) = &quot;puri&quot;\n         myObject(2) = 33.33\n         &#39; Get the array of &#39;Type&#39; class objects.\n         Dim myTypeArray As Type() = Type.GetTypeArray(myObject)\n         Console.WriteLine(&quot;Full names of the &#39;Type&#39; objects in the array are:&quot;)\n         Dim h As Integer\n         For h = 0 To myTypeArray.Length - 1\n            Console.WriteLine(myTypeArray(h).FullName)\n         Next h\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetTypeCode_System_Type_\">\r\n    \r\n            <a id=\"System_Type_GetTypeCode_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetTypeCode(Type)</div>        \r\n          </div>\r\n    \r\n            <p>Gets the underlying type code of the specified <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static TypeCode GetTypeCode (Type type);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>type</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The type whose underlying type code to get.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.typecode\" data-linktype=\"relative-path\">TypeCode</a></div>\r\n                  </div>\r\n                  <p>The code of the underlying type, or <a class=\"xref\" href=\"system.typecode\" data-linktype=\"relative-path\">TypeCode</a> if <code>type</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>When you inherit from <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, you can change the behavior of this method by overriding the <a class=\"xref\" href=\"system.type#System_Type_GetTypeCodeImpl_\" data-linktype=\"relative-path\">GetTypeCodeImpl</a> method.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates how the <a class=\"xref\" href=\"system.typecode\" data-linktype=\"relative-path\">TypeCode</a> enumeration can be used. In a decision block inside the <code>WriteObjectInfo</code> method, the <a class=\"xref\" href=\"system.typecode\" data-linktype=\"relative-path\">TypeCode</a> of an <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a> parameter is examined, and an appropriate message is written to the console.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.TypeCode#2\">void WriteObjectInfo( Object^ testObject )\n{\n   TypeCode typeCode = Type::GetTypeCode( testObject-&gt;GetType() );\n   switch ( typeCode )\n   {\n      case TypeCode::Boolean:\n         Console::WriteLine( &quot;Boolean: {0}&quot;, testObject );\n         break;\n\n      case TypeCode::Double:\n         Console::WriteLine( &quot;Double: {0}&quot;, testObject );\n         break;\n\n      default:\n         Console::WriteLine( &quot;{0}: {1}&quot;, typeCode, testObject );\n         break;\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.TypeCode#2\">    Sub WriteObjectInfo(ByVal testObject As Object)\n        Dim typeCode As TypeCode = Type.GetTypeCode(testObject.GetType())\n\n        Select Case typeCode\n            Case typeCode.Boolean\n                Console.WriteLine(&quot;Boolean: {0}&quot;, testObject)\n\n            Case typeCode.Double\n                Console.WriteLine(&quot;Double: {0}&quot;, testObject)\n\n            Case Else\n                Console.WriteLine(&quot;{0}: {1}&quot;, typeCode.ToString(), testObject)\n        End Select\n    End Sub\n</code></pre><pre><code class=\"lang-cs\" name=\"System.TypeCode#2\">        static void WriteObjectInfo(object testObject)\n        {\n            TypeCode    typeCode = Type.GetTypeCode( testObject.GetType() );\n\n            switch( typeCode )\n            {\n                case TypeCode.Boolean:\n                    Console.WriteLine(&quot;Boolean: {0}&quot;, testObject);\n                    break;\n\n                case TypeCode.Double:\n                    Console.WriteLine(&quot;Double: {0}&quot;, testObject);\n                    break;\n\n                default:\n                    Console.WriteLine(&quot;{0}: {1}&quot;, typeCode.ToString(), testObject);\n                    break;\n            }\n        }\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetTypeCodeImpl\">\r\n    \r\n            <a id=\"System_Type_GetTypeCodeImpl_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetTypeCodeImpl()</div>        \r\n          </div>\r\n    \r\n            <p>Returns the underlying type code of this <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> instance.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected virtual TypeCode GetTypeCodeImpl ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.typecode\" data-linktype=\"relative-path\">TypeCode</a></div>\r\n                  </div>\r\n                  <p>The type code of the underlying type.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method provides the implementation for the <code>static</code> (in C#) or <code>Shared</code> (in Visual Basic) <a class=\"xref\" href=\"system.type#System_Type_GetTypeCode_System_Type_\" data-linktype=\"relative-path\">GetTypeCode(Type)</a> method. When you inherit from <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, you can override this method to provide your own implementation of <a class=\"xref\" href=\"system.type#System_Type_GetTypeCode_\" data-linktype=\"relative-path\">GetTypeCode</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetTypeFromCLSID_System_Guid_\">\r\n    \r\n            <a id=\"System_Type_GetTypeFromCLSID_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetTypeFromCLSID(Guid)</div>        \r\n          </div>\r\n    \r\n            <p>Gets the type associated with the specified class identifier (CLSID).</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static Type GetTypeFromCLSID (Guid clsid);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>clsid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.guid\" data-linktype=\"relative-path\">Guid</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The CLSID of the type to get.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p><code>System.__ComObject</code> regardless of whether the CLSID is valid.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The GetTypeFromCLSID method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object&#39;s class identifier (CLSID).  The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\\CLSID key of the registry. You can retrieve the value of the <a class=\"xref\" href=\"system.type#System_Type_IsCOMObject_\" data-linktype=\"relative-path\">IsCOMObject</a> property to determine whether the type returned by this method is a COM object.  </p>\n<div class=\"TIP\"><h5>Tip</h5><p> You can call the <a class=\"xref\" href=\"system.type#System_Type_GetTypeFromProgID_\" data-linktype=\"relative-path\">GetTypeFromProgID</a> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.  </p>\n</div>\n<p> Instantiating an unmanaged COM object from its CLSID is a two-step process:  </p>\n<ol>\n<li><p>Get a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents the<code>__ComObject</code> that corresponds to the CLSID by calling the GetTypeFromCLSID method.  </p>\n</li>\n<li><p>Call the <a class=\"xref\" href=\"system.activator#System_Activator_CreateInstance_System_Type_\" data-linktype=\"relative-path\">System.Activator.CreateInstance(Type)</a> method to instantiate the COM object.  </p>\n<p>See the example for an illustration.  </p>\n<p>The GetTypeFromCLSID overload ignores any exception that may occur when instantiating a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object based on the <code>clsid</code> argument. Note that no exception is thrown if <code>clsid</code> is not found in the registry.</p>\n</li>\n</ol>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses the CLSID of the Microsoft Word <a href=\"http://msdn.microsoft.com/library/office/ff838565.aspx\" data-linktype=\"external\">Application object</a> to retrieve a COM type that represents the Microsoft Word application. It then instantiates the type by calling the <a class=\"xref\" href=\"system.activator#System_Activator_CreateInstance_\" data-linktype=\"relative-path\">CreateInstance</a> method, and closes it by calling the <a href=\"http://msdn.microsoft.com/library/office/ff844895.aspx\" data-linktype=\"external\">Application.Quit</a> method.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.GetTypeFromCLSID#1\">using System;\nusing System.Reflection;\nusing System.Runtime.InteropServices;\n\npublic class Example\n{\n   private const string WORD_CLSID = &quot;{000209FF-0000-0000-C000-000000000046}&quot;;\n   \n   public static void Main()\n   {\n      // Start an instance of the Word application.\n      var word = Type.GetTypeFromCLSID(Guid.Parse(WORD_CLSID));\n      Console.WriteLine(&quot;Instantiated Type object from CLSID {0}&quot;,\n                        WORD_CLSID);\n      Object wordObj = Activator.CreateInstance(word);\n      Console.WriteLine(&quot;Instantiated {0}&quot;, \n                        wordObj.GetType().FullName);\n      \n      // Close Word.\n      word.InvokeMember(&quot;Quit&quot;, BindingFlags.InvokeMethod, null, \n                        wordObj, new object[] { 0, 0, false } );\n   }\n}\n// The example displays the following output:\n//    Instantiated Type object from CLSID {000209FF-0000-0000-C000-000000000046}\n//    Instantiated Microsoft.Office.Interop.Word.ApplicationClass\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.GetTypeFromCLSID#1\">Imports System.Reflection\nImports System.Runtime.InteropServices\n\nModule Example\n   Private Const WORD_CLSID As String = &quot;{000209FF-0000-0000-C000-000000000046}&quot;\n   \n   Public Sub Main()\n      &#39; Start an instance of the Word application.\n      Dim word As Type = Type.GetTypeFromCLSID(Guid.Parse(WORD_CLSID))\n      Console.WriteLine(&quot;Instantiated Type object from CLSID {0}&quot;,\n                        WORD_CLSID)\n      Dim wordObj As Object = Activator.CreateInstance(word)\n      Console.WriteLine(&quot;Instantiated {0}&quot;, \n                        wordObj.GetType().FullName)\n      \n      &#39; Close Word.\n      word.InvokeMember(&quot;Quit&quot;, BindingFlags.InvokeMethod, Nothing, \n                        wordObj, New Object() { 0, 0, False } )\n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;    Instantiated Type object from CLSID {000209FF-0000-0000-C000-000000000046}\n&#39;    Instantiated Microsoft.Office.Interop.Word.ApplicationClass\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetTypeFromCLSID_System_Guid_System_Boolean_\">\r\n    \r\n            <a id=\"System_Type_GetTypeFromCLSID_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetTypeFromCLSID(Guid,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>clsid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.guid\" data-linktype=\"relative-path\">Guid</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The CLSID of the type to get.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>throwOnError</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to throw any exception that occurs.  </p>\n<p> -or-  </p>\n<p> <code>false</code> to ignore any exception that occurs.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p><code>System.__ComObject</code> regardless of whether the CLSID is valid.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <a class=\"xref\" href=\"system.type#System_Type_GetTypeFromCLSID_\" data-linktype=\"relative-path\">GetTypeFromCLSID</a> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object&#39;s class identifier (CLSID).  The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\\CLSID key of the registry. You can retrieve the value of the <a class=\"xref\" href=\"system.type#System_Type_IsCOMObject_\" data-linktype=\"relative-path\">IsCOMObject</a> property to determine whether the type returned by this method is a COM object.  </p>\n<div class=\"TIP\"><h5>Tip</h5><p> You can call the <a class=\"xref\" href=\"system.type#System_Type_GetTypeFromProgID_\" data-linktype=\"relative-path\">GetTypeFromProgID</a> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.  </p>\n</div>\n<p> Instantiating an unmanaged COM object from its CLSID is a two-step process:  </p>\n<ol>\n<li><p>Get a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents the <code>__ComObject</code> that corresponds to the CLSID by calling the <a class=\"xref\" href=\"system.type#System_Type_GetTypeFromCLSID_\" data-linktype=\"relative-path\">GetTypeFromCLSID</a> method.  </p>\n</li>\n<li><p>Call the <a class=\"xref\" href=\"system.activator#System_Activator_CreateInstance_System_Type_\" data-linktype=\"relative-path\">System.Activator.CreateInstance(Type)</a> method to instantiate the COM object.  </p>\n<p>See the example for an illustration.  </p>\n<p>Exceptions such as <a class=\"xref\" href=\"system.outofmemoryexception\" data-linktype=\"relative-path\">OutOfMemoryException</a> will be thrown when specifying <code>true</code> for <code>throwOnError</code>, but it will not fail for unregistered CLSIDs.</p>\n</li>\n</ol>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses the CLSID of the Microsoft Word <a href=\"http://msdn.microsoft.com/library/office/ff838565.aspx\" data-linktype=\"external\">Application object</a> to retrieve a COM type that represents the Microsoft Word application. It then instantiates the type by calling the <a class=\"xref\" href=\"system.activator#System_Activator_CreateInstance_\" data-linktype=\"relative-path\">CreateInstance</a> method, and closes it by calling the <a href=\"http://msdn.microsoft.com/library/office/ff844895.aspx\" data-linktype=\"external\">Application.Quit</a> method. An exception is thrown if an error occurs while loading the type.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.GetTypeFromCLSID#2\">using System;\nusing System.Reflection;\nusing System.Runtime.InteropServices;\n\npublic class Example\n{\n   private const string WORD_CLSID = &quot;{000209FF-0000-0000-C000-000000000046}&quot;;\n   \n   public static void Main()\n   {\n      try {\n         // Start an instance of the Word application.\n         var word = Type.GetTypeFromCLSID(Guid.Parse(WORD_CLSID), true);\n         Console.WriteLine(&quot;Instantiated Type object from CLSID {0}&quot;,\n                           WORD_CLSID);\n         Object wordObj = Activator.CreateInstance(word);\n         Console.WriteLine(&quot;Instantiated {0}&quot;, \n                           wordObj.GetType().FullName, WORD_CLSID);\n         \n         // Close Word.\n         word.InvokeMember(&quot;Quit&quot;, BindingFlags.InvokeMethod, null, \n                           wordObj, new object[] { 0, 0, false } );\n      }\n      catch (Exception) {\n         Console.WriteLine(&quot;Unable to instantiate an object for {0}&quot;, WORD_CLSID);\n      }\n   }\n}\n// The example displays the following output:\n//    Instantiated Type object from CLSID {000209FF-0000-0000-C000-000000000046}\n//    Instantiated Microsoft.Office.Interop.Word.ApplicationClass\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.GetTypeFromCLSID#2\">Imports System.Reflection\nImports System.Runtime.InteropServices\n\nModule Example\n   Private Const WORD_CLSID As String = &quot;{000209FF-0000-0000-C000-000000000046}&quot;\n   \n   Public Sub Main()\n      &#39; Start an instance of the Word application.\n      Try\n         Dim word As Type = Type.GetTypeFromCLSID(Guid.Parse(WORD_CLSID), True)\n         Console.WriteLine(&quot;Instantiated Type object from CLSID {0}&quot;,\n                           WORD_CLSID)\n         Dim wordObj As Object = Activator.CreateInstance(word)\n         Console.WriteLine(&quot;Instantiated {0}&quot;, \n                           wordObj.GetType().FullName)\n         \n         &#39; Close Word.\n         word.InvokeMember(&quot;Quit&quot;, BindingFlags.InvokeMethod, Nothing, \n                           wordObj, New Object() { 0, 0, False } )\n      &#39; The method can throw any of a number of unexpected exceptions.\n      Catch e As Exception\n         Console.WriteLine(&quot;Unable to instantiate an object for {0}&quot;, WORD_CLSID)\n      End Try\n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;    Instantiated Type object from CLSID {000209FF-0000-0000-C000-000000000046}\n&#39;    Instantiated Microsoft.Office.Interop.Word.ApplicationClass\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetTypeFromCLSID_System_Guid_System_String_\">\r\n    \r\n            <a id=\"System_Type_GetTypeFromCLSID_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetTypeFromCLSID(Guid,String)</div>        \r\n          </div>\r\n    \r\n            <p>Gets the type associated with the specified class identifier (CLSID) from the specified server.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static Type GetTypeFromCLSID (Guid clsid, string server);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>clsid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.guid\" data-linktype=\"relative-path\">Guid</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The CLSID of the type to get.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>server</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The server from which to load the type. If the server name is <code>null</code>, this method automatically reverts to the local machine.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p><code>System.__ComObject</code> regardless of whether the CLSID is valid.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <a class=\"xref\" href=\"system.type#System_Type_GetTypeFromCLSID_\" data-linktype=\"relative-path\">GetTypeFromCLSID</a> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object&#39;s class identifier (CLSID).  The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\\CLSID key of the registry. You can retrieve the value of the <a class=\"xref\" href=\"system.type#System_Type_IsCOMObject_\" data-linktype=\"relative-path\">IsCOMObject</a> property to determine whether the type returned by this method is a COM object.  </p>\n<div class=\"TIP\"><h5>Tip</h5><p> You can call the <a class=\"xref\" href=\"system.type#System_Type_GetTypeFromProgID_\" data-linktype=\"relative-path\">GetTypeFromProgID</a> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.  </p>\n</div>\n<p> Instantiating an unmanaged COM object from its CLSID is a two-step process:  </p>\n<ol>\n<li><p>Get a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents the <code>__ComObject</code> that corresponds to the CLSID by calling the <a class=\"xref\" href=\"system.type#System_Type_GetTypeFromCLSID_\" data-linktype=\"relative-path\">GetTypeFromCLSID</a> method.  </p>\n</li>\n<li><p>Call the <a class=\"xref\" href=\"system.activator#System_Activator_CreateInstance_System_Type_\" data-linktype=\"relative-path\">System.Activator.CreateInstance(Type)</a> method to instantiate the COM object.</p>\n</li>\n</ol>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses the CLSID of the Microsoft Word <a href=\"http://msdn.microsoft.com/library/office/ff838565.aspx\" data-linktype=\"external\">Application object</a> to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com. It then instantiates the type by calling the <a class=\"xref\" href=\"system.activator#System_Activator_CreateInstance_\" data-linktype=\"relative-path\">CreateInstance</a> method, and closes it by calling the <a href=\"http://msdn.microsoft.com/library/office/ff844895.aspx\" data-linktype=\"external\">Application.Quit</a> method.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Type.GetTypeFromCLSID#3\">Imports System.Reflection\nImports System.Runtime.InteropServices\n\nModule Example\n   Private Const WORD_CLSID As String = &quot;{000209FF-0000-0000-C000-000000000046}&quot;\n   \n   Public Sub Main()\n      &#39; Start an instance of the Word application.\n      Dim word As Type = Type.GetTypeFromCLSID(Guid.Parse(WORD_CLSID), &quot;computer17.central.contoso.com&quot;)\n      Console.WriteLine(&quot;Instantiated Type object from CLSID {0}&quot;,\n                        WORD_CLSID)\n      Try\n         Dim wordObj As Object = Activator.CreateInstance(word)\n         Console.WriteLine(&quot;Instantiated {0}&quot;, \n                           wordObj.GetType().FullName)\n         \n         &#39; Close Word.\n         word.InvokeMember(&quot;Quit&quot;, BindingFlags.InvokeMethod, Nothing, \n                           wordObj, New Object() { 0, 0, False } )\n      Catch e As COMException\n         Console.WriteLine(&quot;Unable to instantiate object.&quot;)\n      End Try\n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;    Instantiated Type object from CLSID {000209FF-0000-0000-C000-000000000046}\n&#39;    Instantiated Microsoft.Office.Interop.Word.ApplicationClass\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.GetTypeFromCLSID#3\">using System;\nusing System.Reflection;\nusing System.Runtime.InteropServices;\n\npublic class Example\n{\n   private const string WORD_CLSID = &quot;{000209FF-0000-0000-C000-000000000046}&quot;;\n   \n   public static void Main()\n   {\n      // Start an instance of the Word application.\n      var word = Type.GetTypeFromCLSID(Guid.Parse(WORD_CLSID), &quot;computer17.central.contoso.com&quot;);\n      Console.WriteLine(&quot;Instantiated Type object from CLSID {0}&quot;,\n                        WORD_CLSID);\n      try {\n         Object wordObj = Activator.CreateInstance(word);\n         Console.WriteLine(&quot;Instantiated {0}&quot;, \n                           wordObj.GetType().FullName, WORD_CLSID);\n            \n         // Close Word.\n         word.InvokeMember(&quot;Quit&quot;, BindingFlags.InvokeMethod, null, \n                           wordObj, new object[] { 0, 0, false } );\n      }\n      catch (COMException) {\n         Console.WriteLine(&quot;Unable to instantiate object.&quot;);   \n      }\n   }\n}\n// The example displays the following output:\n//    Instantiated Type object from CLSID {000209FF-0000-0000-C000-000000000046}\n//    Instantiated Microsoft.Office.Interop.Word.ApplicationClass\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetTypeFromCLSID_System_Guid_System_String_System_Boolean_\">\r\n    \r\n            <a id=\"System_Type_GetTypeFromCLSID_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetTypeFromCLSID(Guid,String,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>clsid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.guid\" data-linktype=\"relative-path\">Guid</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The CLSID of the type to get.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>server</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The server from which to load the type. If the server name is <code>null</code>, this method automatically reverts to the local machine.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>throwOnError</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to throw any exception that occurs.  </p>\n<p> -or-  </p>\n<p> <code>false</code> to ignore any exception that occurs.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p><code>System.__ComObject</code> regardless of whether the CLSID is valid.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <a class=\"xref\" href=\"system.type#System_Type_GetTypeFromCLSID_\" data-linktype=\"relative-path\">GetTypeFromCLSID</a> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object&#39;s class identifier (CLSID).  The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\\CLSID key of the registry. You can retrieve the value of the <a class=\"xref\" href=\"system.type#System_Type_IsCOMObject_\" data-linktype=\"relative-path\">IsCOMObject</a> property to determine whether the type returned by this method is a COM object.  </p>\n<div class=\"TIP\"><h5>Tip</h5><p> You can call the <a class=\"xref\" href=\"system.type#System_Type_GetTypeFromProgID_\" data-linktype=\"relative-path\">GetTypeFromProgID</a> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.  </p>\n</div>\n<p> Instantiating an unmanaged COM object from its CLSID is a two-step process:  </p>\n<ol>\n<li><p>Get a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents the <code>__ComObject</code> that corresponds to the CLSID by calling the <a class=\"xref\" href=\"system.type#System_Type_GetTypeFromCLSID_\" data-linktype=\"relative-path\">GetTypeFromCLSID</a> method.  </p>\n</li>\n<li><p>Call the <a class=\"xref\" href=\"system.activator#System_Activator_CreateInstance_System_Type_\" data-linktype=\"relative-path\">System.Activator.CreateInstance(Type)</a> method to instantiate the COM object.  </p>\n<p>Exceptions such as <a class=\"xref\" href=\"system.outofmemoryexception\" data-linktype=\"relative-path\">OutOfMemoryException</a> will be thrown when specifying <code>true</code> for <code>throwOnError</code>, but it will not fail for unregistered CLSIDs.</p>\n</li>\n</ol>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses the CLSID of the Microsoft Word <a href=\"http://msdn.microsoft.com/library/office/ff838565.aspx\" data-linktype=\"external\">Application object</a> to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com. It then instantiates the type by calling the <a class=\"xref\" href=\"system.activator#System_Activator_CreateInstance_\" data-linktype=\"relative-path\">CreateInstance</a> method, and closes it by calling the <a href=\"http://msdn.microsoft.com/library/office/ff844895.aspx\" data-linktype=\"external\">Application.Quit</a> method. An exception is thrown if an error occurs while loading the type.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.GetTypeFromCLSID#4\">using System;\nusing System.Reflection;\nusing System.Runtime.InteropServices;\n\npublic class Example\n{\n   private const string WORD_CLSID = &quot;{000209FF-0000-0000-C000-000000000046}&quot;;\n   \n   public static void Main()\n   {\n      try {\n         // Start an instance of the Word application.\n         var word = Type.GetTypeFromCLSID(Guid.Parse(WORD_CLSID), \n                                          &quot;computer17.central.contoso.com&quot;,\n                                          true);\n         Console.WriteLine(&quot;Instantiated Type object from CLSID {0}&quot;,\n                           WORD_CLSID);\n         Object wordObj = Activator.CreateInstance(word);\n         Console.WriteLine(&quot;Instantiated {0}&quot;, \n                           wordObj.GetType().FullName, WORD_CLSID);\n            \n         // Close Word.\n         word.InvokeMember(&quot;Quit&quot;, BindingFlags.InvokeMethod, null, \n                           wordObj, new object[] { 0, 0, false } );\n      }\n      // The method can throw any of a variety of exceptions.\n      catch (Exception e) {\n         Console.WriteLine(&quot;{0}: Unable to instantiate an object for {1}&quot;, \n                           e.GetType().Name, WORD_CLSID);\n      }      \n   }\n}\n// The example displays the following output:\n//    Instantiated Type object from CLSID {000209FF-0000-0000-C000-000000000046}\n//    Instantiated Microsoft.Office.Interop.Word.ApplicationClass\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.GetTypeFromCLSID#4\">Imports System.Reflection\nImports System.Runtime.InteropServices\n\nModule Example\n   Private Const WORD_CLSID As String = &quot;{000209FF-0000-0000-C000-000000000046}&quot;\n   \n   Public Sub Main()\n      Try\n         &#39; Start an instance of the Word application.\n         Dim word As Type = Type.GetTypeFromCLSID(Guid.Parse(WORD_CLSID), \n                                                  &quot;computer17.central.contoso.com&quot;,\n                                                  True)\n         Console.WriteLine(&quot;Instantiated Type object from CLSID {0}&quot;,\n                           WORD_CLSID)\n\n         Dim wordObj As Object = Activator.CreateInstance(word)\n         Console.WriteLine(&quot;Instantiated {0}&quot;, \n                           wordObj.GetType().FullName)\n         \n         &#39; Close Word.\n         word.InvokeMember(&quot;Quit&quot;, BindingFlags.InvokeMethod, Nothing, \n                           wordObj, New Object() { 0, 0, False } )\n      &#39; The method can throw any of a variety of exceptions.\n      Catch e As Exception\n         Console.WriteLine(&quot;{0}: Unable to instantiate an object for {1}&quot;, \n                           e.GetType().Name, WORD_CLSID)\n      End Try\n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;    Instantiated Type object from CLSID {000209FF-0000-0000-C000-000000000046}\n&#39;    Instantiated Microsoft.Office.Interop.Word.ApplicationClass\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetTypeFromHandle_System_RuntimeTypeHandle_\">\r\n    \r\n            <a id=\"System_Type_GetTypeFromHandle_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetTypeFromHandle(RuntimeTypeHandle)</div>        \r\n          </div>\r\n    \r\n            <p>Gets the type referenced by the specified type handle.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static Type GetTypeFromHandle (RuntimeTypeHandle handle);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>handle</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtimetypehandle\" data-linktype=\"relative-path\">RuntimeTypeHandle</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object that refers to the type.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>The type referenced by the specified <a class=\"xref\" href=\"system.runtimetypehandle\" data-linktype=\"relative-path\">RuntimeTypeHandle</a>, or <code>null</code> if the <span class=\"xref\">stem.RuntimeTypeHandle.Value*</span> property of <code>handle</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.targetinvocationexception\" data-linktype=\"relative-path\">TargetInvocationException</a></div>\r\n                  </div>\r\n                  <p>A class initializer is invoked and throws an exception.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The handles are valid only in the application domain in which they were obtained.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses the GetTypeFromHandle method to get a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object from a <a class=\"xref\" href=\"system.runtimetypehandle\" data-linktype=\"relative-path\">RuntimeTypeHandle</a> provided by the <a class=\"xref\" href=\"system.type#System_Type_GetTypeHandle_\" data-linktype=\"relative-path\">GetTypeHandle</a> method.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_GetTypeFromHandle#1\">        MyClass1 myClass1 = new MyClass1();\n\t     // Get the type referenced by the specified type handle.\n        Type myClass1Type = Type.GetTypeFromHandle(Type.GetTypeHandle(myClass1));\n        Console.WriteLine(&quot;The Names of the Attributes :&quot;+myClass1Type.Attributes);\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetTypeFromHandle#1\">   MyClass1^ myClass1 = gcnew MyClass1;\n   // Get the type referenced by the specified type handle.\n   Type^ myClass1Type = Type::GetTypeFromHandle( Type::GetTypeHandle( myClass1 ) );\n   Console::WriteLine( &quot;The Names of the Attributes : {0}&quot;, myClass1Type-&gt;Attributes );\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetTypeFromHandle#1\">      Dim myClass1 As New MyClass1()\n      &#39; Get the type referenced by the specified type handle.\n      Dim myClass1Type As Type = Type.GetTypeFromHandle(Type.GetTypeHandle(MyClass1))\n      Console.WriteLine((&quot;The Names of the Attributes :&quot; + myClass1Type.Attributes.ToString()))\n   End Sub &#39;Main \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetTypeFromProgID_System_String_\">\r\n    \r\n            <a id=\"System_Type_GetTypeFromProgID_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetTypeFromProgID(String)</div>        \r\n          </div>\r\n    \r\n            <p>Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static Type GetTypeFromProgID (string progID);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>progID</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The ProgID of the type to get.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>The type associated with the specified ProgID, if <code>progID</code> is a valid entry in the registry and a type is associated with it; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>progID</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is provided for COM support. ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetTypeFromProgID_System_String_System_Boolean_\">\r\n    \r\n            <a id=\"System_Type_GetTypeFromProgID_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetTypeFromProgID(String,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static Type GetTypeFromProgID (string progID, bool throwOnError);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>progID</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The ProgID of the type to get.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>throwOnError</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to throw any exception that occurs.  </p>\n<p> -or-  </p>\n<p> <code>false</code> to ignore any exception that occurs.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>The type associated with the specified program identifier (ProgID), if <code>progID</code> is a valid entry in the registry and a type is associated with it; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>progID</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtime.interopservices.comexception\" data-linktype=\"relative-path\">COMException</a></div>\r\n                  </div>\r\n                  <p>The specified ProgID is not registered.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is provided for COM support. Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example retrieves a type by passing a ProgID, specifying whether to throw an exception if the ProgID is invalid. The example then displays the ClassID related to the ProgID, along with any applicable exception message.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_GetTypeFromProgID2#1\">using System;\nclass MainApp \n{\n    public static void Main()\n    {\n        try\n        {\n            // Use the ProgID HKEY_CLASSES_ROOT\\DirControl.DirList.1.\n            string myString1 =&quot;DIRECT.ddPalette.3&quot;; \n            // Use a nonexistent ProgID WrongProgID.\n            string myString2 =&quot;WrongProgID&quot;; \n            // Make a call to the method to get the type information of the given ProgID.\n            Type myType1 =Type.GetTypeFromProgID(myString1,true);\n            Console.WriteLine(&quot;GUID for ProgID DirControl.DirList.1 is {0}.&quot;, myType1.GUID);\n            // Throw an exception because the ProgID is invalid and the throwOnError  \n            // parameter is set to True.\n            Type myType2 =Type.GetTypeFromProgID(myString2,true);\n        }\n        catch(Exception e)\n        {\n            Console.WriteLine(&quot;An exception occurred.&quot;);\n            Console.WriteLine(&quot;Source: {0}&quot;, e.Source);\n            Console.WriteLine(&quot;Message: {0}&quot;, e.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetTypeFromProgID2#1\">using namespace System;\nint main()\n{\n   try\n   {\n      \n      // Use the ProgID HKEY_CLASSES_ROOT\\DirControl.DirList.1.\n      String^ myString1 = &quot;DIRECT.ddPalette.3&quot;;\n      \n      // Use a nonexistent ProgID WrongProgID.\n      String^ myString2 = &quot;WrongProgID&quot;;\n      \n      // Make a call to the method to get the type information of the given ProgID.\n      Type^ myType1 = Type::GetTypeFromProgID( myString1, true );\n      Console::WriteLine( &quot;GUID for ProgID DirControl.DirList.1 is {0}.&quot;, myType1-&gt;GUID );\n      \n      // Throw an exception because the ProgID is invalid and the throwOnError\n      // parameter is set to True.\n      Type^ myType2 = Type::GetTypeFromProgID( myString2, true );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;An exception occurred.&quot; );\n      Console::WriteLine( &quot;Source: {0}&quot;, e-&gt;Source );\n      Console::WriteLine( &quot;Message: {0}&quot;, e-&gt;Message );\n   }\n\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetTypeFromProgID2#1\">Imports System\nClass MainApp\n    Public Shared Sub Main()\n        Try\n            &#39; Use the ProgID HKEY_CLASSES_ROOT\\DirControl.DirList.1.\n            Dim myString1 As String = &quot;DIRECT.ddPalette.3&quot;\n            &#39; Use a nonexistent ProgID WrongProgID.\n            Dim myString2 As String = &quot;WrongProgID&quot;\n            &#39; Make a call to the method to get the type information of the given ProgID.\n            Dim myType1 As Type = Type.GetTypeFromProgID(myString1, True)\n            Console.WriteLine(&quot;GUID for ProgID DirControl.DirList.1 is {0}.&quot;, myType1.GUID.ToString())\n            &#39; Throw an exception because the ProgID is invalid and the throwOnError \n            &#39; parameter is set to True.\n            Dim myType2 As Type = Type.GetTypeFromProgID(myString2, True)\n        Catch e As Exception\n            Console.WriteLine(&quot;An exception occurred.&quot;)\n            Console.WriteLine(&quot;Source: {0}&quot;, e.Source.ToString())\n            Console.WriteLine(&quot;Message: {0}&quot;, e.Message.ToString())\n        End Try\n    End Sub &#39;Main \nEnd Class &#39;MainApp\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetTypeFromProgID_System_String_System_String_\">\r\n    \r\n            <a id=\"System_Type_GetTypeFromProgID_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetTypeFromProgID(String,String)</div>        \r\n          </div>\r\n    \r\n            <p>Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static Type GetTypeFromProgID (string progID, string server);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>progID</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The progID of the type to get.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>server</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The server from which to load the type. If the server name is <code>null</code>, this method automatically reverts to the local machine.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>The type associated with the specified program identifier (progID), if <code>progID</code> is a valid entry in the registry and a type is associated with it; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>prodID</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is provided for COM support. Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example retrieves a type by passing a ProgID and server name. The example then displays the ClassID related to the ProgID, or throws an exception if the ProgID or the server name is invalid.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_GetTypeFromProgID3#1\">using System;\nclass MainApp \n{\n    public static void Main()\n    {\n        try\n        {\n            // Use the ProgID localhost\\HKEY_CLASSES_ROOT\\DirControl.DirList.1.\n            string theProgramID =&quot;DirControl.DirList.1&quot;; \n            // Use the server name localhost.\n            string theServer=&quot;localhost&quot;;\n            // Make a call to the method to get the type information for the given ProgID.\n            Type myType =Type.GetTypeFromProgID(theProgramID,theServer);\n            if(myType==null)\n            {\n                throw new Exception(&quot;Invalid ProgID or Server.&quot;);\n            }\n            Console.WriteLine(&quot;GUID for ProgID DirControl.DirList.1 is {0}.&quot;, myType.GUID);\n        }\n        catch(Exception e)\n        {\n            Console.WriteLine(&quot;An exception occurred.&quot;);\n            Console.WriteLine(&quot;Source: {0}&quot; , e.Source);\n            Console.WriteLine(&quot;Message: {0}&quot; , e.Message);\n        }\t\t\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetTypeFromProgID3#1\">using namespace System;\nint main()\n{\n   try\n   {\n      \n      // Use the ProgID localhost\\HKEY_CLASSES_ROOT\\DirControl::DirList.1.\n      String^ theProgramID = &quot;DirControl.DirList.1&quot;;\n      \n      // Use the server name localhost.\n      String^ theServer = &quot;localhost&quot;;\n      \n      // Make a call to the method to get the type information for the given ProgID.\n      Type^ myType = Type::GetTypeFromProgID( theProgramID, theServer );\n      if ( myType == nullptr )\n      {\n         throw gcnew Exception( &quot;Invalid ProgID or Server.&quot; );\n      }\n      Console::WriteLine( &quot;GUID for ProgID DirControl.DirList.1 is {0}.&quot;, myType-&gt;GUID );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;An exception occurred.&quot; );\n      Console::WriteLine( &quot;Source: {0}&quot;, e-&gt;Source );\n      Console::WriteLine( &quot;Message: {0}&quot;, e-&gt;Message );\n   }\n\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetTypeFromProgID3#1\">Imports System\nClass MainApp\n    Public Shared Sub Main()\n        Try\n            &#39; Use ProgID localhost\\HKEY_CLASSES_ROOT\\DirControl.DirList.1.\n            Dim theProgramID As String = &quot;DirControl.DirList.1&quot;\n            &#39; Use Server name localhost.\n            Dim theServer As String = &quot;localhost&quot;\n            &#39; Make a call to the method to get the type information for the given ProgID.\n            Dim myType As Type = Type.GetTypeFromProgID(theProgramID, theServer)\n            If myType Is Nothing Then\n                Throw New Exception(&quot;Invalid ProgID or server.&quot;)\n            End If\n            Console.WriteLine(&quot;GUID for ProgID DirControl.DirList.1 is {0}.&quot;, myType.GUID.ToString())\n        Catch e As Exception\n            Console.WriteLine(&quot;An exception occurred.&quot;)\n            Console.WriteLine(&quot;Source: {0}.&quot;, e.Source.ToString())\n            Console.WriteLine(&quot;Message: {0}.&quot;, e.Message.ToString())\n        End Try\n    End Sub &#39;Main\nEnd Class &#39;MainApp\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetTypeFromProgID_System_String_System_String_System_Boolean_\">\r\n    \r\n            <a id=\"System_Type_GetTypeFromProgID_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetTypeFromProgID(String,String,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>progID</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The progID of the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> to get.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>server</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The server from which to load the type. If the server name is <code>null</code>, this method automatically reverts to the local machine.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>throwOnError</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to throw any exception that occurs.  </p>\n<p> -or-  </p>\n<p> <code>false</code> to ignore any exception that occurs.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>The type associated with the specified program identifier (progID), if <code>progID</code> is a valid entry in the registry and a type is associated with it; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>progID</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtime.interopservices.comexception\" data-linktype=\"relative-path\">COMException</a></div>\r\n                  </div>\r\n                  <p>The specified progID is not registered.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is provided for COM support. Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example retrieves a type by passing a ProgID and server name. The example then displays the ClassID related to the ProgID, specifying whether to throw an exception if the ProgID or the server name is invalid.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_GetTypeFromProgID4#1\">\nusing System;\nclass MainApp \n{\n    public static void Main()\n    {\n        try\n        {\n            // Use server localhost.\n            string theServer=&quot;localhost&quot;;\n            // Use  ProgID HKEY_CLASSES_ROOT\\DirControl.DirList.1.\n            string myString1 =&quot;DirControl.DirList.1&quot;; \n            // Use a wrong ProgID WrongProgID.\n            string myString2 =&quot;WrongProgID&quot;; \n            // Make a call to the method to get the type information for the given ProgID.\n            Type myType1 =Type.GetTypeFromProgID(myString1,theServer,true);\n            Console.WriteLine(&quot;GUID for ProgID DirControl.DirList.1 is {0}.&quot;, myType1.GUID);\n            // Throw an exception because the ProgID is invalid and the throwOnError \n            // parameter is set to True.\n            Type myType2 =Type.GetTypeFromProgID(myString2, theServer, true);\n        }\n        catch(Exception e)\n        {\n            Console.WriteLine(&quot;An exception occurred. The ProgID is wrong.&quot;);\n            Console.WriteLine(&quot;Source: {0}&quot; , e.Source);\n            Console.WriteLine(&quot;Message: {0}&quot; , e.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_GetTypeFromProgID4#1\">using namespace System;\nint main()\n{\n   try\n   {\n      \n      // Use server localhost.\n      String^ theServer = &quot;localhost&quot;;\n      \n      // Use  ProgID HKEY_CLASSES_ROOT\\DirControl.DirList.1.\n      String^ myString1 = &quot;DirControl.DirList.1&quot;;\n      \n      // Use a wrong ProgID WrongProgID.\n      String^ myString2 = &quot;WrongProgID&quot;;\n      \n      // Make a call to the method to get the type information for the given ProgID.\n      Type^ myType1 = Type::GetTypeFromProgID( myString1, theServer, true );\n      Console::WriteLine( &quot;GUID for ProgID DirControl.DirList.1 is {0}.&quot;, myType1-&gt;GUID );\n      \n      // Throw an exception because the ProgID is invalid and the throwOnError\n      // parameter is set to True.\n      Type^ myType2 = Type::GetTypeFromProgID( myString2, theServer, true );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;An exception occurred. The ProgID is wrong.&quot; );\n      Console::WriteLine( &quot;Source: {0}&quot;, e-&gt;Source );\n      Console::WriteLine( &quot;Message: {0}&quot;, e-&gt;Message );\n   }\n\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetTypeFromProgID4#1\">Imports System\nClass MainApp\n    Public Shared Sub Main()\n        Try\n            &#39; Use Server localhost.\n            Dim theServer As String = &quot;localhost&quot;\n            &#39; Use  ProgID HKEY_CLASSES_ROOT\\DirControl.DirList.1.\n            Dim myString1 As String = &quot;DirControl.DirList.1&quot;\n            &#39; Use a wrong ProgID WrongProgID.\n            Dim myString2 As String = &quot;WrongProgID&quot;\n            &#39; Make a call to the method to get the type information for the given ProgID.\n            Dim myType1 As Type = Type.GetTypeFromProgID(myString1, theServer, True)\n            Console.WriteLine(&quot;GUID for ProgID DirControl.DirList.1 is {0}.&quot;, myType1.GUID.ToString())\n            &#39; Throw an exception because the ProgID is invalid and the throwOnError \n            &#39; parameter is set to True.\n            Dim myType2 As Type = Type.GetTypeFromProgID(myString2, theServer, True)\n        Catch e As Exception\n            Console.WriteLine(&quot;An exception occurred. The ProgID is wrong.&quot;)\n            Console.WriteLine(&quot;Source: {0}&quot;, e.Source.ToString())\n            Console.WriteLine(&quot;Message: {0}&quot;, e.Message.ToString())\n        End Try\n    End Sub &#39;Main \nEnd Class &#39;MainApp\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_GetTypeHandle_System_Object_\">\r\n    \r\n            <a id=\"System_Type_GetTypeHandle_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetTypeHandle(Object)</div>        \r\n          </div>\r\n    \r\n            <p>Gets the handle for the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> of a specified object.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static RuntimeTypeHandle GetTypeHandle (object o);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>o</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object for which to get the type handle.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtimetypehandle\" data-linktype=\"relative-path\">RuntimeTypeHandle</a></div>\r\n                  </div>\r\n                  <p>The handle for the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> of the specified <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>o</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The handles are valid only in the application domain in which they were obtained.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example defines the class <code>MyClass1</code>, gets an instance of it, and retrieves the runtime handle of the object.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_GetTypeHandle#1\">using namespace System;\nusing namespace System::Reflection;\n\npublic ref class MyClass1\n{\nprivate:\n    int x;\n\npublic:\n    int MyMethod()\n    {\n        return x;\n    }\n};\n\nint main()\n{\n    MyClass1^ myClass1 = gcnew MyClass1;\n   \n    // Get the RuntimeTypeHandle from an object.\n    RuntimeTypeHandle myRTHFromObject = Type::GetTypeHandle( myClass1 );\n   \n    // Get the RuntimeTypeHandle from a type.\n    RuntimeTypeHandle myRTHFromType = MyClass1::typeid-&gt;TypeHandle;\n\n    Console::WriteLine( &quot;<br>myRTHFromObject.Value:  {0}&quot;, myRTHFromObject.Value );\n    Console::WriteLine( &quot;myRTHFromObject.GetType():  {0}&quot;, myRTHFromObject.GetType() );\n    Console::WriteLine( &quot;Get the type back from the handle...&quot; );\n    Console::WriteLine( &quot;Type::GetTypeFromHandle(myRTHFromObject):  {0}&quot;, \n        Type::GetTypeFromHandle(myRTHFromObject) );\n\n    Console::WriteLine( &quot;<br>myRTHFromObject.Equals(myRTHFromType):  {0}&quot;, \n        myRTHFromObject.Equals(myRTHFromType) );\n\n    Console::WriteLine( &quot;<br>myRTHFromType.Value:  {0}&quot;, myRTHFromType.Value );\n    Console::WriteLine( &quot;myRTHFromType.GetType():  {0}&quot;, myRTHFromType.GetType() );\n    Console::WriteLine( &quot;Get the type back from the handle...&quot; );\n    Console::WriteLine( &quot;Type::GetTypeFromHandle(myRTHFromType):  {0}&quot;, \n        Type::GetTypeFromHandle(myRTHFromType) );\n}\n\n/* This code example produces output similar to the following:\n\nmyRTHFromObject.Value:  3295832\nmyRTHFromObject.GetType():  System.RuntimeTypeHandle\nGet the type back from the handle...\nType::GetTypeFromHandle(myRTHFromObject):  MyClass1\n\nmyRTHFromObject.Equals(myRTHFromType):  True\n\nmyRTHFromType.Value:  3295832\nmyRTHFromType.GetType():  System.RuntimeTypeHandle\nGet the type back from the handle...\nType::GetTypeFromHandle(myRTHFromType):  MyClass1\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_GetTypeHandle#1\">Imports System\nImports System.Reflection\n\nPublic Class MyClass1\n    Private x As Integer = 0\n   \n    Public Function MyMethod() As Integer\n        Return x\n    End Function &#39;MyMethod\nEnd Class \n\nPublic Class MyClass2\n   \n    Public Shared Sub Main()\n        Dim myClass1 As New MyClass1()\n      \n        &#39; Get the RuntimeTypeHandle from an object.\n        Dim myRTHFromObject As RuntimeTypeHandle = Type.GetTypeHandle(myClass1)\n        &#39; Get the RuntimeTypeHandle from a type.\n        Dim myRTHFromType As RuntimeTypeHandle = GetType(MyClass1).TypeHandle\n      \n        Console.WriteLine(vbLf &amp; &quot;myRTHFromObject.Value:  {0}&quot;, _\n            myRTHFromObject.Value)\n        Console.WriteLine(&quot;myRTHFromObject.GetType():  {0}&quot;, _\n            myRTHFromObject.GetType())\n        Console.WriteLine(&quot;Get the type back from the handle...&quot;)\n        Console.WriteLine(&quot;Type.GetTypeFromHandle(myRTHFromObject):  {0}&quot;, _\n            Type.GetTypeFromHandle(myRTHFromObject))\n\n        Console.WriteLine(vbLf &amp; &quot;myRTHFromObject.Equals(myRTHFromType):  {0}&quot;, _\n            myRTHFromObject.Equals(myRTHFromType))\n\n        Console.WriteLine(vbLf &amp; &quot;myRTHFromType.Value:  {0}&quot;, _\n            myRTHFromType.Value)\n        Console.WriteLine(&quot;myRTHFromType.GetType():  {0}&quot;, _\n            myRTHFromType.GetType())\n        Console.WriteLine(&quot;Get the type back from the handle...&quot;)\n        Console.WriteLine(&quot;Type.GetTypeFromHandle(myRTHFromType):  {0}&quot;, _\n            Type.GetTypeFromHandle(myRTHFromType))\n    End Sub \nEnd Class \n\n&#39; This code example produces output similar to the following:\n&#39;\n&#39;myRTHFromObject.Value:  7549720\n&#39;myRTHFromObject.GetType():  System.RuntimeTypeHandle\n&#39;Get the type back from the handle...\n&#39;Type.GetTypeFromHandle(myRTHFromObject):  MyClass1\n&#39;\n&#39;myRTHFromObject.Equals(myRTHFromType):  True\n&#39;\n&#39;myRTHFromType.Value:  7549720\n&#39;myRTHFromType.GetType():  System.RuntimeTypeHandle\n&#39;Get the type back from the handle...\n&#39;Type.GetTypeFromHandle(myRTHFromType):  MyClass1\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_GetTypeHandle#1\">using System;\nusing System.Reflection;\n\npublic class MyClass1\n{\n    private int x=0;\n    public int MyMethod()\n    {\n        return x;\n    }\n}\n\npublic class MyClass2\n{\n    public static void Main()\n    {\n        MyClass1 myClass1 = new MyClass1();\n\n        // Get the RuntimeTypeHandle from an object.\n        RuntimeTypeHandle myRTHFromObject = Type.GetTypeHandle(myClass1);\n        // Get the RuntimeTypeHandle from a type.\n        RuntimeTypeHandle myRTHFromType = typeof(MyClass1).TypeHandle;\n\n        Console.WriteLine(&quot;<br>myRTHFromObject.Value:  {0}&quot;, myRTHFromObject.Value);\n        Console.WriteLine(&quot;myRTHFromObject.GetType():  {0}&quot;, myRTHFromObject.GetType());\n        Console.WriteLine(&quot;Get the type back from the handle...&quot;);\n        Console.WriteLine(&quot;Type.GetTypeFromHandle(myRTHFromObject):  {0}&quot;, \n            Type.GetTypeFromHandle(myRTHFromObject));\n\n        Console.WriteLine(&quot;<br>myRTHFromObject.Equals(myRTHFromType):  {0}&quot;, \n            myRTHFromObject.Equals(myRTHFromType));\n\n        Console.WriteLine(&quot;<br>myRTHFromType.Value:  {0}&quot;, myRTHFromType.Value);\n        Console.WriteLine(&quot;myRTHFromType.GetType():  {0}&quot;, myRTHFromType.GetType());\n        Console.WriteLine(&quot;Get the type back from the handle...&quot;);\n        Console.WriteLine(&quot;Type.GetTypeFromHandle(myRTHFromType):  {0}&quot;, \n            Type.GetTypeFromHandle(myRTHFromType));\n    }\n}\n\n/* This code example produces output similar to the following:\n\nmyRTHFromObject.Value:  799464\nmyRTHFromObject.GetType():  System.RuntimeTypeHandle\nGet the type back from the handle...\nType.GetTypeFromHandle(myRTHFromObject):  MyClass1\n\nmyRTHFromObject.Equals(myRTHFromType):  True\n\nmyRTHFromType.Value:  799464\nmyRTHFromType.GetType():  System.RuntimeTypeHandle\nGet the type back from the handle...\nType.GetTypeFromHandle(myRTHFromType):  MyClass1\n */\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_HasElementTypeImpl\">\r\n    \r\n            <a id=\"System_Type_HasElementTypeImpl_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">HasElementTypeImpl()</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, implements the <span class=\"xref\">stem.Type.HasElementType*</span> property and determines whether the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> encompasses or refers to another type; that is, whether the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is an array, a pointer, or is passed by reference.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected abstract bool HasElementTypeImpl ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is an array, a pointer, or is passed by reference; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>For example, Type.GetType(&quot;Int32[]&quot;).HasElementTypeImpl returns <code>true</code>, but Type.GetType(&quot;Int32&quot;).HasElementTypeImpl returns <code>false</code>. HasElementTypeImpl also returns <code>true</code> for &quot;Int32*&quot; and &quot;Int32&amp;&quot;.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example defines the class <code>MyTypeDelegator</code>, which overrides the <code>HasElementTypeImpl</code> method. The main class checks for the <code>HasElementType</code> property and displays the element type.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_HasElementTypeImpl#1\">using namespace System;\nusing namespace System::Reflection;\npublic ref class MyTypeDelegator: public TypeDelegator\n{\npublic:\n   String^ myElementType;\n\nprivate:\n   Type^ myType;\n\npublic:\n   MyTypeDelegator( Type^ myType )\n      : TypeDelegator( myType )\n   {\n      this-&gt;myType = myType;\n   }\n\n\nprotected:\n\n   // Override Type::HasElementTypeImpl().\n   virtual bool HasElementTypeImpl() override\n   {\n      \n      // Determine whether the type is an array.\n      if ( myType-&gt;IsArray )\n      {\n         myElementType = &quot;array&quot;;\n         return true;\n      }\n\n      \n      // Determine whether the type is a reference.\n      if ( myType-&gt;IsByRef )\n      {\n         myElementType = &quot;reference&quot;;\n         return true;\n      }\n\n      \n      // Determine whether the type is a pointer.\n      if ( myType-&gt;IsPointer )\n      {\n         myElementType = &quot;pointer&quot;;\n         return true;\n      }\n\n      \n      // Return false if the type is not a reference, array, or pointer type.\n      return false;\n   }\n\n};\n\nint main()\n{\n   try\n   {\n      int myInt = 0;\n      array&lt;Int32&gt;^myArray = gcnew array&lt;Int32&gt;(5);\n      MyTypeDelegator^ myType = gcnew MyTypeDelegator( myArray-&gt;GetType() );\n      \n      // Determine whether myType is an array, pointer, reference type.\n      Console::WriteLine( &quot;<br>Determine whether a variable is an array, pointer, or reference type.<br>&quot; );\n      if ( myType-&gt;HasElementType )\n            Console::WriteLine( &quot;The type of myArray is {0}.&quot;, myType-&gt;myElementType );\n      else\n            Console::WriteLine( &quot;myArray is not an array, pointer, or reference type.&quot; );\n      myType = gcnew MyTypeDelegator( myInt.GetType() );\n      \n      // Determine whether myType is an array, pointer, reference type.\n      if ( myType-&gt;HasElementType )\n            Console::WriteLine( &quot;The type of myInt is {0}.&quot;, myType-&gt;myElementType );\n      else\n            Console::WriteLine( &quot;myInt is not an array, pointer, or reference type.&quot; );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception: {0}&quot;, e-&gt;Message );\n   }\n\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_HasElementTypeImpl#1\">using System;\nusing System.Reflection;\npublic class MyTypeDelegator : TypeDelegator\n{\n    public string myElementType = null;\n    private Type myType = null ; \n    public MyTypeDelegator(Type myType) : base(myType)\n    {\n        this.myType = myType;\n    }\n    // Override Type.HasElementTypeImpl().\n    protected override bool HasElementTypeImpl()\n    {\n        // Determine whether the type is an array.\n        if(myType.IsArray)\n        {\n            myElementType = &quot;array&quot;;\n            return true;\n        }\n        // Determine whether the type is a reference.\n        if(myType.IsByRef)\n        {\n            myElementType = &quot;reference&quot;;\n            return true;\n        }\n        // Determine whether the type is a pointer.\n        if(myType.IsPointer)\n        { \n            myElementType = &quot;pointer&quot;;\n            return true;\n        }\n        // Return false if the type is not a reference, array, or pointer type.\n        return false;\n    }  \n}\npublic class Type_HasElementTypeImpl\n{\n    public static void Main()\n    {\n        try\n        {\n            int myInt = 0 ; \n            int[] myArray = new int[5];\n            MyTypeDelegator myType = new MyTypeDelegator(myArray.GetType());\n            // Determine whether myType is an array, pointer, reference type.  \n            Console.WriteLine(&quot;<br>Determine whether a variable is an array, pointer, or reference type.<br>&quot;);\n            if( myType.HasElementType)\n                Console.WriteLine(&quot;The type of myArray is {0}.&quot;, myType.myElementType);\n            else\n                Console.WriteLine(&quot;myArray is not an array, pointer, or reference type.&quot;);\n            myType = new MyTypeDelegator(myInt.GetType());\n            // Determine whether myType is an array, pointer, reference type. \n            if( myType.HasElementType)\n                Console.WriteLine(&quot;The type of myInt is {0}.&quot;, myType.myElementType);\n            else\n                Console.WriteLine(&quot;myInt is not an array, pointer, or reference type.&quot;);\n        }\n        catch( Exception e )\n        {\n            Console.WriteLine(&quot;Exception: {0}&quot;, e.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_HasElementTypeImpl#1\">Imports System\nImports System.Reflection\nImports Microsoft.VisualBasic\nPublic Class MyTypeDelegator\n    Inherits TypeDelegator\n    Public myElementType As String = Nothing\n    Private myType As Type = Nothing\n    Public Sub New(ByVal myType As Type)\n        MyBase.New(myType)\n        Me.myType = myType\n    End Sub &#39;New\n    &#39; Override Type.HasElementTypeImpl().\n    Protected Overrides Function HasElementTypeImpl() As Boolean\n        &#39; Determine whether the type is an array.\n        If myType.IsArray Then\n            myElementType = &quot;array&quot;\n            Return True\n        End If\n        &#39; Determine whether the type is a reference.\n        If myType.IsByRef Then\n            myElementType = &quot;reference&quot;\n            Return True\n        End If\n        &#39; Determine whether the type is a pointer.\n        If myType.IsPointer Then\n            myElementType = &quot;pointer&quot;\n            Return True\n        End If\n        &#39; The type is not a reference, array, or pointer type.\n        Return False\n    End Function &#39;HasElementTypeImpl\nEnd Class &#39;MyTypeDelegator\nPublic Class Type_HasElementTypeImpl\n    Public Shared Sub Main()\n        Try\n            Dim myInt As Integer = 0\n            Dim myArray(4) As Integer\n            Dim myType As New MyTypeDelegator(myArray.GetType())\n            Console.WriteLine(ControlChars.NewLine + &quot;Determine whether a variable refers to an array or pointer or reference type.&quot; + ControlChars.NewLine)\n            &#39; Determine whether myType is an array, pointer, reference type.  \n            If myType.HasElementType Then\n                Console.WriteLine(&quot;The type of myArray is {0}.&quot;, myType.myElementType.ToString())\n            Else\n                Console.WriteLine(&quot;myArray is not an array, pointer, or reference type.&quot;)\n            End If\n            myType = New MyTypeDelegator(myInt.GetType())\n            &#39; Determine whether myType is an array, pointer, reference type. \n            If myType.HasElementType Then\n                Console.WriteLine(&quot;The type of myInt is {0}.&quot;, myType.myElementType.ToString())\n            Else\n                Console.WriteLine(&quot;myInt is not an array, pointer, or reference type.&quot;)\n            End If\n        Catch e As Exception\n            Console.WriteLine(&quot;Exception: {0}&quot;, e.Message.ToString())\n        End Try\n    End Sub &#39;Main\nEnd Class &#39;Type_HasElementTypeImpl\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_InvokeMember_System_String_System_Reflection_BindingFlags_System_Reflection_Binder_System_Object_System_Object___\">\r\n    \r\n            <a id=\"System_Type_InvokeMember_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">InvokeMember(String,BindingFlags,Binder,Object,Object[])</div>        \r\n          </div>\r\n    \r\n            <p>Invokes the specified member, using the specified binding constraints and matching the specified argument list.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the constructor, method, property, or field member to invoke.  </p>\n<p> -or-  </p>\n<p> An empty string (&quot;&quot;) to invoke the default member.  </p>\n<p> -or-  </p>\n<p> For <code>IDispatch</code> members, a string representing the DispID, for example &quot;[DispID=3]&quot;.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>invokeAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted. The access can be one of the <code>BindingFlags</code> such as <code>Public</code>, <code>NonPublic</code>, <code>Private</code>, <code>InvokeMethod</code>, <code>GetField</code>, and so on. The type of lookup need not be specified. If the type of lookup is omitted, <code>BindingFlags.Public</code> | <code>BindingFlags.Instance</code> | <code>BindingFlags.Static</code> are used.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>binder</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  </p>\n<p> -or-  </p>\n<p> A null reference (<code>Nothing</code> in Visual Basic), to use the <span class=\"xref\">stem.Type.DefaultBinder*</span>. Note that explicitly defining a <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a> object may be required for successfully invoking method overloads with variable arguments.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>target</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object on which to invoke the specified member.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>args</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array containing the arguments to pass to the member to invoke.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></div>\r\n                  </div>\r\n                  <p>An object representing the return value of the invoked member.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>invokeAttr</code> does not contain <code>CreateInstance</code> and <code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>invokeAttr</code> is not a valid <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> attribute.  </p>\n<p> -or-  </p>\n<p> <code>invokeAttr</code> does not contain one of the following binding flags: <code>InvokeMethod</code>, <code>CreateInstance</code>, <code>GetField</code>, <code>SetField</code>, <code>GetProperty</code>, or <code>SetProperty</code>.  </p>\n<p> -or-  </p>\n<p> <code>invokeAttr</code> contains <code>CreateInstance</code> combined with <code>InvokeMethod</code>, <code>GetField</code>, <code>SetField</code>, <code>GetProperty</code>, or <code>SetProperty</code>.  </p>\n<p> -or-  </p>\n<p> <code>invokeAttr</code> contains both <code>GetField</code> and <code>SetField</code>.  </p>\n<p> -or-  </p>\n<p> <code>invokeAttr</code> contains both <code>GetProperty</code> and <code>SetProperty</code>.  </p>\n<p> -or-  </p>\n<p> <code>invokeAttr</code> contains <code>InvokeMethod</code> combined with <code>SetField</code> or <code>SetProperty</code>.  </p>\n<p> -or-  </p>\n<p> <code>invokeAttr</code> contains <code>SetField</code> and <code>args</code> has more than one element.  </p>\n<p> -or-  </p>\n<p> This method is called on a COM object and one of the following binding flags was not passed in: <code>BindingFlags.InvokeMethod</code>, <code>BindingFlags.GetProperty</code>, <code>BindingFlags.SetProperty</code>, <code>BindingFlags.PutDispProperty</code>, or <code>BindingFlags.PutRefDispProperty</code>.  </p>\n<p> -or-  </p>\n<p> One of the named parameter arrays contains a string that is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.methodaccessexception\" data-linktype=\"relative-path\">MethodAccessException</a></div>\r\n                  </div>\r\n                  <p>The specified member is a class initializer.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.missingfieldexception\" data-linktype=\"relative-path\">MissingFieldException</a></div>\r\n                  </div>\r\n                  <p>The field or property cannot be found.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.missingmethodexception\" data-linktype=\"relative-path\">MissingMethodException</a></div>\r\n                  </div>\r\n                  <p>No method can be found that matches the arguments in <code>args</code>.  </p>\n<p> -or-  </p>\n<p> The current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents a type that contains open type parameters, that is, <span class=\"xref\">stem.Type.ContainsGenericParameters*</span> returns <code>true</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.targetexception\" data-linktype=\"relative-path\">TargetException</a></div>\r\n                  </div>\r\n                  <p>The specified member cannot be invoked on <code>target</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a></div>\r\n                  </div>\r\n                  <p>More than one method matches the binding criteria.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The .NET Compact Framework does not currently support this method.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The method represented by <code>name</code> has one or more unspecified generic type parameters. That is, the method&#39;s <span class=\"xref\">stem.Reflection.MethodInfo.ContainsGenericParameters*</span> property returns <code>true</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <div class=\"NOTE\"><h5>Note</h5><p> You cannot use InvokeMember to invoke a generic method.  </p>\n</div>\n<p> The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which members to include in the search:  </p>\n<ul>\n<li><p>Specify <code>BindingFlags.Public</code> to include public members in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.NonPublic</code> to include non-public members (that is, private and protected members) in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.FlattenHierarchy</code> to include static members up the hierarchy.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> modifier flags can be used to change how the search works:  </p>\n</li>\n<li><p><code>BindingFlags.IgnoreCase</code> to ignore the case of <code>name</code>.  </p>\n</li>\n<li><p><code>BindingFlags.DeclaredOnly</code> to search only the members declared on the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, not members that were simply inherited.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> invocation flags can be used to denote what action to take with the member:  </p>\n</li>\n<li><p><code>CreateInstance</code> to invoke a constructor. <code>name</code> is ignored. Not valid with other invocation flags.  </p>\n</li>\n<li><p><code>InvokeMethod</code> to invoke a method, but not a constructor or a type initializer. Not valid with <code>SetField</code> or <code>SetProperty</code>. If <code>InvokeMethod</code> is specified by itself, <code>BindingFlags.Public</code>, <code>BindingFlags.Instance</code>, and <code>BindingFlags.Static</code> are automatically included.  </p>\n</li>\n<li><p><code>GetField</code> to get the value of a field. Not valid with <code>SetField</code>.  </p>\n</li>\n<li><p><code>SetField</code> to set the value of a field. Not valid with <code>GetField</code>.  </p>\n</li>\n<li><p><code>GetProperty</code> to get a property. Not valid with <code>SetProperty</code>.  </p>\n</li>\n<li><p><code>SetProperty</code> to set a property. Not valid with <code>GetProperty</code>.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.  </p>\n<p>A method will be invoked if both of the following conditions are true:  </p>\n</li>\n<li><p>The number of parameters in the method declaration equals the number of arguments in the <code>args</code> array (unless default arguments are defined on the member and <code>BindingFlags.OptionalParamBinding</code> is specified).  </p>\n</li>\n<li><p>The type of each argument can be converted by the binder to the type of the parameter.  </p>\n<p>The binder will find all of the matching methods. These methods are found based upon the type of binding requested (<a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> values <code>InvokeMethod</code>, <code>GetProperty</code>, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.  </p>\n<p>After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The <a class=\"xref\" href=\"system.reflection.binder#System_Reflection_Binder_BindToMethod_\" data-linktype=\"relative-path\">BindToMethod</a> method of the <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.  </p>\n<p>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <a class=\"xref\" href=\"system.reflection\" data-linktype=\"relative-path\">System.Reflection</a> whenever the code is fully trusted.  </p>\n<p>You can use <code>Type.InvokeMember</code> to set a field to a particular value by specifying <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a>. For example, if you want to set a public instance field named F on class C, and F is a <code>String</code>, you can use code such as:  </p>\n<p><code>typeof(C).InvokeMember(&quot;F&quot;, BindingFlags.SetField, null, c, new Object[] {&quot;strings new value&quot;});</code>  </p>\n<p>If F is a <code>String[]</code>, you can use code such as:  </p>\n<p><code>typeof(C).InvokeMember(&quot;F&quot;, BindingFlags.SetField, null, c, new Object[] {new String[]{&quot;a&quot;,&quot;z&quot;,&quot;c&quot;,&quot;d&quot;}});</code>  </p>\n<p>which will initialize the field F to this new array. You can also use <code>Type.InvokeMember</code> to set a position in an array by supplying the index of the value and then the next value by using code such as the following:  </p>\n<p><code>typeof(C).InvokeMember(&quot;F&quot;, BindingFlags.SetField, null, c, new Object[] {1, &quot;b&quot;});</code>  </p>\n<p>This will change string &quot;z&quot; in the array that F holds to string &quot;b&quot;.  </p>\n<p>When you invoke an <code>IDispatch</code> member, you can specify the DispID instead of the member name, using the string format &quot;[DispID=##]&quot;. For example, if the DispID of MyComMethod is 3, you can specify the string &quot;[DispID=3]&quot; instead of &quot;MyComMethod&quot;. Invoking a member by DispID is faster than looking up the member by name. In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.  </p>\n</li>\n</ul>\n<div class=\"NOTE\"><h5>Note</h5><p> Starting with the <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/net-v20sp1-long-md.md&quot; -->.NET Framework 2.0 Service Pack 1<!--END INCLUDE -->, this method can be used to access non-public members if the caller has been granted <a class=\"xref\" href=\"system.security.permissions.reflectionpermission\" data-linktype=\"relative-path\">ReflectionPermission</a> with the <a class=\"xref\" href=\"system.security.permissions.reflectionpermissionflag\" data-linktype=\"relative-path\">System.Security.Permissions.ReflectionPermissionFlag</a> flag and if the grant set of the non-public members is restricted to the callers grant set, or a subset thereof. (See <a href=\"../Topic/Security%20Considerations%20for%20Reflection.md\" data-linktype=\"relative-path\">Security Considerations for Reflection</a>.)  </p>\n<p> To use this functionality, your application should target the <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/net-v35-long-md.md&quot; --> .NET Framework 3.5 <!--END INCLUDE --> or later.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses <code>InvokeMember</code> to access members of a type.  </p>\n<pre><code class=\"lang-cs\" name=\"InvokeMem#1\">using System;\nusing System.Reflection;\n\n// This sample class has a field, constructor, method, and property.\nclass MyType \n{\n    Int32 myField;\n    public MyType(ref Int32 x) {x *= 5;}\n    public override String ToString() {return myField.ToString();}\n    public Int32 MyProp \n    {\n        get {return myField;}\n        set \n        { \n            if (value &lt; 1) \n                throw new ArgumentOutOfRangeException(&quot;value&quot;, value, &quot;value must be &gt; 0&quot;);\n            myField = value;\n        }\n    }\n}\n\nclass MyApp \n{\n    static void Main() \n    {\n        Type t = typeof(MyType);\n        // Create an instance of a type.\n        Object[] args = new Object[] {8};\n        Console.WriteLine(&quot;The value of x before the constructor is called is {0}.&quot;, args[0]);\n        Object obj = t.InvokeMember(null, \n            BindingFlags.DeclaredOnly | \n            BindingFlags.Public | BindingFlags.NonPublic | \n            BindingFlags.Instance | BindingFlags.CreateInstance, null, null, args);\n        Console.WriteLine(&quot;Type: &quot; + obj.GetType().ToString());\n        Console.WriteLine(&quot;The value of x after the constructor returns is {0}.&quot;, args[0]);\n\n        // Read and write to a field.\n        t.InvokeMember(&quot;myField&quot;, \n            BindingFlags.DeclaredOnly | \n            BindingFlags.Public | BindingFlags.NonPublic | \n            BindingFlags.Instance | BindingFlags.SetField, null, obj, new Object[] {5});\n        Int32 v = (Int32) t.InvokeMember(&quot;myField&quot;, \n            BindingFlags.DeclaredOnly | \n            BindingFlags.Public | BindingFlags.NonPublic | \n            BindingFlags.Instance | BindingFlags.GetField, null, obj, null);\n        Console.WriteLine(&quot;myField: &quot; + v);\n\n        // Call a method.\n        String s = (String) t.InvokeMember(&quot;ToString&quot;, \n            BindingFlags.DeclaredOnly | \n            BindingFlags.Public | BindingFlags.NonPublic | \n            BindingFlags.Instance | BindingFlags.InvokeMethod, null, obj, null);\n        Console.WriteLine(&quot;ToString: &quot; + s);\n\n        // Read and write a property. First, attempt to assign an\n        // invalid value; then assign a valid value; finally, get\n        // the value.\n        try \n        {\n            // Assign the value zero to MyProp. The Property Set \n            // throws an exception, because zero is an invalid value.\n            // InvokeMember catches the exception, and throws \n            // TargetInvocationException. To discover the real cause\n            // you must catch TargetInvocationException and examine\n            // the inner exception. \n            t.InvokeMember(&quot;MyProp&quot;, \n                BindingFlags.DeclaredOnly | \n                BindingFlags.Public | BindingFlags.NonPublic | \n                BindingFlags.Instance | BindingFlags.SetProperty, null, obj, new Object[] {0});\n        } \n        catch (TargetInvocationException e) \n        {\n            // If the property assignment failed for some unexpected\n            // reason, rethrow the TargetInvocationException.\n            if (e.InnerException.GetType() != \n                typeof(ArgumentOutOfRangeException)) \n                throw;\n            Console.WriteLine(&quot;An invalid value was assigned to MyProp.&quot;);\n        }\n        t.InvokeMember(&quot;MyProp&quot;, \n            BindingFlags.DeclaredOnly | \n            BindingFlags.Public | BindingFlags.NonPublic | \n            BindingFlags.Instance | BindingFlags.SetProperty, null, obj, new Object[] {2});\n        v = (Int32) t.InvokeMember(&quot;MyProp&quot;, \n            BindingFlags.DeclaredOnly | \n            BindingFlags.Public | BindingFlags.NonPublic | \n            BindingFlags.Instance | BindingFlags.GetProperty, null, obj, null);\n        Console.WriteLine(&quot;MyProp: &quot; + v);\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"InvokeMem#1\">Imports System\nImports System.Reflection\n\n&#39; This sample class has a field, constructor, method, and property.\nClass MyType\n    Private myField As Int32\n\n    Public Sub New(ByRef x As Int32)\n        x *= 5\n    End Sub &#39;New\n\n    Public Overrides Function ToString() As [String]\n        Return myField.ToString()\n    End Function &#39;ToString\n\n    Public Property MyProp() As Int32\n        Get\n            Return myField\n        End Get\n        Set(ByVal Value As Int32)\n            If Value &lt; 1 Then\n                Throw New ArgumentOutOfRangeException(&quot;value&quot;, Value, &quot;value must be &gt; 0&quot;)\n            End If\n            myField = Value\n        End Set\n    End Property\nEnd Class &#39;MyType\n\nClass MyApp\n\n    Shared Sub Main()\n        Dim t As Type = GetType(MyType)\n        &#39; Create an instance of a type.\n        Dim args() As [Object] = {8}\n        Console.WriteLine(&quot;The value of x before the constructor is called is {0}.&quot;, args(0))\n        Dim obj As [Object] = t.InvokeMember(Nothing, BindingFlags.DeclaredOnly Or BindingFlags.Public Or BindingFlags.NonPublic Or BindingFlags.Instance Or BindingFlags.CreateInstance, Nothing, Nothing, args)\n        Console.WriteLine(&quot;Type: {0}&quot;, obj.GetType().ToString())\n        Console.WriteLine(&quot;The value of x after the constructor returns is {0}.&quot;, args(0))\n\n        &#39; Read and write to a field.\n        t.InvokeMember(&quot;myField&quot;, BindingFlags.DeclaredOnly Or BindingFlags.Public Or BindingFlags.NonPublic Or BindingFlags.Instance Or BindingFlags.SetField, Nothing, obj, New [Object]() {5})\n        Dim v As Int32 = CType(t.InvokeMember(&quot;myField&quot;, BindingFlags.DeclaredOnly Or BindingFlags.Public Or BindingFlags.NonPublic Or BindingFlags.Instance Or BindingFlags.GetField, Nothing, obj, Nothing), Int32)\n        Console.WriteLine(&quot;myField: {0}&quot;, v)\n\n        &#39; Call a method.\n        Dim s As [String] = CType(t.InvokeMember(&quot;ToString&quot;, BindingFlags.DeclaredOnly Or BindingFlags.Public Or BindingFlags.NonPublic Or BindingFlags.Instance Or BindingFlags.InvokeMethod, Nothing, obj, Nothing), [String])\n        Console.WriteLine(&quot;ToString: {0}&quot;, s)\n\n        &#39; Read and write a property. First, attempt to assign an\n        &#39; invalid value; then assign a valid value; finally, get\n        &#39; the value.\n        Try\n            &#39; Assign the value zero to MyProp. The Property Set \n            &#39; throws an exception, because zero is an invalid value.\n            &#39; InvokeMember catches the exception, and throws \n            &#39; TargetInvocationException. To discover the real cause\n            &#39; you must catch TargetInvocationException and examine\n            &#39; the inner exception. \n            t.InvokeMember(&quot;MyProp&quot;, BindingFlags.DeclaredOnly Or BindingFlags.Public Or BindingFlags.NonPublic Or BindingFlags.Instance Or BindingFlags.SetProperty, Nothing, obj, New [Object]() {0})\n        Catch e As TargetInvocationException\n            &#39; If the property assignment failed for some unexpected\n            &#39; reason, rethrow the TargetInvocationException.\n            If Not e.InnerException.GetType() Is GetType(ArgumentOutOfRangeException) Then\n                Throw\n            End If\n            Console.WriteLine(&quot;An invalid value was assigned to MyProp.&quot;)\n        End Try\n        t.InvokeMember(&quot;MyProp&quot;, BindingFlags.DeclaredOnly Or BindingFlags.Public Or BindingFlags.NonPublic Or BindingFlags.Instance Or BindingFlags.SetProperty, Nothing, obj, New [Object]() {2})\n        v = CType(t.InvokeMember(&quot;MyProp&quot;, BindingFlags.DeclaredOnly Or BindingFlags.Public Or BindingFlags.NonPublic Or BindingFlags.Instance Or BindingFlags.GetProperty, Nothing, obj, Nothing), Int32)\n        Console.WriteLine(&quot;MyProp: {0}&quot;, v)\n    End Sub &#39;Main\nEnd Class &#39;MyApp\n</code></pre><pre><code class=\"lang-cpp\" name=\"InvokeMem#1\">using namespace System;\nusing namespace System::Reflection;\n\n// This sample class has a field, constructor, method, and property.\nref class MyType\n{\nprivate:\n   Int32 myField;\n\npublic:\n   MyType( interior_ptr&lt;Int32&gt; x )\n   {\n       *x *= 5;\n   }\n\n   virtual String^ ToString() override\n   {\n      return myField.ToString();\n   }\n\n   property Int32 MyProp \n   {\n      Int32 get()\n      {\n         return myField;\n      }\n\n      void set( Int32 value )\n      {\n         if ( value &lt; 1 )\n                  throw gcnew ArgumentOutOfRangeException( &quot;value&quot;,value,&quot;value must be &gt; 0&quot; );\n\n         myField = value;\n      }\n   }\n};\n\nint main()\n{\n   Type^ t = MyType::typeid;\n\n   // Create an instance of a type.\n   array&lt;Object^&gt;^args = {8};\n   Console::WriteLine( &quot;The value of x before the constructor is called is {0}.&quot;, args[ 0 ] );\n   Object^ obj = t-&gt;InvokeMember( nullptr, static_cast&lt;BindingFlags&gt;(BindingFlags::DeclaredOnly | BindingFlags::Public | BindingFlags::NonPublic | BindingFlags::Instance | BindingFlags::CreateInstance), nullptr, nullptr, args );\n   Console::WriteLine( &quot;Type: {0}&quot;, obj-&gt;GetType() );\n   Console::WriteLine( &quot;The value of x after the constructor returns is {0}.&quot;, args[ 0 ] );\n\n   // Read and write to a field.\n   array&lt;Object^&gt;^obj5 = {5};\n   t-&gt;InvokeMember( &quot;myField&quot;, static_cast&lt;BindingFlags&gt;(BindingFlags::DeclaredOnly | BindingFlags::Public | BindingFlags::NonPublic | BindingFlags::Instance | BindingFlags::SetField), nullptr, obj, obj5 );\n   Int32 v = safe_cast&lt;Int32&gt;(t-&gt;InvokeMember( &quot;myField&quot;, static_cast&lt;BindingFlags&gt;(BindingFlags::DeclaredOnly | BindingFlags::Public | BindingFlags::NonPublic | BindingFlags::Instance | BindingFlags::GetField), nullptr, obj, nullptr ));\n   Console::WriteLine( &quot;myField: {0}&quot;, v );\n\n   // Call a method.\n   String^ s = safe_cast&lt;String^&gt;(t-&gt;InvokeMember( &quot;ToString&quot;, static_cast&lt;BindingFlags&gt;(BindingFlags::DeclaredOnly | BindingFlags::Public | BindingFlags::NonPublic | BindingFlags::Instance | BindingFlags::InvokeMethod), nullptr, obj, nullptr ));\n   Console::WriteLine( &quot;ToString: {0}&quot;, s );\n\n   // Read and write a property. First, attempt to assign an\n   // invalid value; then assign a valid value; finally, get\n   // the value.\n   try\n   {\n      // Assign the value zero to MyProp. The Property Set \n      // throws an exception, because zero is an invalid value.\n      // InvokeMember catches the exception, and throws \n      // TargetInvocationException. To discover the real cause\n      // you must catch TargetInvocationException and examine\n      // the inner exception. \n      array&lt;Object^&gt;^obj0 = {(int^)0};\n      t-&gt;InvokeMember( &quot;MyProp&quot;, static_cast&lt;BindingFlags&gt;(BindingFlags::DeclaredOnly | BindingFlags::Public | BindingFlags::NonPublic | BindingFlags::Instance | BindingFlags::SetProperty), nullptr, obj, obj0 );\n   }\n   catch ( TargetInvocationException^ e ) \n   {\n      // If the property assignment failed for some unexpected\n      // reason, rethrow the TargetInvocationException.\n      if ( e-&gt;InnerException-&gt;GetType() != ArgumentOutOfRangeException::typeid )\n            throw;\n\n      Console::WriteLine( &quot;An invalid value was assigned to MyProp.&quot; );\n   }\n\n   array&lt;Object^&gt;^obj2 = {2};\n   t-&gt;InvokeMember( &quot;MyProp&quot;, static_cast&lt;BindingFlags&gt;(BindingFlags::DeclaredOnly | BindingFlags::Public | BindingFlags::NonPublic | BindingFlags::Instance | BindingFlags::SetProperty), nullptr, obj, obj2 );\n   v =  safe_cast&lt;Int32&gt;(t-&gt;InvokeMember( &quot;MyProp&quot;, static_cast&lt;BindingFlags&gt;(BindingFlags::DeclaredOnly | BindingFlags::Public | BindingFlags::NonPublic | BindingFlags::Instance | BindingFlags::GetProperty), nullptr, obj, nullptr ));\n   Console::WriteLine( &quot;MyProp: {0}&quot;, v );\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_InvokeMember_System_String_System_Reflection_BindingFlags_System_Reflection_Binder_System_Object_System_Object___System_Globalization_CultureInfo_\">\r\n    \r\n            <a id=\"System_Type_InvokeMember_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">InvokeMember(String,BindingFlags,Binder,Object,Object[],CultureInfo)</div>        \r\n          </div>\r\n    \r\n            <p>Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the constructor, method, property, or field member to invoke.  </p>\n<p> -or-  </p>\n<p> An empty string (&quot;&quot;) to invoke the default member.  </p>\n<p> -or-  </p>\n<p> For <code>IDispatch</code> members, a string representing the DispID, for example &quot;[DispID=3]&quot;.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>invokeAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted. The access can be one of the <code>BindingFlags</code> such as <code>Public</code>, <code>NonPublic</code>, <code>Private</code>, <code>InvokeMethod</code>, <code>GetField</code>, and so on. The type of lookup need not be specified. If the type of lookup is omitted, <code>BindingFlags.Public</code> | <code>BindingFlags.Instance</code> | <code>BindingFlags.Static</code> are used.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>binder</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  </p>\n<p> -or-  </p>\n<p> A null reference (<code>Nothing</code> in Visual Basic), to use the <span class=\"xref\">stem.Type.DefaultBinder*</span>. Note that explicitly defining a <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a> object may be required for successfully invoking method overloads with variable arguments.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>target</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object on which to invoke the specified member.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>args</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array containing the arguments to pass to the member to invoke.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>culture</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.globalization.cultureinfo\" data-linktype=\"relative-path\">CultureInfo</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a> to a <a class=\"xref\" href=\"system.double\" data-linktype=\"relative-path\">Double</a>.  </p>\n<p> -or-  </p>\n<p> A null reference (<code>Nothing</code> in Visual Basic) to use the current thread&#39;s <a class=\"xref\" href=\"system.globalization.cultureinfo\" data-linktype=\"relative-path\">CultureInfo</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></div>\r\n                  </div>\r\n                  <p>An object representing the return value of the invoked member.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>invokeAttr</code> does not contain <code>CreateInstance</code> and <code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>invokeAttr</code> is not a valid <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> attribute.  </p>\n<p> -or-  </p>\n<p> <code>invokeAttr</code> does not contain one of the following binding flags: <code>InvokeMethod</code>, <code>CreateInstance</code>, <code>GetField</code>, <code>SetField</code>, <code>GetProperty</code>, or <code>SetProperty</code>.  </p>\n<p> -or-  </p>\n<p> <code>invokeAttr</code> contains <code>CreateInstance</code> combined with <code>InvokeMethod</code>, <code>GetField</code>, <code>SetField</code>, <code>GetProperty</code>, or <code>SetProperty</code>.  </p>\n<p> -or-  </p>\n<p> <code>invokeAttr</code> contains both <code>GetField</code> and <code>SetField</code>.  </p>\n<p> -or-  </p>\n<p> <code>invokeAttr</code> contains both <code>GetProperty</code> and <code>SetProperty</code>.  </p>\n<p> -or-  </p>\n<p> <code>invokeAttr</code> contains <code>InvokeMethod</code> combined with <code>SetField</code> or <code>SetProperty</code>.  </p>\n<p> -or-  </p>\n<p> <code>invokeAttr</code> contains <code>SetField</code> and <code>args</code> has more than one element.  </p>\n<p> -or-  </p>\n<p> This method is called on a COM object and one of the following binding flags was not passed in: <code>BindingFlags.InvokeMethod</code>, <code>BindingFlags.GetProperty</code>, <code>BindingFlags.SetProperty</code>, <code>BindingFlags.PutDispProperty</code>, or <code>BindingFlags.PutRefDispProperty</code>.  </p>\n<p> -or-  </p>\n<p> One of the named parameter arrays contains a string that is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.methodaccessexception\" data-linktype=\"relative-path\">MethodAccessException</a></div>\r\n                  </div>\r\n                  <p>The specified member is a class initializer.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.missingfieldexception\" data-linktype=\"relative-path\">MissingFieldException</a></div>\r\n                  </div>\r\n                  <p>The field or property cannot be found.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.missingmethodexception\" data-linktype=\"relative-path\">MissingMethodException</a></div>\r\n                  </div>\r\n                  <p>No method can be found that matches the arguments in <code>args</code>.  </p>\n<p> -or-  </p>\n<p> The current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents a type that contains open type parameters, that is, <span class=\"xref\">stem.Type.ContainsGenericParameters*</span> returns <code>true</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.targetexception\" data-linktype=\"relative-path\">TargetException</a></div>\r\n                  </div>\r\n                  <p>The specified member cannot be invoked on <code>target</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a></div>\r\n                  </div>\r\n                  <p>More than one method matches the binding criteria.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The method represented by <code>name</code> has one or more unspecified generic type parameters. That is, the method&#39;s <span class=\"xref\">stem.Reflection.MethodInfo.ContainsGenericParameters*</span> property returns <code>true</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Although the default binder does not process <a class=\"xref\" href=\"system.globalization.cultureinfo\" data-linktype=\"relative-path\">CultureInfo</a> (the <code>culture</code>parameter), you can use the abstract <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">System.Reflection.Binder</a> class to write a custom binder that does process <code>culture</code>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> You cannot use <a class=\"xref\" href=\"system.type#System_Type_InvokeMember_\" data-linktype=\"relative-path\">InvokeMember</a> to invoke a generic method.  </p>\n</div>\n<p> The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which members to include in the search:  </p>\n<ul>\n<li><p>Specify <code>BindingFlags.Public</code> to include public members in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.NonPublic</code> to include non-public members (that is, private, internal, and protected members) in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.FlattenHierarchy</code> to include static members up the hierarchy.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> modifier flags can be used to change how the search works:  </p>\n</li>\n<li><p><code>BindingFlags.IgnoreCase</code> to ignore the case of <code>name</code>.  </p>\n</li>\n<li><p><code>BindingFlags.DeclaredOnly</code> to search only the members declared on the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, not members that were simply inherited.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> invocation flags can be used to denote what action to take with the member:  </p>\n</li>\n<li><p><code>CreateInstance</code> to invoke a constructor. <code>name</code> is ignored. Not valid with other invocation flags.  </p>\n</li>\n<li><p><code>InvokeMethod</code> to invoke a method, but not a constructor or a type initializer. Not valid with <code>SetField</code> or <code>SetProperty</code>. If <code>InvokeMethod</code> is specified by itself, <code>BindingFlags.Public</code>, <code>BindingFlags.Instance</code>, and <code>BindingFlags.Static</code> are automatically included.  </p>\n</li>\n<li><p><code>GetField</code> to get the value of a field. Not valid with <code>SetField</code>.  </p>\n</li>\n<li><p><code>SetField</code> to set the value of a field. Not valid with <code>GetField</code>.  </p>\n</li>\n<li><p><code>GetProperty</code> to get a property. Not valid with <code>SetProperty</code>.  </p>\n</li>\n<li><p><code>SetProperty</code> to set a property. Not valid with <code>GetProperty</code>.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.  </p>\n<p>A method will be invoked if both of the following conditions are true:  </p>\n</li>\n<li><p>The number of parameters in the method declaration equals the number of arguments in the <code>args</code> array (unless default arguments are defined on the member and <code>BindingFlags.OptionalParamBinding</code> is specified).  </p>\n</li>\n<li><p>The type of each argument can be converted by the binder to the type of the parameter.  </p>\n<p>The binder will find all of the matching methods. These methods are found based upon the type of binding requested (<a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> values <code>InvokeMethod</code>, <code>GetProperty</code>, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.  </p>\n<p>After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The <a class=\"xref\" href=\"system.reflection.binder#System_Reflection_Binder_BindToMethod_\" data-linktype=\"relative-path\">BindToMethod</a> method of the <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.  </p>\n<p>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.  </p>\n<p>You can use <code>Type.InvokeMember</code> to set a field to a particular value by specifying <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a>. For example, if you want to set a public instance field named F on class C, and F is a <code>String</code> you can use code such as:  </p>\n<p><code>typeof(C).InvokeMember(&quot;F&quot;, BindingFlags.SetField, null, c, new Object[] {&quot;strings new value&quot;}, null);</code>  </p>\n<p>If F is a <code>String[]</code>, you can use code such as:  </p>\n<p><code>typeof(C).InvokeMember(&quot;F&quot;, BindingFlags.SetField, null, c, new Object[] {new String[]{&quot;a&quot;,&quot;z&quot;,&quot;c&quot;,&quot;d&quot;}}, null);</code>  </p>\n<p>which will initialize the field F to this new array. You can also use <code>Type.InvokeMember</code> to set a position in an array by supplying the index of the value and then the next value by using code such as the following:  </p>\n<p><code>typeof(C).InvokeMember(&quot;F&quot;, BindingFlags.SetField, null, c, new Object[] {1, &quot;b&quot;}, null);</code>  </p>\n<p>This will change string &quot;z&quot; in the array that F holds to string &quot;b&quot;.  </p>\n<p>When you invoke an <code>IDispatch</code> member you can specify the DispID instead of the member name, using the string format &quot;[DispID=##]&quot;. For example, if the DispID of MyComMethod is 3, you can specify the string &quot;[DispID=3]&quot; instead of &quot;MyComMethod&quot;. Invoking a member by DispID is faster than looking up the member by name. In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.  </p>\n</li>\n</ul>\n<div class=\"NOTE\"><h5>Note</h5><p> Starting with the <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/net-v20sp1-long-md.md&quot; -->.NET Framework 2.0 Service Pack 1<!--END INCLUDE -->, this method can be used to access non-public members if the caller has been granted <a class=\"xref\" href=\"system.security.permissions.reflectionpermission\" data-linktype=\"relative-path\">ReflectionPermission</a> with the <a class=\"xref\" href=\"system.security.permissions.reflectionpermissionflag\" data-linktype=\"relative-path\">System.Security.Permissions.ReflectionPermissionFlag</a> flag and if the grant set of the non-public members is restricted to the callers grant set, or a subset thereof. (See <a href=\"../Topic/Security%20Considerations%20for%20Reflection.md\" data-linktype=\"relative-path\">Security Considerations for Reflection</a>.)  </p>\n<p> To use this functionality, your application should target the <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/net-v35-long-md.md&quot; --> .NET Framework 3.5 <!--END INCLUDE --> or later.</p>\n</div>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_InvokeMember_System_String_System_Reflection_BindingFlags_System_Reflection_Binder_System_Object_System_Object___System_Reflection_ParameterModifier___System_Globalization_CultureInfo_System_String___\">\r\n    \r\n            <a id=\"System_Type_InvokeMember_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">InvokeMember(String,BindingFlags,Binder,Object,Object[],ParameterModifier[],CultureInfo,String[])</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string containing the name of the constructor, method, property, or field member to invoke.  </p>\n<p> -or-  </p>\n<p> An empty string (&quot;&quot;) to invoke the default member.  </p>\n<p> -or-  </p>\n<p> For <code>IDispatch</code> members, a string representing the DispID, for example &quot;[DispID=3]&quot;.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>invokeAttr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitmask comprised of one or more <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> that specify how the search is conducted. The access can be one of the <code>BindingFlags</code> such as <code>Public</code>, <code>NonPublic</code>, <code>Private</code>, <code>InvokeMethod</code>, <code>GetField</code>, and so on. The type of lookup need not be specified. If the type of lookup is omitted, <code>BindingFlags.Public</code> | <code>BindingFlags.Instance</code> | <code>BindingFlags.Static</code> are used.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>binder</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  </p>\n<p> -or-  </p>\n<p> A null reference (Nothing in Visual Basic), to use the <span class=\"xref\">stem.Type.DefaultBinder*</span>. Note that explicitly defining a <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a> object may be required for successfully invoking method overloads with variable arguments.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>target</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object on which to invoke the specified member.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>args</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array containing the arguments to pass to the member to invoke.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>modifiers</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of <a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a> objects representing the attributes associated with the corresponding element in the <code>args</code> array. A parameter&#39;s associated attributes are stored in the member&#39;s signature.  </p>\n<p> The default binder processes this parameter only when calling a COM component.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>culture</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.globalization.cultureinfo\" data-linktype=\"relative-path\">CultureInfo</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.globalization.cultureinfo\" data-linktype=\"relative-path\">CultureInfo</a> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.  </p>\n<p> -or-  </p>\n<p> A null reference (<code>Nothing</code> in Visual Basic) to use the current thread&#39;s <a class=\"xref\" href=\"system.globalization.cultureinfo\" data-linktype=\"relative-path\">CultureInfo</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>namedParameters</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array containing the names of the parameters to which the values in the <code>args</code> array are passed.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></div>\r\n                  </div>\r\n                  <p>An object representing the return value of the invoked member.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>invokeAttr</code> does not contain <code>CreateInstance</code> and <code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>args</code> and <code>modifiers</code> do not have the same length.  </p>\n<p> -or-  </p>\n<p> <code>invokeAttr</code> is not a valid <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> attribute.  </p>\n<p> -or-  </p>\n<p> <code>invokeAttr</code> does not contain one of the following binding flags: <code>InvokeMethod</code>, <code>CreateInstance</code>, <code>GetField</code>, <code>SetField</code>, <code>GetProperty</code>, or <code>SetProperty</code>.  </p>\n<p> -or-  </p>\n<p> <code>invokeAttr</code> contains <code>CreateInstance</code> combined with <code>InvokeMethod</code>, <code>GetField</code>, <code>SetField</code>, <code>GetProperty</code>, or <code>SetProperty</code>.  </p>\n<p> -or-  </p>\n<p> <code>invokeAttr</code> contains both <code>GetField</code> and <code>SetField</code>.  </p>\n<p> -or-  </p>\n<p> <code>invokeAttr</code> contains both <code>GetProperty</code> and <code>SetProperty</code>.  </p>\n<p> -or-  </p>\n<p> <code>invokeAttr</code> contains <code>InvokeMethod</code> combined with <code>SetField</code> or <code>SetProperty</code>.  </p>\n<p> -or-  </p>\n<p> <code>invokeAttr</code> contains <code>SetField</code> and <code>args</code> has more than one element.  </p>\n<p> -or-  </p>\n<p> The named parameter array is larger than the argument array.  </p>\n<p> -or-  </p>\n<p> This method is called on a COM object and one of the following binding flags was not passed in: <code>BindingFlags.InvokeMethod</code>, <code>BindingFlags.GetProperty</code>, <code>BindingFlags.SetProperty</code>, <code>BindingFlags.PutDispProperty</code>, or <code>BindingFlags.PutRefDispProperty</code>.  </p>\n<p> -or-  </p>\n<p> One of the named parameter arrays contains a string that is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.methodaccessexception\" data-linktype=\"relative-path\">MethodAccessException</a></div>\r\n                  </div>\r\n                  <p>The specified member is a class initializer.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.missingfieldexception\" data-linktype=\"relative-path\">MissingFieldException</a></div>\r\n                  </div>\r\n                  <p>The field or property cannot be found.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.missingmethodexception\" data-linktype=\"relative-path\">MissingMethodException</a></div>\r\n                  </div>\r\n                  <p>No method can be found that matches the arguments in <code>args</code>.  </p>\n<p> -or-  </p>\n<p> No member can be found that has the argument names supplied in <code>namedParameters</code>.  </p>\n<p> -or-  </p>\n<p> The current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents a type that contains open type parameters, that is, <span class=\"xref\">stem.Type.ContainsGenericParameters*</span> returns <code>true</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.targetexception\" data-linktype=\"relative-path\">TargetException</a></div>\r\n                  </div>\r\n                  <p>The specified member cannot be invoked on <code>target</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.ambiguousmatchexception\" data-linktype=\"relative-path\">AmbiguousMatchException</a></div>\r\n                  </div>\r\n                  <p>More than one method matches the binding criteria.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The method represented by <code>name</code> has one or more unspecified generic type parameters. That is, the method&#39;s <span class=\"xref\">stem.Reflection.MethodInfo.ContainsGenericParameters*</span> property returns <code>true</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p><code>InvokeMember</code> calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> You cannot use <a class=\"xref\" href=\"system.type#System_Type_InvokeMember_\" data-linktype=\"relative-path\">InvokeMember</a> to invoke a generic method.  </p>\n</div>\n<p> When you invoke an <code>IDispatch</code> member you can specify the DispID instead of the member name, using the string format &quot;[DispID=##]&quot;. For example, if the DispID of MyComMethod is 3, you can specify the string &quot;[DispID=3]&quot; instead of &quot;MyComMethod&quot;. Invoking a member by DispID is faster than looking up the member by name. In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.  </p>\n<p> Although the default binder does not process <a class=\"xref\" href=\"system.reflection.parametermodifier\" data-linktype=\"relative-path\">ParameterModifier</a> or <a class=\"xref\" href=\"system.globalization.cultureinfo\" data-linktype=\"relative-path\">CultureInfo</a> (the <code>modifiers</code> and <code>culture</code> parameters), you can use the abstract <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">System.Reflection.Binder</a> class to write a custom binder that does process <code>modifiers</code> and <code>culture</code>. <code>ParameterModifier</code> is only used when calling through COM interop, and only parameters that are passed by reference are handled.  </p>\n<p> Each parameter in the <code>namedParameters</code> array gets the value in the corresponding element in the <code>args</code> array. If the length of <code>args</code> is greater than the length of <code>namedParameters</code>, the remaining argument values are passed in order.  </p>\n<p> The <code>namedParameters</code> array can be used to change the order of arguments in an input array. For example, given the method <code>M(string a, int b)</code> (<code>M(ByVal a As String, ByVal b As Integer)</code> in Visual Basic) and the input array <code>{ 42, &quot;x&quot; }</code>, the input array can be passed unchanged to <code>args</code> if the array <code>{ &quot;b&quot;, &quot;a&quot; }</code> is supplied for <code>namedParameters</code>.  </p>\n<p> The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> filter flags can be used to define which members to include in the search:  </p>\n<ul>\n<li><p>Specify <code>BindingFlags.Public</code> to include public members in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.NonPublic</code> to include non-public members (that is, private, internal, and protected members) in the search.  </p>\n</li>\n<li><p>Specify <code>BindingFlags.FlattenHierarchy</code> to include static members up the hierarchy.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> modifier flags can be used to change how the search works:  </p>\n</li>\n<li><p><code>BindingFlags.IgnoreCase</code> to ignore the case of <code>name</code>.  </p>\n</li>\n<li><p><code>BindingFlags.DeclaredOnly</code> to search only the members declared on the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>, not members that were simply inherited.  </p>\n<p>The following <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> invocation flags can be used to denote what action to take with the member:  </p>\n</li>\n<li><p><code>CreateInstance</code> to invoke a constructor. <code>name</code> is ignored. Not valid with other invocation flags.  </p>\n</li>\n<li><p><code>InvokeMethod</code> to invoke a method, but not a constructor or a type initializer. Not valid with <code>SetField</code> or <code>SetProperty</code>. If <code>InvokeMethod</code> is specified by itself, <code>BindingFlags.Public</code>, <code>BindingFlags.Instance</code>, and <code>BindingFlags.Static</code> are automatically included.  </p>\n</li>\n<li><p><code>GetField</code> to get the value of a field. Not valid with <code>SetField</code>.  </p>\n</li>\n<li><p><code>SetField</code> to set the value of a field. Not valid with <code>GetField</code>.  </p>\n</li>\n<li><p><code>GetProperty</code> to get a property. Not valid with <code>SetProperty</code>.  </p>\n</li>\n<li><p><code>SetProperty</code> to set a property. Not valid with <code>GetProperty</code>.  </p>\n<p>See <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> for more information.  </p>\n<p>A method will be invoked if both of the following conditions are true:  </p>\n</li>\n<li><p>The number of parameters in the method declaration equals the number of arguments in the <code>args</code> array (unless default arguments are defined on the member and <code>BindingFlags.OptionalParamBinding</code> is specified).  </p>\n</li>\n<li><p>The type of each argument can be converted by the binder to the type of the parameter.  </p>\n<p>The binder will find all of the matching methods. These methods are found based upon the type of binding requested (<a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">BindingFlags</a> values <code>InvokeMethod</code>, <code>GetProperty</code>, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.  </p>\n<p>After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The <a class=\"xref\" href=\"system.reflection.binder#System_Reflection_Binder_BindToMethod_\" data-linktype=\"relative-path\">BindToMethod</a> method of the <a class=\"xref\" href=\"system.reflection.binder\" data-linktype=\"relative-path\">Binder</a> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.  </p>\n<p><code>InvokeMember</code> can be used to invoke methods with parameters that have default values. To bind to these methods, Reflection requires <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a> to be specified. For a parameter that has a default value, you can either supply a different value, or supply <a class=\"xref\" href=\"system.reflection.missing#System_Reflection_Missing_Value\" data-linktype=\"relative-path\">System.Reflection.Missing.Value</a> to use the default value.  </p>\n<p>For example, consider a method such as MyMethod(int x, float y = 2.0). To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and <code>Missing.Value</code> for the second argument. Unless you use <code>Missing.Value</code>, you may not omit optional parameters with the <code>Invoke</code> method. If you must do so, use <code>InvokeMember</code> instead.  </p>\n<p>Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <a class=\"xref\" href=\"system.reflection\" data-linktype=\"relative-path\">System.Reflection</a> whenever the code is fully trusted.  </p>\n<p>You can use <code>Type.InvokeMember</code> to set a field to a particular value by specifying <a class=\"xref\" href=\"system.reflection.bindingflags\" data-linktype=\"relative-path\">System.Reflection.BindingFlags</a>. For example, if you want to set a public instance field named F on class C, and F is a <code>String</code>, you can use code such as:  </p>\n<p><code>typeof(C).InvokeMember(&quot;F&quot;, BindingFlags.SetField, null, c, new Object[] {&quot;strings new value&quot;}, null, null, null);</code>  </p>\n<p>If F is a <code>String[]</code>, you can use code such as:  </p>\n<p><code>typeof(C).InvokeMember(&quot;F&quot;, BindingFlags.SetField, null, c, new Object[] {new String[]{&quot;a&quot;,&quot;z&quot;,&quot;c&quot;,&quot;d&quot;}}, null, null, null);</code>  </p>\n<p>which will initialize the field F to this new array. You can also use <code>Type.InvokeMember</code> to set a position in an array by supplying the index of the value and then the next value by using code such as the following:  </p>\n<p><code>typeof(C).InvokeMember(&quot;F&quot;, BindingFlags.SetField, null, c, new Object[] {1, &quot;b&quot;}, null, null, null);</code>  </p>\n<p>This will change string &quot;z&quot; in the array that F holds to string &quot;b&quot;.  </p>\n</li>\n</ul>\n<div class=\"NOTE\"><h5>Note</h5><p> Starting with the <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/net-v20sp1-long-md.md&quot; -->.NET Framework 2.0 Service Pack 1<!--END INCLUDE -->, this method can be used to access non-public members if the caller has been granted <a class=\"xref\" href=\"system.security.permissions.reflectionpermission\" data-linktype=\"relative-path\">ReflectionPermission</a> with the <a class=\"xref\" href=\"system.security.permissions.reflectionpermissionflag\" data-linktype=\"relative-path\">System.Security.Permissions.ReflectionPermissionFlag</a> flag and if the grant set of the non-public members is restricted to the callers grant set, or a subset thereof. (See <a href=\"../Topic/Security%20Considerations%20for%20Reflection.md\" data-linktype=\"relative-path\">Security Considerations for Reflection</a>.)  </p>\n<p> To use this functionality, your application should target the <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/net-v35-long-md.md&quot; --> .NET Framework 3.5 <!--END INCLUDE --> or later.</p>\n</div>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsArrayImpl\">\r\n    \r\n            <a id=\"System_Type_IsArrayImpl_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsArrayImpl()</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, implements the <span class=\"xref\">stem.Type.IsArray*</span> property and determines whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is an array.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected abstract bool IsArrayImpl ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is an array; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>An instance of the <a class=\"xref\" href=\"system.array\" data-linktype=\"relative-path\">Array</a> class must return <code>false</code> because it is an object, not an array.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example overrides the <code>IsArrayImpl</code> method in the <code>MyTypeDelegator</code> class, checks if a variable is an array, and displays the result.  </p>\n<pre><code class=\"lang-cs\" name=\"Type_IsArrayImpl#1\">using System;\nusing System.Reflection;\npublic class MyTypeDelegator : TypeDelegator\n{\n    public string myElementType = null;\n    public Type myType;\n    public MyTypeDelegator(Type myType) : base(myType)\n    {\n        this.myType = myType;\n    }\n    // Override IsArrayImpl().\n    protected override bool IsArrayImpl()\n    {\n        // Determine whether the type is an array.\n        if(myType.IsArray)\n        {\n            myElementType = &quot;array&quot;;\n            return true;\n        }\n        // Return false if the type is not an array.\n        return false;  \n    }\n}\npublic class Type_IsArrayImpl\n{\n    public static void Main()\n    {\n        try\n        {\n            int myInt = 0 ; \n            // Create an instance of an array element.\n            int[] myArray = new int[5];\n            MyTypeDelegator myType = new MyTypeDelegator(myArray.GetType());\n            Console.WriteLine(&quot;<br>Determine whether the variable is an array.<br>&quot;);\n            // Determine whether myType is an array type.  \n            if( myType.IsArray)\n                Console.WriteLine(&quot;The type of myArray is {0}.&quot;, myType.myElementType);\n            else\n                Console.WriteLine(&quot;myArray is not an array.&quot;);\n            myType = new MyTypeDelegator(myInt.GetType());\n\n            // Determine whether myType is an array type. \n            if( myType.IsArray)\n                Console.WriteLine(&quot;The type of myInt is {0}.&quot;, myType.myElementType);\n            else\n                Console.WriteLine(&quot;myInt is not an array.&quot;);\n        }\n        catch( Exception e )\n        {\n            Console.WriteLine(&quot;Exception: {0}&quot;, e.Message );\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_IsArrayImpl#1\">Imports System\nImports System.Reflection\nImports Microsoft.VisualBasic\nPublic Class MyTypeDelegator\n    Inherits TypeDelegator\n    Public myElementType As String = Nothing\n    Public myType As Type\n    Public Sub New(ByVal myType As Type)\n        MyBase.New(myType)\n        Me.myType = myType\n    End Sub &#39;New\n    &#39; Override IsArrayImpl().\n    Protected Overrides Function IsArrayImpl() As Boolean\n        &#39; Determine whether the type is an array.\n        If myType.IsArray Then\n            myElementType = &quot;array&quot;\n            Return True\n        End If\n        &#39; Return false if the type is not an array.\n        Return False\n    End Function &#39;IsArrayImpl\nEnd Class &#39;MyTypeDelegator\n\nPublic Class Type_IsArrayImpl\n    Public Shared Sub Main()\n        Try\n            Dim myInt As Integer = 0\n            &#39; Create an instance of an array element.\n            Dim myArray(4) As Integer\n            Dim myType As New MyTypeDelegator(myArray.GetType())\n            Console.WriteLine(ControlChars.NewLine + &quot;Determine whether the variable is an array.&quot; + ControlChars.NewLine)\n            &#39; Determine whether &#39;myType&#39; is an array type.  \n            If myType.IsArray Then\n                Console.WriteLine(&quot;The type of myArray is {0}.&quot;, myType.myElementType)\n            Else\n                Console.WriteLine(&quot;myArray is not an array.&quot;)\n            End If\n            myType = New MyTypeDelegator(myInt.GetType())\n            &#39; Determine whether myType is an array type. \n            If myType.IsArray Then\n                Console.WriteLine(&quot;The type of myInt is {0}.&quot;, myType.myElementType)\n            Else\n                Console.WriteLine(&quot;myInt is not an array.&quot;)\n            End If\n        Catch e As Exception\n            Console.WriteLine(&quot;Exception: {0}&quot;, e.Message.ToString())\n        End Try\n    End Sub &#39;Main\nEnd Class &#39;Type_IsArrayImpl\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_IsArrayImpl#1\">using namespace System;\nusing namespace System::Reflection;\npublic ref class MyTypeDelegator: public TypeDelegator\n{\npublic:\n   String^ myElementType;\n   Type^ myType;\n   MyTypeDelegator( Type^ myType )\n      : TypeDelegator( myType )\n   {\n      this-&gt;myType = myType;\n   }\n\n\nprotected:\n\n   // Override IsArrayImpl().\n   virtual bool IsArrayImpl() override\n   {\n      \n      // Determine whether the type is an array.\n      if ( myType-&gt;IsArray )\n      {\n         myElementType = &quot;array&quot;;\n         return true;\n      }\n\n      \n      // Return false if the type is not an array.\n      return false;\n   }\n\n};\n\nint main()\n{\n   try\n   {\n      int myInt = 0;\n      \n      // Create an instance of an array element.\n      array&lt;Int32&gt;^myArray = gcnew array&lt;Int32&gt;(5);\n      MyTypeDelegator^ myType = gcnew MyTypeDelegator( myArray-&gt;GetType() );\n      Console::WriteLine( &quot;<br>Determine whether the variable is an array.<br>&quot; );\n      \n      // Determine whether myType is an array type.\n      if ( myType-&gt;IsArray )\n            Console::WriteLine( &quot;The type of myArray is {0}.&quot;, myType-&gt;myElementType );\n      else\n            Console::WriteLine( &quot;myArray is not an array.&quot; );\n      myType = gcnew MyTypeDelegator( myInt.GetType() );\n      \n      // Determine whether myType is an array type.\n      if ( myType-&gt;IsArray )\n            Console::WriteLine( &quot;The type of myInt is {0}.&quot;, myType-&gt;myElementType );\n      else\n            Console::WriteLine( &quot;myInt is not an array.&quot; );\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception: {0}&quot;, e-&gt;Message );\n   }\n\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsAssignableFrom_System_Type_\">\r\n    \r\n            <a id=\"System_Type_IsAssignableFrom_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsAssignableFrom(Type)</div>        \r\n          </div>\r\n    \r\n            <p>Determines whether an instance of a specified type can be assigned to an instance of the current type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool IsAssignableFrom (Type c);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>c</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The type to compare with the current type.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if any of the following conditions is true:  </p>\n<ul>\n<li><p><code>c</code> and the current instance represent the same type.  </p>\n</li>\n<li><p><code>c</code> is derived either directly or indirectly from the current instance. <code>c</code> is derived directly from the current instance if it inherits from the current instance; <code>c</code> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance.  </p>\n</li>\n<li><p>The current instance is an interface that <code>c</code> implements.  </p>\n</li>\n<li><p><code>c</code> is a generic type parameter, and the current instance represents one of the constraints of <code>c</code>.  </p>\n<p> In the following example, the current instance is a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents the <a class=\"xref\" href=\"system.io.stream\" data-linktype=\"relative-path\">Stream</a> class. <code>GenericWithConstraint</code> is a generic type whose generic type parameter must be of type    <a class=\"xref\" href=\"system.io.stream\" data-linktype=\"relative-path\">Stream</a>. Passing its generic type parameter to the IsAssignableFrom indicates that  an instance of the generic type parameter can be assigned to an <a class=\"xref\" href=\"system.io.stream\" data-linktype=\"relative-path\">Stream</a> object.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Type.IsAssignableFrom#2\">Imports System.IO\n\nModule Example\n   Public Sub Main()\n      Dim t As Type = GetType(Stream)\n      Dim genericT As Type = GetType(GenericWithConstraint(Of ))\n      Dim genericParam As Type = genericT.GetGenericArguments()(0)\n      Console.WriteLine(t.IsAssignableFrom(genericParam))  \n      &#39; Displays True.\n   End Sub\nEnd Module\n\nPublic Class GenericWithConstraint(Of T As Stream)\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.IsAssignableFrom#2\">using System;\nusing System.IO;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Type t = typeof(Stream);\n      Type genericT = typeof(GenericWithConstraint&lt;&gt;);\n      Type genericParam = genericT.GetGenericArguments()[0];\n      Console.WriteLine(t.IsAssignableFrom(genericParam));  \n      // Displays True.\n   }\n}\n\npublic class GenericWithConstraint&lt;T&gt; where T : Stream\n{}\n</code></pre></li>\n<li><p><code>c</code> represents a value type, and the current instance represents <code>Nullable<c></c></code> (<code>Nullable(Of c)</code> in Visual Basic).  </p>\n<p><code>false</code> if none of these conditions are true, or if <code>c</code> is <code>null</code>.</p>\n</li>\n</ul>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The IsAssignableFrom method can be used to determine whether an instance of <code>c</code> can be assigned to an instance of the current type, The method is most useful when you are handling objects whose types are not known at design time and allows for conditional assignment, as the following example shows.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.IsAssignableFrom#3\">using System;\nusing System.Collections;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Type t = typeof(IEnumerable);\n      Type c = typeof(Array);\n      \n      IEnumerable instanceOfT;\n      int[] instanceOfC = { 1, 2, 3, 4 };\n      if (t.IsAssignableFrom(c))\n         instanceOfT = instanceOfC;\n  }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.IsAssignableFrom#3\">Imports System.Collections\n\nModule Example\n   Public Sub Main()\n      Dim t As Type = GetType(IEnumerable)\n      Dim c As Type = GetType(Array)\n      \n      Dim instanceOfT As IEnumerable\n      Dim instanceOfC As Integer() = { 1, 2, 3, 4 }\n      If t.IsAssignableFrom(c) Then\n         instanceOfT = instanceOfC\n      End If  \n   End Sub\nEnd Module\n</code></pre><p> This method thus ensures that a line of code like the following will execute at runtime without throwing an <a class=\"xref\" href=\"system.invalidcastexception\" data-linktype=\"relative-path\">InvalidCastException</a> exception or a similar exception:  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.IsAssignableFrom#4\">         instanceOfT = instanceOfC;\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.IsAssignableFrom#4\">         instanceOfT = instanceOfC\n</code></pre><p> This method can be overridden by a derived class.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> A generic type definition is not assignable from a closed constructed type. That is, you cannot assign the closed constructed type <code>MyGenericList&lt;int&gt;</code> (<code>MyGenericList(Of Integer)</code> in Visual Basic) to a variable of type <code>MyGenericList&lt;T&gt;</code>.  </p>\n</div>\n<p> If the <code>c</code> parameter is of type <a class=\"xref\" href=\"system.reflection.emit.typebuilder\" data-linktype=\"relative-path\">TypeBuilder</a>, the result is based on the type that is to be built. The following code example demonstrates this using a built type named <code>B</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.IsAssignableFrom#1\">using System;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\npublic class A\n{}\n\npublic class Example\n{\n   public static void Main()\n   {\n      AppDomain domain = AppDomain.CurrentDomain;\n      AssemblyName assemName = new AssemblyName();\n      assemName.Name = &quot;TempAssembly&quot;;\n\n      // Define a dynamic assembly in the current application domain.\n      AssemblyBuilder assemBuilder = domain.DefineDynamicAssembly(assemName,\n                                            AssemblyBuilderAccess.Run);\n\n      // Define a dynamic module in this assembly.\n      ModuleBuilder moduleBuilder = assemBuilder.DefineDynamicModule(&quot;TempModule&quot;);\n\n      TypeBuilder b1 = moduleBuilder.DefineType(&quot;B&quot;, TypeAttributes.Public, typeof(A));\n      Console.WriteLine(typeof(A).IsAssignableFrom(b1));\n   }\n}\n// The example displays the following output:\n//        True\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.IsAssignableFrom#1\">Imports System.Reflection\nImports System.Reflection.Emit\n\nPublic Class A\nEnd Class\n\nModule Example\n   Public Sub Main()\n      Dim domain As AppDomain = AppDomain.CurrentDomain\n      Dim assemName As New AssemblyName()\n      assemName.Name = &quot;TempAssembly&quot;\n\n      &#39; Define a dynamic assembly in the current application domain.\n      Dim assemBuilder As AssemblyBuilder = domain.DefineDynamicAssembly(assemName,\n                                                   AssemblyBuilderAccess.Run)\n\n      &#39; Define a dynamic module in this assembly.\n      Dim moduleBuilder As ModuleBuilder = assemBuilder.DefineDynamicModule(&quot;TempModule&quot;)\n\n      Dim b1 As TypeBuilder = moduleBuilder.DefineType(&quot;B&quot;, TypeAttributes.Public, GetType(A))\n      Console.WriteLine(GetType(A).IsAssignableFrom(b1))\n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       True\n</code></pre>\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example demonstrates the <code>IsAssignableFrom</code> method using defined classes, integer arrays, and generics.  </p>\n<pre><code class=\"lang-cs\" name=\"TestIsAssignableFrom#1\">using System;\nusing System.Collections.Generic;\nclass Program\n{\n    public static void Main()\n    {\n            // Demonstrate classes:\n            Console.WriteLine(&quot;Defined Classes:&quot;);\n            Room room1 = new Room();\n            Kitchen kitchen1 = new Kitchen();\n            Bedroom bedroom1 = new Bedroom();\n            Guestroom guestroom1 = new Guestroom();\n            MasterBedroom masterbedroom1 = new MasterBedroom();\n\n            Type room1Type = room1.GetType();\n            Type kitchen1Type = kitchen1.GetType();\n            Type bedroom1Type = bedroom1.GetType();\n            Type guestroom1Type = guestroom1.GetType();\n            Type masterbedroom1Type = masterbedroom1.GetType();\n\n            Console.WriteLine(&quot;room assignable from kitchen: {0}&quot;, room1Type.IsAssignableFrom(kitchen1Type));\n            Console.WriteLine(&quot;bedroom assignable from guestroom: {0}&quot;, bedroom1Type.IsAssignableFrom(guestroom1Type));\n            Console.WriteLine(&quot;kitchen assignable from masterbedroom: {0}&quot;, kitchen1Type.IsAssignableFrom(masterbedroom1Type));\n\n            // Demonstrate arrays:\n            Console.WriteLine();\n            Console.WriteLine(&quot;Integer arrays:&quot;);\n\n            int[] array2 = new int[2];\n            int[] array10 = new int[10];\n            int[,] array22 = new int[2, 2];\n            int[,] array24 = new int[2, 4];\n\n            Type array2Type = array2.GetType();\n            Type array10Type = array10.GetType();\n            Type array22Type = array22.GetType();\n            Type array24Type = array24.GetType();\n\n            Console.WriteLine(&quot;int[2] assignable from int[10]: {0}&quot;, array2Type.IsAssignableFrom(array10Type));\n            Console.WriteLine(&quot;int[2] assignable from int[2,4]: {0}&quot;, array2Type.IsAssignableFrom(array24Type));\n            Console.WriteLine(&quot;int[2,4] assignable from int[2,2]: {0}&quot;, array24Type.IsAssignableFrom(array22Type));\n\n            // Demonstrate generics:\n            Console.WriteLine();\n            Console.WriteLine(&quot;Generics:&quot;);\n\n            // Note that &quot;int?[]&quot; is the same as &quot;Nullable&lt;int&gt;[]&quot;\n            int?[] arrayNull = new int?[10];\n            List&lt;int&gt; genIntList = new List&lt;int&gt;();\n            List&lt;Type&gt; genTList = new List&lt;Type&gt;();\n\n            Type arrayNullType = arrayNull.GetType();\n            Type genIntListType = genIntList.GetType();\n            Type genTListType = genTList.GetType();\n\n            Console.WriteLine(&quot;int[10] assignable from int?[10]: {0}&quot;, array10Type.IsAssignableFrom(arrayNullType));\n            Console.WriteLine(&quot;List&lt;int&gt; assignable from List&lt;Type&gt;: {0}&quot;, genIntListType.IsAssignableFrom(genTListType));\n            Console.WriteLine(&quot;List&lt;Type&gt; assignable from List&lt;int&gt;: {0}&quot;, genTListType.IsAssignableFrom(genIntListType));\n\n            Console.ReadLine();\n\n    }\n}\nclass Room\n{\n}\n\nclass Kitchen : Room\n{\n}\n\nclass Bedroom : Room\n{\n}\n\nclass Guestroom : Bedroom\n{\n}\n\nclass MasterBedroom : Bedroom\n{\n}\n\n//This code example produces the following output:\n//\n// Defned Classes:\n// room assignable from kitchen: True\n// bedroom assignable from guestroom: True\n// kitchen assignable from masterbedroom: False\n//\n// Integer arrays:\n// int[2] assignable from int[10]: True\n// int[2] assignable from int[2,4]: False\n// int[2,4] assignable from int[2,2]: True\n//\n// Generics:\n// int[10] assignable from int?[10]: False\n// List&lt;int&gt; assignable from List&lt;Type&gt;: False\n// List&lt;Type&gt; assignable from List&lt;int&gt;: False\n</code></pre><pre><code class=\"lang-vb\" name=\"TestIsAssignableFrom#1\">Imports System.Collections.Generic\n\nModule Example\n    Public Sub Main()\n        Console.WriteLine(&quot;Defined Classes:&quot;)\n        Dim room1 As New Room()\n        Dim kitchen1 As New Kitchen()\n        Dim bedroom1 As New Bedroom()\n        Dim guestroom1 As New Guestroom()\n        Dim masterbedroom1 As New MasterBedroom()\n\n        Dim room1Type As Type = room1.GetType()\n        Dim kitchen1Type As Type = kitchen1.GetType()\n        Dim bedroom1Type As Type = bedroom1.GetType()\n        Dim guestroom1Type As Type = guestroom1.GetType()\n        Dim masterbedroom1Type As Type = masterbedroom1.GetType()\n\n        Console.WriteLine(&quot;room assignable from kitchen: {0}&quot;, room1Type.IsAssignableFrom(kitchen1Type))\n        Console.WriteLine(&quot;bedroom assignable from guestroom: {0}&quot;, bedroom1Type.IsAssignableFrom(guestroom1Type))\n        Console.WriteLine(&quot;kitchen assignable from masterbedroom: {0}&quot;, kitchen1Type.IsAssignableFrom(masterbedroom1Type))\n\n        &#39; Demonstrate arrays:\n        Console.WriteLine()\n        Console.WriteLine(&quot;Integer arrays:&quot;)\n\n        Dim array10(10) As Integer\n        Dim array2(2) As Integer\n        Dim array22(2, 2) As Integer\n        Dim array24(2, 4) As Integer\n\n        Dim array10Type As Type = array10.GetType\n        Dim array2Type As Type = array2.GetType\n        Dim array22Type As Type = array22.GetType\n        Dim array24Type As Type = array24.GetType\n\n        Console.WriteLine(&quot;Integer(2) assignable from Integer(10): {0}&quot;, array2Type.IsAssignableFrom(array10Type))\n        Console.WriteLine(&quot;Integer(2) assignable from Integer(2,4): {0}&quot;, array2Type.IsAssignableFrom(array24Type))\n        Console.WriteLine(&quot;Integer(2,4) assignable from Integer(2,2): {0}&quot;, array24Type.IsAssignableFrom(array22Type))\n\n        &#39; Demonstrate generics:\n        Console.WriteLine()\n        Console.WriteLine(&quot;Generics:&quot;)\n\n        Dim arrayNull(10) As Nullable(Of Integer)\n        Dim genIntList As New List(Of Integer)\n        Dim genTList As New List(Of Type)\n\n        Dim arrayNullType As Type = arrayNull.GetType\n        Dim genIntListType As Type = genIntList.GetType\n        Dim genTListType As Type = genTList.GetType\n\n        Console.WriteLine(&quot;Integer(10) assignable from Nullable(Of Integer)(10): {0}&quot;, array10Type.IsAssignableFrom(arrayNullType))\n        Console.WriteLine(&quot;List(Of Integer) assignable from List(Of Type): {0}&quot;, genIntListType.IsAssignableFrom(genTListType))\n        Console.WriteLine(&quot;List(Of Type) assignable from List(Of Integer): {0}&quot;, genTListType.IsAssignableFrom(genIntListType))\n        Console.ReadLine()\n    End Sub\nEnd Module\n\nClass Room\nEnd Class\n\nClass Kitchen : Inherits Room\nEnd Class\n\nClass Bedroom : Inherits Room\nEnd Class\n\nClass Guestroom : Inherits Bedroom\nEnd Class\n\nClass MasterBedroom : Inherits Bedroom\nEnd Class\n&#39; The example displays the following output:\n&#39;    Defined Classes:\n&#39;    room assignable from kitchen: True\n&#39;    bedroom assignable from guestroom: True\n&#39;    kitchen assignable from masterbedroom: False\n&#39;\n&#39;    Integer arrays:\n&#39;    Integer(2) assignable from Integer(10): True\n&#39;    Integer(2) assignable from Integer(2,4): False\n&#39;    Integer(2,4) assignable from Integer(2,2): True\n&#39;\n&#39;    Generics:\n&#39;    Integer(10) assignable from Nullable(Of Integer)(10): False\n&#39;    List(Of Integer) assignable from List(Of Type): False\n&#39;    List(Of Type) assignable from List(Of Integer): False\n</code></pre><pre><code class=\"lang-cpp\" name=\"TestIsAssignableFrom#1\">using namespace System;\nusing namespace System::Collections::Generic;\n\nref class Room\n{\n};\n\nref class Kitchen : Room\n{\n};\n\nref class Bedroom : Room\n{\n};\n\nref class Guestroom : Bedroom\n{\n};\n\nref class MasterBedroom : Bedroom\n{\n};\n\nref class Program\n{\npublic:\n    static void Main()\n    {\n            // Demonstrate classes:\n            Console::WriteLine(&quot;Defined Classes:&quot;);\n            Room^ room1 = gcnew Room();\n            Kitchen^ kitchen1 = gcnew Kitchen();\n            Bedroom^ bedroom1 = gcnew Bedroom();\n            Guestroom^ guestroom1 = gcnew Guestroom();\n            MasterBedroom^ masterbedroom1 = gcnew MasterBedroom();\n\n            Type^ room1Type = room1-&gt;GetType();\n            Type^ kitchen1Type = kitchen1-&gt;GetType();\n            Type^ bedroom1Type = bedroom1-&gt;GetType();\n            Type^ guestroom1Type = guestroom1-&gt;GetType();\n            Type^ masterbedroom1Type = masterbedroom1-&gt;GetType();\n\n            Console::WriteLine(&quot;room assignable from kitchen: {0}&quot;, room1Type-&gt;IsAssignableFrom(kitchen1Type));\n            Console::WriteLine(&quot;bedroom assignable from guestroom: {0}&quot;, bedroom1Type-&gt;IsAssignableFrom(guestroom1Type));\n            Console::WriteLine(&quot;kitchen assignable from masterbedroom: {0}&quot;, kitchen1Type-&gt;IsAssignableFrom(masterbedroom1Type));\n\n            // Demonstrate arrays:\n            Console::WriteLine();\n            Console::WriteLine(&quot;Integer arrays:&quot;);\n            array&lt;Int32&gt;^ array2 = gcnew array&lt;Int32&gt;(2);\n            array&lt;Int32&gt;^ array10 = gcnew array&lt;Int32&gt;(10);\n            array&lt;Int32, 2&gt;^ array22 = gcnew array&lt;Int32, 2&gt;(2, 2);\n            array&lt;Int32, 2&gt;^ array24 = gcnew array&lt;Int32, 2&gt;(2, 4);\n\n            Type^ array2Type = array2-&gt;GetType();\n            Type^ array10Type = array10-&gt;GetType();\n            Type^ array22Type = array22-&gt;GetType();\n            Type^ array24Type = array24-&gt;GetType();\n\n            Console::WriteLine(&quot;Int32[2] assignable from Int32[10]: {0}&quot;, array2Type-&gt;IsAssignableFrom(array10Type));\n            Console::WriteLine(&quot;Int32[2] assignable from Int32[2,4]: {0}&quot;, array2Type-&gt;IsAssignableFrom(array24Type));\n            Console::WriteLine(&quot;Int32[2,4] assignable from Int32[2,2]: {0}&quot;, array24Type-&gt;IsAssignableFrom(array22Type));\n\n            // Demonstrate generics:\n            Console::WriteLine();\n            Console::WriteLine(&quot;Generics:&quot;);\n\n            // Note that &quot;int?[]&quot; is the same as &quot;Nullable&lt;int&gt;[]&quot;\n            //int?[] arrayNull = new int?[10];\n            array&lt;Nullable^&gt;^ arrayNull = gcnew array&lt;Nullable^&gt;(10);\n            List&lt;Int32&gt;^ genIntList = gcnew List&lt;Int32&gt;();\n            List&lt;Type^&gt;^ genTList = gcnew List&lt;Type^&gt;();\n\n            Type^ arrayNullType = arrayNull-&gt;GetType();\n            Type^ genIntListType = genIntList-&gt;GetType();\n            Type^ genTListType = genTList-&gt;GetType();\n\n            Console::WriteLine(&quot;Int32[10] assignable from Nullable[10]: {0}&quot;, array10Type-&gt;IsAssignableFrom(arrayNullType));\n            Console::WriteLine(&quot;List&lt;Int32&gt; assignable from List&lt;Type^&gt;: {0}&quot;, genIntListType-&gt;IsAssignableFrom(genTListType));\n            Console::WriteLine(&quot;List&lt;Type^&gt; assignable from List&lt;Int32&gt;: {0}&quot;, genTListType-&gt;IsAssignableFrom(genIntListType));\n\n            Console::ReadLine();\n    }\n};\n\nint main()\n{\n    Program::Main();\n}\n\n//This code example produces the following output:\n//\n// Defned Classes:\n// room assignable from kitchen: True\n// bedroom assignable from guestroom: True\n//kitchen assignable from masterbedroom: False\n//\n// Integer arrays:\n// Int32[2] assignable from Int32[10]: True\n// Int32[2] assignable from Int32[2,4]: False\n// Int32[2,4] assignable from Int32[2,2]: True\n//\n// Generics:\n// Int32[10] assignable from Nullable[10]: False\n// List&lt;Int32&gt; assignable from List&lt;Type^&gt;: False\n// List&lt;Type^&gt; assignable from List&lt;Int32&gt;: False\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsByRefImpl\">\r\n    \r\n            <a id=\"System_Type_IsByRefImpl_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsByRefImpl()</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, implements the <span class=\"xref\">stem.Type.IsByRef*</span> property and determines whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is passed by reference.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected abstract bool IsByRefImpl ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is passed by reference; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsCOMObjectImpl\">\r\n    \r\n            <a id=\"System_Type_IsCOMObjectImpl_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsCOMObjectImpl()</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, implements the <span class=\"xref\">stem.Type.IsCOMObject*</span> property and determines whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is a COM object.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected abstract bool IsCOMObjectImpl ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is a COM object; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method returns <code>false</code> for COM interfaces because they are not objects. COM interfaces can be implemented by Microsoft .NET Framework objects.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsContextfulImpl\">\r\n    \r\n            <a id=\"System_Type_IsContextfulImpl_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsContextfulImpl()</div>        \r\n          </div>\r\n    \r\n            <p>Implements the <span class=\"xref\">stem.Type.IsContextful*</span> property and determines whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> can be hosted in a context.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected virtual bool IsContextfulImpl ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> can be hosted in a context; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method can be overridden by a derived class.  </p>\n<p> A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example demonstrates a use of the <code>IsContextfulImpl</code> method.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_IsContextfulImpl#1\">using namespace System;\nusing namespace System::Reflection;\n\npublic ref class MyTypeDelegatorClass: public TypeDelegator\n{\npublic:\n   String^ myElementType;\n\nprivate:\n   Type^ myType;\n\npublic:\n   MyTypeDelegatorClass( Type^ myType )\n      : TypeDelegator( myType )\n   {\n      this-&gt;myType = myType;\n   }\n\nprotected:\n\n   // Override IsContextfulImpl.\n   virtual bool IsContextfulImpl() override\n   {\n      \n      // Check whether the type is contextful.\n      if ( myType-&gt;IsContextful )\n      {\n         myElementType = &quot; is contextful &quot;;\n         return true;\n      }\n\n      return false;\n   }\n\n};\n\npublic ref class MyTypeDemoClass{};\n\n\n// This class demonstrates IsContextfulImpl.\npublic ref class MyContextBoundClass: public ContextBoundObject\n{\npublic:\n   String^ myString;\n};\n\nint main()\n{\n   try\n   {\n      MyTypeDelegatorClass^ myType;\n      Console::WriteLine( &quot;Check whether MyContextBoundClass can be hosted in a context.&quot; );\n      \n      // Check whether MyContextBoundClass is contextful.\n      myType = gcnew MyTypeDelegatorClass( MyContextBoundClass::typeid );\n      if ( myType-&gt;IsContextful )\n      {\n         Console::WriteLine( &quot;{0} can be hosted in a context.&quot;, MyContextBoundClass::typeid );\n      }\n      else\n      {\n         Console::WriteLine( &quot;{0} cannot be hosted in a context.&quot;, MyContextBoundClass::typeid );\n      }\n      myType = gcnew MyTypeDelegatorClass( MyTypeDemoClass::typeid );\n      Console::WriteLine( &quot;<br>Check whether MyTypeDemoClass can be hosted in a context.&quot; );\n      if ( myType-&gt;IsContextful )\n      {\n         Console::WriteLine( &quot;{0} can be hosted in a context.&quot;, MyTypeDemoClass::typeid );\n      }\n      else\n      {\n         Console::WriteLine( &quot;{0} cannot be hosted in a context.&quot;, MyTypeDemoClass::typeid );\n      }\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception: {0}&quot;, e-&gt;Message );\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_IsContextfulImpl#1\">Imports System\nImports System.Reflection\nImports Microsoft.VisualBasic\nPublic Class MyTypeDelegatorClass\n    Inherits TypeDelegator\n    Public myElementType As String = Nothing\n    Private myType As Type = Nothing\n    Public Sub New(ByVal myType As Type)\n        MyBase.New(myType)\n        Me.myType = myType\n    End Sub &#39;New\n    &#39; Override IsContextfulImpl.\n    Protected Overrides Function IsContextfulImpl() As Boolean\n        &#39; Check whether the type is contextful.\n        If myType.IsContextful Then\n            myElementType = &quot; is contextful &quot;\n            Return True\n        End If\n        Return False\n    End Function &#39;IsContextfulImpl\nEnd Class &#39;MyTypeDelegatorClass\nPublic Class MyTypeDemoClass\n    Public Shared Sub Main()\n        Try\n            Dim myType As MyTypeDelegatorClass\n            Console.WriteLine(&quot;Check whether MyContextBoundClass can be hosted in a context.&quot;)\n            &#39; Check whether MyContextBoundClass is contextful.\n            myType = New MyTypeDelegatorClass(GetType(MyContextBoundClass))\n            If myType.IsContextful Then\n                Console.WriteLine(GetType(MyContextBoundClass).ToString() + &quot; can be hosted in a context.&quot;)\n            Else\n                Console.WriteLine(GetType(MyContextBoundClass).ToString() + &quot; cannot be hosted in a context.&quot;)\n            End If\n            &#39; Check whether the int type is contextful.\n            myType = New MyTypeDelegatorClass(GetType(MyTypeDemoClass))\n            Console.WriteLine(ControlChars.NewLine + &quot;Check whether MyTypeDemoClass can be hosted in a context.&quot;)\n            If myType.IsContextful Then\n                Console.WriteLine(GetType(MyTypeDemoClass).ToString() + &quot; can be hosted in a context.&quot;)\n            Else\n                Console.WriteLine(GetType(MyTypeDemoClass).ToString() + &quot; cannot be hosted in a context.&quot;)\n            End If\n        Catch e As Exception\n            Console.WriteLine(&quot;Exception: {0}&quot;, e.Message.ToString())\n        End Try\n    End Sub &#39;Main\nEnd Class &#39;MyTypeDemoClass\n&#39; This class demonstrates the IsContextfulImpl method.\nPublic Class MyContextBoundClass\n    Inherits ContextBoundObject\n    Public myString As String = &quot;This class is used to demonstrate members of the Type class.&quot;\nEnd Class &#39;MyContextBoundClass\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_IsContextfulImpl#1\">using System;\nusing System.Reflection;\npublic class MyTypeDelegatorClass : TypeDelegator\n{\n    public string myElementType = null;\n    private Type myType = null ; \n\n    public MyTypeDelegatorClass(Type myType) : base(myType)\n    {\n        this.myType = myType;\n    }\n    // Override IsContextfulImpl.\n    protected override bool IsContextfulImpl()\n    {\n        // Check whether the type is contextful.\n        if(myType.IsContextful)\n        { \n            myElementType = &quot; is contextful &quot;;\n            return true;\n        }\n        return false;\n    }\n}\npublic class MyTypeDemoClass\n{\n    public static void Main()\n    {\n        try\n        {\n            MyTypeDelegatorClass myType;\n            Console.WriteLine (&quot;Check whether MyContextBoundClass can be hosted in a context.&quot;);\n            // Check whether MyContextBoundClass is contextful.\n            myType = new MyTypeDelegatorClass(typeof(MyContextBoundClass));\n            if( myType.IsContextful)\n            {\n                Console.WriteLine(typeof(MyContextBoundClass) + &quot; can be hosted in a context.&quot;);\n            }\n            else\n            {\n                Console.WriteLine(typeof(MyContextBoundClass) + &quot; cannot be hosted in a context.&quot;);\n            }\n            // Check whether the int type is contextful.\n            myType = new MyTypeDelegatorClass(typeof(MyTypeDemoClass));\n            Console.WriteLine (&quot;<br>Check whether MyTypeDemoClass can be hosted in a context.&quot;);\n            if( myType.IsContextful)\n            {\n                Console.WriteLine(typeof(MyTypeDemoClass) + &quot; can be hosted in a context.&quot;);\n            }\n            else\n            {\n                Console.WriteLine(typeof(MyTypeDemoClass) + &quot; cannot be hosted in a context.&quot;);\n            }\n        }\n        catch( Exception e )\n        {\n            Console.WriteLine(&quot;Exception: {0}&quot;, e.Message);\n        }\n    }\n}\n// This class demonstrates IsContextfulImpl.\npublic class MyContextBoundClass : ContextBoundObject\n{\n    public string myString = &quot;This class is used to demonstrate members of the Type class.&quot;;\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsEnumDefined_System_Object_\">\r\n    \r\n            <a id=\"System_Type_IsEnumDefined_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsEnumDefined(Object)</div>        \r\n          </div>\r\n    \r\n            <p>Returns a value that indicates whether the specified value exists in the current enumeration type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool IsEnumDefined (object value);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>value</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The value to be tested.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the specified value is a member of the current enumeration type; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p>The current type is not an enumeration.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>value</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p><code>value</code> is of a type that cannot be the underlying type of an enumeration.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsEquivalentTo_System_Type_\">\r\n    \r\n            <a id=\"System_Type_IsEquivalentTo_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsEquivalentTo(Type)</div>        \r\n          </div>\r\n    \r\n            <p>Determines whether two COM types have the same identity and are eligible for type equivalence.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool IsEquivalentTo (Type other);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>other</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The COM type that is tested for equivalence with the current type.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the COM types are equivalent; otherwise, <code>false</code>. This method also returns <code>false</code> if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Beginning with the <!-- BEGIN INCLUDE: Include content from &quot;~/add/includes/net-v40-long-md.md&quot; -->.NET Framework 4<!--END INCLUDE -->, the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies. Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type. Each managed assembly has a different <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object to represent its view of the COM type. The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.  </p>\n<p> Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly. The IsEquivalentTo method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly&#39;s own embedded interop types, and thus can be cast to that type.  </p>\n<p> For more information, see <a href=\"../Topic/Type%20Equivalence%20and%20Embedded%20Interop%20Types.md\" data-linktype=\"relative-path\">Type Equivalence and Embedded Interop Types</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsInstanceOfType_System_Object_\">\r\n    \r\n            <a id=\"System_Type_IsInstanceOfType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsInstanceOfType(Object)</div>        \r\n          </div>\r\n    \r\n            <p>Determines whether the specified object is an instance of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool IsInstanceOfType (object o);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>o</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object to compare with the current type.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the current <code>Type</code> is in the inheritance hierarchy of the object represented by <code>o</code>, or if the current <code>Type</code> is an interface that <code>o</code> implements. <code>false</code> if neither of these conditions is the case, if <code>o</code> is <code>null</code>, or if the current <code>Type</code> is an open generic type (that is, <span class=\"xref\">stem.Type.ContainsGenericParameters*</span> returns <code>true</code>).</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method can be overridden by a derived class.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> A constructed type is not an instance of its generic type definition. That is, <code>MyGenericList&lt;int&gt;</code> (<code>MyGenericList(Of Integer)</code> in Visual Basic) is not an instance of <code>MyGenericList&lt;T&gt;</code> (<code>MyGenericList(Of T)</code> in Visual Basic).</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example demonstrates the use of the <code>IsInstanceOfType</code> method.  </p>\n<pre><code class=\"lang-cs\" name=\"TestIsInstanceOfType#1\">using System;\n\npublic interface IExample {}\n\npublic class BaseClass : IExample {}\n\npublic class DerivedClass : BaseClass {}\n\npublic class Example\n{\n    public static void Main()\n    {\n        var interfaceType = typeof(IExample);\n        var base1 = new BaseClass();\n        var base1Type = base1.GetType();\n        var derived1 = new DerivedClass();\n        var derived1Type = derived1.GetType();\n        int[] arr = new int[11];\n\n        Console.WriteLine(&quot;Is int[] an instance of the Array class? {0}.&quot;,\n                           typeof(Array).IsInstanceOfType(arr));\n        Console.WriteLine(&quot;Is base1 an instance of BaseClass? {0}.&quot;,\n                          base1Type.IsInstanceOfType(base1));\n        Console.WriteLine(&quot;Is derived1 an instance of BaseClass? {0}.&quot;,\n                          base1Type.IsInstanceOfType(derived1));\n        Console.WriteLine(&quot;Is base1 an instance of IExample? {0}.&quot;,\n                          interfaceType.IsInstanceOfType(base1));\n        Console.WriteLine(&quot;Is derived1 an instance of IExample? {0}.&quot;,\n                          interfaceType.IsInstanceOfType(derived1));\n    }\n}\n// The example displays the following output:\n//    Is int[] an instance of the Array class? True.\n//    Is base1 an instance of BaseClass? True.\n//    Is derived1 an instance of BaseClass? True.\n//    Is base1 an instance of IExample? True.\n//    Is derived1 an instance of IExample? True.\n</code></pre><pre><code class=\"lang-vb\" name=\"TestIsInstanceOfType#1\">Public Interface IExample\nEnd Interface\n\nPublic Class BaseClass : Implements IExample\nEnd Class\n\nPublic Class DerivedClass : Inherits BaseClass\nEnd Class\n\nPublic Module Example\n    Public Sub Main()\n        Dim interfaceType As Type = GetType(IExample)\n        Dim base1 As New BaseClass()\n        Dim base1Type As Type = base1.GetType()\n        Dim derived1 = New DerivedClass()\n        Dim derived1Type As Type = derived1.GetType()\n        Dim arr(10) As Integer\n\n        Console.WriteLine(&quot;Is int[] an instance of the Array class? {0}.&quot;,\n                           GetType(Array).IsInstanceOfType(arr))\n        Console.WriteLine(&quot;Is base1 an instance of BaseClass? {0}.&quot;,\n                          base1Type.IsInstanceOfType(base1))\n        Console.WriteLine(&quot;Is derived1 an instance of BaseClass? {0}.&quot;,\n                          base1Type.IsInstanceOfType(derived1))\n        Console.WriteLine(&quot;Is base1 an instance of IExample? {0}.&quot;,\n                          interfaceType.IsInstanceOfType(base1))\n        Console.WriteLine(&quot;Is derived1 an instance of IExample? {0}.&quot;,\n                          interfaceType.IsInstanceOfType(derived1))\n    End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;    Is int[] an instance of the Array class? True.\n&#39;    Is base1 an instance of BaseClass? True.\n&#39;    Is derived1 an instance of BaseClass? True.\n&#39;    Is base1 an instance of IExample? True.\n&#39;    Is derived1 an instance of IExample? True.\n</code></pre><pre><code class=\"lang-cpp\" name=\"TestIsInstanceOfType#1\">using namespace System;\n\npublic interface class IExample{};\n\npublic ref class BaseClass: IExample{};\n\npublic ref class DerivedClass: BaseClass{};\n\nvoid main()\n{\n   Type^ interfaceType = IExample::typeid;\n   BaseClass^ base1 = gcnew BaseClass;\n   Type^ base1Type = base1-&gt;GetType();\n   BaseClass^ derived1 = gcnew DerivedClass;\n   Type^ derived1Type = derived1-&gt;GetType();\n   array&lt;Int32&gt;^ arr = gcnew array&lt;Int32&gt;(11);\n   Type^ arrayType = Array::typeid;\n\n   Console::WriteLine(&quot;Is Int32[] an instance of the Array class? {0}.&quot;,\n                      arrayType-&gt;IsInstanceOfType( arr ) );\n   Console::WriteLine(&quot;Is myclass an instance of BaseClass? {0}.&quot;,\n                      base1Type-&gt;IsInstanceOfType( base1 ) );\n   Console::WriteLine(&quot;Is myderivedclass an instance of BaseClass? {0}.&quot;,\n                      base1Type-&gt;IsInstanceOfType( derived1 ) );\n   Console::WriteLine(&quot;Is myclass an instance of IExample? {0}.&quot;,\n                      interfaceType-&gt;IsInstanceOfType( base1 ) );\n   Console::WriteLine(&quot;Is myderivedclass an instance of IExample? {0}.&quot;,\n                      interfaceType-&gt;IsInstanceOfType( derived1 ) );\n}\n// The example displays the following output:\n//    Is int[] an instance of the Array class? True.\n//    Is base1 an instance of BaseClass? True.\n//    Is derived1 an instance of BaseClass? True.\n//    Is base1 an instance of IExample? True.\n//    Is derived1 an instance of IExample? True.\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsMarshalByRefImpl\">\r\n    \r\n            <a id=\"System_Type_IsMarshalByRefImpl_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsMarshalByRefImpl()</div>        \r\n          </div>\r\n    \r\n            <p>Implements the <span class=\"xref\">stem.Type.IsMarshalByRef*</span> property and determines whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is marshaled by reference.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected virtual bool IsMarshalByRefImpl ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is marshaled by reference; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method can be overridden by a derived class.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example determines whether the given type is marshaled by reference and displays the result.  </p>\n<pre><code class=\"lang-vb\" name=\"Type_IsMarshalByRefImpl#1\">Imports System\nImports System.Reflection\nImports Microsoft.VisualBasic\n\nPublic Class MyTypeDelegatorClass\n    Inherits TypeDelegator\n    Public myElementType As String = Nothing\n    Private myType As Type = Nothing\n    Public Sub New(ByVal myType As Type)\n        MyBase.New(myType)\n        Me.myType = myType\n    End Sub &#39;New\n\n    &#39; Override IsMarshalByRefImpl.\n    Protected Overrides Function IsMarshalByRefImpl() As Boolean\n        &#39; Determine whether the type is marshalled by reference.\n        If myType.IsMarshalByRef Then\n            myElementType = &quot; marshalled by reference&quot;\n            Return True\n        End If\n        Return False\n    End Function &#39;IsMarshalByRefImpl\nEnd Class &#39;MyTypeDelegatorClass\n\nPublic Class MyTypeDemoClass\n\n    Public Shared Sub Main()\n        Try\n            Dim myType As MyTypeDelegatorClass\n            Console.WriteLine(&quot;Determine whether MyContextBoundClass is marshalled by reference.&quot;)\n            &#39; Determine whether MyContextBoundClass is marshalled by reference.\n            myType = New MyTypeDelegatorClass(GetType(MyContextBoundClass))\n            If myType.IsMarshalByRef Then\n                Console.WriteLine(GetType(MyContextBoundClass).ToString() + &quot; is marshalled by reference.&quot;)\n            Else\n                Console.WriteLine(GetType(MyContextBoundClass).ToString() + &quot; is not marshalled by reference.&quot;)\n            End If\n\n            &#39; Determine whether int is marshalled by reference.\n            myType = New MyTypeDelegatorClass(GetType(Integer))\n            Console.WriteLine(ControlChars.NewLine + &quot;Determine whether int is marshalled by reference.&quot;)\n            If myType.IsMarshalByRef Then\n                Console.WriteLine(GetType(Integer).ToString() + &quot; is marshalled by reference.&quot;)\n            Else\n                Console.WriteLine(GetType(Integer).ToString() + &quot; is not marshalled by reference.&quot;)\n            End If\n        Catch e As Exception\n            Console.WriteLine(&quot;Exception: {0}&quot;, e.Message.ToString())\n        End Try\n    End Sub &#39;Main\nEnd Class &#39;MyTypeDemoClass\n\n&#39; This class is used to demonstrate &#39;IsMarshalByRefImpl&#39; method.\nPublic Class MyContextBoundClass\n    Inherits ContextBoundObject\n    Public myString As String = &quot;This class is used to demonstrate members of the Type class.&quot;\nEnd Class &#39;MyContextBoundClass\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_IsMarshalByRefImpl#1\">using System;\nusing System.Reflection;\npublic class MyTypeDelegatorClass : TypeDelegator\n{\n    public string myElementType = null;\n    private Type myType = null ; \n    public MyTypeDelegatorClass(Type myType) : base(myType)\n    {\n        this.myType = myType;\n    }\n    // Override IsMarshalByRefImpl.\n    protected override bool IsMarshalByRefImpl()\n    {\n        // Determine whether the type is marshalled by reference.\n        if(myType.IsMarshalByRef)\n        { \n            myElementType = &quot; marshalled by reference&quot;;\n            return true;\n        }\n        return false;\n    }\n}\npublic class MyTypeDemoClass\n{\n    public static void Main()\n    {\n        try\n        {\n            MyTypeDelegatorClass myType;\n            Console.WriteLine (&quot;Determine whether MyContextBoundClass is marshalled by reference.&quot;);\n            // Determine whether MyContextBoundClass type is marshalled by reference.\n            myType = new MyTypeDelegatorClass(typeof(MyContextBoundClass));\n            if( myType.IsMarshalByRef )\n            {\n                Console.WriteLine(typeof(MyContextBoundClass) + &quot; is marshalled by reference.&quot;);\n            }\n            else\n            {\n                Console.WriteLine(typeof(MyContextBoundClass) + &quot; is not marshalled by reference.&quot;);\n            }\n\n            // Determine whether int type is marshalled by reference.\n            myType = new MyTypeDelegatorClass(typeof(int));\n            Console.WriteLine (&quot;<br>Determine whether int is marshalled by reference.&quot;);\n            if( myType.IsMarshalByRef)\n            {\n                Console.WriteLine(typeof(int) + &quot; is marshalled by reference.&quot;);\n            }\n            else\n            {\n                Console.WriteLine(typeof(int) + &quot; is not marshalled by reference.&quot;);\n            }\n        }\n        catch( Exception e )\n        {\n            Console.WriteLine(&quot;Exception: {0}&quot;, e.Message);\n        }\n    }\n}\n// This class is used to demonstrate the IsMarshalByRefImpl method.\npublic class MyContextBoundClass : ContextBoundObject\n{\n    public string myString = &quot;This class is used to demonstrate members of the Type class.&quot;;\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"Type_IsMarshalByRefImpl#1\">using namespace System;\nusing namespace System::Reflection;\npublic ref class MyTypeDelegatorClass: public TypeDelegator\n{\npublic:\n   String^ myElementType;\n\nprivate:\n   Type^ myType;\n\npublic:\n   MyTypeDelegatorClass( Type^ myType )\n      : TypeDelegator( myType )\n   {\n      this-&gt;myType = myType;\n   }\n\nprotected:\n\n   // Override IsMarshalByRefImpl.\n   virtual bool IsMarshalByRefImpl() override\n   {\n      // Determine whether the type is marshalled by reference.\n      if ( myType-&gt;IsMarshalByRef )\n      {\n         myElementType = &quot; marshalled by reference&quot;;\n         return true;\n      }\n\n      return false;\n   }\n};\n\npublic ref class MyTypeDemoClass{};\n\n\n// This class is used to demonstrate the IsMarshalByRefImpl method.\npublic ref class MyContextBoundClass: public ContextBoundObject\n{\npublic:\n   String^ myString;\n};\n\nint main()\n{\n   try\n   {\n      MyTypeDelegatorClass^ myType;\n      Console::WriteLine( &quot;Determine whether MyContextBoundClass is marshalled by reference.&quot; );\n      \n      // Determine whether MyContextBoundClass type is marshalled by reference.\n      myType = gcnew MyTypeDelegatorClass( MyContextBoundClass::typeid );\n      if ( myType-&gt;IsMarshalByRef )\n      {\n         Console::WriteLine( &quot;{0} is marshalled by reference.&quot;, MyContextBoundClass::typeid );\n      }\n      else\n      {\n         Console::WriteLine( &quot;{0} is not marshalled by reference.&quot;, MyContextBoundClass::typeid );\n      }\n      \n      // Determine whether int type is marshalled by reference.\n      myType = gcnew MyTypeDelegatorClass( int::typeid );\n      Console::WriteLine( &quot;<br>Determine whether int is marshalled by reference.&quot; );\n      if ( myType-&gt;IsMarshalByRef )\n      {\n         Console::WriteLine( &quot;{0} is marshalled by reference.&quot;, int::typeid );\n      }\n      else\n      {\n         Console::WriteLine( &quot;{0} is not marshalled by reference.&quot;, int::typeid );\n      }\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception: {0}&quot;, e-&gt;Message );\n   }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsPointerImpl\">\r\n    \r\n            <a id=\"System_Type_IsPointerImpl_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsPointerImpl()</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, implements the <span class=\"xref\">stem.Type.IsPointer*</span> property and determines whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is a pointer.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected abstract bool IsPointerImpl ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is a pointer; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsPrimitiveImpl\">\r\n    \r\n            <a id=\"System_Type_IsPrimitiveImpl_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsPrimitiveImpl()</div>        \r\n          </div>\r\n    \r\n            <p>When overridden in a derived class, implements the <span class=\"xref\">stem.Type.IsPrimitive*</span> property and determines whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is one of the primitive types.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected abstract bool IsPrimitiveImpl ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is one of the primitive types; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The primitive types are <a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a>, <a class=\"xref\" href=\"system.byte\" data-linktype=\"relative-path\">Byte</a>, <a class=\"xref\" href=\"system.sbyte\" data-linktype=\"relative-path\">SByte</a>, <a class=\"xref\" href=\"system.int16\" data-linktype=\"relative-path\">Int16</a>, <a class=\"xref\" href=\"system.uint16\" data-linktype=\"relative-path\">UInt16</a>, <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a>, <a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a>, <a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a>, <a class=\"xref\" href=\"system.uint64\" data-linktype=\"relative-path\">UInt64</a>, <a class=\"xref\" href=\"system.char\" data-linktype=\"relative-path\">Char</a>, <a class=\"xref\" href=\"system.double\" data-linktype=\"relative-path\">Double</a>, and <a class=\"xref\" href=\"system.single\" data-linktype=\"relative-path\">Single</a>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example determines whether the given type is a primitive type and displays the result.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_IsPrimitiveImpl#1\">using namespace System;\nusing namespace System::Reflection;\n\npublic ref class MyTypeDelegatorClass: public TypeDelegator\n{\npublic:\n   String^ myElementType;\n\nprivate:\n   Type^ myType;\n\npublic:\n   MyTypeDelegatorClass( Type^ myType )\n      : TypeDelegator( myType )\n   {\n      this-&gt;myType = myType;\n   }\n\nprotected:\n\n   // Override the IsPrimitiveImpl.\n   virtual bool IsPrimitiveImpl() override\n   {\n      \n      // Determine whether the type is a primitive type.\n      if ( myType-&gt;IsPrimitive )\n      {\n         myElementType = &quot;primitive&quot;;\n         return true;\n      }\n\n      return false;\n   }\n};\n\nint main()\n{\n   try\n   {\n      Console::WriteLine( &quot;Determine whether int is a primitive type.&quot; );\n      MyTypeDelegatorClass^ myType;\n      myType = gcnew MyTypeDelegatorClass( int::typeid );\n      \n      // Determine whether int is a primitive type.\n      if ( myType-&gt;IsPrimitive )\n      {\n         Console::WriteLine( &quot;{0} is a primitive type.&quot;, int::typeid );\n      }\n      else\n      {\n         Console::WriteLine( &quot;{0} is not a primitive type.&quot;, int::typeid );\n      }\n      Console::WriteLine( &quot;<br>Determine whether String is a primitive type.&quot; );\n      myType = gcnew MyTypeDelegatorClass( String::typeid );\n      \n      // Determine if String is a primitive type.\n      if ( myType-&gt;IsPrimitive )\n      {\n         Console::WriteLine( &quot;{0} is a primitive type.&quot;, String::typeid );\n      }\n      else\n      {\n         Console::WriteLine( &quot;{0} is not a primitive type.&quot;, String::typeid );\n      }\n   }\n   catch ( Exception^ e ) \n   {\n      Console::WriteLine( &quot;Exception: {0}&quot;, e-&gt;Message );\n   }\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_IsPrimitiveImpl#1\">using System;\nusing System.Reflection;\npublic class MyTypeDelegatorClass : TypeDelegator\n{\n    public string myElementType = null;\n    private Type myType = null ; \n    public MyTypeDelegatorClass(Type myType) : base(myType)\n    {\n        this.myType = myType;\n    }\n    // Override the IsPrimitiveImpl.\n    protected override bool IsPrimitiveImpl()\n    {\n        // Determine whether the type is a primitive type.\n        if(myType.IsPrimitive)\n        { \n            myElementType = &quot;primitive&quot;;\n            return true;\n        }\n        return false;\n    }\n}\npublic class MyTypeDemoClass\n{\n    public static void Main()\n    {\n        try\n        {\n            Console.WriteLine (&quot;Determine whether int is a primitive type.&quot;);\n            MyTypeDelegatorClass myType;\n            myType = new MyTypeDelegatorClass(typeof(int));\n            // Determine whether int is a primitive type.\n            if( myType.IsPrimitive)\n            {\n                Console.WriteLine(typeof(int) + &quot; is a primitive type.&quot;);\n            }\n            else\n            {\n                Console.WriteLine(typeof(int) + &quot; is not a primitive type.&quot;);\n            }\n            Console.WriteLine (&quot;<br>Determine whether string is a primitive type.&quot;);\n            myType = new MyTypeDelegatorClass(typeof(string));\n            // Determine if string is a primitive type.\n            if( myType.IsPrimitive)\n            {\n                Console.WriteLine(typeof(string) + &quot; is a primitive type.&quot;);\n            }\n            else\n            {\n                Console.WriteLine(typeof(string) + &quot; is not a primitive type.&quot;);\n            }\n        }\n        catch( Exception e )\n        {\n            Console.WriteLine(&quot;Exception: {0}&quot;, e.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_IsPrimitiveImpl#1\">Imports System\nImports System.Reflection\nImports Microsoft.VisualBasic\nPublic Class MyTypeDelegatorClass\n    Inherits TypeDelegator\n    Public myElementType As String = Nothing\n    Private myType As Type = Nothing\n    Public Sub New(ByVal myType As Type)\n        MyBase.New(myType)\n        Me.myType = myType\n    End Sub &#39;New\n    &#39; Override the IsPrimitiveImpl method.\n    Protected Overrides Function IsPrimitiveImpl() As Boolean\n        &#39; Determine whether the type is a primitive type.\n        If myType.IsPrimitive Then\n            myElementType = &quot;primitive&quot;\n            Return True\n        End If\n        Return False\n    End Function &#39;IsPrimitiveImpl\nEnd Class &#39;MyTypeDelegatorClass\nPublic Class MyTypeDemoClass\n    Public Shared Sub Main()\n        Try\n            Console.WriteLine(&quot;Determine whether int is a primitive type.&quot;)\n            Dim myType As MyTypeDelegatorClass\n            myType = New MyTypeDelegatorClass(GetType(Integer))\n            &#39; Determine whether int is a primitive type.\n            If myType.IsPrimitive Then\n                Console.WriteLine(GetType(Integer).ToString() + &quot; is a primitive type.&quot;)\n            Else\n                Console.WriteLine(GetType(Integer).ToString() + &quot; is not a primitive type.&quot;)\n            End If\n            Console.WriteLine(ControlChars.NewLine + &quot;Determine whether string is a primitive type.&quot;)\n            myType = New MyTypeDelegatorClass(GetType(String))\n            &#39; Determine whether string is a primitive type.\n            If myType.IsPrimitive Then\n                Console.WriteLine(GetType(String).ToString() + &quot; is a primitive type.&quot;)\n            Else\n                Console.WriteLine(GetType(String).ToString() + &quot; is not a primitive type.&quot;)\n            End If\n        Catch e As Exception\n            Console.WriteLine(&quot;Exception: {0}&quot;, e.Message.ToString())\n        End Try\n    End Sub &#39;Main\nEnd Class &#39;MyTypeDemoClass\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsSubclassOf_System_Type_\">\r\n    \r\n            <a id=\"System_Type_IsSubclassOf_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsSubclassOf(Type)</div>        \r\n          </div>\r\n    \r\n            <p>Determines whether the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> derives from the specified <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual bool IsSubclassOf (Type c);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>c</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The type to compare with the current type.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the current <code>Type</code> derives from <code>c</code>; otherwise, <code>false</code>. This method also returns <code>false</code> if <code>c</code> and the current <code>Type</code> are equal.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>c</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>You can call the IsSubclassOf method to determine any of the following:  </p>\n<ul>\n<li><p>Whether one class derives from another.  </p>\n</li>\n<li><p>Whether a type derives from <a class=\"xref\" href=\"system.valuetype\" data-linktype=\"relative-path\">ValueType</a>. However, the <a class=\"xref\" href=\"system.type#System_Type_IsValueType_\" data-linktype=\"relative-path\">IsValueType</a> is a more efficient way to determine whether a type is a value type.  </p>\n</li>\n<li><p>Whether a type derives from <a class=\"xref\" href=\"system.enum\" data-linktype=\"relative-path\">Enum</a>. However, the <a class=\"xref\" href=\"system.type#System_Type_IsEnum_\" data-linktype=\"relative-path\">IsEnum</a> method is a more efficient way to determine whether a type is an enumeration.  </p>\n</li>\n<li><p>Whether a type is a delegate, that is, whether it derives from either <a class=\"xref\" href=\"system.delegate\" data-linktype=\"relative-path\">Delegate</a> or <a class=\"xref\" href=\"system.multicastdelegate\" data-linktype=\"relative-path\">MulticastDelegate</a>.  </p>\n<p>The IsSubclassOf method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface. Use the<a class=\"xref\" href=\"system.type#System_Type_IsAssignableFrom_\" data-linktype=\"relative-path\">IsAssignableFrom</a> method for that purpose, as the following example shows.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.IsSubclassOf#1\">using System;\n\npublic interface IInterface\n{\n   void Display();\n}\n\npublic class Implementation : IInterface\n{\n   public void Display()\n   {\n      Console.WriteLine(&quot;The implementation...&quot;);\n   }\n}\n\npublic class Example\n{\n   public static void Main()\n   {\n      Console.WriteLine(&quot;Implementation is a subclass of IInterface:   {0}&quot;,\n                        typeof(Implementation).IsSubclassOf(typeof(IInterface)));\n      Console.WriteLine(&quot;IInterface is assignable from Implementation: {0}&quot;,\n                        typeof(IInterface).IsAssignableFrom(typeof(Implementation)));\n   }\n}\n// The example displays the following output:\n//       Implementation is a subclass of IInterface:   False\n//       IInterface is assignable from Implementation: True\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.IsSubclassOf#1\">Public Interface IInterface\n   Sub Display()\nEnd Interface\n\nPublic Class Implementation : Implements IInterface\n   Public Sub Display() _\n      Implements IInterface.Display\n\n      Console.WriteLine(&quot;The implementation...&quot;)\n   End Sub\nEnd Class\n\nModule Example\n   Public Sub Main()\n      Console.WriteLine(&quot;Implementation is a subclass of IInterface:   {0}&quot;,\n                        GetType(Implementation).IsSubclassOf(GetType(IInterface)))\n      Console.WriteLine(&quot;IInterface is assignable from Implementation: {0}&quot;,\n                        GetType(IInterface).IsAssignableFrom(GetType(Implementation)))\n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       Implementation is a subclass of IInterface:   False\n&#39;       IInterface is assignable from Implementation: True\n</code></pre><p>If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a> if it has no class constraint.  </p>\n</li>\n</ul>\n<div class=\"NOTE\"><h5>Note</h5><p> Except when used with interfaces, IsSubclassOf is the converse of <a class=\"xref\" href=\"system.type#System_Type_IsAssignableFrom_\" data-linktype=\"relative-path\">IsAssignableFrom</a>. That is, if <code>t1.IsSubclassOf(t2)</code> is <code>true</code>, then <code>t2.IsAssignableFrom(t1)</code> is also <code>true</code>.  </p>\n</div>\n<p> This method can be overridden by a derived class.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates a class named <code>Class1</code>and a derived class named <code>DerivedC1</code>. It calls the IsSubclassOf method to show that <code>DerivedC1</code> is a subclass of <code>Class1</code>.  </p>\n<pre><code class=\"lang-vb\" name=\"TestIsSubclassOf#1\">Public Class Class1\nEnd Class\n\nPublic Class DerivedC1 : Inherits Class1\nEnd Class\n\nPublic Module Example\n   Public Sub Main()\n      Console.WriteLine(&quot;DerivedC1 subclass of Class1: {0}&quot;,\n                         GetType(DerivedC1).IsSubClassOf(GetType(Class1)))\n   End Sub\nEnd Module\n&#39; The example displays the following output:\n&#39;       DerivedC1 subclass of Class1: True\n</code></pre><pre><code class=\"lang-cs\" name=\"TestIsSubclassOf#1\">using System;\n\npublic class Class1 { }\npublic class DerivedC1 : Class1 { }\n\nclass IsSubclassTest\n{\n   public static void Main()\n   {\n      Console.WriteLine(&quot;DerivedC1 subclass of Class1: {0}&quot;,\n                         typeof(DerivedC1).IsSubclassOf(typeof(Class1)));\n   }\n}\n// The example displays the following output:\n//        DerivedC1 subclass of Class1: True\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_IsValueTypeImpl\">\r\n    \r\n            <a id=\"System_Type_IsValueTypeImpl_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">IsValueTypeImpl()</div>        \r\n          </div>\r\n    \r\n            <p>Implements the <span class=\"xref\">stem.Type.IsValueType*</span> property and determines whether the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is a value type; that is, not a class or an interface.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected virtual bool IsValueTypeImpl ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> is a value type; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is provided to enable the implementation of alternate type systems. It is not generally used in application code.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_MakeArrayType\">\r\n    \r\n            <a id=\"System_Type_MakeArrayType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">MakeArrayType()</div>        \r\n          </div>\r\n    \r\n            <p>Returns a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object representing a one-dimensional array of the current type, with a lower bound of zero.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual Type MakeArrayType ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object representing a one-dimensional array of the current type, with a lower bound of zero.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The invoked method is not supported in the base class. Derived classes must provide an implementation.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.typeloadexception\" data-linktype=\"relative-path\">TypeLoadException</a></div>\r\n                  </div>\r\n                  <p>The current type is <a class=\"xref\" href=\"system.typedreference\" data-linktype=\"relative-path\">TypedReference</a>.  </p>\n<p> -or-  </p>\n<p> The current type is a <code>ByRef</code> type. That is, <span class=\"xref\">stem.Type.IsByRef*</span> returns <code>true</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The MakeArrayType method provides a way to generate array types whose element types are computed at run time.  </p>\n<p> <strong>Note</strong> The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays. A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension. This method overload can only be used to create vector types, and it is the only way to create a vector type. Use the <a class=\"xref\" href=\"system.type#System_Type_MakeArrayType_System_Int32_\" data-linktype=\"relative-path\">MakeArrayType(Int32)</a> method overload to create multidimensional array types.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example creates array, <code>ref</code> (<code>ByRef</code> in Visual Basic), and pointer types for the <code>Test</code> class.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.MakeXxxType#1\">using System;\nusing System.Reflection;\n\npublic class Example\n{\n    public static void Main()\n    {\n        // Create a Type object that represents a one-dimensional\n        // array of Example objects.\n        Type t = typeof(Example).MakeArrayType();\n        Console.WriteLine(&quot;\\r<br>Array of Example: {0}&quot;, t);\n\n        // Create a Type object that represents a two-dimensional\n        // array of Example objects.\n        t = typeof(Example).MakeArrayType(2);\n        Console.WriteLine(&quot;\\r<br>Two-dimensional array of Example: {0}&quot;, t);\n\n        // Demonstrate an exception when an invalid array rank is\n        // specified.\n        try\n        {\n            t = typeof(Example).MakeArrayType(-1);\n        }\n        catch(Exception ex)\n        {\n            Console.WriteLine(&quot;\\r<br>{0}&quot;, ex);\n        }\n\n        // Create a Type object that represents a ByRef parameter\n        // of type Example.\n        t = typeof(Example).MakeByRefType();\n        Console.WriteLine(&quot;\\r<br>ByRef Example: {0}&quot;, t);\n\n        // Get a Type object representing the Example class, a\n        // MethodInfo representing the &quot;Test&quot; method, a ParameterInfo\n        // representing the parameter of type Example, and finally\n        // a Type object representing the type of this ByRef parameter.\n        // Compare this Type object with the Type object created using\n        // MakeByRefType.\n        Type t2 = typeof(Example);\n        MethodInfo mi = t2.GetMethod(&quot;Test&quot;);\n        ParameterInfo pi = mi.GetParameters()[0];\n        Type pt = pi.ParameterType;\n        Console.WriteLine(&quot;Are the ByRef types equal? {0}&quot;, (t == pt));\n\n        // Create a Type object that represents a pointer to an\n        // Example object.\n        t = typeof(Example).MakePointerType();\n        Console.WriteLine(&quot;\\r<br>Pointer to Example: {0}&quot;, t);\n    }\n\n    // A sample method with a ByRef parameter.\n    //\n    public void Test(ref Example e)\n    {\n    }\n}\n\n/* This example produces output similar to the following:\n\nArray of Example: Example[]\n\nTwo-dimensional array of Example: Example[,]\n\nSystem.IndexOutOfRangeException: Index was outside the bounds of the array.\n   at System.RuntimeType.MakeArrayType(Int32 rank) in c:\\vbl<br>dp\\clr\\src\\BCL\\System\\RtType.cs:line 2999\n   at Example.Main()\n\nByRef Example: Example&amp;\nAre the ByRef types equal? True\n\nPointer to Example: Example*\n\n */\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Type.MakeXxxType#1\">using namespace System;\nusing namespace System::Reflection;\n\npublic ref class Example\n{\npublic:\n   static void Main()\n   {\n      // Create a Type object that represents a one-dimensional\n      // array of Example objects.\n      Type^ t = Example::typeid-&gt;MakeArrayType();\n      Console::WriteLine( L&quot;\\r<br>Array of Example: {0}&quot;, t );\n      \n      // Create a Type object that represents a two-dimensional\n      // array of Example objects.\n      t = Example::typeid-&gt;MakeArrayType( 2 );\n      Console::WriteLine( L&quot;\\r<br>Two-dimensional array of Example: {0}&quot;, t );\n      \n      // Demonstrate an exception when an invalid array rank is\n      // specified.\n      try\n      {\n         t = Example::typeid-&gt;MakeArrayType(  -1 );\n      }\n      catch ( Exception^ ex ) \n      {\n         Console::WriteLine( L&quot;\\r<br>{0}&quot;, ex );\n      }\n      \n      // Create a Type object that represents a ByRef parameter\n      // of type Example.\n      t = Example::typeid-&gt;MakeByRefType();\n      Console::WriteLine( L&quot;\\r<br>ByRef Example: {0}&quot;, t );\n      \n      // Get a Type object representing the Example class, a\n      // MethodInfo representing the &quot;Test&quot; method, a ParameterInfo\n      // representing the parameter of type Example, and finally\n      // a Type object representing the type of this ByRef parameter.\n      // Compare this Type object with the Type object created using\n      // MakeByRefType.\n      Type^ t2 = Example::typeid;\n      MethodInfo^ mi = t2-&gt;GetMethod( L&quot;Test&quot; );\n      ParameterInfo^ pi = mi-&gt;GetParameters()[ 0 ];\n      Type^ pt = pi-&gt;ParameterType;\n      Console::WriteLine( L&quot;Are the ByRef types equal? {0}&quot;, (t == pt) );\n      \n      // Create a Type object that represents a pointer to an\n      // Example object.\n      t = Example::typeid-&gt;MakePointerType();\n      Console::WriteLine( L&quot;\\r<br>Pointer to Example: {0}&quot;, t );\n   }\n\n   // A sample method with a ByRef parameter.\n   //\n   void Test( interior_ptr&lt;Example^&gt; /*e*/ )\n   {\n   }\n};\n\nint main()\n{\n   Example::Main();\n}\n\n/* This example produces output similar to the following:\n\nArray of Example: Example[]\n\nTwo-dimensional array of Example: Example[,]\n\nSystem.IndexOutOfRangeException: Index was outside the bounds of the array.\n   at System.RuntimeType.MakeArrayType(Int32 rank) in c:\\vbl<br>dp\\clr\\src\\BCL\\System\\RtType.cs:line 2999\n   at Example.Main()\n\nByRef Example: Example&amp;\nAre the ByRef types equal? True\n\nPointer to Example: Example*\n\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.MakeXxxType#1\">Imports System\nImports System.Reflection\nImports Microsoft.VisualBasic\n\nPublic Class Example\n    Public Shared Sub Main()\n        &#39; Create a Type object that represents a one-dimensional\n        &#39; array of Example objects.\n        Dim t As Type = GetType(Example).MakeArrayType()\n        Console.WriteLine(vbCrLf &amp; &quot;Array of Example: &quot; &amp; t.ToString())\n\n        &#39; Create a Type object that represents a two-dimensional\n        &#39; array of Example objects.\n        t = GetType(Example).MakeArrayType(2)\n        Console.WriteLine(vbCrLf &amp; &quot;Two-dimensional array of Example: &quot; &amp; t.ToString())\n\n        &#39; Demonstrate an exception when an invalid array rank is\n        &#39; specified.\n        Try\n            t = GetType(Example).MakeArrayType(-1)\n        Catch ex As Exception\n            Console.WriteLine(vbCrLf &amp; ex.ToString())\n        End Try\n\n        &#39; Create a Type object that represents a ByRef parameter\n        &#39; of type Example.\n        t = GetType(Example).MakeByRefType()\n        Console.WriteLine(vbCrLf &amp; &quot;ByRef Example: &quot; &amp; t.ToString())\n\n        &#39; Get a Type object representing the Example class, a\n        &#39; MethodInfo representing the &quot;Test&quot; method, a ParameterInfo\n        &#39; representing the parameter of type Example, and finally\n        &#39; a Type object representing the type of this ByRef parameter.\n        &#39; Compare this Type object with the Type object created using\n        &#39; MakeByRefType.\n        Dim t2 As Type = GetType(Example)\n        Dim mi As MethodInfo = t2.GetMethod(&quot;Test&quot;)\n        Dim pi As ParameterInfo = mi.GetParameters()(0)\n        Dim pt As Type = pi.ParameterType\n        Console.WriteLine(&quot;Are the ByRef types equal? &quot; &amp; (t Is pt))\n\n        &#39; Create a Type object that represents a pointer to an\n        &#39; Example object.\n        t = GetType(Example).MakePointerType()\n        Console.WriteLine(vbCrLf &amp; &quot;Pointer to Example: &quot; &amp; t.ToString())\n    End Sub\n\n    &#39; A sample method with a ByRef parameter.\n    &#39;\n    Public Sub Test(ByRef e As Example)\n    End Sub\nEnd Class\n\n&#39; This example produces output similar to the following:\n&#39;\n&#39;Array of Example: Example[]\n&#39;\n&#39;Two-dimensional array of Example: Example[,]\n&#39;\n&#39;System.IndexOutOfRangeException: Index was outside the bounds of the array.\n&#39;   at System.RuntimeType.MakeArrayType(Int32 rank) in c:\\vbl<br>dp\\clr\\src\\BCL\\System\\RtType.cs:line 2999\n&#39;   at Example.Main()\n&#39;\n&#39;ByRef Example: Example&amp;\n&#39;Are the ByRef types equal? True\n&#39;\n&#39;Pointer to Example: Example*\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_MakeArrayType_System_Int32_\">\r\n    \r\n            <a id=\"System_Type_MakeArrayType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">MakeArrayType(Int32)</div>        \r\n          </div>\r\n    \r\n            <p>Returns a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object representing an array of the current type, with the specified number of dimensions.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual Type MakeArrayType (int rank);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>rank</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The number of dimensions for the array. This number must be less than or equal to 32.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>An object representing an array of the current type, with the specified number of dimensions.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.indexoutofrangeexception\" data-linktype=\"relative-path\">IndexOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p><code>rank</code> is invalid. For example, 0 or negative.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The invoked method is not supported in the base class.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.typeloadexception\" data-linktype=\"relative-path\">TypeLoadException</a></div>\r\n                  </div>\r\n                  <p>The current type is <a class=\"xref\" href=\"system.typedreference\" data-linktype=\"relative-path\">TypedReference</a>.  </p>\n<p> -or-  </p>\n<p> The current type is a <code>ByRef</code> type. That is, <span class=\"xref\">stem.Type.IsByRef*</span> returns <code>true</code>.  </p>\n<p> -or-  </p>\n<p> <code>rank</code> is greater than 32.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <a class=\"xref\" href=\"system.type#System_Type_MakeArrayType_\" data-linktype=\"relative-path\">MakeArrayType</a> method provides a way to generate array types whose element types are computed at run time.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays. A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension. You cannot use this method overload to create a vector type; if <code>rank</code> is 1, this method overload returns a multidimensional array type that happens to have one dimension. Use the <a class=\"xref\" href=\"system.type#System_Type_MakeArrayType\" data-linktype=\"relative-path\">MakeArrayType()</a> method overload to create vector types.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example creates array, <code>ref</code> (<code>ByRef</code> in Visual Basic), and pointer types for the <code>Test</code> class.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.MakeXxxType#1\">using System;\nusing System.Reflection;\n\npublic class Example\n{\n    public static void Main()\n    {\n        // Create a Type object that represents a one-dimensional\n        // array of Example objects.\n        Type t = typeof(Example).MakeArrayType();\n        Console.WriteLine(&quot;\\r<br>Array of Example: {0}&quot;, t);\n\n        // Create a Type object that represents a two-dimensional\n        // array of Example objects.\n        t = typeof(Example).MakeArrayType(2);\n        Console.WriteLine(&quot;\\r<br>Two-dimensional array of Example: {0}&quot;, t);\n\n        // Demonstrate an exception when an invalid array rank is\n        // specified.\n        try\n        {\n            t = typeof(Example).MakeArrayType(-1);\n        }\n        catch(Exception ex)\n        {\n            Console.WriteLine(&quot;\\r<br>{0}&quot;, ex);\n        }\n\n        // Create a Type object that represents a ByRef parameter\n        // of type Example.\n        t = typeof(Example).MakeByRefType();\n        Console.WriteLine(&quot;\\r<br>ByRef Example: {0}&quot;, t);\n\n        // Get a Type object representing the Example class, a\n        // MethodInfo representing the &quot;Test&quot; method, a ParameterInfo\n        // representing the parameter of type Example, and finally\n        // a Type object representing the type of this ByRef parameter.\n        // Compare this Type object with the Type object created using\n        // MakeByRefType.\n        Type t2 = typeof(Example);\n        MethodInfo mi = t2.GetMethod(&quot;Test&quot;);\n        ParameterInfo pi = mi.GetParameters()[0];\n        Type pt = pi.ParameterType;\n        Console.WriteLine(&quot;Are the ByRef types equal? {0}&quot;, (t == pt));\n\n        // Create a Type object that represents a pointer to an\n        // Example object.\n        t = typeof(Example).MakePointerType();\n        Console.WriteLine(&quot;\\r<br>Pointer to Example: {0}&quot;, t);\n    }\n\n    // A sample method with a ByRef parameter.\n    //\n    public void Test(ref Example e)\n    {\n    }\n}\n\n/* This example produces output similar to the following:\n\nArray of Example: Example[]\n\nTwo-dimensional array of Example: Example[,]\n\nSystem.IndexOutOfRangeException: Index was outside the bounds of the array.\n   at System.RuntimeType.MakeArrayType(Int32 rank) in c:\\vbl<br>dp\\clr\\src\\BCL\\System\\RtType.cs:line 2999\n   at Example.Main()\n\nByRef Example: Example&amp;\nAre the ByRef types equal? True\n\nPointer to Example: Example*\n\n */\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Type.MakeXxxType#1\">using namespace System;\nusing namespace System::Reflection;\n\npublic ref class Example\n{\npublic:\n   static void Main()\n   {\n      // Create a Type object that represents a one-dimensional\n      // array of Example objects.\n      Type^ t = Example::typeid-&gt;MakeArrayType();\n      Console::WriteLine( L&quot;\\r<br>Array of Example: {0}&quot;, t );\n      \n      // Create a Type object that represents a two-dimensional\n      // array of Example objects.\n      t = Example::typeid-&gt;MakeArrayType( 2 );\n      Console::WriteLine( L&quot;\\r<br>Two-dimensional array of Example: {0}&quot;, t );\n      \n      // Demonstrate an exception when an invalid array rank is\n      // specified.\n      try\n      {\n         t = Example::typeid-&gt;MakeArrayType(  -1 );\n      }\n      catch ( Exception^ ex ) \n      {\n         Console::WriteLine( L&quot;\\r<br>{0}&quot;, ex );\n      }\n      \n      // Create a Type object that represents a ByRef parameter\n      // of type Example.\n      t = Example::typeid-&gt;MakeByRefType();\n      Console::WriteLine( L&quot;\\r<br>ByRef Example: {0}&quot;, t );\n      \n      // Get a Type object representing the Example class, a\n      // MethodInfo representing the &quot;Test&quot; method, a ParameterInfo\n      // representing the parameter of type Example, and finally\n      // a Type object representing the type of this ByRef parameter.\n      // Compare this Type object with the Type object created using\n      // MakeByRefType.\n      Type^ t2 = Example::typeid;\n      MethodInfo^ mi = t2-&gt;GetMethod( L&quot;Test&quot; );\n      ParameterInfo^ pi = mi-&gt;GetParameters()[ 0 ];\n      Type^ pt = pi-&gt;ParameterType;\n      Console::WriteLine( L&quot;Are the ByRef types equal? {0}&quot;, (t == pt) );\n      \n      // Create a Type object that represents a pointer to an\n      // Example object.\n      t = Example::typeid-&gt;MakePointerType();\n      Console::WriteLine( L&quot;\\r<br>Pointer to Example: {0}&quot;, t );\n   }\n\n   // A sample method with a ByRef parameter.\n   //\n   void Test( interior_ptr&lt;Example^&gt; /*e*/ )\n   {\n   }\n};\n\nint main()\n{\n   Example::Main();\n}\n\n/* This example produces output similar to the following:\n\nArray of Example: Example[]\n\nTwo-dimensional array of Example: Example[,]\n\nSystem.IndexOutOfRangeException: Index was outside the bounds of the array.\n   at System.RuntimeType.MakeArrayType(Int32 rank) in c:\\vbl<br>dp\\clr\\src\\BCL\\System\\RtType.cs:line 2999\n   at Example.Main()\n\nByRef Example: Example&amp;\nAre the ByRef types equal? True\n\nPointer to Example: Example*\n\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.MakeXxxType#1\">Imports System\nImports System.Reflection\nImports Microsoft.VisualBasic\n\nPublic Class Example\n    Public Shared Sub Main()\n        &#39; Create a Type object that represents a one-dimensional\n        &#39; array of Example objects.\n        Dim t As Type = GetType(Example).MakeArrayType()\n        Console.WriteLine(vbCrLf &amp; &quot;Array of Example: &quot; &amp; t.ToString())\n\n        &#39; Create a Type object that represents a two-dimensional\n        &#39; array of Example objects.\n        t = GetType(Example).MakeArrayType(2)\n        Console.WriteLine(vbCrLf &amp; &quot;Two-dimensional array of Example: &quot; &amp; t.ToString())\n\n        &#39; Demonstrate an exception when an invalid array rank is\n        &#39; specified.\n        Try\n            t = GetType(Example).MakeArrayType(-1)\n        Catch ex As Exception\n            Console.WriteLine(vbCrLf &amp; ex.ToString())\n        End Try\n\n        &#39; Create a Type object that represents a ByRef parameter\n        &#39; of type Example.\n        t = GetType(Example).MakeByRefType()\n        Console.WriteLine(vbCrLf &amp; &quot;ByRef Example: &quot; &amp; t.ToString())\n\n        &#39; Get a Type object representing the Example class, a\n        &#39; MethodInfo representing the &quot;Test&quot; method, a ParameterInfo\n        &#39; representing the parameter of type Example, and finally\n        &#39; a Type object representing the type of this ByRef parameter.\n        &#39; Compare this Type object with the Type object created using\n        &#39; MakeByRefType.\n        Dim t2 As Type = GetType(Example)\n        Dim mi As MethodInfo = t2.GetMethod(&quot;Test&quot;)\n        Dim pi As ParameterInfo = mi.GetParameters()(0)\n        Dim pt As Type = pi.ParameterType\n        Console.WriteLine(&quot;Are the ByRef types equal? &quot; &amp; (t Is pt))\n\n        &#39; Create a Type object that represents a pointer to an\n        &#39; Example object.\n        t = GetType(Example).MakePointerType()\n        Console.WriteLine(vbCrLf &amp; &quot;Pointer to Example: &quot; &amp; t.ToString())\n    End Sub\n\n    &#39; A sample method with a ByRef parameter.\n    &#39;\n    Public Sub Test(ByRef e As Example)\n    End Sub\nEnd Class\n\n&#39; This example produces output similar to the following:\n&#39;\n&#39;Array of Example: Example[]\n&#39;\n&#39;Two-dimensional array of Example: Example[,]\n&#39;\n&#39;System.IndexOutOfRangeException: Index was outside the bounds of the array.\n&#39;   at System.RuntimeType.MakeArrayType(Int32 rank) in c:\\vbl<br>dp\\clr\\src\\BCL\\System\\RtType.cs:line 2999\n&#39;   at Example.Main()\n&#39;\n&#39;ByRef Example: Example&amp;\n&#39;Are the ByRef types equal? True\n&#39;\n&#39;Pointer to Example: Example*\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_MakeByRefType\">\r\n    \r\n            <a id=\"System_Type_MakeByRefType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">MakeByRefType()</div>        \r\n          </div>\r\n    \r\n            <p>Returns a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents the current type when passed as a <code>ref</code> parameter (<code>ByRef</code> parameter in Visual Basic).</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual Type MakeByRefType ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents the current type when passed as a <code>ref</code> parameter (<code>ByRef</code> parameter in Visual Basic).</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The invoked method is not supported in the base class.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.typeloadexception\" data-linktype=\"relative-path\">TypeLoadException</a></div>\r\n                  </div>\r\n                  <p>The current type is <a class=\"xref\" href=\"system.typedreference\" data-linktype=\"relative-path\">TypedReference</a>.  </p>\n<p> -or-  </p>\n<p> The current type is a <code>ByRef</code> type. That is, <span class=\"xref\">stem.Type.IsByRef*</span> returns <code>true</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The MakeByRefType method provides a way to generate <code>ref</code> types (<code>ByRef</code> in Visual Basic) for parameter lists.  </p>\n<p> Using the syntax of Microsoft intermediate language (MSIL), if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a>, this method returns a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object representing <code>Int32&amp;</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example creates array, <code>ref</code> (<code>ByRef</code> in Visual Basic), and pointer types for the <code>Test</code> class.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.MakeXxxType#1\">using System;\nusing System.Reflection;\n\npublic class Example\n{\n    public static void Main()\n    {\n        // Create a Type object that represents a one-dimensional\n        // array of Example objects.\n        Type t = typeof(Example).MakeArrayType();\n        Console.WriteLine(&quot;\\r<br>Array of Example: {0}&quot;, t);\n\n        // Create a Type object that represents a two-dimensional\n        // array of Example objects.\n        t = typeof(Example).MakeArrayType(2);\n        Console.WriteLine(&quot;\\r<br>Two-dimensional array of Example: {0}&quot;, t);\n\n        // Demonstrate an exception when an invalid array rank is\n        // specified.\n        try\n        {\n            t = typeof(Example).MakeArrayType(-1);\n        }\n        catch(Exception ex)\n        {\n            Console.WriteLine(&quot;\\r<br>{0}&quot;, ex);\n        }\n\n        // Create a Type object that represents a ByRef parameter\n        // of type Example.\n        t = typeof(Example).MakeByRefType();\n        Console.WriteLine(&quot;\\r<br>ByRef Example: {0}&quot;, t);\n\n        // Get a Type object representing the Example class, a\n        // MethodInfo representing the &quot;Test&quot; method, a ParameterInfo\n        // representing the parameter of type Example, and finally\n        // a Type object representing the type of this ByRef parameter.\n        // Compare this Type object with the Type object created using\n        // MakeByRefType.\n        Type t2 = typeof(Example);\n        MethodInfo mi = t2.GetMethod(&quot;Test&quot;);\n        ParameterInfo pi = mi.GetParameters()[0];\n        Type pt = pi.ParameterType;\n        Console.WriteLine(&quot;Are the ByRef types equal? {0}&quot;, (t == pt));\n\n        // Create a Type object that represents a pointer to an\n        // Example object.\n        t = typeof(Example).MakePointerType();\n        Console.WriteLine(&quot;\\r<br>Pointer to Example: {0}&quot;, t);\n    }\n\n    // A sample method with a ByRef parameter.\n    //\n    public void Test(ref Example e)\n    {\n    }\n}\n\n/* This example produces output similar to the following:\n\nArray of Example: Example[]\n\nTwo-dimensional array of Example: Example[,]\n\nSystem.IndexOutOfRangeException: Index was outside the bounds of the array.\n   at System.RuntimeType.MakeArrayType(Int32 rank) in c:\\vbl<br>dp\\clr\\src\\BCL\\System\\RtType.cs:line 2999\n   at Example.Main()\n\nByRef Example: Example&amp;\nAre the ByRef types equal? True\n\nPointer to Example: Example*\n\n */\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Type.MakeXxxType#1\">using namespace System;\nusing namespace System::Reflection;\n\npublic ref class Example\n{\npublic:\n   static void Main()\n   {\n      // Create a Type object that represents a one-dimensional\n      // array of Example objects.\n      Type^ t = Example::typeid-&gt;MakeArrayType();\n      Console::WriteLine( L&quot;\\r<br>Array of Example: {0}&quot;, t );\n      \n      // Create a Type object that represents a two-dimensional\n      // array of Example objects.\n      t = Example::typeid-&gt;MakeArrayType( 2 );\n      Console::WriteLine( L&quot;\\r<br>Two-dimensional array of Example: {0}&quot;, t );\n      \n      // Demonstrate an exception when an invalid array rank is\n      // specified.\n      try\n      {\n         t = Example::typeid-&gt;MakeArrayType(  -1 );\n      }\n      catch ( Exception^ ex ) \n      {\n         Console::WriteLine( L&quot;\\r<br>{0}&quot;, ex );\n      }\n      \n      // Create a Type object that represents a ByRef parameter\n      // of type Example.\n      t = Example::typeid-&gt;MakeByRefType();\n      Console::WriteLine( L&quot;\\r<br>ByRef Example: {0}&quot;, t );\n      \n      // Get a Type object representing the Example class, a\n      // MethodInfo representing the &quot;Test&quot; method, a ParameterInfo\n      // representing the parameter of type Example, and finally\n      // a Type object representing the type of this ByRef parameter.\n      // Compare this Type object with the Type object created using\n      // MakeByRefType.\n      Type^ t2 = Example::typeid;\n      MethodInfo^ mi = t2-&gt;GetMethod( L&quot;Test&quot; );\n      ParameterInfo^ pi = mi-&gt;GetParameters()[ 0 ];\n      Type^ pt = pi-&gt;ParameterType;\n      Console::WriteLine( L&quot;Are the ByRef types equal? {0}&quot;, (t == pt) );\n      \n      // Create a Type object that represents a pointer to an\n      // Example object.\n      t = Example::typeid-&gt;MakePointerType();\n      Console::WriteLine( L&quot;\\r<br>Pointer to Example: {0}&quot;, t );\n   }\n\n   // A sample method with a ByRef parameter.\n   //\n   void Test( interior_ptr&lt;Example^&gt; /*e*/ )\n   {\n   }\n};\n\nint main()\n{\n   Example::Main();\n}\n\n/* This example produces output similar to the following:\n\nArray of Example: Example[]\n\nTwo-dimensional array of Example: Example[,]\n\nSystem.IndexOutOfRangeException: Index was outside the bounds of the array.\n   at System.RuntimeType.MakeArrayType(Int32 rank) in c:\\vbl<br>dp\\clr\\src\\BCL\\System\\RtType.cs:line 2999\n   at Example.Main()\n\nByRef Example: Example&amp;\nAre the ByRef types equal? True\n\nPointer to Example: Example*\n\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.MakeXxxType#1\">Imports System\nImports System.Reflection\nImports Microsoft.VisualBasic\n\nPublic Class Example\n    Public Shared Sub Main()\n        &#39; Create a Type object that represents a one-dimensional\n        &#39; array of Example objects.\n        Dim t As Type = GetType(Example).MakeArrayType()\n        Console.WriteLine(vbCrLf &amp; &quot;Array of Example: &quot; &amp; t.ToString())\n\n        &#39; Create a Type object that represents a two-dimensional\n        &#39; array of Example objects.\n        t = GetType(Example).MakeArrayType(2)\n        Console.WriteLine(vbCrLf &amp; &quot;Two-dimensional array of Example: &quot; &amp; t.ToString())\n\n        &#39; Demonstrate an exception when an invalid array rank is\n        &#39; specified.\n        Try\n            t = GetType(Example).MakeArrayType(-1)\n        Catch ex As Exception\n            Console.WriteLine(vbCrLf &amp; ex.ToString())\n        End Try\n\n        &#39; Create a Type object that represents a ByRef parameter\n        &#39; of type Example.\n        t = GetType(Example).MakeByRefType()\n        Console.WriteLine(vbCrLf &amp; &quot;ByRef Example: &quot; &amp; t.ToString())\n\n        &#39; Get a Type object representing the Example class, a\n        &#39; MethodInfo representing the &quot;Test&quot; method, a ParameterInfo\n        &#39; representing the parameter of type Example, and finally\n        &#39; a Type object representing the type of this ByRef parameter.\n        &#39; Compare this Type object with the Type object created using\n        &#39; MakeByRefType.\n        Dim t2 As Type = GetType(Example)\n        Dim mi As MethodInfo = t2.GetMethod(&quot;Test&quot;)\n        Dim pi As ParameterInfo = mi.GetParameters()(0)\n        Dim pt As Type = pi.ParameterType\n        Console.WriteLine(&quot;Are the ByRef types equal? &quot; &amp; (t Is pt))\n\n        &#39; Create a Type object that represents a pointer to an\n        &#39; Example object.\n        t = GetType(Example).MakePointerType()\n        Console.WriteLine(vbCrLf &amp; &quot;Pointer to Example: &quot; &amp; t.ToString())\n    End Sub\n\n    &#39; A sample method with a ByRef parameter.\n    &#39;\n    Public Sub Test(ByRef e As Example)\n    End Sub\nEnd Class\n\n&#39; This example produces output similar to the following:\n&#39;\n&#39;Array of Example: Example[]\n&#39;\n&#39;Two-dimensional array of Example: Example[,]\n&#39;\n&#39;System.IndexOutOfRangeException: Index was outside the bounds of the array.\n&#39;   at System.RuntimeType.MakeArrayType(Int32 rank) in c:\\vbl<br>dp\\clr\\src\\BCL\\System\\RtType.cs:line 2999\n&#39;   at Example.Main()\n&#39;\n&#39;ByRef Example: Example&amp;\n&#39;Are the ByRef types equal? True\n&#39;\n&#39;Pointer to Example: Example*\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_MakeGenericType_System_Type___\">\r\n    \r\n            <a id=\"System_Type_MakeGenericType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">MakeGenericType(Type[])</div>        \r\n          </div>\r\n    \r\n            <p>Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object representing the resulting constructed type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual Type MakeGenericType (Type[] typeArguments);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>typeArguments</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>An array of types to be substituted for the type parameters of the current generic type.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> representing the constructed type formed by substituting the elements of <code>typeArguments</code> for the type parameters of the current generic type.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The current type does not represent a generic type definition. That is, <span class=\"xref\">stem.Type.IsGenericTypeDefinition*</span> returns <code>false</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>typeArguments</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> Any element of <code>typeArguments</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p>The number of elements in <code>typeArguments</code> is not the same as the number of type parameters in the current generic type definition.  </p>\n<p> -or-  </p>\n<p> Any element of <code>typeArguments</code> does not satisfy the constraints specified for the corresponding type parameter of the current generic type.  </p>\n<p> -or-  </p>\n<p> <code>typeArguments</code> contains an element that is a pointer type (<span class=\"xref\">stem.Type.IsPointer*</span> returns <code>true</code>), a by-ref type (<span class=\"xref\">stem.Type.IsByRef*</span> returns <code>true</code>), or <a class=\"xref\" href=\"system.void\" data-linktype=\"relative-path\">Void</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The invoked method is not supported in the base class. Derived classes must provide an implementation.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The MakeGenericType method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents a particular constructed type. You can use this <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object to create run-time instances of the constructed type.  </p>\n<p> Types constructed with MakeGenericType can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types. You might use such open constructed types when you emit dynamic assemblies. For example, consider the classes <code>Base</code> and <code>Derived</code> in the following code.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.MakeGenericType#1\">public class Base&lt;T, U&gt; { }\npublic class Derived&lt;V&gt; : Base&lt;int, V&gt; { }\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Type.MakeGenericType#1\">generic&lt;typename T, typename U&gt;\n    public ref class Base { };\ngeneric&lt;typename V&gt;\n    public ref class Derived : Base&lt;int, V&gt; { };\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.MakeGenericType#1\">Public Class Base(Of T, U)\nEnd Class\nPublic Class Derived(Of V)\n    Inherits Base(Of Integer, V)\nEnd Class\n</code></pre><p> To generate <code>Derived</code> in a dynamic assembly, it is necessary to construct its base type. To do this, call the MakeGenericType method on a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object representing the class <code>Base</code>, using the generic type arguments <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a> and the type parameter <code>V</code> from <code>Derived</code>. Because types and generic type parameters are both represented by <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects, an array containing both can be passed to the MakeGenericType method.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> A constructed type such as <code>Base&lt;int, V&gt;</code> is useful when emitting code, but you cannot call the MakeGenericType method on this type because it is not a generic type definition. To create a closed constructed type that can be instantiated, first call the <a class=\"xref\" href=\"system.type#System_Type_GetGenericTypeDefinition_\" data-linktype=\"relative-path\">GetGenericTypeDefinition</a> method to get a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object representing the generic type definition and then call MakeGenericType with the desired type arguments.  </p>\n</div>\n<p> The <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object returned by MakeGenericType is the same as the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> obtained by calling the <a class=\"xref\" href=\"system.object#System_Object_GetType_\" data-linktype=\"relative-path\">GetType</a> method of the resulting constructed type, or the <a class=\"xref\" href=\"system.object#System_Object_GetType_\" data-linktype=\"relative-path\">GetType</a>method of any constructed type that was created from the same generic type definition using the same type arguments.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> An array of generic types is not itself a generic type. You cannot call MakeGenericType on an array type such as <code>C&lt;T&gt;[]</code> (<code>Dim ac() As C(Of T)</code> in Visual Basic). To construct a closed generic type from <code>C&lt;T&gt;[]</code>, call <a class=\"xref\" href=\"system.type#System_Type_GetElementType_\" data-linktype=\"relative-path\">GetElementType</a> to obtain the generic type definition <code>C&lt;T&gt;</code>; call MakeGenericType on the generic type definition to create the constructed type; and finally call the <a class=\"xref\" href=\"system.type#System_Type_MakeArrayType_\" data-linktype=\"relative-path\">MakeArrayType</a> method on the constructed type to create the array type. The same is true of pointer types and <code>ref</code> types (<code>ByRef</code> in Visual Basic).  </p>\n</div>\n<p> For a list of the invariant conditions for terms used in generic reflection, see the <a class=\"xref\" href=\"system.type#System_Type_IsGenericType_\" data-linktype=\"relative-path\">IsGenericType</a> property remarks.  </p>\n<h2 id=\"nested-types\">Nested Types</h2>\n<p> If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic. This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types. Consider the following classes:  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.MakeGenericType#2\">public class Outermost&lt;T&gt;\n{\n    public class Inner&lt;U&gt;\n    {\n        public class Innermost1&lt;V&gt; {}\n        public class Innermost2 {}\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Type.MakeGenericType#2\">generic&lt;typename T&gt; public ref class Outermost\n{\npublic:\n    generic&lt;typename U&gt; ref class Inner\n    {\n    public:\n        generic&lt;typename V&gt; ref class Innermost1 {};\n        ref class Innermost2 {};\n    };\n};\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.MakeGenericType#2\">Public Class Outermost(Of T)\n    Public Class Inner(Of U)\n        Public Class Innermost1(Of V)\n        End Class\n        Public Class Innermost2\n        End Class\n    End Class\nEnd Class\n</code></pre><p> The type parameter list of the nested class <code>Inner</code> has two type parameters, <code>T</code> and <code>U</code>, the first of which is the type parameter of its enclosing class. Similarly, the type parameter list of the nested class <code>Innermost1</code> has three type parameters, <code>T</code>, <code>U</code>, and <code>V</code>, with <code>T</code> and <code>U</code> coming from its enclosing classes. The nested class <code>Innermost2</code> has two type parameters, <code>T</code> and <code>U</code>, which come from its enclosing classes.  </p>\n<p> If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.  </p>\n<p> To construct a generic type from the generic type definition for a nested type, call the MakeGenericType method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own. To create an instance of <code>Innermost1</code>, call the MakeGenericType method with an array containing three types, to be assigned to T, U, and V. To create an instance of <code>Innermost2</code>, call the MakeGenericType method with an array containing two types, to be assigned to T and U.  </p>\n<p> The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types. Otherwise, the type parameters would not be in scope within the bodies of the nested types. It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the <a href=\"../Topic/Ilasm.exe%20(IL%20Assembler).md\" data-linktype=\"relative-path\">Ilasm.exe (IL Assembler)</a>. Consider the following code for the MSIL assembler:  </p>\n<pre><code>.class public Outer&lt;T&gt; {  \n    .class nested public Inner&lt;U&gt; {  \n        .class nested public Innermost {  \n        }  \n    }  \n}\n</code></pre><p> In this example, it is not possible to define a field of type <code>T</code> or <code>U</code> in class <code>Innermost</code>, because those type parameters are not in scope. The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:  </p>\n<pre><code>.class public Outer&lt;T&gt; {  \n    .class nested public Inner&lt;T, U&gt; {  \n        .class nested public Innermost&lt;T, U, V&gt; {  \n        }  \n    }  \n}\n</code></pre><p> You can use the <a href=\"../Topic/Ildasm.exe%20(IL%20Disassembler).md\" data-linktype=\"relative-path\">Ildasm.exe (IL Disassembler)</a> to examine nested classes defined in the high-level languages and observe this naming scheme.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example uses the MakeGenericType method to create a constructed type from the generic type definition for the <a class=\"xref\" href=\"system.collections.generic.dictionary-2\" data-linktype=\"relative-path\">Dictionary&lt;TKey,TValue&gt;</a> type. The constructed type represents a <a class=\"xref\" href=\"system.collections.generic.dictionary-2\" data-linktype=\"relative-path\">Dictionary&lt;TKey,TValue&gt;</a> of <code>Test</code> objects with string keys.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.BindGenericParameters#1\">using System;\nusing System.Reflection;\nusing System.Collections.Generic;\n\npublic class Test\n{\n    public static void Main()\n    {\n        Console.WriteLine(&quot;\\r<br>--- Create a constructed type from the generic Dictionary type.&quot;);\n\n        // Create a type object representing the generic Dictionary \n        // type, by omitting the type arguments (but keeping the \n        // comma that separates them, so the compiler can infer the\n        // number of type parameters).      \n        Type generic = typeof(Dictionary&lt;,&gt;);\n        DisplayTypeInfo(generic);\n\n        // Create an array of types to substitute for the type\n        // parameters of Dictionary. The key is of type string, and\n        // the type to be contained in the Dictionary is Test.\n        Type[] typeArgs = { typeof(string), typeof(Test) };\n\n        // Create a Type object representing the constructed generic\n        // type.\n        Type constructed = generic.MakeGenericType(typeArgs);\n        DisplayTypeInfo(constructed);\n\n        // Compare the type objects obtained above to type objects\n        // obtained using typeof() and GetGenericTypeDefinition().\n        Console.WriteLine(&quot;\\r<br>--- Compare types obtained by different methods:&quot;);\n\n        Type t = typeof(Dictionary&lt;String, Test&gt;);\n        Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;Are the constructed types equal? {0}&quot;, t == constructed);\n        Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;Are the generic types equal? {0}&quot;, \n            t.GetGenericTypeDefinition() == generic);\n    }\n\n    private static void DisplayTypeInfo(Type t)\n    {\n        Console.WriteLine(&quot;\\r<br>{0}&quot;, t);\n\n        Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;Is this a generic type definition? {0}&quot;, \n            t.IsGenericTypeDefinition);\n\n        Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;Is it a generic type? {0}&quot;, \n            t.IsGenericType);\n\n        Type[] typeArguments = t.GetGenericArguments();\n        Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;List type arguments ({0}):&quot;, typeArguments.Length);\n        foreach (Type tParam in typeArguments)\n        {\n            Console.WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;, tParam);\n        }\n    }\n}\n\n/* This example produces the following output:\n\n--- Create a constructed type from the generic Dictionary type.\n\nSystem.Collections.Generic.Dictionary`2[TKey,TValue]\n        Is this a generic type definition? True\n        Is it a generic type? True\n        List type arguments (2):\n                TKey\n                TValue\n\nSystem.Collections.Generic.Dictionary`2[System.String, Test]\n        Is this a generic type definition? False\n        Is it a generic type? True\n        List type arguments (2):\n                System.String\n                Test\n\n--- Compare types obtained by different methods:\n        Are the constructed types equal? True\n        Are the generic types equal? True\n */\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Type.BindGenericParameters#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Collections::Generic;\n\nnamespace Example\n{\n    public ref class Test\n    {\n    public:\n        static void CreateConstructedType(void)\n        {      \n            Console::WriteLine(&quot;\\r<br>--- Create a constructed type&quot;\n                &quot; from the generic Dictionary`2 type.&quot;);\n            \n            // Create a type object representing \n            // the generic Dictionary`2 type.\n    \t    Type^ genericType = Type::GetType(\n                &quot;System.Collections.Generic.Dictionary`2&quot;);\n    \t    if (genericType != nullptr)\n    \t    {  \n    \t        DisplayTypeInfo(genericType);\n    \t    }\n    \t    else\n    \t    {\n    \t        Console::WriteLine(&quot;The type is not found&quot;);\n    \t        return;\n    \t    }\n            \n            // Create an array of types to substitute for the type\n            // parameters of Dictionary`2. \n            // The key is of type string, and the type to be \n            // contained in the Dictionary`2 is Test.\n            array&lt;Type^&gt;^ typeArgs = {String::typeid, Test::typeid};\n            Type^ constructedType = \n                genericType-&gt;MakeGenericType(typeArgs);\n            DisplayTypeInfo(constructedType);\n            \n            // Compare the type objects obtained above to type objects\n            // obtained using typeof() and GetGenericTypeDefinition().\n            Console::WriteLine(&quot;\\r<br>--- Compare types obtained by&quot;\n                &quot; different methods:&quot;);\n\n    \t    Type^ definedType = Dictionary&lt;String^, Test^&gt;::typeid;\n            Console::WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;Are the constructed types &quot;\n                &quot;equal? {0}&quot;, definedType == constructedType);\n            Console::WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;Are the generic types equal? {0}&quot;, \n                definedType-&gt;GetGenericTypeDefinition() == genericType);\n        }\n\n    private:\n        static void DisplayTypeInfo(Type^ typeToDisplay)\n        {   \n            Console::WriteLine(&quot;\\r<br>{0}&quot;, typeToDisplay);\n            Console::WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;Is this a generic type definition? &quot;\n                &quot;{0}&quot;, typeToDisplay-&gt;IsGenericTypeDefinition);\n            Console::WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;Is it a generic type? &quot;\n                &quot;{0}&quot;, typeToDisplay-&gt;IsGenericType);\n            \n            array&lt;Type^&gt;^ typeArguments = \n                typeToDisplay-&gt;GetGenericArguments();\n            Console::WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;List type arguments ({0}):&quot;, \n                typeArguments-&gt;Length);\n            \n            for each (Type^ typeArgument in typeArguments)\n            {   \n                Console::WriteLine(&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{0}&quot;, typeArgument);\n            }\n        }\n    };\n}\n\nint main(void)\n{\n    Example::Test::CreateConstructedType();\n}\n\n/* This example produces the following output:\n\n--- Create a constructed type from the generic Dictionary`2 type.\n\nSystem.Collections.Generic.Dictionary`2[KeyType,ValueType]\n          Is this a generic type definition? True\n          Is it a generic type? True\n          List type arguments (2):\n                     K\n                     V\n\nSystem.Collections.Generic.Dictionary`2[System.String, Test]\n          Is this a generic type definition? False\n          Is it a generic type? True\n          List type arguments (2):\n                     System.String\n                     Test\n\n--- Compare types obtained by different methods:\n          Are the constructed types equal? True\n          Are the generic types equal? True\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.BindGenericParameters#1\">Imports System\nImports System.Reflection\nImports System.Collections.Generic\nImports Microsoft.VisualBasic\n\nPublic Class Test\n    Public Shared Sub Main()\n        Console.WriteLine(vbCrLf &amp; &quot;--- Create a constructed type from the generic Dictionary type.&quot;)\n\n        &#39; Create a type object representing the generic Dictionary \n        &#39; type, by omitting the type arguments (but keeping the \n        &#39; comma that separates them, so the compiler can infer the\n        &#39; number of type parameters).\n        Dim generic As Type = GetType(Dictionary(Of ,))\n        DisplayTypeInfo(generic)\n\n        &#39; Create an array of types to substitute for the type\n        &#39; parameters of Dictionary. The key is of type string, and\n        &#39; the type to be contained in the Dictionary is Test.\n        Dim typeArgs() As Type = { GetType(String), GetType(Test) }\n\n        &#39; Create a Type object representing the constructed generic\n        &#39; type.\n        Dim constructed As Type = generic.MakeGenericType(typeArgs)\n        DisplayTypeInfo(constructed)\n\n        &#39; Compare the type objects obtained above to type objects\n        &#39; obtained using GetType() and GetGenericTypeDefinition().\n        Console.WriteLine(vbCrLf &amp; &quot;--- Compare types obtained by different methods:&quot;)\n\n        Dim t As Type = GetType(Dictionary(Of String, Test))\n        Console.WriteLine(vbTab &amp; &quot;Are the constructed types equal? &quot; _\n            &amp; (t Is constructed))\n        Console.WriteLine(vbTab &amp; &quot;Are the generic types equal? &quot; _ \n            &amp; (t.GetGenericTypeDefinition() Is generic))\n    End Sub\n\n    Private Shared Sub DisplayTypeInfo(ByVal t As Type)\n        Console.WriteLine(vbCrLf &amp; t.ToString())\n\n        Console.WriteLine(vbTab &amp; &quot;Is this a generic type definition? &quot; _ \n            &amp; t.IsGenericTypeDefinition)\n\n        Console.WriteLine(vbTab &amp; &quot;Is it a generic type? &quot; _ \n            &amp; t.IsGenericType)\n\n        Dim typeArguments() As Type = t.GetGenericArguments()\n        Console.WriteLine(vbTab &amp; &quot;List type arguments ({0}):&quot;, _\n            typeArguments.Length)\n        For Each tParam As Type In typeArguments       \n            Console.WriteLine(vbTab &amp; vbTab &amp; tParam.ToString())\n        Next\n    End Sub\nEnd Class\n\n&#39; This example produces the following output:\n&#39;\n&#39;--- Create a constructed type from the generic Dictionary type.\n&#39;\n&#39;System.Collections.Generic.Dictionary&#39;2[TKey,TValue]\n&#39;        Is this a generic type definition? True\n&#39;        Is it a generic type? True\n&#39;        List type arguments (2):\n&#39;                TKey\n&#39;                TValue\n&#39;\n&#39;System.Collections.Generic.Dictionary`2[System.String,Test]\n&#39;        Is this a generic type definition? False\n&#39;        Is it a generic type? True\n&#39;        List type arguments (2):\n&#39;                System.String\n&#39;                Test\n&#39;\n&#39;--- Compare types obtained by different methods:\n&#39;        Are the constructed types equal? True\n&#39;        Are the generic types equal? True\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_MakePointerType\">\r\n    \r\n            <a id=\"System_Type_MakePointerType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">MakePointerType()</div>        \r\n          </div>\r\n    \r\n            <p>Returns a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents a pointer to the current type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual Type MakePointerType ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents a pointer to the current type.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The invoked method is not supported in the base class.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.typeloadexception\" data-linktype=\"relative-path\">TypeLoadException</a></div>\r\n                  </div>\r\n                  <p>The current type is <a class=\"xref\" href=\"system.typedreference\" data-linktype=\"relative-path\">TypedReference</a>.  </p>\n<p> -or-  </p>\n<p> The current type is a <code>ByRef</code> type. That is, <span class=\"xref\">stem.Type.IsByRef*</span> returns <code>true</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The MakePointerType method provides a way to generate pointer types for parameter lists.  </p>\n<p> Using the syntax of Microsoft intermediate language (MSIL), if the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object represents <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a>, this method returns a <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object representing <code>Int32*</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example creates array, <code>ref</code> (<code>ByRef</code> in Visual Basic), and pointer types for the <code>Test</code> class.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Type.MakeXxxType#1\">using System;\nusing System.Reflection;\n\npublic class Example\n{\n    public static void Main()\n    {\n        // Create a Type object that represents a one-dimensional\n        // array of Example objects.\n        Type t = typeof(Example).MakeArrayType();\n        Console.WriteLine(&quot;\\r<br>Array of Example: {0}&quot;, t);\n\n        // Create a Type object that represents a two-dimensional\n        // array of Example objects.\n        t = typeof(Example).MakeArrayType(2);\n        Console.WriteLine(&quot;\\r<br>Two-dimensional array of Example: {0}&quot;, t);\n\n        // Demonstrate an exception when an invalid array rank is\n        // specified.\n        try\n        {\n            t = typeof(Example).MakeArrayType(-1);\n        }\n        catch(Exception ex)\n        {\n            Console.WriteLine(&quot;\\r<br>{0}&quot;, ex);\n        }\n\n        // Create a Type object that represents a ByRef parameter\n        // of type Example.\n        t = typeof(Example).MakeByRefType();\n        Console.WriteLine(&quot;\\r<br>ByRef Example: {0}&quot;, t);\n\n        // Get a Type object representing the Example class, a\n        // MethodInfo representing the &quot;Test&quot; method, a ParameterInfo\n        // representing the parameter of type Example, and finally\n        // a Type object representing the type of this ByRef parameter.\n        // Compare this Type object with the Type object created using\n        // MakeByRefType.\n        Type t2 = typeof(Example);\n        MethodInfo mi = t2.GetMethod(&quot;Test&quot;);\n        ParameterInfo pi = mi.GetParameters()[0];\n        Type pt = pi.ParameterType;\n        Console.WriteLine(&quot;Are the ByRef types equal? {0}&quot;, (t == pt));\n\n        // Create a Type object that represents a pointer to an\n        // Example object.\n        t = typeof(Example).MakePointerType();\n        Console.WriteLine(&quot;\\r<br>Pointer to Example: {0}&quot;, t);\n    }\n\n    // A sample method with a ByRef parameter.\n    //\n    public void Test(ref Example e)\n    {\n    }\n}\n\n/* This example produces output similar to the following:\n\nArray of Example: Example[]\n\nTwo-dimensional array of Example: Example[,]\n\nSystem.IndexOutOfRangeException: Index was outside the bounds of the array.\n   at System.RuntimeType.MakeArrayType(Int32 rank) in c:\\vbl<br>dp\\clr\\src\\BCL\\System\\RtType.cs:line 2999\n   at Example.Main()\n\nByRef Example: Example&amp;\nAre the ByRef types equal? True\n\nPointer to Example: Example*\n\n */\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Type.MakeXxxType#1\">using namespace System;\nusing namespace System::Reflection;\n\npublic ref class Example\n{\npublic:\n   static void Main()\n   {\n      // Create a Type object that represents a one-dimensional\n      // array of Example objects.\n      Type^ t = Example::typeid-&gt;MakeArrayType();\n      Console::WriteLine( L&quot;\\r<br>Array of Example: {0}&quot;, t );\n      \n      // Create a Type object that represents a two-dimensional\n      // array of Example objects.\n      t = Example::typeid-&gt;MakeArrayType( 2 );\n      Console::WriteLine( L&quot;\\r<br>Two-dimensional array of Example: {0}&quot;, t );\n      \n      // Demonstrate an exception when an invalid array rank is\n      // specified.\n      try\n      {\n         t = Example::typeid-&gt;MakeArrayType(  -1 );\n      }\n      catch ( Exception^ ex ) \n      {\n         Console::WriteLine( L&quot;\\r<br>{0}&quot;, ex );\n      }\n      \n      // Create a Type object that represents a ByRef parameter\n      // of type Example.\n      t = Example::typeid-&gt;MakeByRefType();\n      Console::WriteLine( L&quot;\\r<br>ByRef Example: {0}&quot;, t );\n      \n      // Get a Type object representing the Example class, a\n      // MethodInfo representing the &quot;Test&quot; method, a ParameterInfo\n      // representing the parameter of type Example, and finally\n      // a Type object representing the type of this ByRef parameter.\n      // Compare this Type object with the Type object created using\n      // MakeByRefType.\n      Type^ t2 = Example::typeid;\n      MethodInfo^ mi = t2-&gt;GetMethod( L&quot;Test&quot; );\n      ParameterInfo^ pi = mi-&gt;GetParameters()[ 0 ];\n      Type^ pt = pi-&gt;ParameterType;\n      Console::WriteLine( L&quot;Are the ByRef types equal? {0}&quot;, (t == pt) );\n      \n      // Create a Type object that represents a pointer to an\n      // Example object.\n      t = Example::typeid-&gt;MakePointerType();\n      Console::WriteLine( L&quot;\\r<br>Pointer to Example: {0}&quot;, t );\n   }\n\n   // A sample method with a ByRef parameter.\n   //\n   void Test( interior_ptr&lt;Example^&gt; /*e*/ )\n   {\n   }\n};\n\nint main()\n{\n   Example::Main();\n}\n\n/* This example produces output similar to the following:\n\nArray of Example: Example[]\n\nTwo-dimensional array of Example: Example[,]\n\nSystem.IndexOutOfRangeException: Index was outside the bounds of the array.\n   at System.RuntimeType.MakeArrayType(Int32 rank) in c:\\vbl<br>dp\\clr\\src\\BCL\\System\\RtType.cs:line 2999\n   at Example.Main()\n\nByRef Example: Example&amp;\nAre the ByRef types equal? True\n\nPointer to Example: Example*\n\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Type.MakeXxxType#1\">Imports System\nImports System.Reflection\nImports Microsoft.VisualBasic\n\nPublic Class Example\n    Public Shared Sub Main()\n        &#39; Create a Type object that represents a one-dimensional\n        &#39; array of Example objects.\n        Dim t As Type = GetType(Example).MakeArrayType()\n        Console.WriteLine(vbCrLf &amp; &quot;Array of Example: &quot; &amp; t.ToString())\n\n        &#39; Create a Type object that represents a two-dimensional\n        &#39; array of Example objects.\n        t = GetType(Example).MakeArrayType(2)\n        Console.WriteLine(vbCrLf &amp; &quot;Two-dimensional array of Example: &quot; &amp; t.ToString())\n\n        &#39; Demonstrate an exception when an invalid array rank is\n        &#39; specified.\n        Try\n            t = GetType(Example).MakeArrayType(-1)\n        Catch ex As Exception\n            Console.WriteLine(vbCrLf &amp; ex.ToString())\n        End Try\n\n        &#39; Create a Type object that represents a ByRef parameter\n        &#39; of type Example.\n        t = GetType(Example).MakeByRefType()\n        Console.WriteLine(vbCrLf &amp; &quot;ByRef Example: &quot; &amp; t.ToString())\n\n        &#39; Get a Type object representing the Example class, a\n        &#39; MethodInfo representing the &quot;Test&quot; method, a ParameterInfo\n        &#39; representing the parameter of type Example, and finally\n        &#39; a Type object representing the type of this ByRef parameter.\n        &#39; Compare this Type object with the Type object created using\n        &#39; MakeByRefType.\n        Dim t2 As Type = GetType(Example)\n        Dim mi As MethodInfo = t2.GetMethod(&quot;Test&quot;)\n        Dim pi As ParameterInfo = mi.GetParameters()(0)\n        Dim pt As Type = pi.ParameterType\n        Console.WriteLine(&quot;Are the ByRef types equal? &quot; &amp; (t Is pt))\n\n        &#39; Create a Type object that represents a pointer to an\n        &#39; Example object.\n        t = GetType(Example).MakePointerType()\n        Console.WriteLine(vbCrLf &amp; &quot;Pointer to Example: &quot; &amp; t.ToString())\n    End Sub\n\n    &#39; A sample method with a ByRef parameter.\n    &#39;\n    Public Sub Test(ByRef e As Example)\n    End Sub\nEnd Class\n\n&#39; This example produces output similar to the following:\n&#39;\n&#39;Array of Example: Example[]\n&#39;\n&#39;Two-dimensional array of Example: Example[,]\n&#39;\n&#39;System.IndexOutOfRangeException: Index was outside the bounds of the array.\n&#39;   at System.RuntimeType.MakeArrayType(Int32 rank) in c:\\vbl<br>dp\\clr\\src\\BCL\\System\\RtType.cs:line 2999\n&#39;   at Example.Main()\n&#39;\n&#39;ByRef Example: Example&amp;\n&#39;Are the ByRef types equal? True\n&#39;\n&#39;Pointer to Example: Example*\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_ReflectionOnlyGetType_System_String_System_Boolean_System_Boolean_\">\r\n    \r\n            <a id=\"System_Type_ReflectionOnlyGetType_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ReflectionOnlyGetType(String,Boolean,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Gets the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found. The type is loaded for reflection only, not for execution.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>typeName</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The assembly-qualified name of the <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> to get.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>throwIfNotFound</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to throw a <a class=\"xref\" href=\"system.typeloadexception\" data-linktype=\"relative-path\">TypeLoadException</a> if the type cannot be found; <code>false</code> to return <code>null</code> if the type cannot be found. Specifying <code>false</code> also suppresses some other exception conditions, but not all of them. See the Exceptions section.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>ignoreCase</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to perform a case-insensitive search for <code>typeName</code>; <code>false</code> to perform a case-sensitive search for <code>typeName</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </div>\r\n                  <p>The type with the specified name, if found; otherwise, <code>null</code>. If the type is not found, the <code>throwIfNotFound</code> parameter specifies whether <code>null</code> is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <code>throwIfNotFound</code>. See the Exceptions section.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>typeName</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.targetinvocationexception\" data-linktype=\"relative-path\">TargetInvocationException</a></div>\r\n                  </div>\r\n                  <p>A class initializer is invoked and throws an exception.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.typeloadexception\" data-linktype=\"relative-path\">TypeLoadException</a></div>\r\n                  </div>\r\n                  <p><code>throwIfNotFound</code> is <code>true</code> and the type is not found.  </p>\n<p> -or-  </p>\n<p> <code>throwIfNotFound</code> is <code>true</code> and <code>typeName</code> contains invalid characters, such as an embedded tab.  </p>\n<p> -or-  </p>\n<p> <code>throwIfNotFound</code> is <code>true</code> and <code>typeName</code> is an empty string.  </p>\n<p> -or-  </p>\n<p> <code>throwIfNotFound</code> is <code>true</code> and <code>typeName</code> represents an array type with an invalid size.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents an array of <a class=\"xref\" href=\"system.typedreference\" data-linktype=\"relative-path\">TypedReference</a> objects.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>typeName</code> does not include the assembly name.  </p>\n<p> -or-  </p>\n<p> <code>throwIfNotFound</code> is <code>true</code> and <code>typeName</code> contains invalid syntax; for example, &quot;MyType[,*,]&quot;.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents a generic type that has a pointer type, a <code>ByRef</code> type, or <a class=\"xref\" href=\"system.void\" data-linktype=\"relative-path\">Void</a> as one of its type arguments.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents a generic type that has an incorrect number of type arguments.  </p>\n<p> -or-  </p>\n<p> <code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.filenotfoundexception\" data-linktype=\"relative-path\">FileNotFoundException</a></div>\r\n                  </div>\r\n                  <p><code>throwIfNotFound</code> is <code>true</code> and the assembly or one of its dependencies was not found.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.fileloadexception\" data-linktype=\"relative-path\">FileLoadException</a></div>\r\n                  </div>\r\n                  <p>The assembly or one of its dependencies was found, but could not be loaded.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.badimageformatexception\" data-linktype=\"relative-path\">BadImageFormatException</a></div>\r\n                  </div>\r\n                  <p>The assembly or one of its dependencies is not valid.  </p>\n<p> -or-  </p>\n<p> The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the assembly containing the type is not already loaded into the reflection-only context, using the ReflectionOnlyGetType method is equivalent to first loading the assembly for reflection only, using the <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_ReflectionOnlyLoad_\" data-linktype=\"relative-path\">ReflectionOnlyLoad</a> method, and then loading the type by calling the assembly&#39;s <a class=\"xref\" href=\"system.reflection.assembly#System_Reflection_Assembly_GetType_\" data-linktype=\"relative-path\">GetType</a> method. For information about assembly-qualified names, see the <a class=\"xref\" href=\"system.type#System_Type_AssemblyQualifiedName_\" data-linktype=\"relative-path\">AssemblyQualifiedName</a> property. For additional details on specifying type names, see the <a class=\"xref\" href=\"system.type#System_Type_GetType_System_String_System_Boolean_System_Boolean_\" data-linktype=\"relative-path\">GetType(String,Boolean,Boolean)</a> method overload.  </p>\n<p> If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.  </p>\n<p> The <code>throwIfNotFound</code> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section. Some exceptions are thrown regardless of the value of <code>throwIfNotFound</code>. For example, if the assembly is not valid, a <a class=\"xref\" href=\"system.badimageformatexception\" data-linktype=\"relative-path\">BadImageFormatException</a> is thrown even if <code>throwIfNotFound</code> is <code>false</code>.  </p>\n<p> For more information about using the reflection-only context, see <a href=\"../Topic/How%20to:%20Load%20Assemblies%20into%20the%20Reflection-Only%20Context.md\" data-linktype=\"relative-path\">How to: Load Assemblies into the Reflection-Only Context</a>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_ToString\">\r\n    \r\n            <a id=\"System_Type_ToString_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ToString()</div>        \r\n          </div>\r\n    \r\n            <p>Returns a <code>String</code> representing the name of the current <code>Type</code>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public override string ToString ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a> representing the name of the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method returns the fully qualified common language runtime namespace and name for all primitive types. For example, the C# instruction, <code>(long)0.Type().ToString()</code> returns &quot;System.Int64&quot; instead of merely &quot;Int64&quot;.  </p>\n<p> If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly. If the current <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>This following example demonstrates a use of the <a class=\"xref\" href=\"system.type#System_Type_Namespace_\" data-linktype=\"relative-path\">Namespace</a> and <a class=\"xref\" href=\"system.type#System_Type_Module_\" data-linktype=\"relative-path\">Module</a> properties and the <code>ToString</code> method of <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>.  </p>\n<pre><code class=\"lang-cpp\" name=\"Type_ToString#1\">using namespace System;\n\nnamespace MyNamespace\n{\n   ref class MyClass\n   {\n   };\n}\n\nvoid main()\n{\n      Type^ myType = MyNamespace::MyClass::typeid;\n      Console::WriteLine(&quot;Displaying information about {0}:&quot;, myType );\n      \n      // Get the namespace of the class MyClass.\n      Console::WriteLine(&quot;   Namespace: {0}&quot;, myType-&gt;Namespace );\n      \n      // Get the name of the module.\n      Console::WriteLine(&quot;   Module: {0}&quot;, myType-&gt;Module );\n      \n      // Get the fully qualified common language runtime namespace.\n      Console::WriteLine(&quot;   Fully qualified type: {0}&quot;, myType );\n}\n// The example displays the following output:\n//    Displaying information about MyNamespace.MyClass:\n//       Namespace: MyNamespace\n//       Module: type_tostring.exe\n//       Fully qualified name: MyNamespace.MyClass\n</code></pre><pre><code class=\"lang-cs\" name=\"Type_ToString#1\">using System;\n\nnamespace MyNamespace\n{\n    class MyClass\n    {\n    }\n}\n\npublic class Example\n{\n    public static void Main()\n    {\n         Type myType = typeof(MyNamespace.MyClass);\n         Console.WriteLine(&quot;Displaying information about {0}:&quot;, myType); \n         // Get the namespace of the myClass class.\n         Console.WriteLine(&quot;   Namespace: {0}.&quot;, myType.Namespace);\n         // Get the name of the module.\n         Console.WriteLine(&quot;   Module: {0}.&quot;, myType.Module);\n         // Get the fully qualified type name.\n         Console.WriteLine(&quot;   Fully qualified name: {0}.&quot;, myType.ToString());\n    }\n}\n// The example displays the following output:\n//    Displaying information about MyNamespace.MyClass:\n//       Namespace: MyNamespace.\n//       Module: type_tostring.exe.\n//       Fully qualified name: MyNamespace.MyClass.\n</code></pre><pre><code class=\"lang-vb\" name=\"Type_ToString#1\">Namespace MyNamespace\n    Class [MyClass]\n    End Class \nEnd Namespace \n\nPublic Class Example\n    Public Shared Sub Main()\n         Dim myType As Type = GetType(MyNamespace.MyClass)\n         Console.WriteLine(&quot;, myType)\n         &#39; Get the namespace of the MyClass class.\n         Console.WriteLine(&quot;   Namespace: {0}.&quot;, myType.Namespace)\n         &#39; Get the name of the module.\n         Console.WriteLine(&quot;   Module: {0}.&quot;, myType.Module)\n         &#39; Get the fully qualified type name.\n         Console.WriteLine(&quot;   Fully qualified name: {0}.&quot;, myType.ToString())\n    End Sub\nEnd Class\n&#39; The example displays the following output:\n&#39;       Displaying information about MyNamespace.MyClass:\n&#39;          Namespace: MyNamespace.\n&#39;          Module: type_tostring.exe.\n&#39;          Fully qualified name: MyNamespace.MyClass.\n</code></pre><p> The following example compares the strings returned by the ToString method and the <code>Name</code>, <a class=\"xref\" href=\"system.type#System_Type_FullName_\" data-linktype=\"relative-path\">FullName</a>, and <a class=\"xref\" href=\"system.type#System_Type_AssemblyQualifiedName_\" data-linktype=\"relative-path\">AssemblyQualifiedName</a> properties.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Type.ToString#1\">Imports System.Collections.Generic\nImports System.Globalization\n\nModule Example\n   Public Sub Main()\n      Dim t As Type = GetType(String)\n      ShowTypeInfo(t)\n\n      t = GetType(System.Collections.Generic.List(Of))\n      ShowTypeInfo(t)\n\n      Dim list As New List(Of String)()\n      t = list.GetType()\n      ShowTypeInfo(t)\n      \n      Dim v As Object = 12\n      t = v.GetType()\n      ShowTypeInfo(t)\n      \n      t = GetType(IFormatProvider)\n      ShowTypeInfo(t)\n      \n      Dim ifmt As IFormatProvider = NumberFormatInfo.CurrentInfo\n      t = ifmt.GetType()\n      ShowTypeInfo(t)\n   End Sub\n   \n   Private Sub ShowTypeInfo(t As Type)\n      Console.WriteLine(&quot;Name: {0}&quot;, t.Name)\n      Console.WriteLine(&quot;Full Name: {0}&quot;, t.FullName)\n      Console.WriteLine(&quot;ToString:  {0}&quot;, t.ToString())\n      Console.WriteLine(&quot;Assembly Qualified Name: {0}&quot;, t.AssemblyQualifiedName)\n      Console.WriteLine()\n   End Sub\nEnd Module\n&#39; The example displays output like the following:\n&#39;    Name: String\n&#39;    Full Name: System.String\n&#39;    ToString:  System.String\n&#39;    Assembly Qualified Name: System.String, mscorlib, Version=4.0.0.0, Culture=neutr\n&#39;    al, PublicKeyToken=b77a5c561934e089\n&#39;\n&#39;    Name: List`1\n&#39;    Full Name: System.Collections.Generic.List`1\n&#39;    ToString:  System.Collections.Generic.List`1[T]\n&#39;    Assembly Qualified Name: System.Collections.Generic.List`1, mscorlib, Version=4.\n&#39;    0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\n&#39;\n&#39;    Name: List`1\n&#39;    Full Name: System.Collections.Generic.List`1[[System.String, mscorlib, Version=4\n&#39;    .0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]\n&#39;    ToString:  System.Collections.Generic.List`1[System.String]\n&#39;    Assembly Qualified Name: System.Collections.Generic.List`1[[System.String, mscor\n&#39;    lib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], mscorl\n&#39;    ib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\n&#39;\n&#39;    Name: Int32\n&#39;    Full Name: System.Int32\n&#39;    ToString:  System.Int32\n&#39;    Assembly Qualified Name: System.Int32, mscorlib, Version=4.0.0.0, Culture=neutra\n&#39;    l, PublicKeyToken=b77a5c561934e089\n&#39;\n&#39;    Name: IFormatProvider\n&#39;    Full Name: System.IFormatProvider\n&#39;    ToString:  System.IFormatProvider\n&#39;    Assembly Qualified Name: System.IFormatProvider, mscorlib, Version=4.0.0.0, Cult\n&#39;    ure=neutral, PublicKeyToken=b77a5c561934e089\n&#39;\n&#39;    Name: NumberFormatInfo\n&#39;    Full Name: System.Globalization.NumberFormatInfo\n&#39;    ToString:  System.Globalization.NumberFormatInfo\n&#39;    Assembly Qualified Name: System.Globalization.NumberFormatInfo, mscorlib, Versio\n&#39;    n=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Type.ToString#1\">using System;\nusing System.Collections.Generic;\nusing System.Globalization;\n\npublic class Example\n{\n   public static void Main()\n   {\n      Type t = typeof(String);\n      ShowTypeInfo(t);\n\n      t = typeof(System.Collections.Generic.List&lt;&gt;);\n      ShowTypeInfo(t);\n\n      var list = new List&lt;String&gt;();\n      t = list.GetType();\n      ShowTypeInfo(t);\n\n      Object v = 12;\n      t = v.GetType();\n      ShowTypeInfo(t);\n\n      t = typeof(IFormatProvider);\n      ShowTypeInfo(t);\n\n      IFormatProvider ifmt = NumberFormatInfo.CurrentInfo;\n      t = ifmt.GetType();\n      ShowTypeInfo(t);\n   }\n\n   private static void ShowTypeInfo(Type t)\n   {\n      Console.WriteLine(&quot;Name: {0}&quot;, t.Name);\n      Console.WriteLine(&quot;Full Name: {0}&quot;, t.FullName);\n      Console.WriteLine(&quot;ToString:  {0}&quot;, t.ToString());\n      Console.WriteLine(&quot;Assembly Qualified Name: {0}&quot;,\n                        t.AssemblyQualifiedName);\n      Console.WriteLine();\n   }\n}\n// The example displays output like the following:\n//    Name: String\n//    Full Name: System.String\n//    ToString:  System.String\n//    Assembly Qualified Name: System.String, mscorlib, Version=4.0.0.0, Culture=neutr\n//    al, PublicKeyToken=b77a5c561934e089\n//\n//    Name: List`1\n//    Full Name: System.Collections.Generic.List`1\n//    ToString:  System.Collections.Generic.List`1[T]\n//    Assembly Qualified Name: System.Collections.Generic.List`1, mscorlib, Version=4.\n//    0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\n//\n//    Name: List`1\n//    Full Name: System.Collections.Generic.List`1[[System.String, mscorlib, Version=4\n//    .0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]\n//    ToString:  System.Collections.Generic.List`1[System.String]\n//    Assembly Qualified Name: System.Collections.Generic.List`1[[System.String, mscor\n//    lib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]], mscorl\n//    ib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\n//\n//    Name: Int32\n//    Full Name: System.Int32\n//    ToString:  System.Int32\n//    Assembly Qualified Name: System.Int32, mscorlib, Version=4.0.0.0, Culture=neutra\n//    l, PublicKeyToken=b77a5c561934e089\n//\n//    Name: IFormatProvider\n//    Full Name: System.IFormatProvider\n//    ToString:  System.IFormatProvider\n//    Assembly Qualified Name: System.IFormatProvider, mscorlib, Version=4.0.0.0, Cult\n//    ure=neutral, PublicKeyToken=b77a5c561934e089\n//\n//    Name: NumberFormatInfo\n//    Full Name: System.Globalization.NumberFormatInfo\n//    ToString:  System.Globalization.NumberFormatInfo\n//    Assembly Qualified Name: System.Globalization.NumberFormatInfo, mscorlib, Versio\n//    n=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"operators\">\r\n        <h2>Operators\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Type_op_Equality_System_Type_System_Type_\">\r\n    \r\n            <a id=\"System_Type_op_Equality_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">op_Equality(Type,Type)</div>        \r\n          </div>\r\n    \r\n            <p>Indicates whether two <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects are equal.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool op_Equality (Type left, Type right);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>left</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The first object to compare.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>right</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The second object to compare.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if <code>left</code> is equal to <code>right</code>; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_op_Inequality_System_Type_System_Type_\">\r\n    \r\n            <a id=\"System_Type_op_Inequality_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">op_Inequality(Type,Type)</div>        \r\n          </div>\r\n    \r\n            <p>Indicates whether two <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> objects are not equal.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool op_Inequality (Type left, Type right);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>left</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The first object to compare.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>right</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The second object to compare.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if <code>left</code> is not equal to <code>right</code>; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"eii\">\r\n        <h2>Explicit Interface Implementations\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Type_System_Runtime_InteropServices__Type_GetIDsOfNames_System_Guid__System_IntPtr_System_UInt32_System_UInt32_System_IntPtr_\">\r\n    \r\n            <a id=\"System_Type_System_Runtime_InteropServices__Type_GetIDsOfNames_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_Type.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)</div>        \r\n          </div>\r\n    \r\n            <p>Maps a set of names to a corresponding set of dispatch identifiers.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>riid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.guid\" data-linktype=\"relative-path\">Guid</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Reserved for future use. Must be IID_NULL.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>rgszNames</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Passed-in array of names to be mapped.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>cNames</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Count of the names to be mapped.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>lcid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The locale context in which to interpret the names.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>rgDispId</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Caller-allocated array which receives the IDs corresponding to the names.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notimplementedexception\" data-linktype=\"relative-path\">NotImplementedException</a></div>\r\n                  </div>\r\n                  <p>Late-bound access using the COM <code>IDispatch</code> interface is not supported.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <code>IDispatch::GetIDsOfNames</code>, see the MSDN Library.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_System_Runtime_InteropServices__Type_GetTypeInfo_System_UInt32_System_UInt32_System_IntPtr_\">\r\n    \r\n            <a id=\"System_Type_System_Runtime_InteropServices__Type_GetTypeInfo_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_Type.GetTypeInfo(UInt32,UInt32,IntPtr)</div>        \r\n          </div>\r\n    \r\n            <p>Retrieves the type information for an object, which can then be used to get the type information for an interface.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>iTInfo</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The type information to return.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>lcid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The locale identifier for the type information.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>ppTInfo</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A pointer to the requested type information object.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notimplementedexception\" data-linktype=\"relative-path\">NotImplementedException</a></div>\r\n                  </div>\r\n                  <p>Late-bound access using the COM <code>IDispatch</code> interface is not supported.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <code>IDispatch::GetTypeInfo</code>, see the MSDN Library.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_System_Runtime_InteropServices__Type_GetTypeInfoCount_System_UInt32__\">\r\n    \r\n            <a id=\"System_Type_System_Runtime_InteropServices__Type_GetTypeInfoCount_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_Type.GetTypeInfoCount(UInt32)</div>        \r\n          </div>\r\n    \r\n            <p>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">void _Type.GetTypeInfoCount (out uint pcTInfo);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>pcTInfo</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Points to a location that receives the number of type information interfaces provided by the object.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notimplementedexception\" data-linktype=\"relative-path\">NotImplementedException</a></div>\r\n                  </div>\r\n                  <p>Late-bound access using the COM <code>IDispatch</code> interface is not supported.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <code>IDispatch::GetTypeInfoCount</code>, see the MSDN Library.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Type_System_Runtime_InteropServices__Type_Invoke_System_UInt32_System_Guid__System_UInt32_System_Int16_System_IntPtr_System_IntPtr_System_IntPtr_System_IntPtr_\">\r\n    \r\n            <a id=\"System_Type_System_Runtime_InteropServices__Type_Invoke_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_Type.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)</div>        \r\n          </div>\r\n    \r\n            <p>Provides access to properties and methods exposed by an object.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>dispIdMember</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Identifies the member.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>riid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.guid\" data-linktype=\"relative-path\">Guid</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Reserved for future use. Must be IID_NULL.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>lcid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The locale context in which to interpret arguments.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>wFlags</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int16\" data-linktype=\"relative-path\">Int16</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Flags describing the context of the call.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>pDispParams</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>pVarResult</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Pointer to the location where the result is to be stored.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>pExcepInfo</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Pointer to a structure that contains exception information.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>puArgErr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The index of the first argument that has an error.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notimplementedexception\" data-linktype=\"relative-path\">NotImplementedException</a></div>\r\n                  </div>\r\n                  <p>Late-bound access using the COM <code>IDispatch</code> interface is not supported.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about <code>IDispatch::Invoke</code>, see the MSDN Library.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n","outputRootRelativePath":"./","pageMetadata":"<meta name=\"breadcrumb_path\" content=\"breadcrumb/toc.json\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"fulldocset\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.fulldocset\">\r\n<meta name=\"ref_skeleton_gitcommit\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Type.yml\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Type.yml\">\r\n<meta name=\"APIName\" content=\"System.Type\">\r\n<meta name=\"APIName\" content=\"System.Type..ctor\">\r\n<meta name=\"APIName\" content=\"System.Type.Assembly\">\r\n<meta name=\"APIName\" content=\"System.Type.AssemblyQualifiedName\">\r\n<meta name=\"APIName\" content=\"System.Type.Attributes\">\r\n<meta name=\"APIName\" content=\"System.Type.BaseType\">\r\n<meta name=\"APIName\" content=\"System.Type.ContainsGenericParameters\">\r\n<meta name=\"APIName\" content=\"System.Type.DeclaringMethod\">\r\n<meta name=\"APIName\" content=\"System.Type.DeclaringType\">\r\n<meta name=\"APIName\" content=\"System.Type.DefaultBinder\">\r\n<meta name=\"APIName\" content=\"System.Type.Delimiter\">\r\n<meta name=\"APIName\" content=\"System.Type.EmptyTypes\">\r\n<meta name=\"APIName\" content=\"System.Type.Equals\">\r\n<meta name=\"APIName\" content=\"System.Type.FilterAttribute\">\r\n<meta name=\"APIName\" content=\"System.Type.FilterName\">\r\n<meta name=\"APIName\" content=\"System.Type.FilterNameIgnoreCase\">\r\n<meta name=\"APIName\" content=\"System.Type.FindInterfaces\">\r\n<meta name=\"APIName\" content=\"System.Type.FindMembers\">\r\n<meta name=\"APIName\" content=\"System.Type.FullName\">\r\n<meta name=\"APIName\" content=\"System.Type.GenericParameterAttributes\">\r\n<meta name=\"APIName\" content=\"System.Type.GenericParameterPosition\">\r\n<meta name=\"APIName\" content=\"System.Type.GenericTypeArguments\">\r\n<meta name=\"APIName\" content=\"System.Type.GetArrayRank\">\r\n<meta name=\"APIName\" content=\"System.Type.GetAttributeFlagsImpl\">\r\n<meta name=\"APIName\" content=\"System.Type.GetConstructor\">\r\n<meta name=\"APIName\" content=\"System.Type.GetConstructorImpl\">\r\n<meta name=\"APIName\" content=\"System.Type.GetConstructors\">\r\n<meta name=\"APIName\" content=\"System.Type.GetDefaultMembers\">\r\n<meta name=\"APIName\" content=\"System.Type.GetElementType\">\r\n<meta name=\"APIName\" content=\"System.Type.GetEnumName\">\r\n<meta name=\"APIName\" content=\"System.Type.GetEnumNames\">\r\n<meta name=\"APIName\" content=\"System.Type.GetEnumUnderlyingType\">\r\n<meta name=\"APIName\" content=\"System.Type.GetEnumValues\">\r\n<meta name=\"APIName\" content=\"System.Type.GetEvent\">\r\n<meta name=\"APIName\" content=\"System.Type.GetEvents\">\r\n<meta name=\"APIName\" content=\"System.Type.GetField\">\r\n<meta name=\"APIName\" content=\"System.Type.GetFields\">\r\n<meta name=\"APIName\" content=\"System.Type.GetGenericArguments\">\r\n<meta name=\"APIName\" content=\"System.Type.GetGenericParameterConstraints\">\r\n<meta name=\"APIName\" content=\"System.Type.GetGenericTypeDefinition\">\r\n<meta name=\"APIName\" content=\"System.Type.GetHashCode\">\r\n<meta name=\"APIName\" content=\"System.Type.GetInterface\">\r\n<meta name=\"APIName\" content=\"System.Type.GetInterfaceMap\">\r\n<meta name=\"APIName\" content=\"System.Type.GetInterfaces\">\r\n<meta name=\"APIName\" content=\"System.Type.GetMember\">\r\n<meta name=\"APIName\" content=\"System.Type.GetMembers\">\r\n<meta name=\"APIName\" content=\"System.Type.GetMethod\">\r\n<meta name=\"APIName\" content=\"System.Type.GetMethodImpl\">\r\n<meta name=\"APIName\" content=\"System.Type.GetMethods\">\r\n<meta name=\"APIName\" content=\"System.Type.GetNestedType\">\r\n<meta name=\"APIName\" content=\"System.Type.GetNestedTypes\">\r\n<meta name=\"APIName\" content=\"System.Type.GetProperties\">\r\n<meta name=\"APIName\" content=\"System.Type.GetProperty\">\r\n<meta name=\"APIName\" content=\"System.Type.GetPropertyImpl\">\r\n<meta name=\"APIName\" content=\"System.Type.GetType\">\r\n<meta name=\"APIName\" content=\"System.Type.GetTypeArray\">\r\n<meta name=\"APIName\" content=\"System.Type.GetTypeCode\">\r\n<meta name=\"APIName\" content=\"System.Type.GetTypeCodeImpl\">\r\n<meta name=\"APIName\" content=\"System.Type.GetTypeFromCLSID\">\r\n<meta name=\"APIName\" content=\"System.Type.GetTypeFromHandle\">\r\n<meta name=\"APIName\" content=\"System.Type.GetTypeFromProgID\">\r\n<meta name=\"APIName\" content=\"System.Type.GetTypeHandle\">\r\n<meta name=\"APIName\" content=\"System.Type.GUID\">\r\n<meta name=\"APIName\" content=\"System.Type.HasElementType\">\r\n<meta name=\"APIName\" content=\"System.Type.HasElementTypeImpl\">\r\n<meta name=\"APIName\" content=\"System.Type.InvokeMember\">\r\n<meta name=\"APIName\" content=\"System.Type.IsAbstract\">\r\n<meta name=\"APIName\" content=\"System.Type.IsAnsiClass\">\r\n<meta name=\"APIName\" content=\"System.Type.IsArray\">\r\n<meta name=\"APIName\" content=\"System.Type.IsArrayImpl\">\r\n<meta name=\"APIName\" content=\"System.Type.IsAssignableFrom\">\r\n<meta name=\"APIName\" content=\"System.Type.IsAutoClass\">\r\n<meta name=\"APIName\" content=\"System.Type.IsAutoLayout\">\r\n<meta name=\"APIName\" content=\"System.Type.IsByRef\">\r\n<meta name=\"APIName\" content=\"System.Type.IsByRefImpl\">\r\n<meta name=\"APIName\" content=\"System.Type.IsClass\">\r\n<meta name=\"APIName\" content=\"System.Type.IsCOMObject\">\r\n<meta name=\"APIName\" content=\"System.Type.IsCOMObjectImpl\">\r\n<meta name=\"APIName\" content=\"System.Type.IsConstructedGenericType\">\r\n<meta name=\"APIName\" content=\"System.Type.IsContextful\">\r\n<meta name=\"APIName\" content=\"System.Type.IsContextfulImpl\">\r\n<meta name=\"APIName\" content=\"System.Type.IsEnum\">\r\n<meta name=\"APIName\" content=\"System.Type.IsEnumDefined\">\r\n<meta name=\"APIName\" content=\"System.Type.IsEquivalentTo\">\r\n<meta name=\"APIName\" content=\"System.Type.IsExplicitLayout\">\r\n<meta name=\"APIName\" content=\"System.Type.IsGenericParameter\">\r\n<meta name=\"APIName\" content=\"System.Type.IsGenericType\">\r\n<meta name=\"APIName\" content=\"System.Type.IsGenericTypeDefinition\">\r\n<meta name=\"APIName\" content=\"System.Type.IsImport\">\r\n<meta name=\"APIName\" content=\"System.Type.IsInstanceOfType\">\r\n<meta name=\"APIName\" content=\"System.Type.IsInterface\">\r\n<meta name=\"APIName\" content=\"System.Type.IsLayoutSequential\">\r\n<meta name=\"APIName\" content=\"System.Type.IsMarshalByRef\">\r\n<meta name=\"APIName\" content=\"System.Type.IsMarshalByRefImpl\">\r\n<meta name=\"APIName\" content=\"System.Type.IsNested\">\r\n<meta name=\"APIName\" content=\"System.Type.IsNestedAssembly\">\r\n<meta name=\"APIName\" content=\"System.Type.IsNestedFamANDAssem\">\r\n<meta name=\"APIName\" content=\"System.Type.IsNestedFamily\">\r\n<meta name=\"APIName\" content=\"System.Type.IsNestedFamORAssem\">\r\n<meta name=\"APIName\" content=\"System.Type.IsNestedPrivate\">\r\n<meta name=\"APIName\" content=\"System.Type.IsNestedPublic\">\r\n<meta name=\"APIName\" content=\"System.Type.IsNotPublic\">\r\n<meta name=\"APIName\" content=\"System.Type.IsPointer\">\r\n<meta name=\"APIName\" content=\"System.Type.IsPointerImpl\">\r\n<meta name=\"APIName\" content=\"System.Type.IsPrimitive\">\r\n<meta name=\"APIName\" content=\"System.Type.IsPrimitiveImpl\">\r\n<meta name=\"APIName\" content=\"System.Type.IsPublic\">\r\n<meta name=\"APIName\" content=\"System.Type.IsSealed\">\r\n<meta name=\"APIName\" content=\"System.Type.IsSecurityCritical\">\r\n<meta name=\"APIName\" content=\"System.Type.IsSecuritySafeCritical\">\r\n<meta name=\"APIName\" content=\"System.Type.IsSecurityTransparent\">\r\n<meta name=\"APIName\" content=\"System.Type.IsSerializable\">\r\n<meta name=\"APIName\" content=\"System.Type.IsSpecialName\">\r\n<meta name=\"APIName\" content=\"System.Type.IsSubclassOf\">\r\n<meta name=\"APIName\" content=\"System.Type.IsUnicodeClass\">\r\n<meta name=\"APIName\" content=\"System.Type.IsValueType\">\r\n<meta name=\"APIName\" content=\"System.Type.IsValueTypeImpl\">\r\n<meta name=\"APIName\" content=\"System.Type.IsVisible\">\r\n<meta name=\"APIName\" content=\"System.Type.MakeArrayType\">\r\n<meta name=\"APIName\" content=\"System.Type.MakeByRefType\">\r\n<meta name=\"APIName\" content=\"System.Type.MakeGenericType\">\r\n<meta name=\"APIName\" content=\"System.Type.MakePointerType\">\r\n<meta name=\"APIName\" content=\"System.Type.MemberType\">\r\n<meta name=\"APIName\" content=\"System.Type.Missing\">\r\n<meta name=\"APIName\" content=\"System.Type.Module\">\r\n<meta name=\"APIName\" content=\"System.Type.Namespace\">\r\n<meta name=\"APIName\" content=\"System.Type.op_Equality\">\r\n<meta name=\"APIName\" content=\"System.Type.op_op_Equality\">\r\n<meta name=\"APIName\" content=\"System.Type.op_Inequality\">\r\n<meta name=\"APIName\" content=\"System.Type.op_op_Inequality\">\r\n<meta name=\"APIName\" content=\"System.Type.ReflectedType\">\r\n<meta name=\"APIName\" content=\"System.Type.ReflectionOnlyGetType\">\r\n<meta name=\"APIName\" content=\"System.Type.StructLayoutAttribute\">\r\n<meta name=\"APIName\" content=\"System.Type._Type.GetIDsOfNames\">\r\n<meta name=\"APIName\" content=\"System.Type._Type.GetTypeInfo\">\r\n<meta name=\"APIName\" content=\"System.Type._Type.GetTypeInfoCount\">\r\n<meta name=\"APIName\" content=\"System.Type._Type.Invoke\">\r\n<meta name=\"APIName\" content=\"System.Type.ToString\">\r\n<meta name=\"APIName\" content=\"System.Type.TypeHandle\">\r\n<meta name=\"APIName\" content=\"System.Type.TypeInitializer\">\r\n<meta name=\"APIName\" content=\"System.Type.UnderlyingSystemType\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-01 01:37 AM\">\r\n<meta name=\"document_id\" content=\"31556f16-a6cf-2f2b-127c-cdbe1d433719\">\r\n<meta name=\"original_ecmaxml_local_path\" content=\"W:\\vejk\\s\\fulldocset\\xml\\System\\Type.xml\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.  \n To\">\r\n<meta name=\"toc_rel\" content=\"_splitted/System/toc1.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Type\">\r\n","rawMetadata":{"breadcrumb_path":"breadcrumb/toc.json","search.ms_sitename":"Docs","search.ms_docsetname":"fulldocset","version":null,"_op_canonicalUrlPrefix":"https://ppe.docs.microsoft.com/en-us/fulldotnet/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":true,"depot_name":"MSDN.fulldocset","_op_gitRefSkeletonCommitHistory":[{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"use plugin in master","commit_sha":"501959ac03e19ac52a27aa4c6bbeb980f8b11c8c","commit_date":"2017-03-01 09:31:20 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"fix pointer ref","commit_sha":"76befb0e7f7b41839ec719047e5b39a5981298f3","commit_date":"2017-02-28 15:47:23 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"switch from platform to version","commit_sha":"78cdacb5ca782478af490a6b30c3a2cb2b6b873e","commit_date":"2017-02-28 15:09:51 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"update platforms","commit_sha":"39ad5a8919a59afc93a79ac4bd8e07c3b471b37a","commit_date":"2017-02-28 10:38:59 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"checkin yml","commit_sha":"da161b792852497df7140d7768cee2eccd9cb43f","commit_date":"2017-02-28 09:36:15 +0800"}],"ref_skeleton_gitcommit":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Type.yml","original_ref_skeleton_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Type.yml","open_to_public_contributors":true,"api_name":["System.Type","System.Type..ctor","System.Type.Assembly","System.Type.AssemblyQualifiedName","System.Type.Attributes","System.Type.BaseType","System.Type.ContainsGenericParameters","System.Type.DeclaringMethod","System.Type.DeclaringType","System.Type.DefaultBinder","System.Type.Delimiter","System.Type.EmptyTypes","System.Type.Equals","System.Type.FilterAttribute","System.Type.FilterName","System.Type.FilterNameIgnoreCase","System.Type.FindInterfaces","System.Type.FindMembers","System.Type.FullName","System.Type.GenericParameterAttributes","System.Type.GenericParameterPosition","System.Type.GenericTypeArguments","System.Type.GetArrayRank","System.Type.GetAttributeFlagsImpl","System.Type.GetConstructor","System.Type.GetConstructorImpl","System.Type.GetConstructors","System.Type.GetDefaultMembers","System.Type.GetElementType","System.Type.GetEnumName","System.Type.GetEnumNames","System.Type.GetEnumUnderlyingType","System.Type.GetEnumValues","System.Type.GetEvent","System.Type.GetEvents","System.Type.GetField","System.Type.GetFields","System.Type.GetGenericArguments","System.Type.GetGenericParameterConstraints","System.Type.GetGenericTypeDefinition","System.Type.GetHashCode","System.Type.GetInterface","System.Type.GetInterfaceMap","System.Type.GetInterfaces","System.Type.GetMember","System.Type.GetMembers","System.Type.GetMethod","System.Type.GetMethodImpl","System.Type.GetMethods","System.Type.GetNestedType","System.Type.GetNestedTypes","System.Type.GetProperties","System.Type.GetProperty","System.Type.GetPropertyImpl","System.Type.GetType","System.Type.GetTypeArray","System.Type.GetTypeCode","System.Type.GetTypeCodeImpl","System.Type.GetTypeFromCLSID","System.Type.GetTypeFromHandle","System.Type.GetTypeFromProgID","System.Type.GetTypeHandle","System.Type.GUID","System.Type.HasElementType","System.Type.HasElementTypeImpl","System.Type.InvokeMember","System.Type.IsAbstract","System.Type.IsAnsiClass","System.Type.IsArray","System.Type.IsArrayImpl","System.Type.IsAssignableFrom","System.Type.IsAutoClass","System.Type.IsAutoLayout","System.Type.IsByRef","System.Type.IsByRefImpl","System.Type.IsClass","System.Type.IsCOMObject","System.Type.IsCOMObjectImpl","System.Type.IsConstructedGenericType","System.Type.IsContextful","System.Type.IsContextfulImpl","System.Type.IsEnum","System.Type.IsEnumDefined","System.Type.IsEquivalentTo","System.Type.IsExplicitLayout","System.Type.IsGenericParameter","System.Type.IsGenericType","System.Type.IsGenericTypeDefinition","System.Type.IsImport","System.Type.IsInstanceOfType","System.Type.IsInterface","System.Type.IsLayoutSequential","System.Type.IsMarshalByRef","System.Type.IsMarshalByRefImpl","System.Type.IsNested","System.Type.IsNestedAssembly","System.Type.IsNestedFamANDAssem","System.Type.IsNestedFamily","System.Type.IsNestedFamORAssem","System.Type.IsNestedPrivate","System.Type.IsNestedPublic","System.Type.IsNotPublic","System.Type.IsPointer","System.Type.IsPointerImpl","System.Type.IsPrimitive","System.Type.IsPrimitiveImpl","System.Type.IsPublic","System.Type.IsSealed","System.Type.IsSecurityCritical","System.Type.IsSecuritySafeCritical","System.Type.IsSecurityTransparent","System.Type.IsSerializable","System.Type.IsSpecialName","System.Type.IsSubclassOf","System.Type.IsUnicodeClass","System.Type.IsValueType","System.Type.IsValueTypeImpl","System.Type.IsVisible","System.Type.MakeArrayType","System.Type.MakeByRefType","System.Type.MakeGenericType","System.Type.MakePointerType","System.Type.MemberType","System.Type.Missing","System.Type.Module","System.Type.Namespace","System.Type.op_Equality","System.Type.op_op_Equality","System.Type.op_Inequality","System.Type.op_op_Inequality","System.Type.ReflectedType","System.Type.ReflectionOnlyGetType","System.Type.StructLayoutAttribute","System.Type._Type.GetIDsOfNames","System.Type._Type.GetTypeInfo","System.Type._Type.GetTypeInfoCount","System.Type._Type.Invoke","System.Type.ToString","System.Type.TypeHandle","System.Type.TypeInitializer","System.Type.UnderlyingSystemType"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Type","System::Type","System.Type.#ctor","System::Type::#ctor","System.Type.Assembly","System::Type::Assembly","System.Type.AssemblyQualifiedName","System::Type::AssemblyQualifiedName","System.Type.Attributes","System::Type::Attributes","System.Type.BaseType","System::Type::BaseType","System.Type.ContainsGenericParameters","System::Type::ContainsGenericParameters","System.Type.DeclaringMethod","System::Type::DeclaringMethod","System.Type.DeclaringType","System::Type::DeclaringType","System.Type.DefaultBinder","System::Type::DefaultBinder","System.Type.Delimiter","System::Type::Delimiter","System.Type.EmptyTypes","System::Type::EmptyTypes","System.Type.Equals","System::Type::Equals","System.Type.FilterAttribute","System::Type::FilterAttribute","System.Type.FilterName","System::Type::FilterName","System.Type.FilterNameIgnoreCase","System::Type::FilterNameIgnoreCase","System.Type.FindInterfaces","System::Type::FindInterfaces","System.Type.FindMembers","System::Type::FindMembers","System.Type.FullName","System::Type::FullName","System.Type.GenericParameterAttributes","System::Type::GenericParameterAttributes","System.Type.GenericParameterPosition","System::Type::GenericParameterPosition","System.Type.GenericTypeArguments","System::Type::GenericTypeArguments","System.Type.GetArrayRank","System::Type::GetArrayRank","System.Type.GetAttributeFlagsImpl","System::Type::GetAttributeFlagsImpl","System.Type.GetConstructor","System::Type::GetConstructor","System.Type.GetConstructorImpl","System::Type::GetConstructorImpl","System.Type.GetConstructors","System::Type::GetConstructors","System.Type.GetDefaultMembers","System::Type::GetDefaultMembers","System.Type.GetElementType","System::Type::GetElementType","System.Type.GetEnumName","System::Type::GetEnumName","System.Type.GetEnumNames","System::Type::GetEnumNames","System.Type.GetEnumUnderlyingType","System::Type::GetEnumUnderlyingType","System.Type.GetEnumValues","System::Type::GetEnumValues","System.Type.GetEvent","System::Type::GetEvent","System.Type.GetEvents","System::Type::GetEvents","System.Type.GetField","System::Type::GetField","System.Type.GetFields","System::Type::GetFields","System.Type.GetGenericArguments","System::Type::GetGenericArguments","System.Type.GetGenericParameterConstraints","System::Type::GetGenericParameterConstraints","System.Type.GetGenericTypeDefinition","System::Type::GetGenericTypeDefinition","System.Type.GetHashCode","System::Type::GetHashCode","System.Type.GetInterface","System::Type::GetInterface","System.Type.GetInterfaceMap","System::Type::GetInterfaceMap","System.Type.GetInterfaces","System::Type::GetInterfaces","System.Type.GetMember","System::Type::GetMember","System.Type.GetMembers","System::Type::GetMembers","System.Type.GetMethod","System::Type::GetMethod","System.Type.GetMethodImpl","System::Type::GetMethodImpl","System.Type.GetMethods","System::Type::GetMethods","System.Type.GetNestedType","System::Type::GetNestedType","System.Type.GetNestedTypes","System::Type::GetNestedTypes","System.Type.GetProperties","System::Type::GetProperties","System.Type.GetProperty","System::Type::GetProperty","System.Type.GetPropertyImpl","System::Type::GetPropertyImpl","System.Type.GetType","System::Type::GetType","System.Type.GetTypeArray","System::Type::GetTypeArray","System.Type.GetTypeCode","System::Type::GetTypeCode","System.Type.GetTypeCodeImpl","System::Type::GetTypeCodeImpl","System.Type.GetTypeFromCLSID","System::Type::GetTypeFromCLSID","System.Type.GetTypeFromHandle","System::Type::GetTypeFromHandle","System.Type.GetTypeFromProgID","System::Type::GetTypeFromProgID","System.Type.GetTypeHandle","System::Type::GetTypeHandle","System.Type.GUID","System::Type::GUID","System.Type.HasElementType","System::Type::HasElementType","System.Type.HasElementTypeImpl","System::Type::HasElementTypeImpl","System.Type.InvokeMember","System::Type::InvokeMember","System.Type.IsAbstract","System::Type::IsAbstract","System.Type.IsAnsiClass","System::Type::IsAnsiClass","System.Type.IsArray","System::Type::IsArray","System.Type.IsArrayImpl","System::Type::IsArrayImpl","System.Type.IsAssignableFrom","System::Type::IsAssignableFrom","System.Type.IsAutoClass","System::Type::IsAutoClass","System.Type.IsAutoLayout","System::Type::IsAutoLayout","System.Type.IsByRef","System::Type::IsByRef","System.Type.IsByRefImpl","System::Type::IsByRefImpl","System.Type.IsClass","System::Type::IsClass","System.Type.IsCOMObject","System::Type::IsCOMObject","System.Type.IsCOMObjectImpl","System::Type::IsCOMObjectImpl","System.Type.IsConstructedGenericType","System::Type::IsConstructedGenericType","System.Type.IsContextful","System::Type::IsContextful","System.Type.IsContextfulImpl","System::Type::IsContextfulImpl","System.Type.IsEnum","System::Type::IsEnum","System.Type.IsEnumDefined","System::Type::IsEnumDefined","System.Type.IsEquivalentTo","System::Type::IsEquivalentTo","System.Type.IsExplicitLayout","System::Type::IsExplicitLayout","System.Type.IsGenericParameter","System::Type::IsGenericParameter","System.Type.IsGenericType","System::Type::IsGenericType","System.Type.IsGenericTypeDefinition","System::Type::IsGenericTypeDefinition","System.Type.IsImport","System::Type::IsImport","System.Type.IsInstanceOfType","System::Type::IsInstanceOfType","System.Type.IsInterface","System::Type::IsInterface","System.Type.IsLayoutSequential","System::Type::IsLayoutSequential","System.Type.IsMarshalByRef","System::Type::IsMarshalByRef","System.Type.IsMarshalByRefImpl","System::Type::IsMarshalByRefImpl","System.Type.IsNested","System::Type::IsNested","System.Type.IsNestedAssembly","System::Type::IsNestedAssembly","System.Type.IsNestedFamANDAssem","System::Type::IsNestedFamANDAssem","System.Type.IsNestedFamily","System::Type::IsNestedFamily","System.Type.IsNestedFamORAssem","System::Type::IsNestedFamORAssem","System.Type.IsNestedPrivate","System::Type::IsNestedPrivate","System.Type.IsNestedPublic","System::Type::IsNestedPublic","System.Type.IsNotPublic","System::Type::IsNotPublic","System.Type.IsPointer","System::Type::IsPointer","System.Type.IsPointerImpl","System::Type::IsPointerImpl","System.Type.IsPrimitive","System::Type::IsPrimitive","System.Type.IsPrimitiveImpl","System::Type::IsPrimitiveImpl","System.Type.IsPublic","System::Type::IsPublic","System.Type.IsSealed","System::Type::IsSealed","System.Type.IsSecurityCritical","System::Type::IsSecurityCritical","System.Type.IsSecuritySafeCritical","System::Type::IsSecuritySafeCritical","System.Type.IsSecurityTransparent","System::Type::IsSecurityTransparent","System.Type.IsSerializable","System::Type::IsSerializable","System.Type.IsSpecialName","System::Type::IsSpecialName","System.Type.IsSubclassOf","System::Type::IsSubclassOf","System.Type.IsUnicodeClass","System::Type::IsUnicodeClass","System.Type.IsValueType","System::Type::IsValueType","System.Type.IsValueTypeImpl","System::Type::IsValueTypeImpl","System.Type.IsVisible","System::Type::IsVisible","System.Type.MakeArrayType","System::Type::MakeArrayType","System.Type.MakeByRefType","System::Type::MakeByRefType","System.Type.MakeGenericType","System::Type::MakeGenericType","System.Type.MakePointerType","System::Type::MakePointerType","System.Type.MemberType","System::Type::MemberType","System.Type.Missing","System::Type::Missing","System.Type.Module","System::Type::Module","System.Type.Namespace","System::Type::Namespace","System.Type.op_Equality","System::Type::op_Equality","System.Type.op_Inequality","System::Type::op_Inequality","System.Type.ReflectedType","System::Type::ReflectedType","System.Type.ReflectionOnlyGetType","System::Type::ReflectionOnlyGetType","System.Type.StructLayoutAttribute","System::Type::StructLayoutAttribute","System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames","System::Type::System#Runtime#InteropServices#_Type#GetIDsOfNames","System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo","System::Type::System#Runtime#InteropServices#_Type#GetTypeInfo","System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount","System::Type::System#Runtime#InteropServices#_Type#GetTypeInfoCount","System.Type.System#Runtime#InteropServices#_Type#Invoke","System::Type::System#Runtime#InteropServices#_Type#Invoke","System.Type.ToString","System::Type::ToString","System.Type.TypeHandle","System::Type::TypeHandle","System.Type.TypeInitializer","System::Type::TypeInitializer","System.Type.UnderlyingSystemType","System::Type::UnderlyingSystemType"],"dev_langs":["csharp"],"updated_at":"2017-03-01 01:37 AM","document_id":"31556f16-a6cf-2f2b-127c-cdbe1d433719","original_ecmaxml_local_path":"W:\\vejk\\s\\fulldocset\\xml\\System\\Type.xml","content_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/xml/System/Type.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"Type class | Microsoft Docs","_op_ogTitle":"Type class","description":"Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.  \n To","toc_asset_id":"_splitted/System/toc.json","toc_rel":"_splitted/System/toc.json","source_url":"","ms.assetid":"System.Type","canonical_url":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.type","_op_canonicalUrl":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.type","fileRelativePath":"System.Type.html"},"themesRelativePathToOutputRoot":"_themes/"}