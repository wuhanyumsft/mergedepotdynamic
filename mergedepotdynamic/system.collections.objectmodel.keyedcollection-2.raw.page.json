{"content":"    \r\n    <h1 id=\"System_Collections_ObjectModel_KeyedCollection_2\">\r\n      <span class=\"lang-csharp\">KeyedCollection&lt;TKey,TItem&gt;</span>\r\n        Class\r\n    </h1>\r\n    \r\n    \r\n    <nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n      <h3>In this Article</h3>\r\n    </nav><div class=\"summary\">\r\n    \t<p>Provides the abstract base class for a collection whose keys are embedded in the values.</p>\n\r\n    </div><h2>Syntax</h2>\r\n    \r\n    \t<h3>Declaration</h3>\r\n    \t<pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">[System.Diagnostics.DebuggerDisplay(&quot;Count = {Count}&quot;)]\n[System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.Mscorlib_KeyedCollectionDebugView`2))]\n[System.Runtime.InteropServices.ComVisible(false)]\npublic abstract class KeyedCollection&lt;TKey,TItem&gt; : System.Collections.ObjectModel.Collection&lt;TItem&gt;</code></pre>\r\n    \r\n    \r\n    \t<h2>Type Parameters</h2>\r\n    \r\n    \t<table class=\"nameValue\">\r\n    \t\t<tr>\r\n    \t\t<td>\r\n    \t\tTKey\r\n    \t\t</td>\r\n    \t\t<td>\r\n    \t\t<p>The type of keys in the collection.</p>\n\r\n    \t\t</td>\r\n    \t\t</tr>\r\n    \t\t<tr>\r\n    \t\t<td>\r\n    \t\tTItem\r\n    \t\t</td>\r\n    \t\t<td>\r\n    \t\t<p>The type of items in the collection.</p>\n\r\n    \t\t</td>\r\n    \t\t</tr>\r\n    \t</table>\r\n    \r\n    <h3>Inheritance Hierarchy</h3>\r\n    <ul class=\"inheritance\">\r\n        <li class=\"l0\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>\r\n          </div>\r\n        </li>\r\n        <li class=\"l1\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1\" data-linktype=\"relative-path\">System.Collections.ObjectModel.Collection<titem></titem></a>\r\n          </div>\r\n        </li>\r\n      <li class=\"l2\">\r\n        <div class=\"xref\">\r\n          <div class=\"lang-csharp\">KeyedCollection&lt;TKey,TItem&gt;</div>\r\n        </div>\r\n      </li>\r\n    </ul>\r\n    \r\n      <div class=\"referencebox inheritedMembers\">\r\n        <h3>Inherited Members</h3>\r\n        <h4></h4>\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Add__0_\" data-linktype=\"relative-path\">Add(T)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Clear\" data-linktype=\"relative-path\">Clear()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_CopyTo__0___System_Int32_\" data-linktype=\"relative-path\">CopyTo(T[],Int32)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Count\" data-linktype=\"relative-path\">Count</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_GetEnumerator\" data-linktype=\"relative-path\">GetEnumerator()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_IndexOf__0_\" data-linktype=\"relative-path\">IndexOf(T)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Insert_System_Int32__0_\" data-linktype=\"relative-path\">Insert(Int32,T)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_InsertItem_System_Int32__0_\" data-linktype=\"relative-path\">InsertItem(Int32,T)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Item_System_Int32_\" data-linktype=\"relative-path\">Item(Int32)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Items\" data-linktype=\"relative-path\">Items</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_RemoveAt_System_Int32_\" data-linktype=\"relative-path\">RemoveAt(Int32)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_SetItem_System_Int32__0_\" data-linktype=\"relative-path\">SetItem(Int32,T)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_System_Collections_Generic_ICollection_T__IsReadOnly\" data-linktype=\"relative-path\">ICollection&lt;T&gt;.IsReadOnly</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_System_Collections_ICollection_CopyTo_System_Array_System_Int32_\" data-linktype=\"relative-path\">ICollection.CopyTo(Array,Int32)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_System_Collections_ICollection_IsSynchronized\" data-linktype=\"relative-path\">ICollection.IsSynchronized</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_System_Collections_ICollection_SyncRoot\" data-linktype=\"relative-path\">ICollection.SyncRoot</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_System_Collections_IEnumerable_GetEnumerator\" data-linktype=\"relative-path\">IEnumerable.GetEnumerator()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_System_Collections_IList_Add_System_Object_\" data-linktype=\"relative-path\">IList.Add(Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_System_Collections_IList_Contains_System_Object_\" data-linktype=\"relative-path\">IList.Contains(Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_System_Collections_IList_IndexOf_System_Object_\" data-linktype=\"relative-path\">IList.IndexOf(Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_System_Collections_IList_Insert_System_Int32_System_Object_\" data-linktype=\"relative-path\">IList.Insert(Int32,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_System_Collections_IList_IsFixedSize\" data-linktype=\"relative-path\">IList.IsFixedSize</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_System_Collections_IList_IsReadOnly\" data-linktype=\"relative-path\">IList.IsReadOnly</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_System_Collections_IList_Item_System_Int32_\" data-linktype=\"relative-path\">IList.Item(Int32)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_System_Collections_IList_Remove_System_Object_\" data-linktype=\"relative-path\">IList.Remove(Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a>\r\n          </div>\r\n          \r\n      </div>\r\n    \r\n    \r\n      <h2>Remarks</h2>\r\n      <p>The KeyedCollection(TKey, class provides both O(1) indexed retrieval and keyed retrieval that approaches O(1). It is an abstract type, or more accurately an infinite set of abstract types, because each of its constructed generic types is an abstract base class. To use KeyedCollection(TKey,, derive your collection type from the appropriate constructed type.  </p>\n<p> The KeyedCollection(TKey, class is a hybrid between a collection based on the <a class=\"xref\" href=\"system.collections.generic.ilist-1\" data-linktype=\"relative-path\">IList&lt;T&gt;</a> generic interface and a collection based on the <a class=\"xref\" href=\"system.collections.generic.idictionary-2\" data-linktype=\"relative-path\">IDictionary&lt;TKey,TValue&gt;</a> generic interface. Like collections based on the <a class=\"xref\" href=\"system.collections.generic.ilist-1\" data-linktype=\"relative-path\">IList&lt;T&gt;</a> generic interface, KeyedCollection(TKey, is an indexed list of items. Like collections based on the <a class=\"xref\" href=\"system.collections.generic.idictionary-2\" data-linktype=\"relative-path\">IDictionary&lt;TKey,TValue&gt;</a> generic interface, KeyedCollection(TKey, has a key associated with each element.  </p>\n<p> Unlike dictionaries, an element of KeyedCollection(TKey, is not a key/value pair; instead, the entire element is the value and the key is embedded within the value.  For example, an element of a collection derived from <code>KeyedCollection\\&lt;String,String&gt;</code> (<code>KeyedCollection(Of String, String)</code> in Visual Basic) might be &quot;John Doe Jr.&quot; where the value is &quot;John Doe Jr.&quot; and the key is &quot;Doe&quot;; or a collection of employee records containing integer keys could be derived from <code>KeyedCollection\\&lt;int,Employee&gt;</code>. The abstract <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_GetKeyForItem_\" data-linktype=\"relative-path\">GetKeyForItem</a> method extracts the key from the element.  </p>\n<p> By default, the KeyedCollection(TKey, includes a lookup dictionary that you can obtain with the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_Dictionary_\" data-linktype=\"relative-path\">Dictionary</a> property.  When an item is added to the KeyedCollection(TKey,, the item&#39;s key is extracted once and saved in the lookup dictionary for faster searches. This behavior is overridden by specifying a dictionary creation threshold when you create the KeyedCollection(TKey,. The lookup dictionary is created the first time the number of elements exceeds that threshold.  If you specify â€“1 as the threshold, the lookup dictionary is never created.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> When the internal lookup dictionary is used, it contains references to all the items in the collection if <code>TItem</code> is a reference type, or copies of all the items in the collection if <code>TItem</code> is a value type. Thus, using the lookup dictionary may not be appropriate if <code>TItem</code> is a value type.  </p>\n</div>\n<p> You can access an item by its index or key by using the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_Item_\" data-linktype=\"relative-path\">Item</a>property. You can add items without a key, but these items can subsequently be accessed only by index.</p>\n\r\n    \r\n    \r\n    <h2>Constructors\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Collections_ObjectModel_KeyedCollection_2__ctor\" data-linktype=\"self-bookmark\">KeyedCollection&lt;TKey,TItem&gt;()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Initializes a new instance of the <span class=\"xref\">stem.Collections.ObjectModel.KeyedCollection`2</span> class that uses the default equality comparer.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Collections_ObjectModel_KeyedCollection_2__ctor_System_Collections_Generic_IEqualityComparer__0__\" data-linktype=\"self-bookmark\">KeyedCollection&lt;TKey,TItem&gt;(IEqualityComparer&lt;TKey&gt;)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Initializes a new instance of the <span class=\"xref\">stem.Collections.ObjectModel.KeyedCollection`2</span> class that uses the specified equality comparer.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Collections_ObjectModel_KeyedCollection_2__ctor_System_Collections_Generic_IEqualityComparer__0__System_Int32_\" data-linktype=\"self-bookmark\">KeyedCollection&lt;TKey,TItem&gt;(IEqualityComparer&lt;TKey&gt;,Int32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Initializes a new instance of the <span class=\"xref\">stem.Collections.ObjectModel.KeyedCollection`2</span> class that uses the specified equality comparer and creates a lookup dictionary when the specified threshold is exceeded.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Properties\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Collections_ObjectModel_KeyedCollection_2_Comparer\" data-linktype=\"self-bookmark\">Comparer</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the generic equality comparer that is used to determine equality of keys in the collection.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Collections_ObjectModel_KeyedCollection_2_Dictionary\" data-linktype=\"self-bookmark\">Dictionary</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the lookup dictionary of the <span class=\"xref\">stem.Collections.ObjectModel.KeyedCollection`2</span>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Collections_ObjectModel_KeyedCollection_2_Item__0_\" data-linktype=\"self-bookmark\">Item(TKey)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the element with the specified key.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Methods\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Collections_ObjectModel_KeyedCollection_2_ChangeItemKey__1__0_\" data-linktype=\"self-bookmark\">ChangeItemKey(TItem,TKey)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Changes the key associated with the specified element in the lookup dictionary.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Collections_ObjectModel_KeyedCollection_2_ClearItems\" data-linktype=\"self-bookmark\">ClearItems()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Removes all elements from the <span class=\"xref\">stem.Collections.ObjectModel.KeyedCollection`2</span>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Collections_ObjectModel_KeyedCollection_2_Contains__0_\" data-linktype=\"self-bookmark\">Contains(TKey)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Determines whether the collection contains an element with the specified key.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Collections_ObjectModel_KeyedCollection_2_GetKeyForItem__1_\" data-linktype=\"self-bookmark\">GetKeyForItem(TItem)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>When implemented in a derived class, extracts the key from the specified element.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Collections_ObjectModel_KeyedCollection_2_InsertItem_System_Int32__1_\" data-linktype=\"self-bookmark\">InsertItem(Int32,TItem)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Inserts an element into the <span class=\"xref\">stem.Collections.ObjectModel.KeyedCollection`2</span> at the specified index.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Collections_ObjectModel_KeyedCollection_2_Remove__0_\" data-linktype=\"self-bookmark\">Remove(TKey)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Removes the element with the specified key from the <span class=\"xref\">stem.Collections.ObjectModel.KeyedCollection`2</span>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Collections_ObjectModel_KeyedCollection_2_RemoveItem_System_Int32_\" data-linktype=\"self-bookmark\">RemoveItem(Int32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Removes the element at the specified index of the <span class=\"xref\">stem.Collections.ObjectModel.KeyedCollection`2</span>.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Collections_ObjectModel_KeyedCollection_2_SetItem_System_Int32__1_\" data-linktype=\"self-bookmark\">SetItem(Int32,TItem)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Replaces the item at the specified index with the specified item.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"constructors\">\r\n        <h2>Constructors\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Collections_ObjectModel_KeyedCollection_2__ctor\">\r\n    \r\n            <a id=\"System_Collections_ObjectModel_KeyedCollection_2__ctor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">KeyedCollection&lt;TKey,TItem&gt;()</div>        \r\n          </div>\r\n    \r\n            <p>Initializes a new instance of the <span class=\"xref\">stem.Collections.ObjectModel.KeyedCollection`2</span> class that uses the default equality comparer.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected KeyedCollection ();</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> created with this constructor uses the default generic equality comparer for the type of the key, obtained from <a class=\"xref\" href=\"system.collections.generic.equalitycomparer-1#System_Collections_Generic_EqualityComparer_1_Default_\" data-linktype=\"relative-path\">Default</a>. To specify a different generic equality comparer, use the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2__ctor_System_Collections_Generic_IEqualityComparer__0__\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;(IEqualityComparer&lt;TKey&gt;)</a> constructor or the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2__ctor_System_Collections_Generic_IEqualityComparer__0__System_Int32_\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;(IEqualityComparer&lt;TKey&gt;,Int32)</a> constructor.  </p>\n<p> By default, the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> includes a lookup dictionary that is created when the first item is added. When an item is added to the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a>, the item&#39;s key is extracted once and saved in the lookup dictionary for faster searches. This behavior can be overridden by using the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2__ctor_System_Collections_Generic_IEqualityComparer__0__System_Int32_\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;(IEqualityComparer&lt;TKey&gt;,Int32)</a> constructor and specifying a dictionary creation threshold.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Because the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> class is abstract (<code>MustInherit</code> in Visual Basic), you must derive from it in order to use it. In the constructor for your derived type, call the appropriate <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> constructor. It is not necessary to expose functionality like the equality comparer or the dictionary creation threshold in your constructors.  </p>\n</div>\n<p> This constructor is an O(1) operation.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>This code example shows the minimum code necessary to derive a collection class from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a>: overriding the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_GetKeyForItem_\" data-linktype=\"relative-path\">GetKeyForItem</a> method and providing a public constructor that delegates to a base class constructor. The code example also demonstrates many of the properties and methods inherited from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> and <a class=\"xref\" href=\"system.collections.objectmodel.collection-1\" data-linktype=\"relative-path\">Collection&lt;T&gt;</a> classes.  </p>\n<p> The <code>SimpleOrder</code> class is a very simple requisition list that contains <code>OrderItem</code> objects, each of which represents a line item in the order. The key of <code>OrderItem</code> is immutable, an important consideration for classes that derive from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a>. For a code example that uses mutable keys, see <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_ChangeItemKey_\" data-linktype=\"relative-path\">ChangeItemKey</a>.  </p>\n<pre><code class=\"lang-cpp\" name=\"KeyedCollection#1\">using namespace System;\nusing namespace System::Collections::Generic;\nusing namespace System::Collections::ObjectModel;\n\n// This class represents a simple line item in an order. All the \n// values are immutable except quantity.\n// \npublic ref class OrderItem\n{\nprivate:\n    int _quantity;\n    \npublic:\n    initonly int PartNumber;\n    initonly String^ Description;\n    initonly double UnitPrice;\n    \n    OrderItem(int partNumber, String^ description, \n        int quantity, double unitPrice)\n    {\n        this-&gt;PartNumber = partNumber;\n        this-&gt;Description = description;\n        this-&gt;Quantity = quantity;\n        this-&gt;UnitPrice = unitPrice;\n    } \n    \n    property int Quantity    \n    {\n        int get() { return _quantity; }\n        void set(int value)\n        {\n            if (value &lt; 0)\n                throw gcnew ArgumentException(&quot;Quantity cannot be negative.&quot;);\n            \n            _quantity = value;\n        }\n    }\n        \n    virtual String^ ToString() override \n    {\n        return String::Format(\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, \n            PartNumber, _quantity, Description, UnitPrice, \n            UnitPrice * _quantity);\n    }\n};\n\n// This class represents a very simple keyed list of OrderItems,\n// inheriting most of its behavior from the KeyedCollection and \n// Collection classes. The immediate base class is the constructed\n// type KeyedCollection&lt;int, OrderItem&gt;. When you inherit\n// from KeyedCollection, the second generic type argument is the \n// type that you want to store in the collection -- in this case\n// OrderItem. The first type argument is the type that you want\n// to use as a key. Its values must be calculated from OrderItem; \n// in this case it is the int field PartNumber, so SimpleOrder\n// inherits KeyedCollection&lt;int, OrderItem&gt;.\n//\npublic ref class SimpleOrder : KeyedCollection&lt;int, OrderItem^&gt;\n{\n    // The parameterless constructor of the base class creates a \n    // KeyedCollection with an internal dictionary. For this code \n    // example, no other constructors are exposed.\n    //\npublic:\n    SimpleOrder() {}\n    \n    // This is the only method that absolutely must be overridden,\n    // because without it the KeyedCollection cannot extract the\n    // keys from the items. The input parameter type is the \n    // second generic type argument, in this case OrderItem, and \n    // the return value type is the first generic type argument,\n    // in this case int.\n    //\nprotected:\n    virtual int GetKeyForItem(OrderItem^ item) override \n    {\n        // In this example, the key is the part number.\n        return item-&gt;PartNumber;\n    }\n};\n\npublic ref class Demo\n{    \npublic:\n    static void Main()\n    {\n        SimpleOrder^ weekly = gcnew SimpleOrder();\n\n        // The Add method, inherited from Collection, takes OrderItem.\n        //\n        weekly-&gt;Add(gcnew OrderItem(110072674, &quot;Widget&quot;, 400, 45.17));\n        weekly-&gt;Add(gcnew OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3));\n        weekly-&gt;Add(gcnew OrderItem(101030411, &quot;Motor&quot;, 10, 237.5));\n        weekly-&gt;Add(gcnew OrderItem(110072684, &quot;Gear&quot;, 175, 5.17));\n        \n        Display(weekly);\n    \n        // The Contains method of KeyedCollection takes the key, \n        // type, in this case int.\n        //\n        Console::WriteLine(&quot;<br>Contains(101030411): {0}&quot;, \n            weekly-&gt;Contains(101030411));\n\n        // The default Item property of KeyedCollection takes a key.\n        //\n        Console::WriteLine(&quot;<br>weekly(101030411)-&gt;Description: {0}&quot;, \n            weekly[101030411]-&gt;Description);\n\n        // The Remove method of KeyedCollection takes a key.\n        //\n        Console::WriteLine(&quot;<br>Remove(101030411)&quot;);\n        weekly-&gt;Remove(101030411);\n        Display(weekly);\n\n        // The Insert method, inherited from Collection, takes an \n        // index and an OrderItem.\n        //\n        Console::WriteLine(&quot;<br>Insert(2, New OrderItem(...))&quot;);\n        weekly-&gt;Insert(2, gcnew OrderItem(111033401, &quot;Nut&quot;, 10, .5));\n        Display(weekly);\n\n        // The default Item property is overloaded. One overload comes\n        // from KeyedCollection&lt;int, OrderItem&gt;; that overload\n        // is read-only, and takes Integer because it retrieves by key. \n        // The other overload comes from Collection&lt;OrderItem&gt;, the \n        // base class of KeyedCollection&lt;int, OrderItem&gt;; it \n        // retrieves by index, so it also takes an Integer. The compiler\n        // uses the most-derived overload, from KeyedCollection, so the\n        // only way to access SimpleOrder by index is to cast it to\n        // Collection&lt;OrderItem&gt;. Otherwise the index is interpreted\n        // as a key, and KeyNotFoundException is thrown.\n        //\n        Collection&lt;OrderItem^&gt;^ coweekly = weekly;\n        Console::WriteLine(&quot;<br>coweekly[2].Description: {0}&quot;, \n            coweekly[2]-&gt;Description);\n \n        Console::WriteLine(&quot;<br>coweekly[2] = gcnew OrderItem(...)&quot;);\n        coweekly[2] = gcnew OrderItem(127700026, &quot;Crank&quot;, 27, 5.98);\n\n        OrderItem^ temp = coweekly[2];\n\n        // The IndexOf method inherited from Collection&lt;OrderItem&gt; \n        // takes an OrderItem instead of a key\n        // \n        Console::WriteLine(&quot;<br>IndexOf(temp): {0}&quot;, weekly-&gt;IndexOf(temp));\n\n        // The inherited Remove method also takes an OrderItem.\n        //\n        Console::WriteLine(&quot;<br>Remove(temp)&quot;);\n        weekly-&gt;Remove(temp);\n        Display(weekly);\n\n        Console::WriteLine(&quot;<br>RemoveAt(0)&quot;);\n        weekly-&gt;RemoveAt(0);\n        Display(weekly);\n\n    }\n    \nprivate:\n    static void Display(SimpleOrder^ order)\n    {\n        Console::WriteLine();\n        for each( OrderItem^ item in order )\n        {\n            Console::WriteLine(item);\n        }\n    }\n};\n\nvoid main()\n{\n    Demo::Main();\n}\n\n/* This code example produces the following output:\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n101030411     10 Motor        at   237.50 =   2,375.00\n110072684    175 Gear         at     5.17 =     904.75\n\nContains(101030411): True\n\nweekly(101030411)-&gt;Description: Motor\n\nRemove(101030411)\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n\nInsert(2, New OrderItem(...))\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n111033401     10 Nut          at      .50 =       5.00\n110072684    175 Gear         at     5.17 =     904.75\n\ncoweekly(2)-&gt;Description: Nut\n\ncoweekly[2] = gcnew OrderItem(...)\n\nIndexOf(temp): 2\n\nRemove(temp)\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n\nRemoveAt(0)\n\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n */\n</code></pre><pre><code class=\"lang-cs\" name=\"KeyedCollection#1\">using System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\n\n// This class represents a very simple keyed list of OrderItems,\n// inheriting most of its behavior from the KeyedCollection and \n// Collection classes. The immediate base class is the constructed\n// type KeyedCollection&lt;int, OrderItem&gt;. When you inherit\n// from KeyedCollection, the second generic type argument is the \n// type that you want to store in the collection -- in this case\n// OrderItem. The first type argument is the type that you want\n// to use as a key. Its values must be calculated from OrderItem; \n// in this case it is the int field PartNumber, so SimpleOrder\n// inherits KeyedCollection&lt;int, OrderItem&gt;.\n//\npublic class SimpleOrder : KeyedCollection&lt;int, OrderItem&gt;\n{\n       \n    // This is the only method that absolutely must be overridden,\n    // because without it the KeyedCollection cannot extract the\n    // keys from the items. The input parameter type is the \n    // second generic type argument, in this case OrderItem, and \n    // the return value type is the first generic type argument,\n    // in this case int.\n    //\n    protected override int GetKeyForItem(OrderItem item)\n    {\n        // In this example, the key is the part number.\n        return item.PartNumber;\n    }\n}\n\npublic class Demo\n{    \n    public static void Main()\n    {\n        SimpleOrder weekly = new SimpleOrder();\n\n        // The Add method, inherited from Collection, takes OrderItem.\n        //\n        weekly.Add(new OrderItem(110072674, &quot;Widget&quot;, 400, 45.17));\n        weekly.Add(new OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3));\n        weekly.Add(new OrderItem(101030411, &quot;Motor&quot;, 10, 237.5));\n        weekly.Add(new OrderItem(110072684, &quot;Gear&quot;, 175, 5.17));\n        \n        Display(weekly);\n    \n        // The Contains method of KeyedCollection takes the key, \n        // type, in this case int.\n        //\n        Console.WriteLine(&quot;<br>Contains(101030411): {0}&quot;, \n            weekly.Contains(101030411));\n\n        // The default Item property of KeyedCollection takes a key.\n        //\n        Console.WriteLine(&quot;<br>weekly[101030411].Description: {0}&quot;, \n            weekly[101030411].Description);\n\n        // The Remove method of KeyedCollection takes a key.\n        //\n        Console.WriteLine(&quot;<br>Remove(101030411)&quot;);\n        weekly.Remove(101030411);\n        Display(weekly);\n\n        // The Insert method, inherited from Collection, takes an \n        // index and an OrderItem.\n        //\n        Console.WriteLine(&quot;<br>Insert(2, New OrderItem(...))&quot;);\n        weekly.Insert(2, new OrderItem(111033401, &quot;Nut&quot;, 10, .5));\n        Display(weekly);\n\n        // The default Item property is overloaded. One overload comes\n        // from KeyedCollection&lt;int, OrderItem&gt;; that overload\n        // is read-only, and takes Integer because it retrieves by key. \n        // The other overload comes from Collection&lt;OrderItem&gt;, the \n        // base class of KeyedCollection&lt;int, OrderItem&gt;; it \n        // retrieves by index, so it also takes an Integer. The compiler\n        // uses the most-derived overload, from KeyedCollection, so the\n        // only way to access SimpleOrder by index is to cast it to\n        // Collection&lt;OrderItem&gt;. Otherwise the index is interpreted\n        // as a key, and KeyNotFoundException is thrown.\n        //\n        Collection&lt;OrderItem&gt; coweekly = weekly;\n        Console.WriteLine(&quot;<br>coweekly[2].Description: {0}&quot;, \n            coweekly[2].Description);\n \n        Console.WriteLine(&quot;<br>coweekly[2] = new OrderItem(...)&quot;);\n        coweekly[2] = new OrderItem(127700026, &quot;Crank&quot;, 27, 5.98);\n\n        OrderItem temp = coweekly[2];\n\n        // The IndexOf method inherited from Collection&lt;OrderItem&gt; \n        // takes an OrderItem instead of a key\n        // \n        Console.WriteLine(&quot;<br>IndexOf(temp): {0}&quot;, weekly.IndexOf(temp));\n\n        // The inherited Remove method also takes an OrderItem.\n        //\n        Console.WriteLine(&quot;<br>Remove(temp)&quot;);\n        weekly.Remove(temp);\n        Display(weekly);\n\n        Console.WriteLine(&quot;<br>RemoveAt(0)&quot;);\n        weekly.RemoveAt(0);\n        Display(weekly);\n\n    }\n    \n    private static void Display(SimpleOrder order)\n    {\n        Console.WriteLine();\n        foreach( OrderItem item in order )\n        {\n            Console.WriteLine(item);\n        }\n    }\n}\n\n// This class represents a simple line item in an order. All the \n// values are immutable except quantity.\n// \npublic class OrderItem\n{\n    public readonly int PartNumber;\n    public readonly string Description;\n    public readonly double UnitPrice;\n    \n    private int _quantity = 0;\n    \n    public OrderItem(int partNumber, string description, \n        int quantity, double unitPrice)\n    {\n        this.PartNumber = partNumber;\n        this.Description = description;\n        this.Quantity = quantity;\n        this.UnitPrice = unitPrice;\n    } \n    \n    public int Quantity    \n    {\n        get { return _quantity; }\n        set\n        {\n            if (value&lt;0)\n                throw new ArgumentException(&quot;Quantity cannot be negative.&quot;);\n            \n            _quantity = value;\n        }\n    }\n        \n    public override string ToString()\n    {\n        return String.Format(\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, \n            PartNumber, _quantity, Description, UnitPrice, \n            UnitPrice * _quantity);\n    }\n}\n\n/* This code example produces the following output:\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n101030411     10 Motor        at   237.50 =   2,375.00\n110072684    175 Gear         at     5.17 =     904.75\n\nContains(101030411): True\n\nweekly[101030411].Description: Motor\n\nRemove(101030411)\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n\nInsert(2, New OrderItem(...))\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n111033401     10 Nut          at      .50 =       5.00\n110072684    175 Gear         at     5.17 =     904.75\n\ncoweekly[2].Description: Nut\n\ncoweekly[2] = new OrderItem(...)\n\nIndexOf(temp): 2\n\nRemove(temp)\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n\nRemoveAt(0)\n\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"KeyedCollection#1\">Imports System\nImports System.Collections.Generic\nImports System.Collections.ObjectModel\n\n&#39; This class represents a very simple keyed list of OrderItems,\n&#39; inheriting most of its behavior from the KeyedCollection and \n&#39; Collection classes. The immediate base class is the constructed\n&#39; type KeyedCollection(Of Integer, OrderItem). When you inherit\n&#39; from KeyedCollection, the second generic type argument is the \n&#39; type that you want to store in the collection -- in this case\n&#39; OrderItem. The first generic argument is the type that you want\n&#39; to use as a key. Its values must be calculated from OrderItem; \n&#39; in this case it is the Integer field PartNumber, so SimpleOrder\n&#39; inherits KeyedCollection(Of Integer, OrderItem).\n&#39;\nPublic Class SimpleOrder\n    Inherits KeyedCollection(Of Integer, OrderItem)\n\n\n    &#39; This is the only method that absolutely must be overridden,\n    &#39; because without it the KeyedCollection cannot extract the\n    &#39; keys from the items. The input parameter type is the \n    &#39; second generic type argument, in this case OrderItem, and \n    &#39; the return value type is the first generic type argument,\n    &#39; in this case Integer.\n    &#39;\n    Protected Overrides Function GetKeyForItem( _\n        ByVal item As OrderItem) As Integer\n\n        &#39; In this example, the key is the part number.\n        Return item.PartNumber   \n    End Function\n\nEnd Class\n\nPublic Class Demo\n    \n    Public Shared Sub Main() \n        Dim weekly As New SimpleOrder()\n\n        &#39; The Add method, inherited from Collection, takes OrderItem.\n        &#39;\n        weekly.Add(New OrderItem(110072674, &quot;Widget&quot;, 400, 45.17))\n        weekly.Add(New OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3))\n        weekly.Add(New OrderItem(101030411, &quot;Motor&quot;, 10, 237.5))\n        weekly.Add(New OrderItem(110072684, &quot;Gear&quot;, 175, 5.17))\n        \n        Display(weekly)\n    \n        &#39; The Contains method of KeyedCollection takes TKey.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Contains(101030411): {0}&quot;, _\n            weekly.Contains(101030411))\n\n        &#39; The default Item property of KeyedCollection takes the key\n        &#39; type, Integer.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;weekly(101030411).Description: {0}&quot;, _\n            weekly(101030411).Description)\n\n        &#39; The Remove method of KeyedCollection takes a key.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Remove(101030411)&quot;)\n        weekly.Remove(101030411)\n        Display(weekly)\n\n        &#39; The Insert method, inherited from Collection, takes an \n        &#39; index and an OrderItem.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Insert(2, New OrderItem(...))&quot;)\n        weekly.Insert(2, New OrderItem(111033401, &quot;Nut&quot;, 10, .5))\n        Display(weekly)\n\n        &#39; The default Item property is overloaded. One overload comes\n        &#39; from KeyedCollection(Of Integer, OrderItem); that overload\n        &#39; is read-only, and takes Integer because it retrieves by key. \n        &#39; The other overload comes from Collection(Of OrderItem), the \n        &#39; base class of KeyedCollection(Of Integer, OrderItem); it \n        &#39; retrieves by index, so it also takes an Integer. The compiler\n        &#39; uses the most-derived overload, from KeyedCollection, so the\n        &#39; only way to access SimpleOrder by index is to cast it to\n        &#39; Collection(Of OrderItem). Otherwise the index is interpreted\n        &#39; as a key, and KeyNotFoundException is thrown.\n        &#39;\n        Dim coweekly As Collection(Of OrderItem) = weekly\n        Console.WriteLine(vbLf &amp; &quot;coweekly(2).Description: {0}&quot;, _\n            coweekly(2).Description)\n \n        Console.WriteLine(vbLf &amp; &quot;coweekly(2) = New OrderItem(...)&quot;)\n        coweekly(2) = New OrderItem(127700026, &quot;Crank&quot;, 27, 5.98)\n\n        Dim temp As OrderItem = coweekly(2)\n\n        &#39; The IndexOf method, inherited from Collection(Of OrderItem), \n        &#39; takes an OrderItem instead of a key.\n        &#39; \n        Console.WriteLine(vbLf &amp; &quot;IndexOf(temp): {0}&quot;, _\n            weekly.IndexOf(temp))\n\n        &#39; The inherited Remove method also takes an OrderItem.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Remove(temp)&quot;)\n        weekly.Remove(temp)\n        Display(weekly)\n\n        Console.WriteLine(vbLf &amp; &quot;RemoveAt(0)&quot;)\n        weekly.RemoveAt(0)\n        Display(weekly)\n\n    End Sub\n    \n    Private Shared Sub Display(ByVal order As SimpleOrder) \n        Console.WriteLine()\n        For Each item As OrderItem In  order\n            Console.WriteLine(item)\n        Next item\n    End Sub\nEnd Class\n\n&#39; This class represents a simple line item in an order. All the \n&#39; values are immutable except quantity.\n&#39; \nPublic Class OrderItem\n    Public ReadOnly PartNumber As Integer\n    Public ReadOnly Description As String\n    Public ReadOnly UnitPrice As Double\n    \n    Private _quantity As Integer = 0\n    \n    Public Sub New(ByVal partNumber As Integer, _\n                   ByVal description As String, _\n                   ByVal quantity As Integer, _\n                   ByVal unitPrice As Double) \n        Me.PartNumber = partNumber\n        Me.Description = description\n        Me.Quantity = quantity\n        Me.UnitPrice = unitPrice\n    End Sub &#39;New\n    \n    Public Property Quantity() As Integer \n        Get\n            Return _quantity\n        End Get\n        Set\n            If value &lt; 0 Then\n                Throw New ArgumentException(&quot;Quantity cannot be negative.&quot;)\n            End If\n            _quantity = value\n        End Set\n    End Property\n        \n    Public Overrides Function ToString() As String \n        Return String.Format( _\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, _\n            PartNumber, _quantity, Description, UnitPrice, _\n            UnitPrice * _quantity)\n    End Function\nEnd Class\n\n&#39; This code example produces the following output:\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;101030411     10 Motor        at   237.50 =   2,375.00\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;Contains(101030411): True\n&#39;\n&#39;weekly(101030411).Description: Motor\n&#39;\n&#39;Remove(101030411)\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;Insert(2, New OrderItem(...))\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;111033401     10 Nut          at      .50 =       5.00\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;coweekly(2).Description: Nut\n&#39;\n&#39;coweekly(2) = New OrderItem(...)\n&#39;\n&#39;IndexOf(temp): 2\n&#39;\n&#39;Remove(temp)\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;RemoveAt(0)\n&#39;\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;110072684    175 Gear         at     5.17 =     904.75\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Collections_ObjectModel_KeyedCollection_2__ctor_System_Collections_Generic_IEqualityComparer__0__\">\r\n    \r\n            <a id=\"System_Collections_ObjectModel_KeyedCollection_2__ctor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">KeyedCollection&lt;TKey,TItem&gt;(IEqualityComparer&lt;TKey&gt;)</div>        \r\n          </div>\r\n    \r\n            <p>Initializes a new instance of the <span class=\"xref\">stem.Collections.ObjectModel.KeyedCollection`2</span> class that uses the specified equality comparer.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>comparer</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.generic.iequalitycomparer-1\" data-linktype=\"relative-path\">IEqualityComparer</a>&lt;<span class=\"xref\">TKey</span>&gt;</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The implementation of the <span class=\"xref\">stem.Collections.Generic.IEqualityComparer`1</span> generic interface to use when comparing keys, or <code>null</code> to use the default equality comparer for the type of the key, obtained from <span class=\"xref\">stem.Collections.Generic.EqualityComparer`1.Default*</span>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>By default, the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> includes a lookup dictionary that is created when the first item is added. When an item is added to the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a>, the item&#39;s key is extracted once and saved in the lookup dictionary for faster searches. This behavior can be overridden by using the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2__ctor_System_Collections_Generic_IEqualityComparer__0__System_Int32_\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;(IEqualityComparer&lt;TKey&gt;,Int32)</a> constructor and specifying a dictionary creation threshold.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Because the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> class is abstract (<code>MustInherit</code> in Visual Basic), you must derive from it in order to use it. In the constructor for your derived type, call the appropriate <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> constructor. It is not necessary to expose functionality like the equality comparer or the dictionary creation threshold in your constructors.  </p>\n</div>\n<p> This constructor is an O(1) operation.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Collections_ObjectModel_KeyedCollection_2__ctor_System_Collections_Generic_IEqualityComparer__0__System_Int32_\">\r\n    \r\n            <a id=\"System_Collections_ObjectModel_KeyedCollection_2__ctor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">KeyedCollection&lt;TKey,TItem&gt;(IEqualityComparer&lt;TKey&gt;,Int32)</div>        \r\n          </div>\r\n    \r\n            <p>Initializes a new instance of the <span class=\"xref\">stem.Collections.ObjectModel.KeyedCollection`2</span> class that uses the specified equality comparer and creates a lookup dictionary when the specified threshold is exceeded.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected KeyedCollection (System.Collections.Generic.IEqualityComparer&lt;TKey&gt; comparer, int dictionaryCreationThreshold);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>comparer</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.generic.iequalitycomparer-1\" data-linktype=\"relative-path\">IEqualityComparer</a>&lt;<span class=\"xref\">TKey</span>&gt;</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The implementation of the <span class=\"xref\">stem.Collections.Generic.IEqualityComparer`1</span> generic interface to use when comparing keys, or <code>null</code> to use the default equality comparer for the type of the key, obtained from <span class=\"xref\">stem.Collections.Generic.EqualityComparer`1.Default*</span>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>dictionaryCreationThreshold</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The number of elements the collection can hold without creating a lookup dictionary (0 creates the lookup dictionary when the first item is added), or â€“1 to specify that a lookup dictionary is never created.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p><code>dictionaryCreationThreshold</code> is less than â€“1.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>By default, the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> includes a lookup dictionary that is created when the first item is added. When an item is added to the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a>, the item&#39;s key is extracted once and saved in the lookup dictionary for faster searches. This constructor allows you to override that behavior. Specify 0 to create the dictionary when the first element is added, 1 to create the dictionary when the second element is added, and so on. If you specify â€“1 as the threshold, the lookup dictionary is never created.  </p>\n<p> For very small collections the improvement in retrieval speed provided by the lookup dictionary might not be worth the extra memory required by the dictionary. Setting a threshold allows you to decide when to make that tradeoff.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Because the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> class is abstract (<code>MustInherit</code> in Visual Basic), you must derive from it in order to use it. In the constructor for your derived type, call the appropriate <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> constructor. It is not necessary to expose functionality like the equality comparer or the dictionary creation threshold in your constructors.  </p>\n</div>\n<p> This constructor is an O(1) operation.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example shows how to override the protected <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_InsertItem_\" data-linktype=\"relative-path\">InsertItem</a>, <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_RemoveItem_\" data-linktype=\"relative-path\">RemoveItem</a>, <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_ClearItems_\" data-linktype=\"relative-path\">ClearItems</a>, and <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_SetItem_\" data-linktype=\"relative-path\">SetItem</a> methods, to provide custom behavior for the <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Add_\" data-linktype=\"relative-path\">Add</a>, <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_Remove_\" data-linktype=\"relative-path\">Remove</a>, and <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Clear_\" data-linktype=\"relative-path\">Clear</a> methods, and for setting the default <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Item_\" data-linktype=\"relative-path\">Item</a> property (the indexer in C#). The custom behavior provided in this example is a notification event named <code>Changed</code>, which is raised at the end of each of the overridden methods.  </p>\n<p> The code example uses the KeyedCollection(TKey, constructor with a threshold of 0, so that the internal dictionary is created the first time an object is added to the collection.  </p>\n<p> The code example creates the <code>SimpleOrder</code> class, which derives from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> and represents a simple order form. The order form contains <code>OrderItem</code> objects representing items ordered. The code example also creates a <code>SimpleOrderChangedEventArgs</code> class to contain the event information, and an enumeration to identify the type of change.  </p>\n<p> The code example demonstrates the custom behavior by calling the properties and methods of the derived class, in the <code>Main</code> method of the <code>Demo</code> class.  </p>\n<p> This code example uses objects with immutable keys. For a code example that uses mutable keys, see <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_ChangeItemKey_\" data-linktype=\"relative-path\">ChangeItemKey</a>.  </p>\n<pre><code class=\"lang-vb\" name=\"KeyedCollection2#1\">Imports System\nImports System.Collections.Generic\nImports System.Collections.ObjectModel\n\n&#39; This class derives from KeyedCollection and shows how to override\n&#39; the protected ClearItems, InsertItem, RemoveItem, and SetItem \n&#39; methods in order to change the behavior of the default Item \n&#39; property and the Add, Clear, Insert, and Remove methods. The\n&#39; class implements a Changed event, which is raised by all the\n&#39; protected methods.\n&#39;\n&#39; SimpleOrder is a collection of OrderItem objects, and its key\n&#39; is the PartNumber field of OrderItem. PartNumber is an Integer,\n&#39; so SimpleOrder inherits KeyedCollection(Of Integer, OrderItem).\n&#39; (Note that the key of OrderItem cannot be changed; if it could \n&#39; be changed, SimpleOrder would have to override ChangeItemKey.)\n&#39;\nPublic Class SimpleOrder\n    Inherits KeyedCollection(Of Integer, OrderItem)\n\n    Public Event Changed As EventHandler(Of SimpleOrderChangedEventArgs)\n\n    &#39; This parameterless constructor calls the base class constructor\n    &#39; that specifies a dictionary threshold of 0, so that the internal\n    &#39; dictionary is created as soon as an item is added to the \n    &#39; collection.\n    &#39;\n    Public Sub New()\n        MyBase.New(Nothing, 0)\n    End Sub\n    \n    &#39; This is the only method that absolutely must be overridden,\n    &#39; because without it the KeyedCollection cannot extract the\n    &#39; keys from the items. \n    &#39;\n    Protected Overrides Function GetKeyForItem( _\n        ByVal item As OrderItem) As Integer\n\n        &#39; In this example, the key is the part number.\n        Return item.PartNumber   \n    End Function\n\n    Protected Overrides Sub InsertItem( _\n        ByVal index As Integer, ByVal newItem As OrderItem)\n\n        MyBase.InsertItem(index, newItem)\n\n        RaiseEvent Changed(Me, New SimpleOrderChangedEventArgs( _\n            ChangeType.Added, newItem, Nothing))\n    End Sub\n\n    Protected Overrides Sub SetItem(ByVal index As Integer, _\n        ByVal newItem As OrderItem)\n\n        Dim replaced As OrderItem = Items(index)\n        MyBase.SetItem(index, newItem)\n\n        RaiseEvent Changed(Me, New SimpleOrderChangedEventArgs( _\n            ChangeType.Replaced, replaced, newItem))\n    End Sub\n\n    Protected Overrides Sub RemoveItem(ByVal index As Integer)\n\n        Dim removedItem As OrderItem = Items(index)\n        MyBase.RemoveItem(index)\n\n        RaiseEvent Changed(Me, New SimpleOrderChangedEventArgs( _\n            ChangeType.Removed, removedItem, Nothing))\n    End Sub\n\n    Protected Overrides Sub ClearItems()\n        MyBase.ClearItems()\n\n        RaiseEvent Changed(Me, New SimpleOrderChangedEventArgs( _\n            ChangeType.Cleared, Nothing, Nothing))\n    End Sub\n\nEnd Class\n\n&#39; Event argument for the Changed event.\n&#39;\nPublic Class SimpleOrderChangedEventArgs\n    Inherits EventArgs\n\n    Private _changedItem As OrderItem\n    Private _changeType As ChangeType\n    Private _replacedWith As OrderItem\n\n    Public ReadOnly Property ChangedItem As OrderItem\n        Get\n            Return _changedItem\n        End Get\n    End Property\n\n    Public ReadOnly Property ChangeType As ChangeType\n        Get\n            Return _changeType\n        End Get\n    End Property\n\n    Public ReadOnly Property ReplacedWith As OrderItem\n        Get\n            Return _replacedWith\n        End Get\n    End Property\n\n    Public Sub New(ByVal change As ChangeType, ByVal item As OrderItem, _\n        ByVal replacement As OrderItem)\n\n        _changeType = change\n        _changedItem = item\n        _replacedWith = replacement\n    End Sub\nEnd Class\n\nPublic Enum ChangeType\n    Added\n    Removed\n    Replaced\n    Cleared\nEnd Enum\n\nPublic Class Demo\n    \n    Public Shared Sub Main() \n        Dim weekly As New SimpleOrder()\n        AddHandler weekly.Changed, AddressOf ChangedHandler\n\n        &#39; The Add method, inherited from Collection, takes OrderItem.\n        &#39;\n        weekly.Add(New OrderItem(110072674, &quot;Widget&quot;, 400, 45.17))\n        weekly.Add(New OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3))\n        weekly.Add(New OrderItem(101030411, &quot;Motor&quot;, 10, 237.5))\n        weekly.Add(New OrderItem(110072684, &quot;Gear&quot;, 175, 5.17))\n\n        Display(weekly)\n        \n        &#39; The Contains method of KeyedCollection takes TKey.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Contains(101030411): {0}&quot;, _\n            weekly.Contains(101030411))\n\n        &#39; The default Item property of KeyedCollection takes the key\n        &#39; type, Integer. The property is read-only.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;weekly(101030411).Description: {0}&quot;, _\n            weekly(101030411).Description)\n\n        &#39; The Remove method of KeyedCollection takes a key.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Remove(101030411)&quot;)\n        weekly.Remove(101030411)\n\n        &#39; The Insert method, inherited from Collection, takes an \n        &#39; index and an OrderItem.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Insert(2, New OrderItem(...))&quot;)\n        weekly.Insert(2, New OrderItem(111033401, &quot;Nut&quot;, 10, .5))\n         \n        &#39; The default Item property is overloaded. One overload comes\n        &#39; from KeyedCollection(Of Integer, OrderItem); that overload\n        &#39; is read-only, and takes Integer because it retrieves by key. \n        &#39; The other overload comes from Collection(Of OrderItem), the \n        &#39; base class of KeyedCollection(Of Integer, OrderItem); it \n        &#39; retrieves by index, so it also takes an Integer. The compiler\n        &#39; uses the most-derived overload, from KeyedCollection, so the\n        &#39; only way to access SimpleOrder by index is to cast it to\n        &#39; Collection(Of OrderItem). Otherwise the index is interpreted\n        &#39; as a key, and KeyNotFoundException is thrown.\n        &#39;\n        Dim coweekly As Collection(Of OrderItem) = weekly\n        Console.WriteLine(vbLf &amp; &quot;coweekly(2).Description: {0}&quot;, _\n            coweekly(2).Description)\n \n        Console.WriteLine(vbLf &amp; &quot;coweekly(2) = New OrderItem(...)&quot;)\n        coweekly(2) = New OrderItem(127700026, &quot;Crank&quot;, 27, 5.98)\n\n        Dim temp As OrderItem = coweekly(2)\n\n        &#39; The IndexOf method, inherited from Collection(Of OrderItem), \n        &#39; takes an OrderItem instead of a key.\n        &#39; \n        Console.WriteLine(vbLf &amp; &quot;IndexOf(temp): {0}&quot;, _\n            weekly.IndexOf(temp))\n\n        &#39; The inherited Remove method also takes an OrderItem.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Remove(temp)&quot;)\n        weekly.Remove(temp)\n\n        Console.WriteLine(vbLf &amp; &quot;RemoveAt(0)&quot;)\n        weekly.RemoveAt(0)\n\n        &#39; Increase the quantity for a line item.\n        Console.WriteLine(vbLf &amp; &quot;coweekly(1) = New OrderItem(...)&quot;)\n        coweekly(1) = New OrderItem(coweekly(1).PartNumber, _\n            coweekly(1).Description, coweekly(1).Quantity + 1000, _\n            coweekly(1).UnitPrice)\n\n        Display(weekly)\n\n        Console.WriteLine()\n        weekly.Clear()\n    End Sub\n    \n    Private Shared Sub Display(ByVal order As SimpleOrder) \n        Console.WriteLine()\n        For Each item As OrderItem In  order\n            Console.WriteLine(item)\n        Next item\n    End Sub\n\n    Private Shared Sub ChangedHandler(ByVal source As Object, _\n        ByVal e As SimpleOrderChangedEventArgs)\n\n        Dim item As OrderItem = e.ChangedItem\n\n        If e.ChangeType = ChangeType.Replaced Then\n            Dim replacement As OrderItem = e.ReplacedWith\n\n            Console.WriteLine(&quot;{0} (quantity {1}) was replaced &quot; &amp; _\n                &quot;by {2}, (quantity {3}).&quot;, item.Description, _\n                item.Quantity, replacement.Description, replacement.Quantity)\n\n        ElseIf e.ChangeType = ChangeType.Cleared Then\n            Console.WriteLine(&quot;The order list was cleared.&quot;)\n\n        Else\n            Console.WriteLine(&quot;{0} (quantity {1}) was {2}.&quot;, _\n                item.Description, item.Quantity, e.ChangeType)\n        End If\n    End Sub\nEnd Class\n\n&#39; This class represents a simple line item in an order. All the \n&#39; values are immutable except quantity.\n&#39; \nPublic Class OrderItem\n    \n    Private _partNumber As Integer\n    Private _description As String\n    Private _unitPrice As Double\n    Private _quantity As Integer\n\n    Public ReadOnly Property PartNumber As Integer\n        Get\n            Return _partNumber\n        End Get\n    End Property\n\n    Public ReadOnly Property Description As String\n        Get\n            Return _description\n        End Get\n    End Property\n\n    Public ReadOnly Property UnitPrice As Double\n        Get\n            Return _unitPrice\n        End Get\n    End Property\n    \n    Public ReadOnly Property Quantity() As Integer \n        Get\n            Return _quantity\n        End Get\n    End Property\n    \n    Public Sub New(ByVal partNumber As Integer, _\n                   ByVal description As String, _\n                   ByVal quantity As Integer, _\n                   ByVal unitPrice As Double) \n        _partNumber = partNumber\n        _description = description\n        _quantity = quantity\n        _unitPrice = unitPrice\n    End Sub &#39;New\n        \n    Public Overrides Function ToString() As String \n        Return String.Format( _\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, _\n            PartNumber, _quantity, Description, UnitPrice, _\n            UnitPrice * _quantity)\n    End Function\nEnd Class\n\n&#39; This code example produces the following output:\n&#39;\n&#39;Widget (quantity 400) was Added.\n&#39;Sprocket (quantity 27) was Added.\n&#39;Motor (quantity 10) was Added.\n&#39;Gear (quantity 175) was Added.\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;101030411     10 Motor        at   237.50 =   2,375.00\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;Contains(101030411): True\n&#39;\n&#39;weekly(101030411).Description: Motor\n&#39;\n&#39;Remove(101030411)\n&#39;Motor (quantity 10) was Removed.\n&#39;\n&#39;Insert(2, New OrderItem(...))\n&#39;Nut (quantity 10) was Added.\n&#39;\n&#39;coweekly(2).Description: Nut\n&#39;\n&#39;coweekly(2) = New OrderItem(...)\n&#39;Nut (quantity 10) was replaced by Crank, (quantity 27).\n&#39;\n&#39;IndexOf(temp): 2\n&#39;\n&#39;Remove(temp)\n&#39;Crank (quantity 27) was Removed.\n&#39;\n&#39;RemoveAt(0)\n&#39;Widget (quantity 400) was Removed.\n&#39;\n&#39;coweekly(1) = New OrderItem(...)\n&#39;Gear (quantity 175) was replaced by Gear, (quantity 1175).\n&#39;\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;110072684   1175 Gear         at     5.17 =   6,074.75\n&#39;\n&#39;The order list was cleared.\n</code></pre><pre><code class=\"lang-cs\" name=\"KeyedCollection2#1\">using System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\n\n// This class derives from KeyedCollection and shows how to override\n// the protected ClearItems, InsertItem, RemoveItem, and SetItem \n// methods in order to change the behavior of the default Item \n// property and the Add, Clear, Insert, and Remove methods. The\n// class implements a Changed event, which is raised by all the\n// protected methods.\n//\n// SimpleOrder is a collection of OrderItem objects, and its key\n// is the PartNumber field of OrderItem. PartNumber is an Integer,\n// so SimpleOrder inherits KeyedCollection&lt;int, OrderItem&gt;.\n// (Note that the key of OrderItem cannot be changed; if it could \n// be changed, SimpleOrder would have to override ChangeItemKey.)\n//\npublic class SimpleOrder : KeyedCollection&lt;int, OrderItem&gt;\n{\n    public event EventHandler&lt;SimpleOrderChangedEventArgs&gt; Changed;\n\n    // This parameterless constructor calls the base class constructor\n    // that specifies a dictionary threshold of 0, so that the internal\n    // dictionary is created as soon as an item is added to the \n    // collection.\n    //\n    public SimpleOrder() : base(null, 0) {}\n    \n    // This is the only method that absolutely must be overridden,\n    // because without it the KeyedCollection cannot extract the\n    // keys from the items. \n    //\n    protected override int GetKeyForItem(OrderItem item)\n    {\n        // In this example, the key is the part number.\n        return item.PartNumber;\n    }\n\n    protected override void InsertItem(int index, OrderItem newItem)\n    {\n        base.InsertItem(index, newItem);\n\n        EventHandler&lt;SimpleOrderChangedEventArgs&gt; temp = Changed;\n        if (temp != null)\n        {\n            temp(this, new SimpleOrderChangedEventArgs(\n                ChangeType.Added, newItem, null));\n        }\n    }\n\n    protected override void SetItem(int index, OrderItem newItem)\n    {\n        OrderItem replaced = Items[index];\n        base.SetItem(index, newItem);\n\n        EventHandler&lt;SimpleOrderChangedEventArgs&gt; temp = Changed;\n        if (temp != null)\n        {\n            temp(this, new SimpleOrderChangedEventArgs(\n                ChangeType.Replaced, replaced, newItem));\n        }\n    }\n\n    protected override void RemoveItem(int index)\n    {\n        OrderItem removedItem = Items[index];\n        base.RemoveItem(index);\n\n        EventHandler&lt;SimpleOrderChangedEventArgs&gt; temp = Changed;\n        if (temp != null)\n        {\n            temp(this, new SimpleOrderChangedEventArgs(\n                ChangeType.Removed, removedItem, null));\n        }\n    }\n\n    protected override void ClearItems()\n    {\n        base.ClearItems();\n\n        EventHandler&lt;SimpleOrderChangedEventArgs&gt; temp = Changed;\n        if (temp != null)\n        {\n            temp(this, new SimpleOrderChangedEventArgs(\n                ChangeType.Cleared, null, null));\n        }\n    }\n}\n\n// Event argument for the Changed event.\n//\npublic class SimpleOrderChangedEventArgs : EventArgs\n{\n    private OrderItem _changedItem;\n    private ChangeType _changeType;\n    private OrderItem _replacedWith;\n\n    public OrderItem ChangedItem { get { return _changedItem; }}\n    public ChangeType ChangeType { get { return _changeType; }}\n    public OrderItem ReplacedWith { get { return _replacedWith; }}\n\n    public SimpleOrderChangedEventArgs(ChangeType change, \n        OrderItem item, OrderItem replacement)\n    {\n        _changeType = change;\n        _changedItem = item;\n        _replacedWith = replacement;\n    }\n}\n\npublic enum ChangeType\n{\n    Added, \n    Removed, \n    Replaced, \n    Cleared\n};\n\npublic class Demo\n{    \n    public static void Main()\n    {\n        SimpleOrder weekly = new SimpleOrder();\n        weekly.Changed += new \n            EventHandler&lt;SimpleOrderChangedEventArgs&gt;(ChangedHandler);\n\n        // The Add method, inherited from Collection, takes OrderItem.\n        //\n        weekly.Add(new OrderItem(110072674, &quot;Widget&quot;, 400, 45.17));\n        weekly.Add(new OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3));\n        weekly.Add(new OrderItem(101030411, &quot;Motor&quot;, 10, 237.5));\n        weekly.Add(new OrderItem(110072684, &quot;Gear&quot;, 175, 5.17));\n\n        Display(weekly);\n        \n        // The Contains method of KeyedCollection takes TKey.\n        //\n        Console.WriteLine(&quot;<br>Contains(101030411): {0}&quot;, \n            weekly.Contains(101030411));\n\n        // The default Item property of KeyedCollection takes the key\n        // type, Integer. The property is read-only.\n        //\n        Console.WriteLine(&quot;<br>weekly[101030411].Description: {0}&quot;, \n            weekly[101030411].Description);\n\n        // The Remove method of KeyedCollection takes a key.\n        //\n        Console.WriteLine(&quot;<br>Remove(101030411)&quot;);\n        weekly.Remove(101030411);\n\n        // The Insert method, inherited from Collection, takes an \n        // index and an OrderItem.\n        //\n        Console.WriteLine(&quot;<br>Insert(2, new OrderItem(...))&quot;);\n        weekly.Insert(2, new OrderItem(111033401, &quot;Nut&quot;, 10, .5));\n         \n        // The default Item property is overloaded. One overload comes\n        // from KeyedCollection&lt;int, OrderItem&gt;; that overload\n        // is read-only, and takes Integer because it retrieves by key. \n        // The other overload comes from Collection&lt;OrderItem&gt;, the \n        // base class of KeyedCollection&lt;int, OrderItem&gt;; it \n        // retrieves by index, so it also takes an Integer. The compiler\n        // uses the most-derived overload, from KeyedCollection, so the\n        // only way to access SimpleOrder by index is to cast it to\n        // Collection&lt;OrderItem&gt;. Otherwise the index is interpreted\n        // as a key, and KeyNotFoundException is thrown.\n        //\n        Collection&lt;OrderItem&gt; coweekly = weekly;\n        Console.WriteLine(&quot;<br>coweekly[2].Description: {0}&quot;, \n            coweekly[2].Description);\n \n        Console.WriteLine(&quot;<br>coweekly[2] = new OrderItem(...)&quot;);\n        coweekly[2] = new OrderItem(127700026, &quot;Crank&quot;, 27, 5.98);\n\n        OrderItem temp = coweekly[2];\n\n        // The IndexOf method, inherited from Collection&lt;OrderItem&gt;, \n        // takes an OrderItem instead of a key.\n        // \n        Console.WriteLine(&quot;<br>IndexOf(temp): {0}&quot;, weekly.IndexOf(temp));\n\n        // The inherited Remove method also takes an OrderItem.\n        //\n        Console.WriteLine(&quot;<br>Remove(temp)&quot;);\n        weekly.Remove(temp);\n\n        Console.WriteLine(&quot;<br>RemoveAt(0)&quot;);\n        weekly.RemoveAt(0);\n\n        // Increase the quantity for a line item.\n        Console.WriteLine(&quot;<br>coweekly(1) = New OrderItem(...)&quot;);\n        coweekly[1] = new OrderItem(coweekly[1].PartNumber, \n            coweekly[1].Description, coweekly[1].Quantity + 1000, \n            coweekly[1].UnitPrice);\n\n        Display(weekly);\n\n        Console.WriteLine();\n        weekly.Clear();\n    }\n    \n    private static void Display(SimpleOrder order)\n    {\n        Console.WriteLine();\n        foreach( OrderItem item in order )\n        {\n            Console.WriteLine(item);\n        }\n    }\n\n    private static void ChangedHandler(object source, \n        SimpleOrderChangedEventArgs e)\n    {\n\n        OrderItem item = e.ChangedItem;\n\n        if (e.ChangeType==ChangeType.Replaced)\n        {\n            OrderItem replacement = e.ReplacedWith;\n\n            Console.WriteLine(&quot;{0} (quantity {1}) was replaced &quot; +\n                &quot;by {2}, (quantity {3}).&quot;, item.Description, \n                item.Quantity, replacement.Description, \n                replacement.Quantity);\n        }\n        else if(e.ChangeType == ChangeType.Cleared)\n        {\n            Console.WriteLine(&quot;The order list was cleared.&quot;);\n        }\n        else\n        {\n            Console.WriteLine(&quot;{0} (quantity {1}) was {2}.&quot;, \n                item.Description, item.Quantity, e.ChangeType);\n        }\n    }\n}\n\n// This class represents a simple line item in an order. All the \n// values are immutable except quantity.\n// \npublic class OrderItem\n{\n    private int _partNumber;\n    private string _description;\n    private double _unitPrice;\n    private int _quantity;\n    \n    public int PartNumber { get { return _partNumber; }}\n    public string Description { get { return _description; }}\n    public double UnitPrice { get { return _unitPrice; }}\n    public int Quantity { get { return _quantity; }}\n    \n    public OrderItem(int partNumber, string description, int quantity, \n        double unitPrice)\n    {\n        _partNumber = partNumber;\n        _description = description;\n        _quantity = quantity;\n        _unitPrice = unitPrice;\n    }\n    \n    public override string ToString()\n    {\n        return String.Format(\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, \n            PartNumber, _quantity, Description, UnitPrice, \n            UnitPrice * _quantity);\n    }\n}\n\n/* This code example produces the following output:\n\nWidget (quantity 400) was Added.\nSprocket (quantity 27) was Added.\nMotor (quantity 10) was Added.\nGear (quantity 175) was Added.\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n101030411     10 Motor        at   237.50 =   2,375.00\n110072684    175 Gear         at     5.17 =     904.75\n\nContains(101030411): True\n\nweekly[101030411].Description: Motor\n\nRemove(101030411)\nMotor (quantity 10) was Removed.\n\nInsert(2, new OrderItem(...))\nNut (quantity 10) was Added.\n\ncoweekly[2].Description: Nut\n\ncoweekly[2] = new OrderItem(...)\nNut (quantity 10) was replaced by Crank, (quantity 27).\n\nIndexOf(temp): 2\n\nRemove(temp)\nCrank (quantity 27) was Removed.\n\nRemoveAt(0)\nWidget (quantity 400) was Removed.\n\ncoweekly(1) = New OrderItem(...)\nGear (quantity 175) was replaced by Gear, (quantity 1175).\n\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684   1175 Gear         at     5.17 =   6,074.75\n\nThe order list was cleared.\n */\n</code></pre><pre><code class=\"lang-cpp\" name=\"KeyedCollection2#1\">using namespace System;\nusing namespace System::Collections::Generic;\nusing namespace System::Collections::ObjectModel;\n\npublic enum class ChangeTypes\n{\n    Added,\n    Removed, \n    Replaced, \n    Cleared\n};\n\nref class SimpleOrderChangedEventArgs; \n\n// This class represents a simple line item in an order. All the \n// values are immutable except quantity.\n// \npublic ref class OrderItem\n{\nprivate:\n    int _quantity;\n\npublic:\n    initonly int PartNumber;\n    initonly String^ Description;\n    initonly double UnitPrice;\n        \n    OrderItem(int partNumber, String^ description, int quantity, \n        double unitPrice)\n    {\n        this-&gt;PartNumber = partNumber;\n        this-&gt;Description = description;\n        this-&gt;Quantity = quantity;\n        this-&gt;UnitPrice = unitPrice;\n    };\n    \n    property int Quantity    \n    {\n        int get() { return _quantity; };\n        void set(int value)\n        {\n            if (value &lt; 0)\n                throw gcnew ArgumentException(&quot;Quantity cannot be negative.&quot;);\n            \n            _quantity = value;\n        };\n    };\n        \n    virtual String^ ToString() override \n    {\n        return String::Format(\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, \n            PartNumber, _quantity, Description, UnitPrice, \n            UnitPrice * _quantity);\n    };\n};\n\n// Event argument for the Changed event.\n//\npublic ref class SimpleOrderChangedEventArgs : EventArgs\n{\npublic:\n    OrderItem^ ChangedItem;\n    initonly ChangeTypes ChangeType;\n    OrderItem^ ReplacedWith;\n\n    SimpleOrderChangedEventArgs(ChangeTypes change, \n        OrderItem^ item, OrderItem^ replacement)\n    {\n        this-&gt;ChangeType = change;\n        this-&gt;ChangedItem = item;\n        this-&gt;ReplacedWith = replacement;\n    }\n};\n\n// This class derives from KeyedCollection and shows how to override\n// the protected ClearItems, InsertItem, RemoveItem, and SetItem \n// methods in order to change the behavior of the default Item \n// property and the Add, Clear, Insert, and Remove methods. The\n// class implements a Changed event, which is raised by all the\n// protected methods.\n//\n// SimpleOrder is a collection of OrderItem objects, and its key\n// is the PartNumber field of OrderItem-&gt; PartNumber is an Integer,\n// so SimpleOrder inherits KeyedCollection&lt;int, OrderItem&gt;.\n// (Note that the key of OrderItem cannot be changed; if it could \n// be changed, SimpleOrder would have to override ChangeItemKey.)\n//\npublic ref class SimpleOrder : KeyedCollection&lt;int, OrderItem^&gt;\n{\npublic:\n    event EventHandler&lt;SimpleOrderChangedEventArgs^&gt;^ Changed;\n\n    // This parameterless constructor calls the base class constructor\n    // that specifies a dictionary threshold of 0, so that the internal\n    // dictionary is created as soon as an item is added to the \n    // collection.\n    //\n    SimpleOrder() : KeyedCollection&lt;int, OrderItem^&gt;(nullptr, 0) {};\n    \n    // This is the only method that absolutely must be overridden,\n    // because without it the KeyedCollection cannot extract the\n    // keys from the items. \n    //\nprotected:\n    virtual int GetKeyForItem(OrderItem^ item) override\n    {\n        // In this example, the key is the part number.\n        return item-&gt;PartNumber;\n    }\n\n    virtual void InsertItem(int index, OrderItem^ newItem) override \n    {\n        __super::InsertItem(index, newItem);\n\n        Changed(this, gcnew SimpleOrderChangedEventArgs(\n            ChangeTypes::Added, newItem, nullptr));\n    }\n\n    virtual void SetItem(int index, OrderItem^ newItem) override \n    {\n        OrderItem^ replaced = this-&gt;Items[index];\n        __super::SetItem(index, newItem);\n\n        Changed(this, gcnew SimpleOrderChangedEventArgs(\n            ChangeTypes::Replaced, replaced, newItem));\n    }\n\n    virtual void RemoveItem(int index) override \n    {\n        OrderItem^ removedItem = Items[index];\n        __super::RemoveItem(index);\n\n        Changed(this, gcnew SimpleOrderChangedEventArgs(\n            ChangeTypes::Removed, removedItem, nullptr));\n    }\n\n    virtual void ClearItems() override \n    {\n        __super::ClearItems();\n\n        Changed(this, gcnew SimpleOrderChangedEventArgs(\n            ChangeTypes::Cleared, nullptr, nullptr));\n    }\n\n    // This method uses the internal reference to the dictionary\n    // to test fo\npublic:\n    void AddOrMerge(OrderItem^ newItem)\n    {\n\n        int key = this-&gt;GetKeyForItem(newItem);\n        OrderItem^ existingItem = nullptr;\n\n        // The dictionary is not created until the first item is \n        // added, so it is necessary to test for null. Using \n        // AndAlso ensures that TryGetValue is not called if the\n        // dictionary does not exist.\n        //\n        if (this-&gt;Dictionary != nullptr &amp;&amp; \n            this-&gt;Dictionary-&gt;TryGetValue(key, existingItem))\n        {\n            existingItem-&gt;Quantity += newItem-&gt;Quantity;\n        }\n        else\n        {\n            this-&gt;Add(newItem);\n        }\n    }\n};\n\npublic ref class Demo\n{    \npublic:\n    static void Main()\n    {\n        SimpleOrder^ weekly = gcnew SimpleOrder();\n        weekly-&gt;Changed += gcnew \n            EventHandler&lt;SimpleOrderChangedEventArgs^&gt;(ChangedHandler);\n\n        // The Add method, inherited from Collection, takes OrderItem-&gt;\n        //\n        weekly-&gt;Add(gcnew OrderItem(110072674, &quot;Widget&quot;, 400, 45.17));\n        weekly-&gt;Add(gcnew OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3));\n        weekly-&gt;Add(gcnew OrderItem(101030411, &quot;Motor&quot;, 10, 237.5));\n        weekly-&gt;Add(gcnew OrderItem(110072684, &quot;Gear&quot;, 175, 5.17));\n\n        Display(weekly);\n        \n        // The Contains method of KeyedCollection takes TKey.\n        //\n        Console::WriteLine(&quot;<br>Contains(101030411): {0}&quot;, \n            weekly-&gt;Contains(101030411));\n\n        // The default Item property of KeyedCollection takes the key\n        // type, Integer. The property is read-only.\n        //\n        Console::WriteLine(&quot;<br>weekly[101030411]-&gt;Description: {0}&quot;, \n            weekly[101030411]-&gt;Description);\n\n        // The Remove method of KeyedCollection takes a key.\n        //\n        Console::WriteLine(&quot;<br>Remove(101030411)&quot;);\n        weekly-&gt;Remove(101030411);\n\n        // The Insert method, inherited from Collection, takes an \n        // index and an OrderItem.\n        //\n        Console::WriteLine(&quot;<br>Insert(2, gcnew OrderItem(...))&quot;);\n        weekly-&gt;Insert(2, gcnew OrderItem(111033401, &quot;Nut&quot;, 10, .5));\n         \n        // The default Item property is overloaded. One overload comes\n        // from KeyedCollection&lt;int, OrderItem&gt;; that overload\n        // is read-only, and takes Integer because it retrieves by key. \n        // The other overload comes from Collection&lt;OrderItem&gt;, the \n        // base class of KeyedCollection&lt;int, OrderItem&gt;; it \n        // retrieves by index, so it also takes an Integer. The compiler\n        // uses the most-derived overload, from KeyedCollection, so the\n        // only way to access SimpleOrder by index is to cast it to\n        // Collection&lt;OrderItem&gt;. Otherwise the index is interpreted\n        // as a key, and KeyNotFoundException is thrown.\n        //\n        Collection&lt;OrderItem^&gt;^ coweekly = weekly;\n        Console::WriteLine(&quot;<br>coweekly[2].Description: {0}&quot;, \n            coweekly[2]-&gt;Description);\n \n        Console::WriteLine(&quot;<br>coweekly[2] = gcnew OrderItem(...)&quot;);\n        coweekly[2] = gcnew OrderItem(127700026, &quot;Crank&quot;, 27, 5.98);\n\n        OrderItem^ temp = coweekly[2];\n\n        // The IndexOf method, inherited from Collection&lt;OrderItem&gt;, \n        // takes an OrderItem instead of a key.\n        // \n        Console::WriteLine(&quot;<br>IndexOf(temp): {0}&quot;, weekly-&gt;IndexOf(temp));\n\n        // The inherited Remove method also takes an OrderItem-&gt;\n        //\n        Console::WriteLine(&quot;<br>Remove(temp)&quot;);\n        weekly-&gt;Remove(temp);\n\n        Console::WriteLine(&quot;<br>RemoveAt(0)&quot;);\n        weekly-&gt;RemoveAt(0);\n\n        weekly-&gt;AddOrMerge(gcnew OrderItem(110072684, &quot;Gear&quot;, 1000, 5.17));\n\n        Display(weekly);\n\n        Console::WriteLine();\n        weekly-&gt;Clear();\n    }\n    \nprivate:\n    static void Display(SimpleOrder^ order)\n    {\n        Console::WriteLine();\n        for each( OrderItem^ item in order )\n        {\n            Console::WriteLine(item);\n        }\n    }\n\n    static void ChangedHandler(Object^ source, \n        SimpleOrderChangedEventArgs^ e)\n    {\n        OrderItem^ item = e-&gt;ChangedItem;\n\n        if (e-&gt;ChangeType == ChangeTypes::Replaced)\n        {\n            OrderItem^ replacement = e-&gt;ReplacedWith;\n\n            Console::WriteLine(&quot;{0} (quantity {1}) was replaced &quot; +\n                &quot;by {2}, (quantity {3}).&quot;, item-&gt;Description, \n                item-&gt;Quantity, replacement-&gt;Description, \n                replacement-&gt;Quantity);\n        }\n        else if(e-&gt;ChangeType == ChangeTypes::Cleared)\n        {\n            Console::WriteLine(&quot;The order list was cleared.&quot;);\n        }\n        else\n        {\n            Console::WriteLine(&quot;{0} (quantity {1}) was {2}.&quot;, \n                item-&gt;Description, item-&gt;Quantity, e-&gt;ChangeType);\n        }\n    }\n};\n\nvoid main()\n{\n    Demo::Main();\n}\n\n/* This code example produces the following output:\n\nWidget (quantity 400) was Added.\nSprocket (quantity 27) was Added.\nMotor (quantity 10) was Added.\nGear (quantity 175) was Added.\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n101030411     10 Motor        at   237.50 =   2,375.00\n110072684    175 Gear         at     5.17 =     904.75\n\nContains(101030411): True\n\nweekly[101030411]-&gt;Description: Motor\n\nRemove(101030411)\nMotor (quantity 10) was Removed.\n\nInsert(2, gcnew OrderItem(...))\nNut (quantity 10) was Added.\n\ncoweekly[2].Description: Nut\n\ncoweekly[2] = gcnew OrderItem(...)\nNut (quantity 10) was replaced by Crank, (quantity 27).\n\nIndexOf(temp): 2\n\nRemove(temp)\nCrank (quantity 27) was Removed.\n\nRemoveAt(0)\nWidget (quantity 400) was Removed.\n\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684   1175 Gear         at     5.17 =   6,074.75\n\nThe order list was cleared.\n */\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"properties\">\r\n        <h2>Properties\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Collections_ObjectModel_KeyedCollection_2_Comparer\">\r\n    \r\n            <a id=\"System_Collections_ObjectModel_KeyedCollection_2_Comparer_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Comparer</div>        \r\n          </div>\r\n    \r\n            <p>Gets the generic equality comparer that is used to determine equality of keys in the collection.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Collections.Generic.IEqualityComparer&lt;TKey&gt; Comparer { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.generic.iequalitycomparer-1\" data-linktype=\"relative-path\">IEqualityComparer</a>&lt;<span class=\"xref\">TKey</span>&gt;</div>\r\n                  </div>\r\n                  <p>The implementation of the <span class=\"xref\">stem.Collections.Generic.IEqualityComparer`1</span> generic interface that is used to determine equality of keys in the collection.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Retrieving the value of this property is an O(1) operation.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Collections_ObjectModel_KeyedCollection_2_Dictionary\">\r\n    \r\n            <a id=\"System_Collections_ObjectModel_KeyedCollection_2_Dictionary_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Dictionary</div>        \r\n          </div>\r\n    \r\n            <p>Gets the lookup dictionary of the <span class=\"xref\">stem.Collections.ObjectModel.KeyedCollection`2</span>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected System.Collections.Generic.IDictionary&lt;TKey,TItem&gt; Dictionary { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.generic.idictionary-2\" data-linktype=\"relative-path\">IDictionary</a>&lt;<span class=\"xref\">TKey</span>,<span class=\"xref\">TItem</span>&gt;</div>\r\n                  </div>\r\n                  <p>The lookup dictionary of the <span class=\"xref\">stem.Collections.ObjectModel.KeyedCollection`2</span>, if it exists; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>By default, the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> includes a lookup dictionary that is created when the first item is added. When an item is added to the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a>, the item&#39;s key is extracted once and saved in the lookup dictionary for faster searches. This behavior can be overridden by using the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2__ctor_System_Collections_Generic_IEqualityComparer__0__System_Int32_\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;(IEqualityComparer&lt;TKey&gt;,Int32)</a> constructor and specifying a dictionary creation threshold.  </p>\n<p> Retrieving the value of this property is an O(1) operation.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example shows how to override the protected <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_ChangeItemKey_\" data-linktype=\"relative-path\">ChangeItemKey</a> method to support mutable keys, and how to override the protected <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_InsertItem_\" data-linktype=\"relative-path\">InsertItem</a>, <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_RemoveItem_\" data-linktype=\"relative-path\">RemoveItem</a>, <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_ClearItems_\" data-linktype=\"relative-path\">ClearItems</a>, and <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_SetItem_\" data-linktype=\"relative-path\">SetItem</a> methods to maintain the integrity of the keys and the collection.  </p>\n<p> The code example creates the <code>MutableKeys</code> collection, which derives from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a>, and the <code>MutableKey</code> class. The <code>MutableKey</code> class has a settable <code>Key</code> property. When a new key is assigned to the property, the property setter calls the <code>internal</code> (<code>Friend</code> in Visual Basic) <code>ChangeKey</code> method of the collection to test whether the new key would conflict with an existing key. If so, an exception is thrown and the property value is not changed.  </p>\n<p> In order to maintain the connection between a <code>MutableKey</code> object and the <code>MutableKeys</code> collection and to prevent an object from being inserted into two collections, the <code>MutableKey</code> class has an <code>internal</code> (<code>Friend</code> in Visual Basic) <code>Collection</code> field. This field is maintained by the protected methods that provide custom behavior for adding and removing items from the collection, such as the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_InsertItem_\" data-linktype=\"relative-path\">InsertItem</a> method. The field is set when the item is added to a collection and cleared when the item is removed.  </p>\n<pre><code class=\"lang-cs\" name=\"KeyedCollectionMutable#1\">using System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\n\n// This class demonstrates one way to use the ChangeItemKey\n// method to store objects with keys that can be changed. The \n// ChangeItemKey method is used to keep the internal lookup\n// Dictionary in sync with the keys of the stored objects. \n//\n// MutableKeys stores MutableKey objects, which have an Integer\n// Key property that can be set. Therefore, MutableKeys inherits\n// KeyedCollection(Of Integer, MutableKey).\n//\npublic class MutableKeys : KeyedCollection&lt;int, MutableKey&gt;\n{\n    // This parameterless constructor delegates to the base class \n    // constructor that specifies a dictionary threshold. A\n    // threshold of 0 means the internal Dictionary is created\n    // the first time an object is added.\n    //\n    public MutableKeys() : base(null, 0) {}\n    \n    protected override int GetKeyForItem(MutableKey item)\n    {\n        // The key is MutableKey.Key.\n        return item.Key;\n    }\n\n    protected override void InsertItem(int index, MutableKey newItem)\n    {\n        if (newItem.Collection != null) \n            throw new ArgumentException(&quot;The item already belongs to a collection.&quot;);\n\n        base.InsertItem(index, newItem);\n        newItem.Collection = this;\n    }\n\n    protected override void SetItem(int index, MutableKey newItem)\n    {\n        MutableKey replaced = Items[index];\n\n        if (newItem.Collection != null) \n            throw new ArgumentException(&quot;The item already belongs to a collection.&quot;);\n\n        base.SetItem(index, newItem);\n        newItem.Collection = this;\n        replaced.Collection = null;\n    }\n\n    protected override void RemoveItem(int index)\n    {\n        MutableKey removedItem = Items[index];\n\n        base.RemoveItem(index);\n        removedItem.Collection = null;\n    }\n\n    protected override void ClearItems()\n    {\n        foreach( MutableKey mk in Items )\n        {\n            mk.Collection = null;\n        }\n        \n        base.ClearItems();\n    }\n\n    internal void ChangeKey(MutableKey item, int newKey)\n    {\n        base.ChangeItemKey(item, newKey);\n    }\n    \n    public void Dump()\n    {\n        Console.WriteLine(&quot;<br>DUMP:&quot;);\n        if (Dictionary == null)\n        {\n            Console.WriteLine(&quot;    The dictionary has not been created.&quot;);\n        }\n        else\n        {\n            Console.WriteLine(&quot;    Dictionary entries&quot;);\n            Console.WriteLine(&quot;    ------------------&quot;);\n\n            foreach( KeyValuePair&lt;int, MutableKey&gt; kvp in Dictionary )\n            {\n                Console.WriteLine(&quot;    {0} : {1}&quot;, kvp.Key, kvp.Value);\n            }\n        }\n\n        Console.WriteLine(&quot;<br>    List of items&quot;);\n        Console.WriteLine(&quot;    -------------&quot;);\n\n        foreach( MutableKey mk in Items )\n        {\n            Console.WriteLine(&quot;    {0}&quot;, mk);\n        }\n    }\n}\n\npublic class Demo\n{\n    public static void Main()\n    {\n        MutableKeys mkeys = new MutableKeys();\n\n        // The Add method is inherited from Collection.\n        //\n        mkeys.Add(new MutableKey(110072674, &quot;Widget&quot;));\n        mkeys.Add(new MutableKey(110072675, &quot;Sprocket&quot;));\n\n        mkeys.Dump();\n    \n        Console.WriteLine(&quot;<br>Create and insert a new item:&quot;);\n        MutableKey test = new MutableKey(110072684, &quot;Gear&quot;);\n        mkeys.Insert(1, test);\n\n        mkeys.Dump();\n\n        try\n        {\n            Console.WriteLine(&quot;<br>Try to insert the item again:&quot;);\n            mkeys.Insert(1, test);\n        }\n        catch(ArgumentException ex)\n        {\n            Console.WriteLine(&quot;Error: {0}&quot;, ex.Message);\n        }\n\n        Console.WriteLine(&quot;<br>Change the Key property of the item:&quot;);\n        test.Key = 100000072;\n\n        mkeys.Dump();\n\n        try\n        {\n            Console.WriteLine(&quot;<br>Try to set the Key property to an existing key:&quot;);\n            test.Key = 110072674;\n        }\n        catch(ArgumentException ex)\n        {\n            Console.WriteLine(&quot;Error: {0}&quot;, ex.Message);\n        }\n\n        mkeys.Dump();\n    }\n    \n    private static void Display(MutableKeys order)\n    {\n        Console.WriteLine();\n        foreach( MutableKey item in order )\n        {\n            Console.WriteLine(item);\n        }\n    }\n}\n\n// This class has a key that can be changed.\n// \npublic class MutableKey\n{\n\n    public MutableKey(int newKey, string newValue)\n    {\n        _key = newKey;\n        Value = newValue;\n    } //New\n    \n    public string Value;\n    internal MutableKeys Collection;\n    \n    private int _key;\n    public int Key    \n    {\n        get\n        {\n            return _key;\n        }\n        set\n        {\n            if (Collection != null)\n            {\n                Collection.ChangeKey(this, value);\n            }\n\n            _key = value;\n        }\n    }\n\n    public override string ToString()\n    {\n        return String.Format(&quot;{0,9} {1}&quot;, _key, Value);\n    }\n        \n}\n\n/* This code example produces the following output:\n\nDUMP:\n    Dictionary entries\n    ------------------\n    110072674 : 110072674 Widget\n    110072675 : 110072675 Sprocket\n\n    List of items\n    -------------\n    110072674 Widget\n    110072675 Sprocket\n\nCreate and insert a new item:\n\nDUMP:\n    Dictionary entries\n    ------------------\n    110072674 : 110072674 Widget\n    110072675 : 110072675 Sprocket\n    110072684 : 110072684 Gear\n\n    List of items\n    -------------\n    110072674 Widget\n    110072684 Gear\n    110072675 Sprocket\n\nTry to insert the item again:\nError: The item already belongs to a collection.\n\nChange the Key property of the item:\n\nDUMP:\n    Dictionary entries\n    ------------------\n    110072674 : 110072674 Widget\n    110072675 : 110072675 Sprocket\n    100000072 : 100000072 Gear\n\n    List of items\n    -------------\n    110072674 Widget\n    100000072 Gear\n    110072675 Sprocket\n\nTry to set the Key property to an existing key:\nError: An item with the same key has already been added.\n\nDUMP:\n    Dictionary entries\n    ------------------\n    110072674 : 110072674 Widget\n    110072675 : 110072675 Sprocket\n    100000072 : 100000072 Gear\n\n    List of items\n    -------------\n    110072674 Widget\n    100000072 Gear\n    110072675 Sprocket\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"KeyedCollectionMutable#1\">Imports System\nImports System.Collections.Generic\nImports System.Collections.ObjectModel\n\n&#39; This class demonstrates one way to use the ChangeItemKey\n&#39; method to store objects with keys that can be changed. The \n&#39; ChangeItemKey method is used to keep the internal lookup\n&#39; Dictionary in sync with the keys of the stored objects. \n&#39;\n&#39; MutableKeys stores MutableKey objects, which have an Integer\n&#39; Key property that can be set. Therefore, MutableKeys inherits\n&#39; KeyedCollection(Of Integer, MutableKey).\n&#39;\nPublic Class MutableKeys\n    Inherits KeyedCollection(Of Integer, MutableKey)\n\n    &#39; This parameterless constructor delegates to the base class \n    &#39; constructor that specifies a dictionary threshold. A\n    &#39; threshold of 0 means the internal Dictionary is created\n    &#39; the first time an object is added.\n    &#39;\n    Public Sub New()\n        MyBase.New(Nothing, 0)\n    End Sub\n    \n    Protected Overrides Function GetKeyForItem( _\n        ByVal item As MutableKey) As Integer\n\n        &#39; The key is MutableKey.Key.\n        Return item.Key   \n    End Function\n\n    Protected Overrides Sub InsertItem( _\n        ByVal index As Integer, ByVal newItem As MutableKey)\n\n        If newItem.Collection IsNot Nothing Then _\n            Throw New ArgumentException(&quot;The item already belongs to a collection.&quot;)\n\n        MyBase.InsertItem(index, newItem)\n        newItem.Collection = Me\n    End Sub\n\n    Protected Overrides Sub SetItem(ByVal index As Integer, _\n        ByVal newItem As MutableKey)\n\n        Dim replaced As MutableKey = Items(index)\n\n        If newItem.Collection IsNot Nothing Then _\n            Throw New ArgumentException(&quot;The item already belongs to a collection.&quot;)\n\n        MyBase.SetItem(index, newItem)\n        newItem.Collection = Me\n        replaced.Collection = Nothing\n    End Sub\n\n    Protected Overrides Sub RemoveItem(ByVal index As Integer)\n        Dim removedItem As MutableKey = Items(index)\n\n        MyBase.RemoveItem(index)\n        removedItem.Collection = Nothing\n    End Sub\n\n    Protected Overrides Sub ClearItems()\n        For Each mk As MutableKey In Items\n            mk.Collection = Nothing\n        Next\n        \n        MyBase.ClearItems()\n    End Sub\n\n    Friend Sub ChangeKey(ByVal item As MutableKey, _\n        ByVal newKey As Integer)\n\n        MyBase.ChangeItemKey(item, newKey)\n    End Sub\n    \n    Public Sub Dump()\n        Console.WriteLine(vbLf &amp; &quot;DUMP:&quot;)\n        If Dictionary Is Nothing Then\n            Console.WriteLine(&quot;    The dictionary has not been created.&quot;)\n        Else\n            Console.WriteLine(&quot;    Dictionary entries&quot;)\n            Console.WriteLine(&quot;    ------------------&quot;)\n\n            For Each kvp As KeyValuePair(Of Integer, MutableKey) In Dictionary\n                Console.WriteLine(&quot;    {0} : {1}&quot;, kvp.Key, kvp.Value)\n            Next\n        End If\n\n        Console.WriteLine(vbLf &amp; &quot;    List of items&quot;)\n        Console.WriteLine(&quot;    -------------&quot;)\n\n        For Each mk As MutableKey In Items\n            Console.WriteLine(&quot;    {0}&quot;, mk)\n        Next\n    End Sub\n\nEnd Class\n\nPublic Class Demo\n    \n    Public Shared Sub Main() \n\n        Dim mkeys As New MutableKeys()\n\n        &#39; The Add method is inherited from Collection.\n        &#39;\n        mkeys.Add(New MutableKey(110072674, &quot;Widget&quot;))\n        mkeys.Add(New MutableKey(110072675, &quot;Sprocket&quot;))\n\n        mkeys.Dump() \n    \n        Console.WriteLine(vbLf &amp; &quot;Create and insert a new item:&quot;)\n        Dim test As New MutableKey(110072684, &quot;Gear&quot;)\n        mkeys.Insert(1, test)\n\n        mkeys.Dump()\n\n        Try\n            Console.WriteLine(vbLf &amp; &quot;Try to insert the item again:&quot;)\n            mkeys.Insert(1, test)\n        Catch ex As ArgumentException\n            Console.WriteLine(&quot;Error: {0}&quot;, ex.Message)\n        End Try\n\n        Console.WriteLine(vbLf &amp; &quot;Change the Key property of the item:&quot;)\n        test.Key = 100000072\n\n        mkeys.Dump()\n\n        Try\n            Console.WriteLine(vbLf &amp; &quot;Try to set the Key property to an existing key:&quot;)\n            test.Key = 110072674\n        Catch ex As ArgumentException\n            Console.WriteLine(&quot;Error: {0}&quot;, ex.Message)\n        End Try\n\n        mkeys.Dump()\n\n    End Sub\n    \n    Private Shared Sub Display(ByVal order As MutableKeys) \n        Console.WriteLine()\n        For Each item As MutableKey In  order\n            Console.WriteLine(item)\n        Next item\n    End Sub\nEnd Class\n\n&#39; This class has a key that can be changed.\n&#39; \nPublic Class MutableKey\n\n    Public Sub New(ByVal newKey As Integer, ByVal newValue As String)\n        _key = newKey\n        Value = newValue\n    End Sub &#39;New\n    \n    Public Value As String\n    Friend Collection As MutableKeys\n    \n    Private _key As Integer\n    Public Property Key As Integer \n        Get\n            Return _key\n        End Get\n        Set\n            If Collection IsNot Nothing Then\n                Collection.ChangeKey(Me, value)\n            End If\n\n            _key = value\n        End Set\n    End Property\n\n    Public Overrides Function ToString() As String \n        Return String.Format(&quot;{0,9} {1}&quot;, _key, Value)\n    End Function\n        \nEnd Class\n\n&#39; This code example produces the following output:\n&#39;\n&#39;DUMP:\n&#39;    Dictionary entries\n&#39;    ------------------\n&#39;    110072674 : 110072674 Widget\n&#39;    110072675 : 110072675 Sprocket\n&#39;\n&#39;    List of items\n&#39;    -------------\n&#39;    110072674 Widget\n&#39;    110072675 Sprocket\n&#39;\n&#39;Create and insert a new item:\n&#39;\n&#39;DUMP:\n&#39;    Dictionary entries\n&#39;    ------------------\n&#39;    110072674 : 110072674 Widget\n&#39;    110072675 : 110072675 Sprocket\n&#39;    110072684 : 110072684 Gear\n&#39;\n&#39;    List of items\n&#39;    -------------\n&#39;    110072674 Widget\n&#39;    110072684 Gear\n&#39;    110072675 Sprocket\n&#39;\n&#39;Try to insert the item again:\n&#39;Error: The item already belongs to a collection.\n&#39;\n&#39;Change the Key property of the item:\n&#39;\n&#39;DUMP:\n&#39;    Dictionary entries\n&#39;    ------------------\n&#39;    110072674 : 110072674 Widget\n&#39;    110072675 : 110072675 Sprocket\n&#39;    100000072 : 100000072 Gear\n&#39;\n&#39;    List of items\n&#39;    -------------\n&#39;    110072674 Widget\n&#39;    100000072 Gear\n&#39;    110072675 Sprocket\n&#39;\n&#39;Try to set the Key property to an existing key:\n&#39;Error: An item with the same key has already been added.\n&#39;\n&#39;DUMP:\n&#39;    Dictionary entries\n&#39;    ------------------\n&#39;    110072674 : 110072674 Widget\n&#39;    110072675 : 110072675 Sprocket\n&#39;    100000072 : 100000072 Gear\n&#39;\n&#39;    List of items\n&#39;    -------------\n&#39;    110072674 Widget\n&#39;    100000072 Gear\n&#39;    110072675 Sprocket\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Collections_ObjectModel_KeyedCollection_2_Item__0_\">\r\n    \r\n            <a id=\"System_Collections_ObjectModel_KeyedCollection_2_Item_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Item(TKey)</div>        \r\n          </div>\r\n    \r\n            <p>Gets the element with the specified key.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public TItem this[TKey key] { get; }</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>key</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><span class=\"xref\">TKey</span></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The key of the element to get.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><span class=\"xref\">TItem</span></div>\r\n                  </div>\r\n                  <p>The element with the specified key. If an element with the specified key is not found, an exception is thrown.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>key</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.collections.generic.keynotfoundexception\" data-linktype=\"relative-path\">KeyNotFoundException</a></div>\r\n                  </div>\r\n                  <p>An element with the specified key does not exist in the collection.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This property provides the ability to access a specific element in the collection by using the following syntax: <code>myCollection[key]</code> (<code>myCollection(key)</code> in Visual Basic).  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> This property is distinct from the inherited <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Item_\" data-linktype=\"relative-path\">Item</a> property, which gets and sets elements by numeric index. However, if <code>TKey</code> is of type <a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a>, this property masks the inherited property. In that case, you can access the inherited property by casting the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> to its base type. For example, <code>KeyedCollection&lt;int, MyType&gt;</code> (<code>KeyedCollection(Of Integer, MyType)</code> in Visual Basic, <code>KeyedCollection&lt;int, MyType^&gt;</code> in C++) can be cast to <code>Collection&lt;MyType&gt;</code> (<code>Collection(Of MyType)</code> in Visual Basic, <code>Collection&lt;MyType^&gt;</code> in C++).  </p>\n</div>\n<p> If the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> has a lookup dictionary, <code>key</code> is used to retrieve the element from the dictionary.  If there is no lookup dictionary, the key of each element is extracted using the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_GetKeyForItem_\" data-linktype=\"relative-path\">GetKeyForItem</a> method and compared with the specified key.  </p>\n<p> The C# language uses the  keyword to define the indexers instead of implementing the Item property. Visual Basic implements Item as a default property, which provides the same indexing functionality.  </p>\n<p> Retrieving the value of this property is an O(1) operation if the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> has a lookup dictionary; otherwise it is an O(<code>n</code>) operation, where <code>n</code> is <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Count_\" data-linktype=\"relative-path\">Count</a>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>This code example shows the minimum code necessary to derive a collection class from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a>: overriding the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_GetKeyForItem_\" data-linktype=\"relative-path\">GetKeyForItem</a> method and providing a public constructor that delegates to a base class constructor. The code example also demonstrates many of the properties and methods inherited from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> and <a class=\"xref\" href=\"system.collections.objectmodel.collection-1\" data-linktype=\"relative-path\">Collection&lt;T&gt;</a> classes.  </p>\n<p> The code example calls both the Item property, which is read-only and retrieves by key, and the <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Item_\" data-linktype=\"relative-path\">Item</a> property, which is settable and retrieves by index. It shows how to access the latter property when the objects in the derived collection have integer keys, indistinguishable from the integers used for indexed retrieval.  </p>\n<p> The <code>SimpleOrder</code> class is a very simple requisition list that contains <code>OrderItem</code> objects, each of which represents a line item in the order. The key of <code>OrderItem</code> is immutable, an important consideration for classes that derive from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a>. For a code example that uses mutable keys, see <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_ChangeItemKey_\" data-linktype=\"relative-path\">ChangeItemKey</a>.  </p>\n<pre><code class=\"lang-cpp\" name=\"KeyedCollection#1\">using namespace System;\nusing namespace System::Collections::Generic;\nusing namespace System::Collections::ObjectModel;\n\n// This class represents a simple line item in an order. All the \n// values are immutable except quantity.\n// \npublic ref class OrderItem\n{\nprivate:\n    int _quantity;\n    \npublic:\n    initonly int PartNumber;\n    initonly String^ Description;\n    initonly double UnitPrice;\n    \n    OrderItem(int partNumber, String^ description, \n        int quantity, double unitPrice)\n    {\n        this-&gt;PartNumber = partNumber;\n        this-&gt;Description = description;\n        this-&gt;Quantity = quantity;\n        this-&gt;UnitPrice = unitPrice;\n    } \n    \n    property int Quantity    \n    {\n        int get() { return _quantity; }\n        void set(int value)\n        {\n            if (value &lt; 0)\n                throw gcnew ArgumentException(&quot;Quantity cannot be negative.&quot;);\n            \n            _quantity = value;\n        }\n    }\n        \n    virtual String^ ToString() override \n    {\n        return String::Format(\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, \n            PartNumber, _quantity, Description, UnitPrice, \n            UnitPrice * _quantity);\n    }\n};\n\n// This class represents a very simple keyed list of OrderItems,\n// inheriting most of its behavior from the KeyedCollection and \n// Collection classes. The immediate base class is the constructed\n// type KeyedCollection&lt;int, OrderItem&gt;. When you inherit\n// from KeyedCollection, the second generic type argument is the \n// type that you want to store in the collection -- in this case\n// OrderItem. The first type argument is the type that you want\n// to use as a key. Its values must be calculated from OrderItem; \n// in this case it is the int field PartNumber, so SimpleOrder\n// inherits KeyedCollection&lt;int, OrderItem&gt;.\n//\npublic ref class SimpleOrder : KeyedCollection&lt;int, OrderItem^&gt;\n{\n    // The parameterless constructor of the base class creates a \n    // KeyedCollection with an internal dictionary. For this code \n    // example, no other constructors are exposed.\n    //\npublic:\n    SimpleOrder() {}\n    \n    // This is the only method that absolutely must be overridden,\n    // because without it the KeyedCollection cannot extract the\n    // keys from the items. The input parameter type is the \n    // second generic type argument, in this case OrderItem, and \n    // the return value type is the first generic type argument,\n    // in this case int.\n    //\nprotected:\n    virtual int GetKeyForItem(OrderItem^ item) override \n    {\n        // In this example, the key is the part number.\n        return item-&gt;PartNumber;\n    }\n};\n\npublic ref class Demo\n{    \npublic:\n    static void Main()\n    {\n        SimpleOrder^ weekly = gcnew SimpleOrder();\n\n        // The Add method, inherited from Collection, takes OrderItem.\n        //\n        weekly-&gt;Add(gcnew OrderItem(110072674, &quot;Widget&quot;, 400, 45.17));\n        weekly-&gt;Add(gcnew OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3));\n        weekly-&gt;Add(gcnew OrderItem(101030411, &quot;Motor&quot;, 10, 237.5));\n        weekly-&gt;Add(gcnew OrderItem(110072684, &quot;Gear&quot;, 175, 5.17));\n        \n        Display(weekly);\n    \n        // The Contains method of KeyedCollection takes the key, \n        // type, in this case int.\n        //\n        Console::WriteLine(&quot;<br>Contains(101030411): {0}&quot;, \n            weekly-&gt;Contains(101030411));\n\n        // The default Item property of KeyedCollection takes a key.\n        //\n        Console::WriteLine(&quot;<br>weekly(101030411)-&gt;Description: {0}&quot;, \n            weekly[101030411]-&gt;Description);\n\n        // The Remove method of KeyedCollection takes a key.\n        //\n        Console::WriteLine(&quot;<br>Remove(101030411)&quot;);\n        weekly-&gt;Remove(101030411);\n        Display(weekly);\n\n        // The Insert method, inherited from Collection, takes an \n        // index and an OrderItem.\n        //\n        Console::WriteLine(&quot;<br>Insert(2, New OrderItem(...))&quot;);\n        weekly-&gt;Insert(2, gcnew OrderItem(111033401, &quot;Nut&quot;, 10, .5));\n        Display(weekly);\n\n        // The default Item property is overloaded. One overload comes\n        // from KeyedCollection&lt;int, OrderItem&gt;; that overload\n        // is read-only, and takes Integer because it retrieves by key. \n        // The other overload comes from Collection&lt;OrderItem&gt;, the \n        // base class of KeyedCollection&lt;int, OrderItem&gt;; it \n        // retrieves by index, so it also takes an Integer. The compiler\n        // uses the most-derived overload, from KeyedCollection, so the\n        // only way to access SimpleOrder by index is to cast it to\n        // Collection&lt;OrderItem&gt;. Otherwise the index is interpreted\n        // as a key, and KeyNotFoundException is thrown.\n        //\n        Collection&lt;OrderItem^&gt;^ coweekly = weekly;\n        Console::WriteLine(&quot;<br>coweekly[2].Description: {0}&quot;, \n            coweekly[2]-&gt;Description);\n \n        Console::WriteLine(&quot;<br>coweekly[2] = gcnew OrderItem(...)&quot;);\n        coweekly[2] = gcnew OrderItem(127700026, &quot;Crank&quot;, 27, 5.98);\n\n        OrderItem^ temp = coweekly[2];\n\n        // The IndexOf method inherited from Collection&lt;OrderItem&gt; \n        // takes an OrderItem instead of a key\n        // \n        Console::WriteLine(&quot;<br>IndexOf(temp): {0}&quot;, weekly-&gt;IndexOf(temp));\n\n        // The inherited Remove method also takes an OrderItem.\n        //\n        Console::WriteLine(&quot;<br>Remove(temp)&quot;);\n        weekly-&gt;Remove(temp);\n        Display(weekly);\n\n        Console::WriteLine(&quot;<br>RemoveAt(0)&quot;);\n        weekly-&gt;RemoveAt(0);\n        Display(weekly);\n\n    }\n    \nprivate:\n    static void Display(SimpleOrder^ order)\n    {\n        Console::WriteLine();\n        for each( OrderItem^ item in order )\n        {\n            Console::WriteLine(item);\n        }\n    }\n};\n\nvoid main()\n{\n    Demo::Main();\n}\n\n/* This code example produces the following output:\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n101030411     10 Motor        at   237.50 =   2,375.00\n110072684    175 Gear         at     5.17 =     904.75\n\nContains(101030411): True\n\nweekly(101030411)-&gt;Description: Motor\n\nRemove(101030411)\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n\nInsert(2, New OrderItem(...))\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n111033401     10 Nut          at      .50 =       5.00\n110072684    175 Gear         at     5.17 =     904.75\n\ncoweekly(2)-&gt;Description: Nut\n\ncoweekly[2] = gcnew OrderItem(...)\n\nIndexOf(temp): 2\n\nRemove(temp)\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n\nRemoveAt(0)\n\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n */\n</code></pre><pre><code class=\"lang-cs\" name=\"KeyedCollection#1\">using System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\n\n// This class represents a very simple keyed list of OrderItems,\n// inheriting most of its behavior from the KeyedCollection and \n// Collection classes. The immediate base class is the constructed\n// type KeyedCollection&lt;int, OrderItem&gt;. When you inherit\n// from KeyedCollection, the second generic type argument is the \n// type that you want to store in the collection -- in this case\n// OrderItem. The first type argument is the type that you want\n// to use as a key. Its values must be calculated from OrderItem; \n// in this case it is the int field PartNumber, so SimpleOrder\n// inherits KeyedCollection&lt;int, OrderItem&gt;.\n//\npublic class SimpleOrder : KeyedCollection&lt;int, OrderItem&gt;\n{\n       \n    // This is the only method that absolutely must be overridden,\n    // because without it the KeyedCollection cannot extract the\n    // keys from the items. The input parameter type is the \n    // second generic type argument, in this case OrderItem, and \n    // the return value type is the first generic type argument,\n    // in this case int.\n    //\n    protected override int GetKeyForItem(OrderItem item)\n    {\n        // In this example, the key is the part number.\n        return item.PartNumber;\n    }\n}\n\npublic class Demo\n{    \n    public static void Main()\n    {\n        SimpleOrder weekly = new SimpleOrder();\n\n        // The Add method, inherited from Collection, takes OrderItem.\n        //\n        weekly.Add(new OrderItem(110072674, &quot;Widget&quot;, 400, 45.17));\n        weekly.Add(new OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3));\n        weekly.Add(new OrderItem(101030411, &quot;Motor&quot;, 10, 237.5));\n        weekly.Add(new OrderItem(110072684, &quot;Gear&quot;, 175, 5.17));\n        \n        Display(weekly);\n    \n        // The Contains method of KeyedCollection takes the key, \n        // type, in this case int.\n        //\n        Console.WriteLine(&quot;<br>Contains(101030411): {0}&quot;, \n            weekly.Contains(101030411));\n\n        // The default Item property of KeyedCollection takes a key.\n        //\n        Console.WriteLine(&quot;<br>weekly[101030411].Description: {0}&quot;, \n            weekly[101030411].Description);\n\n        // The Remove method of KeyedCollection takes a key.\n        //\n        Console.WriteLine(&quot;<br>Remove(101030411)&quot;);\n        weekly.Remove(101030411);\n        Display(weekly);\n\n        // The Insert method, inherited from Collection, takes an \n        // index and an OrderItem.\n        //\n        Console.WriteLine(&quot;<br>Insert(2, New OrderItem(...))&quot;);\n        weekly.Insert(2, new OrderItem(111033401, &quot;Nut&quot;, 10, .5));\n        Display(weekly);\n\n        // The default Item property is overloaded. One overload comes\n        // from KeyedCollection&lt;int, OrderItem&gt;; that overload\n        // is read-only, and takes Integer because it retrieves by key. \n        // The other overload comes from Collection&lt;OrderItem&gt;, the \n        // base class of KeyedCollection&lt;int, OrderItem&gt;; it \n        // retrieves by index, so it also takes an Integer. The compiler\n        // uses the most-derived overload, from KeyedCollection, so the\n        // only way to access SimpleOrder by index is to cast it to\n        // Collection&lt;OrderItem&gt;. Otherwise the index is interpreted\n        // as a key, and KeyNotFoundException is thrown.\n        //\n        Collection&lt;OrderItem&gt; coweekly = weekly;\n        Console.WriteLine(&quot;<br>coweekly[2].Description: {0}&quot;, \n            coweekly[2].Description);\n \n        Console.WriteLine(&quot;<br>coweekly[2] = new OrderItem(...)&quot;);\n        coweekly[2] = new OrderItem(127700026, &quot;Crank&quot;, 27, 5.98);\n\n        OrderItem temp = coweekly[2];\n\n        // The IndexOf method inherited from Collection&lt;OrderItem&gt; \n        // takes an OrderItem instead of a key\n        // \n        Console.WriteLine(&quot;<br>IndexOf(temp): {0}&quot;, weekly.IndexOf(temp));\n\n        // The inherited Remove method also takes an OrderItem.\n        //\n        Console.WriteLine(&quot;<br>Remove(temp)&quot;);\n        weekly.Remove(temp);\n        Display(weekly);\n\n        Console.WriteLine(&quot;<br>RemoveAt(0)&quot;);\n        weekly.RemoveAt(0);\n        Display(weekly);\n\n    }\n    \n    private static void Display(SimpleOrder order)\n    {\n        Console.WriteLine();\n        foreach( OrderItem item in order )\n        {\n            Console.WriteLine(item);\n        }\n    }\n}\n\n// This class represents a simple line item in an order. All the \n// values are immutable except quantity.\n// \npublic class OrderItem\n{\n    public readonly int PartNumber;\n    public readonly string Description;\n    public readonly double UnitPrice;\n    \n    private int _quantity = 0;\n    \n    public OrderItem(int partNumber, string description, \n        int quantity, double unitPrice)\n    {\n        this.PartNumber = partNumber;\n        this.Description = description;\n        this.Quantity = quantity;\n        this.UnitPrice = unitPrice;\n    } \n    \n    public int Quantity    \n    {\n        get { return _quantity; }\n        set\n        {\n            if (value&lt;0)\n                throw new ArgumentException(&quot;Quantity cannot be negative.&quot;);\n            \n            _quantity = value;\n        }\n    }\n        \n    public override string ToString()\n    {\n        return String.Format(\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, \n            PartNumber, _quantity, Description, UnitPrice, \n            UnitPrice * _quantity);\n    }\n}\n\n/* This code example produces the following output:\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n101030411     10 Motor        at   237.50 =   2,375.00\n110072684    175 Gear         at     5.17 =     904.75\n\nContains(101030411): True\n\nweekly[101030411].Description: Motor\n\nRemove(101030411)\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n\nInsert(2, New OrderItem(...))\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n111033401     10 Nut          at      .50 =       5.00\n110072684    175 Gear         at     5.17 =     904.75\n\ncoweekly[2].Description: Nut\n\ncoweekly[2] = new OrderItem(...)\n\nIndexOf(temp): 2\n\nRemove(temp)\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n\nRemoveAt(0)\n\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"KeyedCollection#1\">Imports System\nImports System.Collections.Generic\nImports System.Collections.ObjectModel\n\n&#39; This class represents a very simple keyed list of OrderItems,\n&#39; inheriting most of its behavior from the KeyedCollection and \n&#39; Collection classes. The immediate base class is the constructed\n&#39; type KeyedCollection(Of Integer, OrderItem). When you inherit\n&#39; from KeyedCollection, the second generic type argument is the \n&#39; type that you want to store in the collection -- in this case\n&#39; OrderItem. The first generic argument is the type that you want\n&#39; to use as a key. Its values must be calculated from OrderItem; \n&#39; in this case it is the Integer field PartNumber, so SimpleOrder\n&#39; inherits KeyedCollection(Of Integer, OrderItem).\n&#39;\nPublic Class SimpleOrder\n    Inherits KeyedCollection(Of Integer, OrderItem)\n\n\n    &#39; This is the only method that absolutely must be overridden,\n    &#39; because without it the KeyedCollection cannot extract the\n    &#39; keys from the items. The input parameter type is the \n    &#39; second generic type argument, in this case OrderItem, and \n    &#39; the return value type is the first generic type argument,\n    &#39; in this case Integer.\n    &#39;\n    Protected Overrides Function GetKeyForItem( _\n        ByVal item As OrderItem) As Integer\n\n        &#39; In this example, the key is the part number.\n        Return item.PartNumber   \n    End Function\n\nEnd Class\n\nPublic Class Demo\n    \n    Public Shared Sub Main() \n        Dim weekly As New SimpleOrder()\n\n        &#39; The Add method, inherited from Collection, takes OrderItem.\n        &#39;\n        weekly.Add(New OrderItem(110072674, &quot;Widget&quot;, 400, 45.17))\n        weekly.Add(New OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3))\n        weekly.Add(New OrderItem(101030411, &quot;Motor&quot;, 10, 237.5))\n        weekly.Add(New OrderItem(110072684, &quot;Gear&quot;, 175, 5.17))\n        \n        Display(weekly)\n    \n        &#39; The Contains method of KeyedCollection takes TKey.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Contains(101030411): {0}&quot;, _\n            weekly.Contains(101030411))\n\n        &#39; The default Item property of KeyedCollection takes the key\n        &#39; type, Integer.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;weekly(101030411).Description: {0}&quot;, _\n            weekly(101030411).Description)\n\n        &#39; The Remove method of KeyedCollection takes a key.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Remove(101030411)&quot;)\n        weekly.Remove(101030411)\n        Display(weekly)\n\n        &#39; The Insert method, inherited from Collection, takes an \n        &#39; index and an OrderItem.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Insert(2, New OrderItem(...))&quot;)\n        weekly.Insert(2, New OrderItem(111033401, &quot;Nut&quot;, 10, .5))\n        Display(weekly)\n\n        &#39; The default Item property is overloaded. One overload comes\n        &#39; from KeyedCollection(Of Integer, OrderItem); that overload\n        &#39; is read-only, and takes Integer because it retrieves by key. \n        &#39; The other overload comes from Collection(Of OrderItem), the \n        &#39; base class of KeyedCollection(Of Integer, OrderItem); it \n        &#39; retrieves by index, so it also takes an Integer. The compiler\n        &#39; uses the most-derived overload, from KeyedCollection, so the\n        &#39; only way to access SimpleOrder by index is to cast it to\n        &#39; Collection(Of OrderItem). Otherwise the index is interpreted\n        &#39; as a key, and KeyNotFoundException is thrown.\n        &#39;\n        Dim coweekly As Collection(Of OrderItem) = weekly\n        Console.WriteLine(vbLf &amp; &quot;coweekly(2).Description: {0}&quot;, _\n            coweekly(2).Description)\n \n        Console.WriteLine(vbLf &amp; &quot;coweekly(2) = New OrderItem(...)&quot;)\n        coweekly(2) = New OrderItem(127700026, &quot;Crank&quot;, 27, 5.98)\n\n        Dim temp As OrderItem = coweekly(2)\n\n        &#39; The IndexOf method, inherited from Collection(Of OrderItem), \n        &#39; takes an OrderItem instead of a key.\n        &#39; \n        Console.WriteLine(vbLf &amp; &quot;IndexOf(temp): {0}&quot;, _\n            weekly.IndexOf(temp))\n\n        &#39; The inherited Remove method also takes an OrderItem.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Remove(temp)&quot;)\n        weekly.Remove(temp)\n        Display(weekly)\n\n        Console.WriteLine(vbLf &amp; &quot;RemoveAt(0)&quot;)\n        weekly.RemoveAt(0)\n        Display(weekly)\n\n    End Sub\n    \n    Private Shared Sub Display(ByVal order As SimpleOrder) \n        Console.WriteLine()\n        For Each item As OrderItem In  order\n            Console.WriteLine(item)\n        Next item\n    End Sub\nEnd Class\n\n&#39; This class represents a simple line item in an order. All the \n&#39; values are immutable except quantity.\n&#39; \nPublic Class OrderItem\n    Public ReadOnly PartNumber As Integer\n    Public ReadOnly Description As String\n    Public ReadOnly UnitPrice As Double\n    \n    Private _quantity As Integer = 0\n    \n    Public Sub New(ByVal partNumber As Integer, _\n                   ByVal description As String, _\n                   ByVal quantity As Integer, _\n                   ByVal unitPrice As Double) \n        Me.PartNumber = partNumber\n        Me.Description = description\n        Me.Quantity = quantity\n        Me.UnitPrice = unitPrice\n    End Sub &#39;New\n    \n    Public Property Quantity() As Integer \n        Get\n            Return _quantity\n        End Get\n        Set\n            If value &lt; 0 Then\n                Throw New ArgumentException(&quot;Quantity cannot be negative.&quot;)\n            End If\n            _quantity = value\n        End Set\n    End Property\n        \n    Public Overrides Function ToString() As String \n        Return String.Format( _\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, _\n            PartNumber, _quantity, Description, UnitPrice, _\n            UnitPrice * _quantity)\n    End Function\nEnd Class\n\n&#39; This code example produces the following output:\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;101030411     10 Motor        at   237.50 =   2,375.00\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;Contains(101030411): True\n&#39;\n&#39;weekly(101030411).Description: Motor\n&#39;\n&#39;Remove(101030411)\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;Insert(2, New OrderItem(...))\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;111033401     10 Nut          at      .50 =       5.00\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;coweekly(2).Description: Nut\n&#39;\n&#39;coweekly(2) = New OrderItem(...)\n&#39;\n&#39;IndexOf(temp): 2\n&#39;\n&#39;Remove(temp)\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;RemoveAt(0)\n&#39;\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;110072684    175 Gear         at     5.17 =     904.75\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"methods\">\r\n        <h2>Methods\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Collections_ObjectModel_KeyedCollection_2_ChangeItemKey__1__0_\">\r\n    \r\n            <a id=\"System_Collections_ObjectModel_KeyedCollection_2_ChangeItemKey_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ChangeItemKey(TItem,TKey)</div>        \r\n          </div>\r\n    \r\n            <p>Changes the key associated with the specified element in the lookup dictionary.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected void ChangeItemKey (TItem item, TKey newKey);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>item</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><span class=\"xref\">TItem</span></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The element to change the key of.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>newKey</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><span class=\"xref\">TKey</span></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The new key for <code>item</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>item</code> is <code>null</code>.  </p>\n<p> -or-  </p>\n<p> <code>key</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>item</code> is not found.  </p>\n<p> -or-  </p>\n<p> <code>key</code> already exists in the <span class=\"xref\">stem.Collections.ObjectModel.KeyedCollection`2</span>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method does not modify the key embedded in <code>item</code>; it simply replaces the key saved in the lookup dictionary.  Therefore, if <code>newKey</code> is different from the key that is embedded in <code>item</code>, you cannot access <code>item</code> by using the key returned by <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_GetKeyForItem_\" data-linktype=\"relative-path\">GetKeyForItem</a>.  </p>\n<p> This method does nothing if the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> does not have a lookup dictionary.  </p>\n<p> Every key in a <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> must be unique. A key cannot be <code>null</code>.  </p>\n<p> This method is an O(1) operation.  </p>\n<h2 id=\"notes-for-implementers\">Notes for Implementers</h2>\n<p> Before modifying the key embedded in an item, you must call this method to update the key in the lookup dictionary. If the dictionary creation threshold is â€“1, calling this method is not necessary.  </p>\n<p> Do not expose the ChangeItemKey method as a public method of a derived class. Misuse of this method puts the lookup dictionary out of sync with item keys. For example, setting the key to <code>null</code> and then setting it to another value adds multiple keys for an item to the lookup dictionary. Expose this method internally to allow mutable item keys: When the key for an item changes, this method is used to change the key in the lookup dictionary.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example shows how to override the protected ChangeItemKey method to support mutable keys, and how to override the protected <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_InsertItem_\" data-linktype=\"relative-path\">InsertItem</a>, <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_RemoveItem_\" data-linktype=\"relative-path\">RemoveItem</a>, <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_ClearItems_\" data-linktype=\"relative-path\">ClearItems</a>, and <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_SetItem_\" data-linktype=\"relative-path\">SetItem</a> methods to maintain the integrity of the keys and the collection.  </p>\n<p> The code example creates the <code>MutableKeys</code> collection, which derives from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a>, and the <code>MutableKey</code> class. The <code>MutableKey</code> class has a settable <code>Key</code> property. When a new key is assigned to the property, the property setter calls the <code>internal</code> (<code>Friend</code> in Visual Basic) <code>ChangeKey</code> method of the collection to test whether the new key would conflict with an existing key. If so, an exception is thrown and the property value is not changed.  </p>\n<p> In order to maintain the connection between a <code>MutableKey</code> object and the <code>MutableKeys</code> collection and to prevent an object from being inserted into two collections, the <code>MutableKey</code> class has an <code>internal</code> (<code>Friend</code> in Visual Basic) <code>Collection</code> field. This field is maintained by the protected methods that provide custom behavior for adding and removing items from the collection, such as the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_InsertItem_\" data-linktype=\"relative-path\">InsertItem</a> method. The field is set when the item is added to a collection and cleared when the item is removed.  </p>\n<pre><code class=\"lang-cs\" name=\"KeyedCollectionMutable#1\">using System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\n\n// This class demonstrates one way to use the ChangeItemKey\n// method to store objects with keys that can be changed. The \n// ChangeItemKey method is used to keep the internal lookup\n// Dictionary in sync with the keys of the stored objects. \n//\n// MutableKeys stores MutableKey objects, which have an Integer\n// Key property that can be set. Therefore, MutableKeys inherits\n// KeyedCollection(Of Integer, MutableKey).\n//\npublic class MutableKeys : KeyedCollection&lt;int, MutableKey&gt;\n{\n    // This parameterless constructor delegates to the base class \n    // constructor that specifies a dictionary threshold. A\n    // threshold of 0 means the internal Dictionary is created\n    // the first time an object is added.\n    //\n    public MutableKeys() : base(null, 0) {}\n    \n    protected override int GetKeyForItem(MutableKey item)\n    {\n        // The key is MutableKey.Key.\n        return item.Key;\n    }\n\n    protected override void InsertItem(int index, MutableKey newItem)\n    {\n        if (newItem.Collection != null) \n            throw new ArgumentException(&quot;The item already belongs to a collection.&quot;);\n\n        base.InsertItem(index, newItem);\n        newItem.Collection = this;\n    }\n\n    protected override void SetItem(int index, MutableKey newItem)\n    {\n        MutableKey replaced = Items[index];\n\n        if (newItem.Collection != null) \n            throw new ArgumentException(&quot;The item already belongs to a collection.&quot;);\n\n        base.SetItem(index, newItem);\n        newItem.Collection = this;\n        replaced.Collection = null;\n    }\n\n    protected override void RemoveItem(int index)\n    {\n        MutableKey removedItem = Items[index];\n\n        base.RemoveItem(index);\n        removedItem.Collection = null;\n    }\n\n    protected override void ClearItems()\n    {\n        foreach( MutableKey mk in Items )\n        {\n            mk.Collection = null;\n        }\n        \n        base.ClearItems();\n    }\n\n    internal void ChangeKey(MutableKey item, int newKey)\n    {\n        base.ChangeItemKey(item, newKey);\n    }\n    \n    public void Dump()\n    {\n        Console.WriteLine(&quot;<br>DUMP:&quot;);\n        if (Dictionary == null)\n        {\n            Console.WriteLine(&quot;    The dictionary has not been created.&quot;);\n        }\n        else\n        {\n            Console.WriteLine(&quot;    Dictionary entries&quot;);\n            Console.WriteLine(&quot;    ------------------&quot;);\n\n            foreach( KeyValuePair&lt;int, MutableKey&gt; kvp in Dictionary )\n            {\n                Console.WriteLine(&quot;    {0} : {1}&quot;, kvp.Key, kvp.Value);\n            }\n        }\n\n        Console.WriteLine(&quot;<br>    List of items&quot;);\n        Console.WriteLine(&quot;    -------------&quot;);\n\n        foreach( MutableKey mk in Items )\n        {\n            Console.WriteLine(&quot;    {0}&quot;, mk);\n        }\n    }\n}\n\npublic class Demo\n{\n    public static void Main()\n    {\n        MutableKeys mkeys = new MutableKeys();\n\n        // The Add method is inherited from Collection.\n        //\n        mkeys.Add(new MutableKey(110072674, &quot;Widget&quot;));\n        mkeys.Add(new MutableKey(110072675, &quot;Sprocket&quot;));\n\n        mkeys.Dump();\n    \n        Console.WriteLine(&quot;<br>Create and insert a new item:&quot;);\n        MutableKey test = new MutableKey(110072684, &quot;Gear&quot;);\n        mkeys.Insert(1, test);\n\n        mkeys.Dump();\n\n        try\n        {\n            Console.WriteLine(&quot;<br>Try to insert the item again:&quot;);\n            mkeys.Insert(1, test);\n        }\n        catch(ArgumentException ex)\n        {\n            Console.WriteLine(&quot;Error: {0}&quot;, ex.Message);\n        }\n\n        Console.WriteLine(&quot;<br>Change the Key property of the item:&quot;);\n        test.Key = 100000072;\n\n        mkeys.Dump();\n\n        try\n        {\n            Console.WriteLine(&quot;<br>Try to set the Key property to an existing key:&quot;);\n            test.Key = 110072674;\n        }\n        catch(ArgumentException ex)\n        {\n            Console.WriteLine(&quot;Error: {0}&quot;, ex.Message);\n        }\n\n        mkeys.Dump();\n    }\n    \n    private static void Display(MutableKeys order)\n    {\n        Console.WriteLine();\n        foreach( MutableKey item in order )\n        {\n            Console.WriteLine(item);\n        }\n    }\n}\n\n// This class has a key that can be changed.\n// \npublic class MutableKey\n{\n\n    public MutableKey(int newKey, string newValue)\n    {\n        _key = newKey;\n        Value = newValue;\n    } //New\n    \n    public string Value;\n    internal MutableKeys Collection;\n    \n    private int _key;\n    public int Key    \n    {\n        get\n        {\n            return _key;\n        }\n        set\n        {\n            if (Collection != null)\n            {\n                Collection.ChangeKey(this, value);\n            }\n\n            _key = value;\n        }\n    }\n\n    public override string ToString()\n    {\n        return String.Format(&quot;{0,9} {1}&quot;, _key, Value);\n    }\n        \n}\n\n/* This code example produces the following output:\n\nDUMP:\n    Dictionary entries\n    ------------------\n    110072674 : 110072674 Widget\n    110072675 : 110072675 Sprocket\n\n    List of items\n    -------------\n    110072674 Widget\n    110072675 Sprocket\n\nCreate and insert a new item:\n\nDUMP:\n    Dictionary entries\n    ------------------\n    110072674 : 110072674 Widget\n    110072675 : 110072675 Sprocket\n    110072684 : 110072684 Gear\n\n    List of items\n    -------------\n    110072674 Widget\n    110072684 Gear\n    110072675 Sprocket\n\nTry to insert the item again:\nError: The item already belongs to a collection.\n\nChange the Key property of the item:\n\nDUMP:\n    Dictionary entries\n    ------------------\n    110072674 : 110072674 Widget\n    110072675 : 110072675 Sprocket\n    100000072 : 100000072 Gear\n\n    List of items\n    -------------\n    110072674 Widget\n    100000072 Gear\n    110072675 Sprocket\n\nTry to set the Key property to an existing key:\nError: An item with the same key has already been added.\n\nDUMP:\n    Dictionary entries\n    ------------------\n    110072674 : 110072674 Widget\n    110072675 : 110072675 Sprocket\n    100000072 : 100000072 Gear\n\n    List of items\n    -------------\n    110072674 Widget\n    100000072 Gear\n    110072675 Sprocket\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"KeyedCollectionMutable#1\">Imports System\nImports System.Collections.Generic\nImports System.Collections.ObjectModel\n\n&#39; This class demonstrates one way to use the ChangeItemKey\n&#39; method to store objects with keys that can be changed. The \n&#39; ChangeItemKey method is used to keep the internal lookup\n&#39; Dictionary in sync with the keys of the stored objects. \n&#39;\n&#39; MutableKeys stores MutableKey objects, which have an Integer\n&#39; Key property that can be set. Therefore, MutableKeys inherits\n&#39; KeyedCollection(Of Integer, MutableKey).\n&#39;\nPublic Class MutableKeys\n    Inherits KeyedCollection(Of Integer, MutableKey)\n\n    &#39; This parameterless constructor delegates to the base class \n    &#39; constructor that specifies a dictionary threshold. A\n    &#39; threshold of 0 means the internal Dictionary is created\n    &#39; the first time an object is added.\n    &#39;\n    Public Sub New()\n        MyBase.New(Nothing, 0)\n    End Sub\n    \n    Protected Overrides Function GetKeyForItem( _\n        ByVal item As MutableKey) As Integer\n\n        &#39; The key is MutableKey.Key.\n        Return item.Key   \n    End Function\n\n    Protected Overrides Sub InsertItem( _\n        ByVal index As Integer, ByVal newItem As MutableKey)\n\n        If newItem.Collection IsNot Nothing Then _\n            Throw New ArgumentException(&quot;The item already belongs to a collection.&quot;)\n\n        MyBase.InsertItem(index, newItem)\n        newItem.Collection = Me\n    End Sub\n\n    Protected Overrides Sub SetItem(ByVal index As Integer, _\n        ByVal newItem As MutableKey)\n\n        Dim replaced As MutableKey = Items(index)\n\n        If newItem.Collection IsNot Nothing Then _\n            Throw New ArgumentException(&quot;The item already belongs to a collection.&quot;)\n\n        MyBase.SetItem(index, newItem)\n        newItem.Collection = Me\n        replaced.Collection = Nothing\n    End Sub\n\n    Protected Overrides Sub RemoveItem(ByVal index As Integer)\n        Dim removedItem As MutableKey = Items(index)\n\n        MyBase.RemoveItem(index)\n        removedItem.Collection = Nothing\n    End Sub\n\n    Protected Overrides Sub ClearItems()\n        For Each mk As MutableKey In Items\n            mk.Collection = Nothing\n        Next\n        \n        MyBase.ClearItems()\n    End Sub\n\n    Friend Sub ChangeKey(ByVal item As MutableKey, _\n        ByVal newKey As Integer)\n\n        MyBase.ChangeItemKey(item, newKey)\n    End Sub\n    \n    Public Sub Dump()\n        Console.WriteLine(vbLf &amp; &quot;DUMP:&quot;)\n        If Dictionary Is Nothing Then\n            Console.WriteLine(&quot;    The dictionary has not been created.&quot;)\n        Else\n            Console.WriteLine(&quot;    Dictionary entries&quot;)\n            Console.WriteLine(&quot;    ------------------&quot;)\n\n            For Each kvp As KeyValuePair(Of Integer, MutableKey) In Dictionary\n                Console.WriteLine(&quot;    {0} : {1}&quot;, kvp.Key, kvp.Value)\n            Next\n        End If\n\n        Console.WriteLine(vbLf &amp; &quot;    List of items&quot;)\n        Console.WriteLine(&quot;    -------------&quot;)\n\n        For Each mk As MutableKey In Items\n            Console.WriteLine(&quot;    {0}&quot;, mk)\n        Next\n    End Sub\n\nEnd Class\n\nPublic Class Demo\n    \n    Public Shared Sub Main() \n\n        Dim mkeys As New MutableKeys()\n\n        &#39; The Add method is inherited from Collection.\n        &#39;\n        mkeys.Add(New MutableKey(110072674, &quot;Widget&quot;))\n        mkeys.Add(New MutableKey(110072675, &quot;Sprocket&quot;))\n\n        mkeys.Dump() \n    \n        Console.WriteLine(vbLf &amp; &quot;Create and insert a new item:&quot;)\n        Dim test As New MutableKey(110072684, &quot;Gear&quot;)\n        mkeys.Insert(1, test)\n\n        mkeys.Dump()\n\n        Try\n            Console.WriteLine(vbLf &amp; &quot;Try to insert the item again:&quot;)\n            mkeys.Insert(1, test)\n        Catch ex As ArgumentException\n            Console.WriteLine(&quot;Error: {0}&quot;, ex.Message)\n        End Try\n\n        Console.WriteLine(vbLf &amp; &quot;Change the Key property of the item:&quot;)\n        test.Key = 100000072\n\n        mkeys.Dump()\n\n        Try\n            Console.WriteLine(vbLf &amp; &quot;Try to set the Key property to an existing key:&quot;)\n            test.Key = 110072674\n        Catch ex As ArgumentException\n            Console.WriteLine(&quot;Error: {0}&quot;, ex.Message)\n        End Try\n\n        mkeys.Dump()\n\n    End Sub\n    \n    Private Shared Sub Display(ByVal order As MutableKeys) \n        Console.WriteLine()\n        For Each item As MutableKey In  order\n            Console.WriteLine(item)\n        Next item\n    End Sub\nEnd Class\n\n&#39; This class has a key that can be changed.\n&#39; \nPublic Class MutableKey\n\n    Public Sub New(ByVal newKey As Integer, ByVal newValue As String)\n        _key = newKey\n        Value = newValue\n    End Sub &#39;New\n    \n    Public Value As String\n    Friend Collection As MutableKeys\n    \n    Private _key As Integer\n    Public Property Key As Integer \n        Get\n            Return _key\n        End Get\n        Set\n            If Collection IsNot Nothing Then\n                Collection.ChangeKey(Me, value)\n            End If\n\n            _key = value\n        End Set\n    End Property\n\n    Public Overrides Function ToString() As String \n        Return String.Format(&quot;{0,9} {1}&quot;, _key, Value)\n    End Function\n        \nEnd Class\n\n&#39; This code example produces the following output:\n&#39;\n&#39;DUMP:\n&#39;    Dictionary entries\n&#39;    ------------------\n&#39;    110072674 : 110072674 Widget\n&#39;    110072675 : 110072675 Sprocket\n&#39;\n&#39;    List of items\n&#39;    -------------\n&#39;    110072674 Widget\n&#39;    110072675 Sprocket\n&#39;\n&#39;Create and insert a new item:\n&#39;\n&#39;DUMP:\n&#39;    Dictionary entries\n&#39;    ------------------\n&#39;    110072674 : 110072674 Widget\n&#39;    110072675 : 110072675 Sprocket\n&#39;    110072684 : 110072684 Gear\n&#39;\n&#39;    List of items\n&#39;    -------------\n&#39;    110072674 Widget\n&#39;    110072684 Gear\n&#39;    110072675 Sprocket\n&#39;\n&#39;Try to insert the item again:\n&#39;Error: The item already belongs to a collection.\n&#39;\n&#39;Change the Key property of the item:\n&#39;\n&#39;DUMP:\n&#39;    Dictionary entries\n&#39;    ------------------\n&#39;    110072674 : 110072674 Widget\n&#39;    110072675 : 110072675 Sprocket\n&#39;    100000072 : 100000072 Gear\n&#39;\n&#39;    List of items\n&#39;    -------------\n&#39;    110072674 Widget\n&#39;    100000072 Gear\n&#39;    110072675 Sprocket\n&#39;\n&#39;Try to set the Key property to an existing key:\n&#39;Error: An item with the same key has already been added.\n&#39;\n&#39;DUMP:\n&#39;    Dictionary entries\n&#39;    ------------------\n&#39;    110072674 : 110072674 Widget\n&#39;    110072675 : 110072675 Sprocket\n&#39;    100000072 : 100000072 Gear\n&#39;\n&#39;    List of items\n&#39;    -------------\n&#39;    110072674 Widget\n&#39;    100000072 Gear\n&#39;    110072675 Sprocket\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Collections_ObjectModel_KeyedCollection_2_ClearItems\">\r\n    \r\n            <a id=\"System_Collections_ObjectModel_KeyedCollection_2_ClearItems_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ClearItems()</div>        \r\n          </div>\r\n    \r\n            <p>Removes all elements from the <span class=\"xref\">stem.Collections.ObjectModel.KeyedCollection`2</span>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected override void ClearItems ();</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If there is a lookup dictionary, this method clears it but does not delete it.  </p>\n<p> If the number of elements has exceeded the dictionary creation threshold and the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> is using a lookup dictionary, it will continue to use a lookup dictionary even though the number of elements is again under the threshold.  </p>\n<p> This method is an O(<code>n</code>) operation, where <code>n</code> is <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Count_\" data-linktype=\"relative-path\">Count</a>.  </p>\n<h2 id=\"notes-for-implementers\">Notes for Implementers</h2>\n<p> Override this method to provide customized behavior for the <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Clear_\" data-linktype=\"relative-path\">Clear</a> method, inherited from the <a class=\"xref\" href=\"system.collections.objectmodel.collection-1\" data-linktype=\"relative-path\">Collection&lt;T&gt;</a> generic class.  </p>\n<p> Call the base class implementation of this method to clear the underlying collection and to clear the lookup dictionary.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>This section contains two code examples that demonstrate overriding the ClearItems method to provide custom behavior for clearing all objects from the collection. The first example adds a custom notification event and the second provides support for a collection of objects with mutable keys.  </p>\n<p> Example 1  </p>\n<p> The following code example shows how to override the protected <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_InsertItem_\" data-linktype=\"relative-path\">InsertItem</a>, <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_RemoveItem_\" data-linktype=\"relative-path\">RemoveItem</a>, ClearItems, and <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_SetItem_\" data-linktype=\"relative-path\">SetItem</a> methods, to provide custom behavior for the <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Add_\" data-linktype=\"relative-path\">Add</a>, <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_Remove_\" data-linktype=\"relative-path\">Remove</a>, and <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Clear_\" data-linktype=\"relative-path\">Clear</a> methods, and for setting the default <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Item_\" data-linktype=\"relative-path\">Item</a> property (the indexer in C#). The custom behavior provided in this example is a notification event named <code>Changed</code>, which is raised at the end of each of the overridden methods.  </p>\n<p> The code example creates the <code>SimpleOrder</code> class, which derives from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> and represents a simple order form. The order form contains <code>OrderItem</code> objects representing items ordered. The code example also creates a <code>SimpleOrderChangedEventArgs</code> class to contain the event information, and an enumeration to identify the type of change.  </p>\n<p> The code example demonstrates the custom behavior by calling the properties and methods of the derived class, in the <code>Main</code> method of the <code>Demo</code> class.  </p>\n<p> This code example uses objects with immutable keys. For a code example that uses mutable keys, see <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_ChangeItemKey_\" data-linktype=\"relative-path\">ChangeItemKey</a>.  </p>\n<pre><code class=\"lang-vb\" name=\"KeyedCollection2#1\">Imports System\nImports System.Collections.Generic\nImports System.Collections.ObjectModel\n\n&#39; This class derives from KeyedCollection and shows how to override\n&#39; the protected ClearItems, InsertItem, RemoveItem, and SetItem \n&#39; methods in order to change the behavior of the default Item \n&#39; property and the Add, Clear, Insert, and Remove methods. The\n&#39; class implements a Changed event, which is raised by all the\n&#39; protected methods.\n&#39;\n&#39; SimpleOrder is a collection of OrderItem objects, and its key\n&#39; is the PartNumber field of OrderItem. PartNumber is an Integer,\n&#39; so SimpleOrder inherits KeyedCollection(Of Integer, OrderItem).\n&#39; (Note that the key of OrderItem cannot be changed; if it could \n&#39; be changed, SimpleOrder would have to override ChangeItemKey.)\n&#39;\nPublic Class SimpleOrder\n    Inherits KeyedCollection(Of Integer, OrderItem)\n\n    Public Event Changed As EventHandler(Of SimpleOrderChangedEventArgs)\n\n    &#39; This parameterless constructor calls the base class constructor\n    &#39; that specifies a dictionary threshold of 0, so that the internal\n    &#39; dictionary is created as soon as an item is added to the \n    &#39; collection.\n    &#39;\n    Public Sub New()\n        MyBase.New(Nothing, 0)\n    End Sub\n    \n    &#39; This is the only method that absolutely must be overridden,\n    &#39; because without it the KeyedCollection cannot extract the\n    &#39; keys from the items. \n    &#39;\n    Protected Overrides Function GetKeyForItem( _\n        ByVal item As OrderItem) As Integer\n\n        &#39; In this example, the key is the part number.\n        Return item.PartNumber   \n    End Function\n\n    Protected Overrides Sub InsertItem( _\n        ByVal index As Integer, ByVal newItem As OrderItem)\n\n        MyBase.InsertItem(index, newItem)\n\n        RaiseEvent Changed(Me, New SimpleOrderChangedEventArgs( _\n            ChangeType.Added, newItem, Nothing))\n    End Sub\n\n    Protected Overrides Sub SetItem(ByVal index As Integer, _\n        ByVal newItem As OrderItem)\n\n        Dim replaced As OrderItem = Items(index)\n        MyBase.SetItem(index, newItem)\n\n        RaiseEvent Changed(Me, New SimpleOrderChangedEventArgs( _\n            ChangeType.Replaced, replaced, newItem))\n    End Sub\n\n    Protected Overrides Sub RemoveItem(ByVal index As Integer)\n\n        Dim removedItem As OrderItem = Items(index)\n        MyBase.RemoveItem(index)\n\n        RaiseEvent Changed(Me, New SimpleOrderChangedEventArgs( _\n            ChangeType.Removed, removedItem, Nothing))\n    End Sub\n\n    Protected Overrides Sub ClearItems()\n        MyBase.ClearItems()\n\n        RaiseEvent Changed(Me, New SimpleOrderChangedEventArgs( _\n            ChangeType.Cleared, Nothing, Nothing))\n    End Sub\n\nEnd Class\n\n&#39; Event argument for the Changed event.\n&#39;\nPublic Class SimpleOrderChangedEventArgs\n    Inherits EventArgs\n\n    Private _changedItem As OrderItem\n    Private _changeType As ChangeType\n    Private _replacedWith As OrderItem\n\n    Public ReadOnly Property ChangedItem As OrderItem\n        Get\n            Return _changedItem\n        End Get\n    End Property\n\n    Public ReadOnly Property ChangeType As ChangeType\n        Get\n            Return _changeType\n        End Get\n    End Property\n\n    Public ReadOnly Property ReplacedWith As OrderItem\n        Get\n            Return _replacedWith\n        End Get\n    End Property\n\n    Public Sub New(ByVal change As ChangeType, ByVal item As OrderItem, _\n        ByVal replacement As OrderItem)\n\n        _changeType = change\n        _changedItem = item\n        _replacedWith = replacement\n    End Sub\nEnd Class\n\nPublic Enum ChangeType\n    Added\n    Removed\n    Replaced\n    Cleared\nEnd Enum\n\nPublic Class Demo\n    \n    Public Shared Sub Main() \n        Dim weekly As New SimpleOrder()\n        AddHandler weekly.Changed, AddressOf ChangedHandler\n\n        &#39; The Add method, inherited from Collection, takes OrderItem.\n        &#39;\n        weekly.Add(New OrderItem(110072674, &quot;Widget&quot;, 400, 45.17))\n        weekly.Add(New OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3))\n        weekly.Add(New OrderItem(101030411, &quot;Motor&quot;, 10, 237.5))\n        weekly.Add(New OrderItem(110072684, &quot;Gear&quot;, 175, 5.17))\n\n        Display(weekly)\n        \n        &#39; The Contains method of KeyedCollection takes TKey.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Contains(101030411): {0}&quot;, _\n            weekly.Contains(101030411))\n\n        &#39; The default Item property of KeyedCollection takes the key\n        &#39; type, Integer. The property is read-only.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;weekly(101030411).Description: {0}&quot;, _\n            weekly(101030411).Description)\n\n        &#39; The Remove method of KeyedCollection takes a key.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Remove(101030411)&quot;)\n        weekly.Remove(101030411)\n\n        &#39; The Insert method, inherited from Collection, takes an \n        &#39; index and an OrderItem.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Insert(2, New OrderItem(...))&quot;)\n        weekly.Insert(2, New OrderItem(111033401, &quot;Nut&quot;, 10, .5))\n         \n        &#39; The default Item property is overloaded. One overload comes\n        &#39; from KeyedCollection(Of Integer, OrderItem); that overload\n        &#39; is read-only, and takes Integer because it retrieves by key. \n        &#39; The other overload comes from Collection(Of OrderItem), the \n        &#39; base class of KeyedCollection(Of Integer, OrderItem); it \n        &#39; retrieves by index, so it also takes an Integer. The compiler\n        &#39; uses the most-derived overload, from KeyedCollection, so the\n        &#39; only way to access SimpleOrder by index is to cast it to\n        &#39; Collection(Of OrderItem). Otherwise the index is interpreted\n        &#39; as a key, and KeyNotFoundException is thrown.\n        &#39;\n        Dim coweekly As Collection(Of OrderItem) = weekly\n        Console.WriteLine(vbLf &amp; &quot;coweekly(2).Description: {0}&quot;, _\n            coweekly(2).Description)\n \n        Console.WriteLine(vbLf &amp; &quot;coweekly(2) = New OrderItem(...)&quot;)\n        coweekly(2) = New OrderItem(127700026, &quot;Crank&quot;, 27, 5.98)\n\n        Dim temp As OrderItem = coweekly(2)\n\n        &#39; The IndexOf method, inherited from Collection(Of OrderItem), \n        &#39; takes an OrderItem instead of a key.\n        &#39; \n        Console.WriteLine(vbLf &amp; &quot;IndexOf(temp): {0}&quot;, _\n            weekly.IndexOf(temp))\n\n        &#39; The inherited Remove method also takes an OrderItem.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Remove(temp)&quot;)\n        weekly.Remove(temp)\n\n        Console.WriteLine(vbLf &amp; &quot;RemoveAt(0)&quot;)\n        weekly.RemoveAt(0)\n\n        &#39; Increase the quantity for a line item.\n        Console.WriteLine(vbLf &amp; &quot;coweekly(1) = New OrderItem(...)&quot;)\n        coweekly(1) = New OrderItem(coweekly(1).PartNumber, _\n            coweekly(1).Description, coweekly(1).Quantity + 1000, _\n            coweekly(1).UnitPrice)\n\n        Display(weekly)\n\n        Console.WriteLine()\n        weekly.Clear()\n    End Sub\n    \n    Private Shared Sub Display(ByVal order As SimpleOrder) \n        Console.WriteLine()\n        For Each item As OrderItem In  order\n            Console.WriteLine(item)\n        Next item\n    End Sub\n\n    Private Shared Sub ChangedHandler(ByVal source As Object, _\n        ByVal e As SimpleOrderChangedEventArgs)\n\n        Dim item As OrderItem = e.ChangedItem\n\n        If e.ChangeType = ChangeType.Replaced Then\n            Dim replacement As OrderItem = e.ReplacedWith\n\n            Console.WriteLine(&quot;{0} (quantity {1}) was replaced &quot; &amp; _\n                &quot;by {2}, (quantity {3}).&quot;, item.Description, _\n                item.Quantity, replacement.Description, replacement.Quantity)\n\n        ElseIf e.ChangeType = ChangeType.Cleared Then\n            Console.WriteLine(&quot;The order list was cleared.&quot;)\n\n        Else\n            Console.WriteLine(&quot;{0} (quantity {1}) was {2}.&quot;, _\n                item.Description, item.Quantity, e.ChangeType)\n        End If\n    End Sub\nEnd Class\n\n&#39; This class represents a simple line item in an order. All the \n&#39; values are immutable except quantity.\n&#39; \nPublic Class OrderItem\n    \n    Private _partNumber As Integer\n    Private _description As String\n    Private _unitPrice As Double\n    Private _quantity As Integer\n\n    Public ReadOnly Property PartNumber As Integer\n        Get\n            Return _partNumber\n        End Get\n    End Property\n\n    Public ReadOnly Property Description As String\n        Get\n            Return _description\n        End Get\n    End Property\n\n    Public ReadOnly Property UnitPrice As Double\n        Get\n            Return _unitPrice\n        End Get\n    End Property\n    \n    Public ReadOnly Property Quantity() As Integer \n        Get\n            Return _quantity\n        End Get\n    End Property\n    \n    Public Sub New(ByVal partNumber As Integer, _\n                   ByVal description As String, _\n                   ByVal quantity As Integer, _\n                   ByVal unitPrice As Double) \n        _partNumber = partNumber\n        _description = description\n        _quantity = quantity\n        _unitPrice = unitPrice\n    End Sub &#39;New\n        \n    Public Overrides Function ToString() As String \n        Return String.Format( _\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, _\n            PartNumber, _quantity, Description, UnitPrice, _\n            UnitPrice * _quantity)\n    End Function\nEnd Class\n\n&#39; This code example produces the following output:\n&#39;\n&#39;Widget (quantity 400) was Added.\n&#39;Sprocket (quantity 27) was Added.\n&#39;Motor (quantity 10) was Added.\n&#39;Gear (quantity 175) was Added.\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;101030411     10 Motor        at   237.50 =   2,375.00\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;Contains(101030411): True\n&#39;\n&#39;weekly(101030411).Description: Motor\n&#39;\n&#39;Remove(101030411)\n&#39;Motor (quantity 10) was Removed.\n&#39;\n&#39;Insert(2, New OrderItem(...))\n&#39;Nut (quantity 10) was Added.\n&#39;\n&#39;coweekly(2).Description: Nut\n&#39;\n&#39;coweekly(2) = New OrderItem(...)\n&#39;Nut (quantity 10) was replaced by Crank, (quantity 27).\n&#39;\n&#39;IndexOf(temp): 2\n&#39;\n&#39;Remove(temp)\n&#39;Crank (quantity 27) was Removed.\n&#39;\n&#39;RemoveAt(0)\n&#39;Widget (quantity 400) was Removed.\n&#39;\n&#39;coweekly(1) = New OrderItem(...)\n&#39;Gear (quantity 175) was replaced by Gear, (quantity 1175).\n&#39;\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;110072684   1175 Gear         at     5.17 =   6,074.75\n&#39;\n&#39;The order list was cleared.\n</code></pre><pre><code class=\"lang-cs\" name=\"KeyedCollection2#1\">using System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\n\n// This class derives from KeyedCollection and shows how to override\n// the protected ClearItems, InsertItem, RemoveItem, and SetItem \n// methods in order to change the behavior of the default Item \n// property and the Add, Clear, Insert, and Remove methods. The\n// class implements a Changed event, which is raised by all the\n// protected methods.\n//\n// SimpleOrder is a collection of OrderItem objects, and its key\n// is the PartNumber field of OrderItem. PartNumber is an Integer,\n// so SimpleOrder inherits KeyedCollection&lt;int, OrderItem&gt;.\n// (Note that the key of OrderItem cannot be changed; if it could \n// be changed, SimpleOrder would have to override ChangeItemKey.)\n//\npublic class SimpleOrder : KeyedCollection&lt;int, OrderItem&gt;\n{\n    public event EventHandler&lt;SimpleOrderChangedEventArgs&gt; Changed;\n\n    // This parameterless constructor calls the base class constructor\n    // that specifies a dictionary threshold of 0, so that the internal\n    // dictionary is created as soon as an item is added to the \n    // collection.\n    //\n    public SimpleOrder() : base(null, 0) {}\n    \n    // This is the only method that absolutely must be overridden,\n    // because without it the KeyedCollection cannot extract the\n    // keys from the items. \n    //\n    protected override int GetKeyForItem(OrderItem item)\n    {\n        // In this example, the key is the part number.\n        return item.PartNumber;\n    }\n\n    protected override void InsertItem(int index, OrderItem newItem)\n    {\n        base.InsertItem(index, newItem);\n\n        EventHandler&lt;SimpleOrderChangedEventArgs&gt; temp = Changed;\n        if (temp != null)\n        {\n            temp(this, new SimpleOrderChangedEventArgs(\n                ChangeType.Added, newItem, null));\n        }\n    }\n\n    protected override void SetItem(int index, OrderItem newItem)\n    {\n        OrderItem replaced = Items[index];\n        base.SetItem(index, newItem);\n\n        EventHandler&lt;SimpleOrderChangedEventArgs&gt; temp = Changed;\n        if (temp != null)\n        {\n            temp(this, new SimpleOrderChangedEventArgs(\n                ChangeType.Replaced, replaced, newItem));\n        }\n    }\n\n    protected override void RemoveItem(int index)\n    {\n        OrderItem removedItem = Items[index];\n        base.RemoveItem(index);\n\n        EventHandler&lt;SimpleOrderChangedEventArgs&gt; temp = Changed;\n        if (temp != null)\n        {\n            temp(this, new SimpleOrderChangedEventArgs(\n                ChangeType.Removed, removedItem, null));\n        }\n    }\n\n    protected override void ClearItems()\n    {\n        base.ClearItems();\n\n        EventHandler&lt;SimpleOrderChangedEventArgs&gt; temp = Changed;\n        if (temp != null)\n        {\n            temp(this, new SimpleOrderChangedEventArgs(\n                ChangeType.Cleared, null, null));\n        }\n    }\n}\n\n// Event argument for the Changed event.\n//\npublic class SimpleOrderChangedEventArgs : EventArgs\n{\n    private OrderItem _changedItem;\n    private ChangeType _changeType;\n    private OrderItem _replacedWith;\n\n    public OrderItem ChangedItem { get { return _changedItem; }}\n    public ChangeType ChangeType { get { return _changeType; }}\n    public OrderItem ReplacedWith { get { return _replacedWith; }}\n\n    public SimpleOrderChangedEventArgs(ChangeType change, \n        OrderItem item, OrderItem replacement)\n    {\n        _changeType = change;\n        _changedItem = item;\n        _replacedWith = replacement;\n    }\n}\n\npublic enum ChangeType\n{\n    Added, \n    Removed, \n    Replaced, \n    Cleared\n};\n\npublic class Demo\n{    \n    public static void Main()\n    {\n        SimpleOrder weekly = new SimpleOrder();\n        weekly.Changed += new \n            EventHandler&lt;SimpleOrderChangedEventArgs&gt;(ChangedHandler);\n\n        // The Add method, inherited from Collection, takes OrderItem.\n        //\n        weekly.Add(new OrderItem(110072674, &quot;Widget&quot;, 400, 45.17));\n        weekly.Add(new OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3));\n        weekly.Add(new OrderItem(101030411, &quot;Motor&quot;, 10, 237.5));\n        weekly.Add(new OrderItem(110072684, &quot;Gear&quot;, 175, 5.17));\n\n        Display(weekly);\n        \n        // The Contains method of KeyedCollection takes TKey.\n        //\n        Console.WriteLine(&quot;<br>Contains(101030411): {0}&quot;, \n            weekly.Contains(101030411));\n\n        // The default Item property of KeyedCollection takes the key\n        // type, Integer. The property is read-only.\n        //\n        Console.WriteLine(&quot;<br>weekly[101030411].Description: {0}&quot;, \n            weekly[101030411].Description);\n\n        // The Remove method of KeyedCollection takes a key.\n        //\n        Console.WriteLine(&quot;<br>Remove(101030411)&quot;);\n        weekly.Remove(101030411);\n\n        // The Insert method, inherited from Collection, takes an \n        // index and an OrderItem.\n        //\n        Console.WriteLine(&quot;<br>Insert(2, new OrderItem(...))&quot;);\n        weekly.Insert(2, new OrderItem(111033401, &quot;Nut&quot;, 10, .5));\n         \n        // The default Item property is overloaded. One overload comes\n        // from KeyedCollection&lt;int, OrderItem&gt;; that overload\n        // is read-only, and takes Integer because it retrieves by key. \n        // The other overload comes from Collection&lt;OrderItem&gt;, the \n        // base class of KeyedCollection&lt;int, OrderItem&gt;; it \n        // retrieves by index, so it also takes an Integer. The compiler\n        // uses the most-derived overload, from KeyedCollection, so the\n        // only way to access SimpleOrder by index is to cast it to\n        // Collection&lt;OrderItem&gt;. Otherwise the index is interpreted\n        // as a key, and KeyNotFoundException is thrown.\n        //\n        Collection&lt;OrderItem&gt; coweekly = weekly;\n        Console.WriteLine(&quot;<br>coweekly[2].Description: {0}&quot;, \n            coweekly[2].Description);\n \n        Console.WriteLine(&quot;<br>coweekly[2] = new OrderItem(...)&quot;);\n        coweekly[2] = new OrderItem(127700026, &quot;Crank&quot;, 27, 5.98);\n\n        OrderItem temp = coweekly[2];\n\n        // The IndexOf method, inherited from Collection&lt;OrderItem&gt;, \n        // takes an OrderItem instead of a key.\n        // \n        Console.WriteLine(&quot;<br>IndexOf(temp): {0}&quot;, weekly.IndexOf(temp));\n\n        // The inherited Remove method also takes an OrderItem.\n        //\n        Console.WriteLine(&quot;<br>Remove(temp)&quot;);\n        weekly.Remove(temp);\n\n        Console.WriteLine(&quot;<br>RemoveAt(0)&quot;);\n        weekly.RemoveAt(0);\n\n        // Increase the quantity for a line item.\n        Console.WriteLine(&quot;<br>coweekly(1) = New OrderItem(...)&quot;);\n        coweekly[1] = new OrderItem(coweekly[1].PartNumber, \n            coweekly[1].Description, coweekly[1].Quantity + 1000, \n            coweekly[1].UnitPrice);\n\n        Display(weekly);\n\n        Console.WriteLine();\n        weekly.Clear();\n    }\n    \n    private static void Display(SimpleOrder order)\n    {\n        Console.WriteLine();\n        foreach( OrderItem item in order )\n        {\n            Console.WriteLine(item);\n        }\n    }\n\n    private static void ChangedHandler(object source, \n        SimpleOrderChangedEventArgs e)\n    {\n\n        OrderItem item = e.ChangedItem;\n\n        if (e.ChangeType==ChangeType.Replaced)\n        {\n            OrderItem replacement = e.ReplacedWith;\n\n            Console.WriteLine(&quot;{0} (quantity {1}) was replaced &quot; +\n                &quot;by {2}, (quantity {3}).&quot;, item.Description, \n                item.Quantity, replacement.Description, \n                replacement.Quantity);\n        }\n        else if(e.ChangeType == ChangeType.Cleared)\n        {\n            Console.WriteLine(&quot;The order list was cleared.&quot;);\n        }\n        else\n        {\n            Console.WriteLine(&quot;{0} (quantity {1}) was {2}.&quot;, \n                item.Description, item.Quantity, e.ChangeType);\n        }\n    }\n}\n\n// This class represents a simple line item in an order. All the \n// values are immutable except quantity.\n// \npublic class OrderItem\n{\n    private int _partNumber;\n    private string _description;\n    private double _unitPrice;\n    private int _quantity;\n    \n    public int PartNumber { get { return _partNumber; }}\n    public string Description { get { return _description; }}\n    public double UnitPrice { get { return _unitPrice; }}\n    public int Quantity { get { return _quantity; }}\n    \n    public OrderItem(int partNumber, string description, int quantity, \n        double unitPrice)\n    {\n        _partNumber = partNumber;\n        _description = description;\n        _quantity = quantity;\n        _unitPrice = unitPrice;\n    }\n    \n    public override string ToString()\n    {\n        return String.Format(\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, \n            PartNumber, _quantity, Description, UnitPrice, \n            UnitPrice * _quantity);\n    }\n}\n\n/* This code example produces the following output:\n\nWidget (quantity 400) was Added.\nSprocket (quantity 27) was Added.\nMotor (quantity 10) was Added.\nGear (quantity 175) was Added.\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n101030411     10 Motor        at   237.50 =   2,375.00\n110072684    175 Gear         at     5.17 =     904.75\n\nContains(101030411): True\n\nweekly[101030411].Description: Motor\n\nRemove(101030411)\nMotor (quantity 10) was Removed.\n\nInsert(2, new OrderItem(...))\nNut (quantity 10) was Added.\n\ncoweekly[2].Description: Nut\n\ncoweekly[2] = new OrderItem(...)\nNut (quantity 10) was replaced by Crank, (quantity 27).\n\nIndexOf(temp): 2\n\nRemove(temp)\nCrank (quantity 27) was Removed.\n\nRemoveAt(0)\nWidget (quantity 400) was Removed.\n\ncoweekly(1) = New OrderItem(...)\nGear (quantity 175) was replaced by Gear, (quantity 1175).\n\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684   1175 Gear         at     5.17 =   6,074.75\n\nThe order list was cleared.\n */\n</code></pre><pre><code class=\"lang-cpp\" name=\"KeyedCollection2#1\">using namespace System;\nusing namespace System::Collections::Generic;\nusing namespace System::Collections::ObjectModel;\n\npublic enum class ChangeTypes\n{\n    Added,\n    Removed, \n    Replaced, \n    Cleared\n};\n\nref class SimpleOrderChangedEventArgs; \n\n// This class represents a simple line item in an order. All the \n// values are immutable except quantity.\n// \npublic ref class OrderItem\n{\nprivate:\n    int _quantity;\n\npublic:\n    initonly int PartNumber;\n    initonly String^ Description;\n    initonly double UnitPrice;\n        \n    OrderItem(int partNumber, String^ description, int quantity, \n        double unitPrice)\n    {\n        this-&gt;PartNumber = partNumber;\n        this-&gt;Description = description;\n        this-&gt;Quantity = quantity;\n        this-&gt;UnitPrice = unitPrice;\n    };\n    \n    property int Quantity    \n    {\n        int get() { return _quantity; };\n        void set(int value)\n        {\n            if (value &lt; 0)\n                throw gcnew ArgumentException(&quot;Quantity cannot be negative.&quot;);\n            \n            _quantity = value;\n        };\n    };\n        \n    virtual String^ ToString() override \n    {\n        return String::Format(\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, \n            PartNumber, _quantity, Description, UnitPrice, \n            UnitPrice * _quantity);\n    };\n};\n\n// Event argument for the Changed event.\n//\npublic ref class SimpleOrderChangedEventArgs : EventArgs\n{\npublic:\n    OrderItem^ ChangedItem;\n    initonly ChangeTypes ChangeType;\n    OrderItem^ ReplacedWith;\n\n    SimpleOrderChangedEventArgs(ChangeTypes change, \n        OrderItem^ item, OrderItem^ replacement)\n    {\n        this-&gt;ChangeType = change;\n        this-&gt;ChangedItem = item;\n        this-&gt;ReplacedWith = replacement;\n    }\n};\n\n// This class derives from KeyedCollection and shows how to override\n// the protected ClearItems, InsertItem, RemoveItem, and SetItem \n// methods in order to change the behavior of the default Item \n// property and the Add, Clear, Insert, and Remove methods. The\n// class implements a Changed event, which is raised by all the\n// protected methods.\n//\n// SimpleOrder is a collection of OrderItem objects, and its key\n// is the PartNumber field of OrderItem-&gt; PartNumber is an Integer,\n// so SimpleOrder inherits KeyedCollection&lt;int, OrderItem&gt;.\n// (Note that the key of OrderItem cannot be changed; if it could \n// be changed, SimpleOrder would have to override ChangeItemKey.)\n//\npublic ref class SimpleOrder : KeyedCollection&lt;int, OrderItem^&gt;\n{\npublic:\n    event EventHandler&lt;SimpleOrderChangedEventArgs^&gt;^ Changed;\n\n    // This parameterless constructor calls the base class constructor\n    // that specifies a dictionary threshold of 0, so that the internal\n    // dictionary is created as soon as an item is added to the \n    // collection.\n    //\n    SimpleOrder() : KeyedCollection&lt;int, OrderItem^&gt;(nullptr, 0) {};\n    \n    // This is the only method that absolutely must be overridden,\n    // because without it the KeyedCollection cannot extract the\n    // keys from the items. \n    //\nprotected:\n    virtual int GetKeyForItem(OrderItem^ item) override\n    {\n        // In this example, the key is the part number.\n        return item-&gt;PartNumber;\n    }\n\n    virtual void InsertItem(int index, OrderItem^ newItem) override \n    {\n        __super::InsertItem(index, newItem);\n\n        Changed(this, gcnew SimpleOrderChangedEventArgs(\n            ChangeTypes::Added, newItem, nullptr));\n    }\n\n    virtual void SetItem(int index, OrderItem^ newItem) override \n    {\n        OrderItem^ replaced = this-&gt;Items[index];\n        __super::SetItem(index, newItem);\n\n        Changed(this, gcnew SimpleOrderChangedEventArgs(\n            ChangeTypes::Replaced, replaced, newItem));\n    }\n\n    virtual void RemoveItem(int index) override \n    {\n        OrderItem^ removedItem = Items[index];\n        __super::RemoveItem(index);\n\n        Changed(this, gcnew SimpleOrderChangedEventArgs(\n            ChangeTypes::Removed, removedItem, nullptr));\n    }\n\n    virtual void ClearItems() override \n    {\n        __super::ClearItems();\n\n        Changed(this, gcnew SimpleOrderChangedEventArgs(\n            ChangeTypes::Cleared, nullptr, nullptr));\n    }\n\n    // This method uses the internal reference to the dictionary\n    // to test fo\npublic:\n    void AddOrMerge(OrderItem^ newItem)\n    {\n\n        int key = this-&gt;GetKeyForItem(newItem);\n        OrderItem^ existingItem = nullptr;\n\n        // The dictionary is not created until the first item is \n        // added, so it is necessary to test for null. Using \n        // AndAlso ensures that TryGetValue is not called if the\n        // dictionary does not exist.\n        //\n        if (this-&gt;Dictionary != nullptr &amp;&amp; \n            this-&gt;Dictionary-&gt;TryGetValue(key, existingItem))\n        {\n            existingItem-&gt;Quantity += newItem-&gt;Quantity;\n        }\n        else\n        {\n            this-&gt;Add(newItem);\n        }\n    }\n};\n\npublic ref class Demo\n{    \npublic:\n    static void Main()\n    {\n        SimpleOrder^ weekly = gcnew SimpleOrder();\n        weekly-&gt;Changed += gcnew \n            EventHandler&lt;SimpleOrderChangedEventArgs^&gt;(ChangedHandler);\n\n        // The Add method, inherited from Collection, takes OrderItem-&gt;\n        //\n        weekly-&gt;Add(gcnew OrderItem(110072674, &quot;Widget&quot;, 400, 45.17));\n        weekly-&gt;Add(gcnew OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3));\n        weekly-&gt;Add(gcnew OrderItem(101030411, &quot;Motor&quot;, 10, 237.5));\n        weekly-&gt;Add(gcnew OrderItem(110072684, &quot;Gear&quot;, 175, 5.17));\n\n        Display(weekly);\n        \n        // The Contains method of KeyedCollection takes TKey.\n        //\n        Console::WriteLine(&quot;<br>Contains(101030411): {0}&quot;, \n            weekly-&gt;Contains(101030411));\n\n        // The default Item property of KeyedCollection takes the key\n        // type, Integer. The property is read-only.\n        //\n        Console::WriteLine(&quot;<br>weekly[101030411]-&gt;Description: {0}&quot;, \n            weekly[101030411]-&gt;Description);\n\n        // The Remove method of KeyedCollection takes a key.\n        //\n        Console::WriteLine(&quot;<br>Remove(101030411)&quot;);\n        weekly-&gt;Remove(101030411);\n\n        // The Insert method, inherited from Collection, takes an \n        // index and an OrderItem.\n        //\n        Console::WriteLine(&quot;<br>Insert(2, gcnew OrderItem(...))&quot;);\n        weekly-&gt;Insert(2, gcnew OrderItem(111033401, &quot;Nut&quot;, 10, .5));\n         \n        // The default Item property is overloaded. One overload comes\n        // from KeyedCollection&lt;int, OrderItem&gt;; that overload\n        // is read-only, and takes Integer because it retrieves by key. \n        // The other overload comes from Collection&lt;OrderItem&gt;, the \n        // base class of KeyedCollection&lt;int, OrderItem&gt;; it \n        // retrieves by index, so it also takes an Integer. The compiler\n        // uses the most-derived overload, from KeyedCollection, so the\n        // only way to access SimpleOrder by index is to cast it to\n        // Collection&lt;OrderItem&gt;. Otherwise the index is interpreted\n        // as a key, and KeyNotFoundException is thrown.\n        //\n        Collection&lt;OrderItem^&gt;^ coweekly = weekly;\n        Console::WriteLine(&quot;<br>coweekly[2].Description: {0}&quot;, \n            coweekly[2]-&gt;Description);\n \n        Console::WriteLine(&quot;<br>coweekly[2] = gcnew OrderItem(...)&quot;);\n        coweekly[2] = gcnew OrderItem(127700026, &quot;Crank&quot;, 27, 5.98);\n\n        OrderItem^ temp = coweekly[2];\n\n        // The IndexOf method, inherited from Collection&lt;OrderItem&gt;, \n        // takes an OrderItem instead of a key.\n        // \n        Console::WriteLine(&quot;<br>IndexOf(temp): {0}&quot;, weekly-&gt;IndexOf(temp));\n\n        // The inherited Remove method also takes an OrderItem-&gt;\n        //\n        Console::WriteLine(&quot;<br>Remove(temp)&quot;);\n        weekly-&gt;Remove(temp);\n\n        Console::WriteLine(&quot;<br>RemoveAt(0)&quot;);\n        weekly-&gt;RemoveAt(0);\n\n        weekly-&gt;AddOrMerge(gcnew OrderItem(110072684, &quot;Gear&quot;, 1000, 5.17));\n\n        Display(weekly);\n\n        Console::WriteLine();\n        weekly-&gt;Clear();\n    }\n    \nprivate:\n    static void Display(SimpleOrder^ order)\n    {\n        Console::WriteLine();\n        for each( OrderItem^ item in order )\n        {\n            Console::WriteLine(item);\n        }\n    }\n\n    static void ChangedHandler(Object^ source, \n        SimpleOrderChangedEventArgs^ e)\n    {\n        OrderItem^ item = e-&gt;ChangedItem;\n\n        if (e-&gt;ChangeType == ChangeTypes::Replaced)\n        {\n            OrderItem^ replacement = e-&gt;ReplacedWith;\n\n            Console::WriteLine(&quot;{0} (quantity {1}) was replaced &quot; +\n                &quot;by {2}, (quantity {3}).&quot;, item-&gt;Description, \n                item-&gt;Quantity, replacement-&gt;Description, \n                replacement-&gt;Quantity);\n        }\n        else if(e-&gt;ChangeType == ChangeTypes::Cleared)\n        {\n            Console::WriteLine(&quot;The order list was cleared.&quot;);\n        }\n        else\n        {\n            Console::WriteLine(&quot;{0} (quantity {1}) was {2}.&quot;, \n                item-&gt;Description, item-&gt;Quantity, e-&gt;ChangeType);\n        }\n    }\n};\n\nvoid main()\n{\n    Demo::Main();\n}\n\n/* This code example produces the following output:\n\nWidget (quantity 400) was Added.\nSprocket (quantity 27) was Added.\nMotor (quantity 10) was Added.\nGear (quantity 175) was Added.\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n101030411     10 Motor        at   237.50 =   2,375.00\n110072684    175 Gear         at     5.17 =     904.75\n\nContains(101030411): True\n\nweekly[101030411]-&gt;Description: Motor\n\nRemove(101030411)\nMotor (quantity 10) was Removed.\n\nInsert(2, gcnew OrderItem(...))\nNut (quantity 10) was Added.\n\ncoweekly[2].Description: Nut\n\ncoweekly[2] = gcnew OrderItem(...)\nNut (quantity 10) was replaced by Crank, (quantity 27).\n\nIndexOf(temp): 2\n\nRemove(temp)\nCrank (quantity 27) was Removed.\n\nRemoveAt(0)\nWidget (quantity 400) was Removed.\n\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684   1175 Gear         at     5.17 =   6,074.75\n\nThe order list was cleared.\n */\n</code></pre><p> Example 2  </p>\n<p> The following code example shows how to override the protected <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_ChangeItemKey_\" data-linktype=\"relative-path\">ChangeItemKey</a> method to support mutable keys, and how to override the protected <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_InsertItem_\" data-linktype=\"relative-path\">InsertItem</a>, <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_RemoveItem_\" data-linktype=\"relative-path\">RemoveItem</a>, ClearItems, and <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_SetItem_\" data-linktype=\"relative-path\">SetItem</a> methods to maintain the integrity of the keys and the collection.  </p>\n<p> The code example creates the <code>MutableKeys</code> collection, which derives from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a>, and the <code>MutableKey</code> class. The <code>MutableKey</code> class has a settable <code>Key</code> property. When a new key is assigned to the property, the property setter calls the <code>internal</code> (<code>Friend</code> in Visual Basic) <code>ChangeKey</code> method of the collection to test whether the new key would conflict with an existing key. If so, an exception is thrown and the property value is not changed.  </p>\n<p> In order to maintain the connection between a <code>MutableKey</code> object and the <code>MutableKeys</code> collection and to prevent an object from being inserted into two collections, the <code>MutableKey</code> class has an <code>internal</code> (<code>Friend</code> in Visual Basic) <code>Collection</code> field. This field is maintained by the protected methods that provide custom behavior for adding and removing items from the collection, such as the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_InsertItem_\" data-linktype=\"relative-path\">InsertItem</a> method. The field is set when the item is added to a collection and cleared when the item is removed.  </p>\n<pre><code class=\"lang-cs\" name=\"KeyedCollectionMutable#1\">using System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\n\n// This class demonstrates one way to use the ChangeItemKey\n// method to store objects with keys that can be changed. The \n// ChangeItemKey method is used to keep the internal lookup\n// Dictionary in sync with the keys of the stored objects. \n//\n// MutableKeys stores MutableKey objects, which have an Integer\n// Key property that can be set. Therefore, MutableKeys inherits\n// KeyedCollection(Of Integer, MutableKey).\n//\npublic class MutableKeys : KeyedCollection&lt;int, MutableKey&gt;\n{\n    // This parameterless constructor delegates to the base class \n    // constructor that specifies a dictionary threshold. A\n    // threshold of 0 means the internal Dictionary is created\n    // the first time an object is added.\n    //\n    public MutableKeys() : base(null, 0) {}\n    \n    protected override int GetKeyForItem(MutableKey item)\n    {\n        // The key is MutableKey.Key.\n        return item.Key;\n    }\n\n    protected override void InsertItem(int index, MutableKey newItem)\n    {\n        if (newItem.Collection != null) \n            throw new ArgumentException(&quot;The item already belongs to a collection.&quot;);\n\n        base.InsertItem(index, newItem);\n        newItem.Collection = this;\n    }\n\n    protected override void SetItem(int index, MutableKey newItem)\n    {\n        MutableKey replaced = Items[index];\n\n        if (newItem.Collection != null) \n            throw new ArgumentException(&quot;The item already belongs to a collection.&quot;);\n\n        base.SetItem(index, newItem);\n        newItem.Collection = this;\n        replaced.Collection = null;\n    }\n\n    protected override void RemoveItem(int index)\n    {\n        MutableKey removedItem = Items[index];\n\n        base.RemoveItem(index);\n        removedItem.Collection = null;\n    }\n\n    protected override void ClearItems()\n    {\n        foreach( MutableKey mk in Items )\n        {\n            mk.Collection = null;\n        }\n        \n        base.ClearItems();\n    }\n\n    internal void ChangeKey(MutableKey item, int newKey)\n    {\n        base.ChangeItemKey(item, newKey);\n    }\n    \n    public void Dump()\n    {\n        Console.WriteLine(&quot;<br>DUMP:&quot;);\n        if (Dictionary == null)\n        {\n            Console.WriteLine(&quot;    The dictionary has not been created.&quot;);\n        }\n        else\n        {\n            Console.WriteLine(&quot;    Dictionary entries&quot;);\n            Console.WriteLine(&quot;    ------------------&quot;);\n\n            foreach( KeyValuePair&lt;int, MutableKey&gt; kvp in Dictionary )\n            {\n                Console.WriteLine(&quot;    {0} : {1}&quot;, kvp.Key, kvp.Value);\n            }\n        }\n\n        Console.WriteLine(&quot;<br>    List of items&quot;);\n        Console.WriteLine(&quot;    -------------&quot;);\n\n        foreach( MutableKey mk in Items )\n        {\n            Console.WriteLine(&quot;    {0}&quot;, mk);\n        }\n    }\n}\n\npublic class Demo\n{\n    public static void Main()\n    {\n        MutableKeys mkeys = new MutableKeys();\n\n        // The Add method is inherited from Collection.\n        //\n        mkeys.Add(new MutableKey(110072674, &quot;Widget&quot;));\n        mkeys.Add(new MutableKey(110072675, &quot;Sprocket&quot;));\n\n        mkeys.Dump();\n    \n        Console.WriteLine(&quot;<br>Create and insert a new item:&quot;);\n        MutableKey test = new MutableKey(110072684, &quot;Gear&quot;);\n        mkeys.Insert(1, test);\n\n        mkeys.Dump();\n\n        try\n        {\n            Console.WriteLine(&quot;<br>Try to insert the item again:&quot;);\n            mkeys.Insert(1, test);\n        }\n        catch(ArgumentException ex)\n        {\n            Console.WriteLine(&quot;Error: {0}&quot;, ex.Message);\n        }\n\n        Console.WriteLine(&quot;<br>Change the Key property of the item:&quot;);\n        test.Key = 100000072;\n\n        mkeys.Dump();\n\n        try\n        {\n            Console.WriteLine(&quot;<br>Try to set the Key property to an existing key:&quot;);\n            test.Key = 110072674;\n        }\n        catch(ArgumentException ex)\n        {\n            Console.WriteLine(&quot;Error: {0}&quot;, ex.Message);\n        }\n\n        mkeys.Dump();\n    }\n    \n    private static void Display(MutableKeys order)\n    {\n        Console.WriteLine();\n        foreach( MutableKey item in order )\n        {\n            Console.WriteLine(item);\n        }\n    }\n}\n\n// This class has a key that can be changed.\n// \npublic class MutableKey\n{\n\n    public MutableKey(int newKey, string newValue)\n    {\n        _key = newKey;\n        Value = newValue;\n    } //New\n    \n    public string Value;\n    internal MutableKeys Collection;\n    \n    private int _key;\n    public int Key    \n    {\n        get\n        {\n            return _key;\n        }\n        set\n        {\n            if (Collection != null)\n            {\n                Collection.ChangeKey(this, value);\n            }\n\n            _key = value;\n        }\n    }\n\n    public override string ToString()\n    {\n        return String.Format(&quot;{0,9} {1}&quot;, _key, Value);\n    }\n        \n}\n\n/* This code example produces the following output:\n\nDUMP:\n    Dictionary entries\n    ------------------\n    110072674 : 110072674 Widget\n    110072675 : 110072675 Sprocket\n\n    List of items\n    -------------\n    110072674 Widget\n    110072675 Sprocket\n\nCreate and insert a new item:\n\nDUMP:\n    Dictionary entries\n    ------------------\n    110072674 : 110072674 Widget\n    110072675 : 110072675 Sprocket\n    110072684 : 110072684 Gear\n\n    List of items\n    -------------\n    110072674 Widget\n    110072684 Gear\n    110072675 Sprocket\n\nTry to insert the item again:\nError: The item already belongs to a collection.\n\nChange the Key property of the item:\n\nDUMP:\n    Dictionary entries\n    ------------------\n    110072674 : 110072674 Widget\n    110072675 : 110072675 Sprocket\n    100000072 : 100000072 Gear\n\n    List of items\n    -------------\n    110072674 Widget\n    100000072 Gear\n    110072675 Sprocket\n\nTry to set the Key property to an existing key:\nError: An item with the same key has already been added.\n\nDUMP:\n    Dictionary entries\n    ------------------\n    110072674 : 110072674 Widget\n    110072675 : 110072675 Sprocket\n    100000072 : 100000072 Gear\n\n    List of items\n    -------------\n    110072674 Widget\n    100000072 Gear\n    110072675 Sprocket\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"KeyedCollectionMutable#1\">Imports System\nImports System.Collections.Generic\nImports System.Collections.ObjectModel\n\n&#39; This class demonstrates one way to use the ChangeItemKey\n&#39; method to store objects with keys that can be changed. The \n&#39; ChangeItemKey method is used to keep the internal lookup\n&#39; Dictionary in sync with the keys of the stored objects. \n&#39;\n&#39; MutableKeys stores MutableKey objects, which have an Integer\n&#39; Key property that can be set. Therefore, MutableKeys inherits\n&#39; KeyedCollection(Of Integer, MutableKey).\n&#39;\nPublic Class MutableKeys\n    Inherits KeyedCollection(Of Integer, MutableKey)\n\n    &#39; This parameterless constructor delegates to the base class \n    &#39; constructor that specifies a dictionary threshold. A\n    &#39; threshold of 0 means the internal Dictionary is created\n    &#39; the first time an object is added.\n    &#39;\n    Public Sub New()\n        MyBase.New(Nothing, 0)\n    End Sub\n    \n    Protected Overrides Function GetKeyForItem( _\n        ByVal item As MutableKey) As Integer\n\n        &#39; The key is MutableKey.Key.\n        Return item.Key   \n    End Function\n\n    Protected Overrides Sub InsertItem( _\n        ByVal index As Integer, ByVal newItem As MutableKey)\n\n        If newItem.Collection IsNot Nothing Then _\n            Throw New ArgumentException(&quot;The item already belongs to a collection.&quot;)\n\n        MyBase.InsertItem(index, newItem)\n        newItem.Collection = Me\n    End Sub\n\n    Protected Overrides Sub SetItem(ByVal index As Integer, _\n        ByVal newItem As MutableKey)\n\n        Dim replaced As MutableKey = Items(index)\n\n        If newItem.Collection IsNot Nothing Then _\n            Throw New ArgumentException(&quot;The item already belongs to a collection.&quot;)\n\n        MyBase.SetItem(index, newItem)\n        newItem.Collection = Me\n        replaced.Collection = Nothing\n    End Sub\n\n    Protected Overrides Sub RemoveItem(ByVal index As Integer)\n        Dim removedItem As MutableKey = Items(index)\n\n        MyBase.RemoveItem(index)\n        removedItem.Collection = Nothing\n    End Sub\n\n    Protected Overrides Sub ClearItems()\n        For Each mk As MutableKey In Items\n            mk.Collection = Nothing\n        Next\n        \n        MyBase.ClearItems()\n    End Sub\n\n    Friend Sub ChangeKey(ByVal item As MutableKey, _\n        ByVal newKey As Integer)\n\n        MyBase.ChangeItemKey(item, newKey)\n    End Sub\n    \n    Public Sub Dump()\n        Console.WriteLine(vbLf &amp; &quot;DUMP:&quot;)\n        If Dictionary Is Nothing Then\n            Console.WriteLine(&quot;    The dictionary has not been created.&quot;)\n        Else\n            Console.WriteLine(&quot;    Dictionary entries&quot;)\n            Console.WriteLine(&quot;    ------------------&quot;)\n\n            For Each kvp As KeyValuePair(Of Integer, MutableKey) In Dictionary\n                Console.WriteLine(&quot;    {0} : {1}&quot;, kvp.Key, kvp.Value)\n            Next\n        End If\n\n        Console.WriteLine(vbLf &amp; &quot;    List of items&quot;)\n        Console.WriteLine(&quot;    -------------&quot;)\n\n        For Each mk As MutableKey In Items\n            Console.WriteLine(&quot;    {0}&quot;, mk)\n        Next\n    End Sub\n\nEnd Class\n\nPublic Class Demo\n    \n    Public Shared Sub Main() \n\n        Dim mkeys As New MutableKeys()\n\n        &#39; The Add method is inherited from Collection.\n        &#39;\n        mkeys.Add(New MutableKey(110072674, &quot;Widget&quot;))\n        mkeys.Add(New MutableKey(110072675, &quot;Sprocket&quot;))\n\n        mkeys.Dump() \n    \n        Console.WriteLine(vbLf &amp; &quot;Create and insert a new item:&quot;)\n        Dim test As New MutableKey(110072684, &quot;Gear&quot;)\n        mkeys.Insert(1, test)\n\n        mkeys.Dump()\n\n        Try\n            Console.WriteLine(vbLf &amp; &quot;Try to insert the item again:&quot;)\n            mkeys.Insert(1, test)\n        Catch ex As ArgumentException\n            Console.WriteLine(&quot;Error: {0}&quot;, ex.Message)\n        End Try\n\n        Console.WriteLine(vbLf &amp; &quot;Change the Key property of the item:&quot;)\n        test.Key = 100000072\n\n        mkeys.Dump()\n\n        Try\n            Console.WriteLine(vbLf &amp; &quot;Try to set the Key property to an existing key:&quot;)\n            test.Key = 110072674\n        Catch ex As ArgumentException\n            Console.WriteLine(&quot;Error: {0}&quot;, ex.Message)\n        End Try\n\n        mkeys.Dump()\n\n    End Sub\n    \n    Private Shared Sub Display(ByVal order As MutableKeys) \n        Console.WriteLine()\n        For Each item As MutableKey In  order\n            Console.WriteLine(item)\n        Next item\n    End Sub\nEnd Class\n\n&#39; This class has a key that can be changed.\n&#39; \nPublic Class MutableKey\n\n    Public Sub New(ByVal newKey As Integer, ByVal newValue As String)\n        _key = newKey\n        Value = newValue\n    End Sub &#39;New\n    \n    Public Value As String\n    Friend Collection As MutableKeys\n    \n    Private _key As Integer\n    Public Property Key As Integer \n        Get\n            Return _key\n        End Get\n        Set\n            If Collection IsNot Nothing Then\n                Collection.ChangeKey(Me, value)\n            End If\n\n            _key = value\n        End Set\n    End Property\n\n    Public Overrides Function ToString() As String \n        Return String.Format(&quot;{0,9} {1}&quot;, _key, Value)\n    End Function\n        \nEnd Class\n\n&#39; This code example produces the following output:\n&#39;\n&#39;DUMP:\n&#39;    Dictionary entries\n&#39;    ------------------\n&#39;    110072674 : 110072674 Widget\n&#39;    110072675 : 110072675 Sprocket\n&#39;\n&#39;    List of items\n&#39;    -------------\n&#39;    110072674 Widget\n&#39;    110072675 Sprocket\n&#39;\n&#39;Create and insert a new item:\n&#39;\n&#39;DUMP:\n&#39;    Dictionary entries\n&#39;    ------------------\n&#39;    110072674 : 110072674 Widget\n&#39;    110072675 : 110072675 Sprocket\n&#39;    110072684 : 110072684 Gear\n&#39;\n&#39;    List of items\n&#39;    -------------\n&#39;    110072674 Widget\n&#39;    110072684 Gear\n&#39;    110072675 Sprocket\n&#39;\n&#39;Try to insert the item again:\n&#39;Error: The item already belongs to a collection.\n&#39;\n&#39;Change the Key property of the item:\n&#39;\n&#39;DUMP:\n&#39;    Dictionary entries\n&#39;    ------------------\n&#39;    110072674 : 110072674 Widget\n&#39;    110072675 : 110072675 Sprocket\n&#39;    100000072 : 100000072 Gear\n&#39;\n&#39;    List of items\n&#39;    -------------\n&#39;    110072674 Widget\n&#39;    100000072 Gear\n&#39;    110072675 Sprocket\n&#39;\n&#39;Try to set the Key property to an existing key:\n&#39;Error: An item with the same key has already been added.\n&#39;\n&#39;DUMP:\n&#39;    Dictionary entries\n&#39;    ------------------\n&#39;    110072674 : 110072674 Widget\n&#39;    110072675 : 110072675 Sprocket\n&#39;    100000072 : 100000072 Gear\n&#39;\n&#39;    List of items\n&#39;    -------------\n&#39;    110072674 Widget\n&#39;    100000072 Gear\n&#39;    110072675 Sprocket\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Collections_ObjectModel_KeyedCollection_2_Contains__0_\">\r\n    \r\n            <a id=\"System_Collections_ObjectModel_KeyedCollection_2_Contains_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Contains(TKey)</div>        \r\n          </div>\r\n    \r\n            <p>Determines whether the collection contains an element with the specified key.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool Contains (TKey key);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>key</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><span class=\"xref\">TKey</span></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The key to locate in the <span class=\"xref\">stem.Collections.ObjectModel.KeyedCollection`2</span>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the <span class=\"xref\">stem.Collections.ObjectModel.KeyedCollection`2</span> contains an element with the specified key; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>key</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> has a lookup dictionary, <code>key</code> is used to search the dictionary. If there is no lookup dictionary, the key of each element is extracted using the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_GetKeyForItem_\" data-linktype=\"relative-path\">GetKeyForItem</a> method and compared with the specified key.  </p>\n<p> This method is an O(1) operation if the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> has a lookup dictionary; otherwise it is an O(<code>n</code>) operation, where <code>n</code> is <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Count_\" data-linktype=\"relative-path\">Count</a>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>This code example shows the minimum code necessary to derive a collection class from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a>: overriding the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_GetKeyForItem_\" data-linktype=\"relative-path\">GetKeyForItem</a> method and providing a public constructor that delegates to a base class constructor. The code example also demonstrates many of the properties and methods inherited from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> and <a class=\"xref\" href=\"system.collections.objectmodel.collection-1\" data-linktype=\"relative-path\">Collection&lt;T&gt;</a> classes.  </p>\n<p> The <code>SimpleOrder</code> class is a very simple requisition list that contains <code>OrderItem</code> objects, each of which represents a line item in the order. The key of <code>OrderItem</code> is immutable, an important consideration for classes that derive from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a>. For a code example that uses mutable keys, see <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_ChangeItemKey_\" data-linktype=\"relative-path\">ChangeItemKey</a>.  </p>\n<pre><code class=\"lang-cpp\" name=\"KeyedCollection#1\">using namespace System;\nusing namespace System::Collections::Generic;\nusing namespace System::Collections::ObjectModel;\n\n// This class represents a simple line item in an order. All the \n// values are immutable except quantity.\n// \npublic ref class OrderItem\n{\nprivate:\n    int _quantity;\n    \npublic:\n    initonly int PartNumber;\n    initonly String^ Description;\n    initonly double UnitPrice;\n    \n    OrderItem(int partNumber, String^ description, \n        int quantity, double unitPrice)\n    {\n        this-&gt;PartNumber = partNumber;\n        this-&gt;Description = description;\n        this-&gt;Quantity = quantity;\n        this-&gt;UnitPrice = unitPrice;\n    } \n    \n    property int Quantity    \n    {\n        int get() { return _quantity; }\n        void set(int value)\n        {\n            if (value &lt; 0)\n                throw gcnew ArgumentException(&quot;Quantity cannot be negative.&quot;);\n            \n            _quantity = value;\n        }\n    }\n        \n    virtual String^ ToString() override \n    {\n        return String::Format(\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, \n            PartNumber, _quantity, Description, UnitPrice, \n            UnitPrice * _quantity);\n    }\n};\n\n// This class represents a very simple keyed list of OrderItems,\n// inheriting most of its behavior from the KeyedCollection and \n// Collection classes. The immediate base class is the constructed\n// type KeyedCollection&lt;int, OrderItem&gt;. When you inherit\n// from KeyedCollection, the second generic type argument is the \n// type that you want to store in the collection -- in this case\n// OrderItem. The first type argument is the type that you want\n// to use as a key. Its values must be calculated from OrderItem; \n// in this case it is the int field PartNumber, so SimpleOrder\n// inherits KeyedCollection&lt;int, OrderItem&gt;.\n//\npublic ref class SimpleOrder : KeyedCollection&lt;int, OrderItem^&gt;\n{\n    // The parameterless constructor of the base class creates a \n    // KeyedCollection with an internal dictionary. For this code \n    // example, no other constructors are exposed.\n    //\npublic:\n    SimpleOrder() {}\n    \n    // This is the only method that absolutely must be overridden,\n    // because without it the KeyedCollection cannot extract the\n    // keys from the items. The input parameter type is the \n    // second generic type argument, in this case OrderItem, and \n    // the return value type is the first generic type argument,\n    // in this case int.\n    //\nprotected:\n    virtual int GetKeyForItem(OrderItem^ item) override \n    {\n        // In this example, the key is the part number.\n        return item-&gt;PartNumber;\n    }\n};\n\npublic ref class Demo\n{    \npublic:\n    static void Main()\n    {\n        SimpleOrder^ weekly = gcnew SimpleOrder();\n\n        // The Add method, inherited from Collection, takes OrderItem.\n        //\n        weekly-&gt;Add(gcnew OrderItem(110072674, &quot;Widget&quot;, 400, 45.17));\n        weekly-&gt;Add(gcnew OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3));\n        weekly-&gt;Add(gcnew OrderItem(101030411, &quot;Motor&quot;, 10, 237.5));\n        weekly-&gt;Add(gcnew OrderItem(110072684, &quot;Gear&quot;, 175, 5.17));\n        \n        Display(weekly);\n    \n        // The Contains method of KeyedCollection takes the key, \n        // type, in this case int.\n        //\n        Console::WriteLine(&quot;<br>Contains(101030411): {0}&quot;, \n            weekly-&gt;Contains(101030411));\n\n        // The default Item property of KeyedCollection takes a key.\n        //\n        Console::WriteLine(&quot;<br>weekly(101030411)-&gt;Description: {0}&quot;, \n            weekly[101030411]-&gt;Description);\n\n        // The Remove method of KeyedCollection takes a key.\n        //\n        Console::WriteLine(&quot;<br>Remove(101030411)&quot;);\n        weekly-&gt;Remove(101030411);\n        Display(weekly);\n\n        // The Insert method, inherited from Collection, takes an \n        // index and an OrderItem.\n        //\n        Console::WriteLine(&quot;<br>Insert(2, New OrderItem(...))&quot;);\n        weekly-&gt;Insert(2, gcnew OrderItem(111033401, &quot;Nut&quot;, 10, .5));\n        Display(weekly);\n\n        // The default Item property is overloaded. One overload comes\n        // from KeyedCollection&lt;int, OrderItem&gt;; that overload\n        // is read-only, and takes Integer because it retrieves by key. \n        // The other overload comes from Collection&lt;OrderItem&gt;, the \n        // base class of KeyedCollection&lt;int, OrderItem&gt;; it \n        // retrieves by index, so it also takes an Integer. The compiler\n        // uses the most-derived overload, from KeyedCollection, so the\n        // only way to access SimpleOrder by index is to cast it to\n        // Collection&lt;OrderItem&gt;. Otherwise the index is interpreted\n        // as a key, and KeyNotFoundException is thrown.\n        //\n        Collection&lt;OrderItem^&gt;^ coweekly = weekly;\n        Console::WriteLine(&quot;<br>coweekly[2].Description: {0}&quot;, \n            coweekly[2]-&gt;Description);\n \n        Console::WriteLine(&quot;<br>coweekly[2] = gcnew OrderItem(...)&quot;);\n        coweekly[2] = gcnew OrderItem(127700026, &quot;Crank&quot;, 27, 5.98);\n\n        OrderItem^ temp = coweekly[2];\n\n        // The IndexOf method inherited from Collection&lt;OrderItem&gt; \n        // takes an OrderItem instead of a key\n        // \n        Console::WriteLine(&quot;<br>IndexOf(temp): {0}&quot;, weekly-&gt;IndexOf(temp));\n\n        // The inherited Remove method also takes an OrderItem.\n        //\n        Console::WriteLine(&quot;<br>Remove(temp)&quot;);\n        weekly-&gt;Remove(temp);\n        Display(weekly);\n\n        Console::WriteLine(&quot;<br>RemoveAt(0)&quot;);\n        weekly-&gt;RemoveAt(0);\n        Display(weekly);\n\n    }\n    \nprivate:\n    static void Display(SimpleOrder^ order)\n    {\n        Console::WriteLine();\n        for each( OrderItem^ item in order )\n        {\n            Console::WriteLine(item);\n        }\n    }\n};\n\nvoid main()\n{\n    Demo::Main();\n}\n\n/* This code example produces the following output:\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n101030411     10 Motor        at   237.50 =   2,375.00\n110072684    175 Gear         at     5.17 =     904.75\n\nContains(101030411): True\n\nweekly(101030411)-&gt;Description: Motor\n\nRemove(101030411)\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n\nInsert(2, New OrderItem(...))\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n111033401     10 Nut          at      .50 =       5.00\n110072684    175 Gear         at     5.17 =     904.75\n\ncoweekly(2)-&gt;Description: Nut\n\ncoweekly[2] = gcnew OrderItem(...)\n\nIndexOf(temp): 2\n\nRemove(temp)\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n\nRemoveAt(0)\n\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n */\n</code></pre><pre><code class=\"lang-cs\" name=\"KeyedCollection#1\">using System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\n\n// This class represents a very simple keyed list of OrderItems,\n// inheriting most of its behavior from the KeyedCollection and \n// Collection classes. The immediate base class is the constructed\n// type KeyedCollection&lt;int, OrderItem&gt;. When you inherit\n// from KeyedCollection, the second generic type argument is the \n// type that you want to store in the collection -- in this case\n// OrderItem. The first type argument is the type that you want\n// to use as a key. Its values must be calculated from OrderItem; \n// in this case it is the int field PartNumber, so SimpleOrder\n// inherits KeyedCollection&lt;int, OrderItem&gt;.\n//\npublic class SimpleOrder : KeyedCollection&lt;int, OrderItem&gt;\n{\n       \n    // This is the only method that absolutely must be overridden,\n    // because without it the KeyedCollection cannot extract the\n    // keys from the items. The input parameter type is the \n    // second generic type argument, in this case OrderItem, and \n    // the return value type is the first generic type argument,\n    // in this case int.\n    //\n    protected override int GetKeyForItem(OrderItem item)\n    {\n        // In this example, the key is the part number.\n        return item.PartNumber;\n    }\n}\n\npublic class Demo\n{    \n    public static void Main()\n    {\n        SimpleOrder weekly = new SimpleOrder();\n\n        // The Add method, inherited from Collection, takes OrderItem.\n        //\n        weekly.Add(new OrderItem(110072674, &quot;Widget&quot;, 400, 45.17));\n        weekly.Add(new OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3));\n        weekly.Add(new OrderItem(101030411, &quot;Motor&quot;, 10, 237.5));\n        weekly.Add(new OrderItem(110072684, &quot;Gear&quot;, 175, 5.17));\n        \n        Display(weekly);\n    \n        // The Contains method of KeyedCollection takes the key, \n        // type, in this case int.\n        //\n        Console.WriteLine(&quot;<br>Contains(101030411): {0}&quot;, \n            weekly.Contains(101030411));\n\n        // The default Item property of KeyedCollection takes a key.\n        //\n        Console.WriteLine(&quot;<br>weekly[101030411].Description: {0}&quot;, \n            weekly[101030411].Description);\n\n        // The Remove method of KeyedCollection takes a key.\n        //\n        Console.WriteLine(&quot;<br>Remove(101030411)&quot;);\n        weekly.Remove(101030411);\n        Display(weekly);\n\n        // The Insert method, inherited from Collection, takes an \n        // index and an OrderItem.\n        //\n        Console.WriteLine(&quot;<br>Insert(2, New OrderItem(...))&quot;);\n        weekly.Insert(2, new OrderItem(111033401, &quot;Nut&quot;, 10, .5));\n        Display(weekly);\n\n        // The default Item property is overloaded. One overload comes\n        // from KeyedCollection&lt;int, OrderItem&gt;; that overload\n        // is read-only, and takes Integer because it retrieves by key. \n        // The other overload comes from Collection&lt;OrderItem&gt;, the \n        // base class of KeyedCollection&lt;int, OrderItem&gt;; it \n        // retrieves by index, so it also takes an Integer. The compiler\n        // uses the most-derived overload, from KeyedCollection, so the\n        // only way to access SimpleOrder by index is to cast it to\n        // Collection&lt;OrderItem&gt;. Otherwise the index is interpreted\n        // as a key, and KeyNotFoundException is thrown.\n        //\n        Collection&lt;OrderItem&gt; coweekly = weekly;\n        Console.WriteLine(&quot;<br>coweekly[2].Description: {0}&quot;, \n            coweekly[2].Description);\n \n        Console.WriteLine(&quot;<br>coweekly[2] = new OrderItem(...)&quot;);\n        coweekly[2] = new OrderItem(127700026, &quot;Crank&quot;, 27, 5.98);\n\n        OrderItem temp = coweekly[2];\n\n        // The IndexOf method inherited from Collection&lt;OrderItem&gt; \n        // takes an OrderItem instead of a key\n        // \n        Console.WriteLine(&quot;<br>IndexOf(temp): {0}&quot;, weekly.IndexOf(temp));\n\n        // The inherited Remove method also takes an OrderItem.\n        //\n        Console.WriteLine(&quot;<br>Remove(temp)&quot;);\n        weekly.Remove(temp);\n        Display(weekly);\n\n        Console.WriteLine(&quot;<br>RemoveAt(0)&quot;);\n        weekly.RemoveAt(0);\n        Display(weekly);\n\n    }\n    \n    private static void Display(SimpleOrder order)\n    {\n        Console.WriteLine();\n        foreach( OrderItem item in order )\n        {\n            Console.WriteLine(item);\n        }\n    }\n}\n\n// This class represents a simple line item in an order. All the \n// values are immutable except quantity.\n// \npublic class OrderItem\n{\n    public readonly int PartNumber;\n    public readonly string Description;\n    public readonly double UnitPrice;\n    \n    private int _quantity = 0;\n    \n    public OrderItem(int partNumber, string description, \n        int quantity, double unitPrice)\n    {\n        this.PartNumber = partNumber;\n        this.Description = description;\n        this.Quantity = quantity;\n        this.UnitPrice = unitPrice;\n    } \n    \n    public int Quantity    \n    {\n        get { return _quantity; }\n        set\n        {\n            if (value&lt;0)\n                throw new ArgumentException(&quot;Quantity cannot be negative.&quot;);\n            \n            _quantity = value;\n        }\n    }\n        \n    public override string ToString()\n    {\n        return String.Format(\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, \n            PartNumber, _quantity, Description, UnitPrice, \n            UnitPrice * _quantity);\n    }\n}\n\n/* This code example produces the following output:\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n101030411     10 Motor        at   237.50 =   2,375.00\n110072684    175 Gear         at     5.17 =     904.75\n\nContains(101030411): True\n\nweekly[101030411].Description: Motor\n\nRemove(101030411)\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n\nInsert(2, New OrderItem(...))\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n111033401     10 Nut          at      .50 =       5.00\n110072684    175 Gear         at     5.17 =     904.75\n\ncoweekly[2].Description: Nut\n\ncoweekly[2] = new OrderItem(...)\n\nIndexOf(temp): 2\n\nRemove(temp)\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n\nRemoveAt(0)\n\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"KeyedCollection#1\">Imports System\nImports System.Collections.Generic\nImports System.Collections.ObjectModel\n\n&#39; This class represents a very simple keyed list of OrderItems,\n&#39; inheriting most of its behavior from the KeyedCollection and \n&#39; Collection classes. The immediate base class is the constructed\n&#39; type KeyedCollection(Of Integer, OrderItem). When you inherit\n&#39; from KeyedCollection, the second generic type argument is the \n&#39; type that you want to store in the collection -- in this case\n&#39; OrderItem. The first generic argument is the type that you want\n&#39; to use as a key. Its values must be calculated from OrderItem; \n&#39; in this case it is the Integer field PartNumber, so SimpleOrder\n&#39; inherits KeyedCollection(Of Integer, OrderItem).\n&#39;\nPublic Class SimpleOrder\n    Inherits KeyedCollection(Of Integer, OrderItem)\n\n\n    &#39; This is the only method that absolutely must be overridden,\n    &#39; because without it the KeyedCollection cannot extract the\n    &#39; keys from the items. The input parameter type is the \n    &#39; second generic type argument, in this case OrderItem, and \n    &#39; the return value type is the first generic type argument,\n    &#39; in this case Integer.\n    &#39;\n    Protected Overrides Function GetKeyForItem( _\n        ByVal item As OrderItem) As Integer\n\n        &#39; In this example, the key is the part number.\n        Return item.PartNumber   \n    End Function\n\nEnd Class\n\nPublic Class Demo\n    \n    Public Shared Sub Main() \n        Dim weekly As New SimpleOrder()\n\n        &#39; The Add method, inherited from Collection, takes OrderItem.\n        &#39;\n        weekly.Add(New OrderItem(110072674, &quot;Widget&quot;, 400, 45.17))\n        weekly.Add(New OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3))\n        weekly.Add(New OrderItem(101030411, &quot;Motor&quot;, 10, 237.5))\n        weekly.Add(New OrderItem(110072684, &quot;Gear&quot;, 175, 5.17))\n        \n        Display(weekly)\n    \n        &#39; The Contains method of KeyedCollection takes TKey.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Contains(101030411): {0}&quot;, _\n            weekly.Contains(101030411))\n\n        &#39; The default Item property of KeyedCollection takes the key\n        &#39; type, Integer.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;weekly(101030411).Description: {0}&quot;, _\n            weekly(101030411).Description)\n\n        &#39; The Remove method of KeyedCollection takes a key.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Remove(101030411)&quot;)\n        weekly.Remove(101030411)\n        Display(weekly)\n\n        &#39; The Insert method, inherited from Collection, takes an \n        &#39; index and an OrderItem.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Insert(2, New OrderItem(...))&quot;)\n        weekly.Insert(2, New OrderItem(111033401, &quot;Nut&quot;, 10, .5))\n        Display(weekly)\n\n        &#39; The default Item property is overloaded. One overload comes\n        &#39; from KeyedCollection(Of Integer, OrderItem); that overload\n        &#39; is read-only, and takes Integer because it retrieves by key. \n        &#39; The other overload comes from Collection(Of OrderItem), the \n        &#39; base class of KeyedCollection(Of Integer, OrderItem); it \n        &#39; retrieves by index, so it also takes an Integer. The compiler\n        &#39; uses the most-derived overload, from KeyedCollection, so the\n        &#39; only way to access SimpleOrder by index is to cast it to\n        &#39; Collection(Of OrderItem). Otherwise the index is interpreted\n        &#39; as a key, and KeyNotFoundException is thrown.\n        &#39;\n        Dim coweekly As Collection(Of OrderItem) = weekly\n        Console.WriteLine(vbLf &amp; &quot;coweekly(2).Description: {0}&quot;, _\n            coweekly(2).Description)\n \n        Console.WriteLine(vbLf &amp; &quot;coweekly(2) = New OrderItem(...)&quot;)\n        coweekly(2) = New OrderItem(127700026, &quot;Crank&quot;, 27, 5.98)\n\n        Dim temp As OrderItem = coweekly(2)\n\n        &#39; The IndexOf method, inherited from Collection(Of OrderItem), \n        &#39; takes an OrderItem instead of a key.\n        &#39; \n        Console.WriteLine(vbLf &amp; &quot;IndexOf(temp): {0}&quot;, _\n            weekly.IndexOf(temp))\n\n        &#39; The inherited Remove method also takes an OrderItem.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Remove(temp)&quot;)\n        weekly.Remove(temp)\n        Display(weekly)\n\n        Console.WriteLine(vbLf &amp; &quot;RemoveAt(0)&quot;)\n        weekly.RemoveAt(0)\n        Display(weekly)\n\n    End Sub\n    \n    Private Shared Sub Display(ByVal order As SimpleOrder) \n        Console.WriteLine()\n        For Each item As OrderItem In  order\n            Console.WriteLine(item)\n        Next item\n    End Sub\nEnd Class\n\n&#39; This class represents a simple line item in an order. All the \n&#39; values are immutable except quantity.\n&#39; \nPublic Class OrderItem\n    Public ReadOnly PartNumber As Integer\n    Public ReadOnly Description As String\n    Public ReadOnly UnitPrice As Double\n    \n    Private _quantity As Integer = 0\n    \n    Public Sub New(ByVal partNumber As Integer, _\n                   ByVal description As String, _\n                   ByVal quantity As Integer, _\n                   ByVal unitPrice As Double) \n        Me.PartNumber = partNumber\n        Me.Description = description\n        Me.Quantity = quantity\n        Me.UnitPrice = unitPrice\n    End Sub &#39;New\n    \n    Public Property Quantity() As Integer \n        Get\n            Return _quantity\n        End Get\n        Set\n            If value &lt; 0 Then\n                Throw New ArgumentException(&quot;Quantity cannot be negative.&quot;)\n            End If\n            _quantity = value\n        End Set\n    End Property\n        \n    Public Overrides Function ToString() As String \n        Return String.Format( _\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, _\n            PartNumber, _quantity, Description, UnitPrice, _\n            UnitPrice * _quantity)\n    End Function\nEnd Class\n\n&#39; This code example produces the following output:\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;101030411     10 Motor        at   237.50 =   2,375.00\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;Contains(101030411): True\n&#39;\n&#39;weekly(101030411).Description: Motor\n&#39;\n&#39;Remove(101030411)\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;Insert(2, New OrderItem(...))\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;111033401     10 Nut          at      .50 =       5.00\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;coweekly(2).Description: Nut\n&#39;\n&#39;coweekly(2) = New OrderItem(...)\n&#39;\n&#39;IndexOf(temp): 2\n&#39;\n&#39;Remove(temp)\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;RemoveAt(0)\n&#39;\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;110072684    175 Gear         at     5.17 =     904.75\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Collections_ObjectModel_KeyedCollection_2_GetKeyForItem__1_\">\r\n    \r\n            <a id=\"System_Collections_ObjectModel_KeyedCollection_2_GetKeyForItem_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetKeyForItem(TItem)</div>        \r\n          </div>\r\n    \r\n            <p>When implemented in a derived class, extracts the key from the specified element.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected abstract TKey GetKeyForItem (TItem item);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>item</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><span class=\"xref\">TItem</span></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The element from which to extract the key.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><span class=\"xref\">TKey</span></div>\r\n                  </div>\r\n                  <p>The key for the specified element.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the key in the lookup dictionary is different from the key that is embedded in <code>item</code>, you cannot access <code>item</code> by using the key returned by GetKeyForItem.  </p>\n<p> You can implement this method to return <code>null</code> for a collection that contains items without keys, in which case the items can be accessed only by their index. This method is an O(1) operation.  </p>\n<h2 id=\"notes-for-implementers\">Notes for Implementers</h2>\n<p> You must override this method to provide the dictionary with a way to extract keys from items in the dictionary.  </p>\n<p> This method is called internally. It is not necessary for it to be public.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>This code example shows the minimum code necessary to derive a collection class from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a>: overriding the GetKeyForItem method and providing a public constructor that delegates to a base class constructor. The code example also demonstrates many of the properties and methods inherited from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> and <a class=\"xref\" href=\"system.collections.objectmodel.collection-1\" data-linktype=\"relative-path\">Collection&lt;T&gt;</a> classes.  </p>\n<p> The <code>SimpleOrder</code> class is a very simple requisition list that contains <code>OrderItem</code> objects, each of which represents a line item in the order. The key of <code>OrderItem</code> is immutable, an important consideration for classes that derive from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a>. For a code example that uses mutable keys, see <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_ChangeItemKey_\" data-linktype=\"relative-path\">ChangeItemKey</a>.  </p>\n<pre><code class=\"lang-cpp\" name=\"KeyedCollection#1\">using namespace System;\nusing namespace System::Collections::Generic;\nusing namespace System::Collections::ObjectModel;\n\n// This class represents a simple line item in an order. All the \n// values are immutable except quantity.\n// \npublic ref class OrderItem\n{\nprivate:\n    int _quantity;\n    \npublic:\n    initonly int PartNumber;\n    initonly String^ Description;\n    initonly double UnitPrice;\n    \n    OrderItem(int partNumber, String^ description, \n        int quantity, double unitPrice)\n    {\n        this-&gt;PartNumber = partNumber;\n        this-&gt;Description = description;\n        this-&gt;Quantity = quantity;\n        this-&gt;UnitPrice = unitPrice;\n    } \n    \n    property int Quantity    \n    {\n        int get() { return _quantity; }\n        void set(int value)\n        {\n            if (value &lt; 0)\n                throw gcnew ArgumentException(&quot;Quantity cannot be negative.&quot;);\n            \n            _quantity = value;\n        }\n    }\n        \n    virtual String^ ToString() override \n    {\n        return String::Format(\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, \n            PartNumber, _quantity, Description, UnitPrice, \n            UnitPrice * _quantity);\n    }\n};\n\n// This class represents a very simple keyed list of OrderItems,\n// inheriting most of its behavior from the KeyedCollection and \n// Collection classes. The immediate base class is the constructed\n// type KeyedCollection&lt;int, OrderItem&gt;. When you inherit\n// from KeyedCollection, the second generic type argument is the \n// type that you want to store in the collection -- in this case\n// OrderItem. The first type argument is the type that you want\n// to use as a key. Its values must be calculated from OrderItem; \n// in this case it is the int field PartNumber, so SimpleOrder\n// inherits KeyedCollection&lt;int, OrderItem&gt;.\n//\npublic ref class SimpleOrder : KeyedCollection&lt;int, OrderItem^&gt;\n{\n    // The parameterless constructor of the base class creates a \n    // KeyedCollection with an internal dictionary. For this code \n    // example, no other constructors are exposed.\n    //\npublic:\n    SimpleOrder() {}\n    \n    // This is the only method that absolutely must be overridden,\n    // because without it the KeyedCollection cannot extract the\n    // keys from the items. The input parameter type is the \n    // second generic type argument, in this case OrderItem, and \n    // the return value type is the first generic type argument,\n    // in this case int.\n    //\nprotected:\n    virtual int GetKeyForItem(OrderItem^ item) override \n    {\n        // In this example, the key is the part number.\n        return item-&gt;PartNumber;\n    }\n};\n\npublic ref class Demo\n{    \npublic:\n    static void Main()\n    {\n        SimpleOrder^ weekly = gcnew SimpleOrder();\n\n        // The Add method, inherited from Collection, takes OrderItem.\n        //\n        weekly-&gt;Add(gcnew OrderItem(110072674, &quot;Widget&quot;, 400, 45.17));\n        weekly-&gt;Add(gcnew OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3));\n        weekly-&gt;Add(gcnew OrderItem(101030411, &quot;Motor&quot;, 10, 237.5));\n        weekly-&gt;Add(gcnew OrderItem(110072684, &quot;Gear&quot;, 175, 5.17));\n        \n        Display(weekly);\n    \n        // The Contains method of KeyedCollection takes the key, \n        // type, in this case int.\n        //\n        Console::WriteLine(&quot;<br>Contains(101030411): {0}&quot;, \n            weekly-&gt;Contains(101030411));\n\n        // The default Item property of KeyedCollection takes a key.\n        //\n        Console::WriteLine(&quot;<br>weekly(101030411)-&gt;Description: {0}&quot;, \n            weekly[101030411]-&gt;Description);\n\n        // The Remove method of KeyedCollection takes a key.\n        //\n        Console::WriteLine(&quot;<br>Remove(101030411)&quot;);\n        weekly-&gt;Remove(101030411);\n        Display(weekly);\n\n        // The Insert method, inherited from Collection, takes an \n        // index and an OrderItem.\n        //\n        Console::WriteLine(&quot;<br>Insert(2, New OrderItem(...))&quot;);\n        weekly-&gt;Insert(2, gcnew OrderItem(111033401, &quot;Nut&quot;, 10, .5));\n        Display(weekly);\n\n        // The default Item property is overloaded. One overload comes\n        // from KeyedCollection&lt;int, OrderItem&gt;; that overload\n        // is read-only, and takes Integer because it retrieves by key. \n        // The other overload comes from Collection&lt;OrderItem&gt;, the \n        // base class of KeyedCollection&lt;int, OrderItem&gt;; it \n        // retrieves by index, so it also takes an Integer. The compiler\n        // uses the most-derived overload, from KeyedCollection, so the\n        // only way to access SimpleOrder by index is to cast it to\n        // Collection&lt;OrderItem&gt;. Otherwise the index is interpreted\n        // as a key, and KeyNotFoundException is thrown.\n        //\n        Collection&lt;OrderItem^&gt;^ coweekly = weekly;\n        Console::WriteLine(&quot;<br>coweekly[2].Description: {0}&quot;, \n            coweekly[2]-&gt;Description);\n \n        Console::WriteLine(&quot;<br>coweekly[2] = gcnew OrderItem(...)&quot;);\n        coweekly[2] = gcnew OrderItem(127700026, &quot;Crank&quot;, 27, 5.98);\n\n        OrderItem^ temp = coweekly[2];\n\n        // The IndexOf method inherited from Collection&lt;OrderItem&gt; \n        // takes an OrderItem instead of a key\n        // \n        Console::WriteLine(&quot;<br>IndexOf(temp): {0}&quot;, weekly-&gt;IndexOf(temp));\n\n        // The inherited Remove method also takes an OrderItem.\n        //\n        Console::WriteLine(&quot;<br>Remove(temp)&quot;);\n        weekly-&gt;Remove(temp);\n        Display(weekly);\n\n        Console::WriteLine(&quot;<br>RemoveAt(0)&quot;);\n        weekly-&gt;RemoveAt(0);\n        Display(weekly);\n\n    }\n    \nprivate:\n    static void Display(SimpleOrder^ order)\n    {\n        Console::WriteLine();\n        for each( OrderItem^ item in order )\n        {\n            Console::WriteLine(item);\n        }\n    }\n};\n\nvoid main()\n{\n    Demo::Main();\n}\n\n/* This code example produces the following output:\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n101030411     10 Motor        at   237.50 =   2,375.00\n110072684    175 Gear         at     5.17 =     904.75\n\nContains(101030411): True\n\nweekly(101030411)-&gt;Description: Motor\n\nRemove(101030411)\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n\nInsert(2, New OrderItem(...))\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n111033401     10 Nut          at      .50 =       5.00\n110072684    175 Gear         at     5.17 =     904.75\n\ncoweekly(2)-&gt;Description: Nut\n\ncoweekly[2] = gcnew OrderItem(...)\n\nIndexOf(temp): 2\n\nRemove(temp)\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n\nRemoveAt(0)\n\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n */\n</code></pre><pre><code class=\"lang-cs\" name=\"KeyedCollection#1\">using System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\n\n// This class represents a very simple keyed list of OrderItems,\n// inheriting most of its behavior from the KeyedCollection and \n// Collection classes. The immediate base class is the constructed\n// type KeyedCollection&lt;int, OrderItem&gt;. When you inherit\n// from KeyedCollection, the second generic type argument is the \n// type that you want to store in the collection -- in this case\n// OrderItem. The first type argument is the type that you want\n// to use as a key. Its values must be calculated from OrderItem; \n// in this case it is the int field PartNumber, so SimpleOrder\n// inherits KeyedCollection&lt;int, OrderItem&gt;.\n//\npublic class SimpleOrder : KeyedCollection&lt;int, OrderItem&gt;\n{\n       \n    // This is the only method that absolutely must be overridden,\n    // because without it the KeyedCollection cannot extract the\n    // keys from the items. The input parameter type is the \n    // second generic type argument, in this case OrderItem, and \n    // the return value type is the first generic type argument,\n    // in this case int.\n    //\n    protected override int GetKeyForItem(OrderItem item)\n    {\n        // In this example, the key is the part number.\n        return item.PartNumber;\n    }\n}\n\npublic class Demo\n{    \n    public static void Main()\n    {\n        SimpleOrder weekly = new SimpleOrder();\n\n        // The Add method, inherited from Collection, takes OrderItem.\n        //\n        weekly.Add(new OrderItem(110072674, &quot;Widget&quot;, 400, 45.17));\n        weekly.Add(new OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3));\n        weekly.Add(new OrderItem(101030411, &quot;Motor&quot;, 10, 237.5));\n        weekly.Add(new OrderItem(110072684, &quot;Gear&quot;, 175, 5.17));\n        \n        Display(weekly);\n    \n        // The Contains method of KeyedCollection takes the key, \n        // type, in this case int.\n        //\n        Console.WriteLine(&quot;<br>Contains(101030411): {0}&quot;, \n            weekly.Contains(101030411));\n\n        // The default Item property of KeyedCollection takes a key.\n        //\n        Console.WriteLine(&quot;<br>weekly[101030411].Description: {0}&quot;, \n            weekly[101030411].Description);\n\n        // The Remove method of KeyedCollection takes a key.\n        //\n        Console.WriteLine(&quot;<br>Remove(101030411)&quot;);\n        weekly.Remove(101030411);\n        Display(weekly);\n\n        // The Insert method, inherited from Collection, takes an \n        // index and an OrderItem.\n        //\n        Console.WriteLine(&quot;<br>Insert(2, New OrderItem(...))&quot;);\n        weekly.Insert(2, new OrderItem(111033401, &quot;Nut&quot;, 10, .5));\n        Display(weekly);\n\n        // The default Item property is overloaded. One overload comes\n        // from KeyedCollection&lt;int, OrderItem&gt;; that overload\n        // is read-only, and takes Integer because it retrieves by key. \n        // The other overload comes from Collection&lt;OrderItem&gt;, the \n        // base class of KeyedCollection&lt;int, OrderItem&gt;; it \n        // retrieves by index, so it also takes an Integer. The compiler\n        // uses the most-derived overload, from KeyedCollection, so the\n        // only way to access SimpleOrder by index is to cast it to\n        // Collection&lt;OrderItem&gt;. Otherwise the index is interpreted\n        // as a key, and KeyNotFoundException is thrown.\n        //\n        Collection&lt;OrderItem&gt; coweekly = weekly;\n        Console.WriteLine(&quot;<br>coweekly[2].Description: {0}&quot;, \n            coweekly[2].Description);\n \n        Console.WriteLine(&quot;<br>coweekly[2] = new OrderItem(...)&quot;);\n        coweekly[2] = new OrderItem(127700026, &quot;Crank&quot;, 27, 5.98);\n\n        OrderItem temp = coweekly[2];\n\n        // The IndexOf method inherited from Collection&lt;OrderItem&gt; \n        // takes an OrderItem instead of a key\n        // \n        Console.WriteLine(&quot;<br>IndexOf(temp): {0}&quot;, weekly.IndexOf(temp));\n\n        // The inherited Remove method also takes an OrderItem.\n        //\n        Console.WriteLine(&quot;<br>Remove(temp)&quot;);\n        weekly.Remove(temp);\n        Display(weekly);\n\n        Console.WriteLine(&quot;<br>RemoveAt(0)&quot;);\n        weekly.RemoveAt(0);\n        Display(weekly);\n\n    }\n    \n    private static void Display(SimpleOrder order)\n    {\n        Console.WriteLine();\n        foreach( OrderItem item in order )\n        {\n            Console.WriteLine(item);\n        }\n    }\n}\n\n// This class represents a simple line item in an order. All the \n// values are immutable except quantity.\n// \npublic class OrderItem\n{\n    public readonly int PartNumber;\n    public readonly string Description;\n    public readonly double UnitPrice;\n    \n    private int _quantity = 0;\n    \n    public OrderItem(int partNumber, string description, \n        int quantity, double unitPrice)\n    {\n        this.PartNumber = partNumber;\n        this.Description = description;\n        this.Quantity = quantity;\n        this.UnitPrice = unitPrice;\n    } \n    \n    public int Quantity    \n    {\n        get { return _quantity; }\n        set\n        {\n            if (value&lt;0)\n                throw new ArgumentException(&quot;Quantity cannot be negative.&quot;);\n            \n            _quantity = value;\n        }\n    }\n        \n    public override string ToString()\n    {\n        return String.Format(\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, \n            PartNumber, _quantity, Description, UnitPrice, \n            UnitPrice * _quantity);\n    }\n}\n\n/* This code example produces the following output:\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n101030411     10 Motor        at   237.50 =   2,375.00\n110072684    175 Gear         at     5.17 =     904.75\n\nContains(101030411): True\n\nweekly[101030411].Description: Motor\n\nRemove(101030411)\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n\nInsert(2, New OrderItem(...))\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n111033401     10 Nut          at      .50 =       5.00\n110072684    175 Gear         at     5.17 =     904.75\n\ncoweekly[2].Description: Nut\n\ncoweekly[2] = new OrderItem(...)\n\nIndexOf(temp): 2\n\nRemove(temp)\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n\nRemoveAt(0)\n\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"KeyedCollection#1\">Imports System\nImports System.Collections.Generic\nImports System.Collections.ObjectModel\n\n&#39; This class represents a very simple keyed list of OrderItems,\n&#39; inheriting most of its behavior from the KeyedCollection and \n&#39; Collection classes. The immediate base class is the constructed\n&#39; type KeyedCollection(Of Integer, OrderItem). When you inherit\n&#39; from KeyedCollection, the second generic type argument is the \n&#39; type that you want to store in the collection -- in this case\n&#39; OrderItem. The first generic argument is the type that you want\n&#39; to use as a key. Its values must be calculated from OrderItem; \n&#39; in this case it is the Integer field PartNumber, so SimpleOrder\n&#39; inherits KeyedCollection(Of Integer, OrderItem).\n&#39;\nPublic Class SimpleOrder\n    Inherits KeyedCollection(Of Integer, OrderItem)\n\n\n    &#39; This is the only method that absolutely must be overridden,\n    &#39; because without it the KeyedCollection cannot extract the\n    &#39; keys from the items. The input parameter type is the \n    &#39; second generic type argument, in this case OrderItem, and \n    &#39; the return value type is the first generic type argument,\n    &#39; in this case Integer.\n    &#39;\n    Protected Overrides Function GetKeyForItem( _\n        ByVal item As OrderItem) As Integer\n\n        &#39; In this example, the key is the part number.\n        Return item.PartNumber   \n    End Function\n\nEnd Class\n\nPublic Class Demo\n    \n    Public Shared Sub Main() \n        Dim weekly As New SimpleOrder()\n\n        &#39; The Add method, inherited from Collection, takes OrderItem.\n        &#39;\n        weekly.Add(New OrderItem(110072674, &quot;Widget&quot;, 400, 45.17))\n        weekly.Add(New OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3))\n        weekly.Add(New OrderItem(101030411, &quot;Motor&quot;, 10, 237.5))\n        weekly.Add(New OrderItem(110072684, &quot;Gear&quot;, 175, 5.17))\n        \n        Display(weekly)\n    \n        &#39; The Contains method of KeyedCollection takes TKey.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Contains(101030411): {0}&quot;, _\n            weekly.Contains(101030411))\n\n        &#39; The default Item property of KeyedCollection takes the key\n        &#39; type, Integer.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;weekly(101030411).Description: {0}&quot;, _\n            weekly(101030411).Description)\n\n        &#39; The Remove method of KeyedCollection takes a key.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Remove(101030411)&quot;)\n        weekly.Remove(101030411)\n        Display(weekly)\n\n        &#39; The Insert method, inherited from Collection, takes an \n        &#39; index and an OrderItem.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Insert(2, New OrderItem(...))&quot;)\n        weekly.Insert(2, New OrderItem(111033401, &quot;Nut&quot;, 10, .5))\n        Display(weekly)\n\n        &#39; The default Item property is overloaded. One overload comes\n        &#39; from KeyedCollection(Of Integer, OrderItem); that overload\n        &#39; is read-only, and takes Integer because it retrieves by key. \n        &#39; The other overload comes from Collection(Of OrderItem), the \n        &#39; base class of KeyedCollection(Of Integer, OrderItem); it \n        &#39; retrieves by index, so it also takes an Integer. The compiler\n        &#39; uses the most-derived overload, from KeyedCollection, so the\n        &#39; only way to access SimpleOrder by index is to cast it to\n        &#39; Collection(Of OrderItem). Otherwise the index is interpreted\n        &#39; as a key, and KeyNotFoundException is thrown.\n        &#39;\n        Dim coweekly As Collection(Of OrderItem) = weekly\n        Console.WriteLine(vbLf &amp; &quot;coweekly(2).Description: {0}&quot;, _\n            coweekly(2).Description)\n \n        Console.WriteLine(vbLf &amp; &quot;coweekly(2) = New OrderItem(...)&quot;)\n        coweekly(2) = New OrderItem(127700026, &quot;Crank&quot;, 27, 5.98)\n\n        Dim temp As OrderItem = coweekly(2)\n\n        &#39; The IndexOf method, inherited from Collection(Of OrderItem), \n        &#39; takes an OrderItem instead of a key.\n        &#39; \n        Console.WriteLine(vbLf &amp; &quot;IndexOf(temp): {0}&quot;, _\n            weekly.IndexOf(temp))\n\n        &#39; The inherited Remove method also takes an OrderItem.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Remove(temp)&quot;)\n        weekly.Remove(temp)\n        Display(weekly)\n\n        Console.WriteLine(vbLf &amp; &quot;RemoveAt(0)&quot;)\n        weekly.RemoveAt(0)\n        Display(weekly)\n\n    End Sub\n    \n    Private Shared Sub Display(ByVal order As SimpleOrder) \n        Console.WriteLine()\n        For Each item As OrderItem In  order\n            Console.WriteLine(item)\n        Next item\n    End Sub\nEnd Class\n\n&#39; This class represents a simple line item in an order. All the \n&#39; values are immutable except quantity.\n&#39; \nPublic Class OrderItem\n    Public ReadOnly PartNumber As Integer\n    Public ReadOnly Description As String\n    Public ReadOnly UnitPrice As Double\n    \n    Private _quantity As Integer = 0\n    \n    Public Sub New(ByVal partNumber As Integer, _\n                   ByVal description As String, _\n                   ByVal quantity As Integer, _\n                   ByVal unitPrice As Double) \n        Me.PartNumber = partNumber\n        Me.Description = description\n        Me.Quantity = quantity\n        Me.UnitPrice = unitPrice\n    End Sub &#39;New\n    \n    Public Property Quantity() As Integer \n        Get\n            Return _quantity\n        End Get\n        Set\n            If value &lt; 0 Then\n                Throw New ArgumentException(&quot;Quantity cannot be negative.&quot;)\n            End If\n            _quantity = value\n        End Set\n    End Property\n        \n    Public Overrides Function ToString() As String \n        Return String.Format( _\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, _\n            PartNumber, _quantity, Description, UnitPrice, _\n            UnitPrice * _quantity)\n    End Function\nEnd Class\n\n&#39; This code example produces the following output:\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;101030411     10 Motor        at   237.50 =   2,375.00\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;Contains(101030411): True\n&#39;\n&#39;weekly(101030411).Description: Motor\n&#39;\n&#39;Remove(101030411)\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;Insert(2, New OrderItem(...))\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;111033401     10 Nut          at      .50 =       5.00\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;coweekly(2).Description: Nut\n&#39;\n&#39;coweekly(2) = New OrderItem(...)\n&#39;\n&#39;IndexOf(temp): 2\n&#39;\n&#39;Remove(temp)\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;RemoveAt(0)\n&#39;\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;110072684    175 Gear         at     5.17 =     904.75\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Collections_ObjectModel_KeyedCollection_2_InsertItem_System_Int32__1_\">\r\n    \r\n            <a id=\"System_Collections_ObjectModel_KeyedCollection_2_InsertItem_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">InsertItem(Int32,TItem)</div>        \r\n          </div>\r\n    \r\n            <p>Inserts an element into the <span class=\"xref\">stem.Collections.ObjectModel.KeyedCollection`2</span> at the specified index.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected override void InsertItem (int index, TItem item);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>index</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The zero-based index at which <code>item</code> should be inserted.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>item</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><span class=\"xref\">TItem</span></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The object to insert.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p><code>index</code> is less than 0.  </p>\n<p> -or-  </p>\n<p> <code>index</code> is greater than <span class=\"xref\">stem.Collections.ObjectModel.Collection`1.Count*</span>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If <code>index</code> is equal to <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Count_\" data-linktype=\"relative-path\">Count</a>, <code>item</code> is added to the end of the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a>.  </p>\n<p> This method is an O(<code>n</code>) operation, where <code>n</code> is <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Count_\" data-linktype=\"relative-path\">Count</a>.  </p>\n<p> InsertItem is called by the <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Add_\" data-linktype=\"relative-path\">Add</a> and <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Insert_\" data-linktype=\"relative-path\">Insert</a> methods.  </p>\n<h2 id=\"notes-for-implementers\">Notes for Implementers</h2>\n<p> Override this method to provide customized behavior for the <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Add_\" data-linktype=\"relative-path\">Add</a> and <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Insert_\" data-linktype=\"relative-path\">Insert</a> methods, inherited from the <a class=\"xref\" href=\"system.collections.objectmodel.collection-1\" data-linktype=\"relative-path\">Collection&lt;T&gt;</a> generic class.  </p>\n<p> Call the base class implementation of this method to insert the item into the underlying collection and to update the lookup dictionary.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>This section contains two code examples that demonstrate overriding the InsertItem method to provide custom behavior for adding or inserting objects into the collection. The first example adds a custom notification event and the second provides support for a collection of objects with mutable keys.  </p>\n<p> Example 1  </p>\n<p> The following code example shows how to override the protected InsertItem, <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_RemoveItem_\" data-linktype=\"relative-path\">RemoveItem</a>, <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_ClearItems_\" data-linktype=\"relative-path\">ClearItems</a>, and <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_SetItem_\" data-linktype=\"relative-path\">SetItem</a> methods, to provide custom behavior for the <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Add_\" data-linktype=\"relative-path\">Add</a>, <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_Remove_\" data-linktype=\"relative-path\">Remove</a>, and <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Clear_\" data-linktype=\"relative-path\">Clear</a> methods, and for setting the default <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Item_\" data-linktype=\"relative-path\">Item</a> property (the indexer in C#). The custom behavior provided in this example is a notification event named <code>Changed</code>, which is raised at the end of each of the overridden methods.  </p>\n<p> The code example creates the <code>SimpleOrder</code> class, which derives from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> and represents a simple order form. The order form contains <code>OrderItem</code> objects representing items ordered. The code example also creates a <code>SimpleOrderChangedEventArgs</code> class to contain the event information, and an enumeration to identify the type of change.  </p>\n<p> The code example demonstrates the custom behavior by calling the properties and methods of the derived class, in the <code>Main</code> method of the <code>Demo</code> class.  </p>\n<p> This code example uses objects with immutable keys. For a code example that uses mutable keys, see <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_ChangeItemKey_\" data-linktype=\"relative-path\">ChangeItemKey</a>.  </p>\n<pre><code class=\"lang-vb\" name=\"KeyedCollection2#1\">Imports System\nImports System.Collections.Generic\nImports System.Collections.ObjectModel\n\n&#39; This class derives from KeyedCollection and shows how to override\n&#39; the protected ClearItems, InsertItem, RemoveItem, and SetItem \n&#39; methods in order to change the behavior of the default Item \n&#39; property and the Add, Clear, Insert, and Remove methods. The\n&#39; class implements a Changed event, which is raised by all the\n&#39; protected methods.\n&#39;\n&#39; SimpleOrder is a collection of OrderItem objects, and its key\n&#39; is the PartNumber field of OrderItem. PartNumber is an Integer,\n&#39; so SimpleOrder inherits KeyedCollection(Of Integer, OrderItem).\n&#39; (Note that the key of OrderItem cannot be changed; if it could \n&#39; be changed, SimpleOrder would have to override ChangeItemKey.)\n&#39;\nPublic Class SimpleOrder\n    Inherits KeyedCollection(Of Integer, OrderItem)\n\n    Public Event Changed As EventHandler(Of SimpleOrderChangedEventArgs)\n\n    &#39; This parameterless constructor calls the base class constructor\n    &#39; that specifies a dictionary threshold of 0, so that the internal\n    &#39; dictionary is created as soon as an item is added to the \n    &#39; collection.\n    &#39;\n    Public Sub New()\n        MyBase.New(Nothing, 0)\n    End Sub\n    \n    &#39; This is the only method that absolutely must be overridden,\n    &#39; because without it the KeyedCollection cannot extract the\n    &#39; keys from the items. \n    &#39;\n    Protected Overrides Function GetKeyForItem( _\n        ByVal item As OrderItem) As Integer\n\n        &#39; In this example, the key is the part number.\n        Return item.PartNumber   \n    End Function\n\n    Protected Overrides Sub InsertItem( _\n        ByVal index As Integer, ByVal newItem As OrderItem)\n\n        MyBase.InsertItem(index, newItem)\n\n        RaiseEvent Changed(Me, New SimpleOrderChangedEventArgs( _\n            ChangeType.Added, newItem, Nothing))\n    End Sub\n\n    Protected Overrides Sub SetItem(ByVal index As Integer, _\n        ByVal newItem As OrderItem)\n\n        Dim replaced As OrderItem = Items(index)\n        MyBase.SetItem(index, newItem)\n\n        RaiseEvent Changed(Me, New SimpleOrderChangedEventArgs( _\n            ChangeType.Replaced, replaced, newItem))\n    End Sub\n\n    Protected Overrides Sub RemoveItem(ByVal index As Integer)\n\n        Dim removedItem As OrderItem = Items(index)\n        MyBase.RemoveItem(index)\n\n        RaiseEvent Changed(Me, New SimpleOrderChangedEventArgs( _\n            ChangeType.Removed, removedItem, Nothing))\n    End Sub\n\n    Protected Overrides Sub ClearItems()\n        MyBase.ClearItems()\n\n        RaiseEvent Changed(Me, New SimpleOrderChangedEventArgs( _\n            ChangeType.Cleared, Nothing, Nothing))\n    End Sub\n\nEnd Class\n\n&#39; Event argument for the Changed event.\n&#39;\nPublic Class SimpleOrderChangedEventArgs\n    Inherits EventArgs\n\n    Private _changedItem As OrderItem\n    Private _changeType As ChangeType\n    Private _replacedWith As OrderItem\n\n    Public ReadOnly Property ChangedItem As OrderItem\n        Get\n            Return _changedItem\n        End Get\n    End Property\n\n    Public ReadOnly Property ChangeType As ChangeType\n        Get\n            Return _changeType\n        End Get\n    End Property\n\n    Public ReadOnly Property ReplacedWith As OrderItem\n        Get\n            Return _replacedWith\n        End Get\n    End Property\n\n    Public Sub New(ByVal change As ChangeType, ByVal item As OrderItem, _\n        ByVal replacement As OrderItem)\n\n        _changeType = change\n        _changedItem = item\n        _replacedWith = replacement\n    End Sub\nEnd Class\n\nPublic Enum ChangeType\n    Added\n    Removed\n    Replaced\n    Cleared\nEnd Enum\n\nPublic Class Demo\n    \n    Public Shared Sub Main() \n        Dim weekly As New SimpleOrder()\n        AddHandler weekly.Changed, AddressOf ChangedHandler\n\n        &#39; The Add method, inherited from Collection, takes OrderItem.\n        &#39;\n        weekly.Add(New OrderItem(110072674, &quot;Widget&quot;, 400, 45.17))\n        weekly.Add(New OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3))\n        weekly.Add(New OrderItem(101030411, &quot;Motor&quot;, 10, 237.5))\n        weekly.Add(New OrderItem(110072684, &quot;Gear&quot;, 175, 5.17))\n\n        Display(weekly)\n        \n        &#39; The Contains method of KeyedCollection takes TKey.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Contains(101030411): {0}&quot;, _\n            weekly.Contains(101030411))\n\n        &#39; The default Item property of KeyedCollection takes the key\n        &#39; type, Integer. The property is read-only.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;weekly(101030411).Description: {0}&quot;, _\n            weekly(101030411).Description)\n\n        &#39; The Remove method of KeyedCollection takes a key.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Remove(101030411)&quot;)\n        weekly.Remove(101030411)\n\n        &#39; The Insert method, inherited from Collection, takes an \n        &#39; index and an OrderItem.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Insert(2, New OrderItem(...))&quot;)\n        weekly.Insert(2, New OrderItem(111033401, &quot;Nut&quot;, 10, .5))\n         \n        &#39; The default Item property is overloaded. One overload comes\n        &#39; from KeyedCollection(Of Integer, OrderItem); that overload\n        &#39; is read-only, and takes Integer because it retrieves by key. \n        &#39; The other overload comes from Collection(Of OrderItem), the \n        &#39; base class of KeyedCollection(Of Integer, OrderItem); it \n        &#39; retrieves by index, so it also takes an Integer. The compiler\n        &#39; uses the most-derived overload, from KeyedCollection, so the\n        &#39; only way to access SimpleOrder by index is to cast it to\n        &#39; Collection(Of OrderItem). Otherwise the index is interpreted\n        &#39; as a key, and KeyNotFoundException is thrown.\n        &#39;\n        Dim coweekly As Collection(Of OrderItem) = weekly\n        Console.WriteLine(vbLf &amp; &quot;coweekly(2).Description: {0}&quot;, _\n            coweekly(2).Description)\n \n        Console.WriteLine(vbLf &amp; &quot;coweekly(2) = New OrderItem(...)&quot;)\n        coweekly(2) = New OrderItem(127700026, &quot;Crank&quot;, 27, 5.98)\n\n        Dim temp As OrderItem = coweekly(2)\n\n        &#39; The IndexOf method, inherited from Collection(Of OrderItem), \n        &#39; takes an OrderItem instead of a key.\n        &#39; \n        Console.WriteLine(vbLf &amp; &quot;IndexOf(temp): {0}&quot;, _\n            weekly.IndexOf(temp))\n\n        &#39; The inherited Remove method also takes an OrderItem.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Remove(temp)&quot;)\n        weekly.Remove(temp)\n\n        Console.WriteLine(vbLf &amp; &quot;RemoveAt(0)&quot;)\n        weekly.RemoveAt(0)\n\n        &#39; Increase the quantity for a line item.\n        Console.WriteLine(vbLf &amp; &quot;coweekly(1) = New OrderItem(...)&quot;)\n        coweekly(1) = New OrderItem(coweekly(1).PartNumber, _\n            coweekly(1).Description, coweekly(1).Quantity + 1000, _\n            coweekly(1).UnitPrice)\n\n        Display(weekly)\n\n        Console.WriteLine()\n        weekly.Clear()\n    End Sub\n    \n    Private Shared Sub Display(ByVal order As SimpleOrder) \n        Console.WriteLine()\n        For Each item As OrderItem In  order\n            Console.WriteLine(item)\n        Next item\n    End Sub\n\n    Private Shared Sub ChangedHandler(ByVal source As Object, _\n        ByVal e As SimpleOrderChangedEventArgs)\n\n        Dim item As OrderItem = e.ChangedItem\n\n        If e.ChangeType = ChangeType.Replaced Then\n            Dim replacement As OrderItem = e.ReplacedWith\n\n            Console.WriteLine(&quot;{0} (quantity {1}) was replaced &quot; &amp; _\n                &quot;by {2}, (quantity {3}).&quot;, item.Description, _\n                item.Quantity, replacement.Description, replacement.Quantity)\n\n        ElseIf e.ChangeType = ChangeType.Cleared Then\n            Console.WriteLine(&quot;The order list was cleared.&quot;)\n\n        Else\n            Console.WriteLine(&quot;{0} (quantity {1}) was {2}.&quot;, _\n                item.Description, item.Quantity, e.ChangeType)\n        End If\n    End Sub\nEnd Class\n\n&#39; This class represents a simple line item in an order. All the \n&#39; values are immutable except quantity.\n&#39; \nPublic Class OrderItem\n    \n    Private _partNumber As Integer\n    Private _description As String\n    Private _unitPrice As Double\n    Private _quantity As Integer\n\n    Public ReadOnly Property PartNumber As Integer\n        Get\n            Return _partNumber\n        End Get\n    End Property\n\n    Public ReadOnly Property Description As String\n        Get\n            Return _description\n        End Get\n    End Property\n\n    Public ReadOnly Property UnitPrice As Double\n        Get\n            Return _unitPrice\n        End Get\n    End Property\n    \n    Public ReadOnly Property Quantity() As Integer \n        Get\n            Return _quantity\n        End Get\n    End Property\n    \n    Public Sub New(ByVal partNumber As Integer, _\n                   ByVal description As String, _\n                   ByVal quantity As Integer, _\n                   ByVal unitPrice As Double) \n        _partNumber = partNumber\n        _description = description\n        _quantity = quantity\n        _unitPrice = unitPrice\n    End Sub &#39;New\n        \n    Public Overrides Function ToString() As String \n        Return String.Format( _\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, _\n            PartNumber, _quantity, Description, UnitPrice, _\n            UnitPrice * _quantity)\n    End Function\nEnd Class\n\n&#39; This code example produces the following output:\n&#39;\n&#39;Widget (quantity 400) was Added.\n&#39;Sprocket (quantity 27) was Added.\n&#39;Motor (quantity 10) was Added.\n&#39;Gear (quantity 175) was Added.\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;101030411     10 Motor        at   237.50 =   2,375.00\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;Contains(101030411): True\n&#39;\n&#39;weekly(101030411).Description: Motor\n&#39;\n&#39;Remove(101030411)\n&#39;Motor (quantity 10) was Removed.\n&#39;\n&#39;Insert(2, New OrderItem(...))\n&#39;Nut (quantity 10) was Added.\n&#39;\n&#39;coweekly(2).Description: Nut\n&#39;\n&#39;coweekly(2) = New OrderItem(...)\n&#39;Nut (quantity 10) was replaced by Crank, (quantity 27).\n&#39;\n&#39;IndexOf(temp): 2\n&#39;\n&#39;Remove(temp)\n&#39;Crank (quantity 27) was Removed.\n&#39;\n&#39;RemoveAt(0)\n&#39;Widget (quantity 400) was Removed.\n&#39;\n&#39;coweekly(1) = New OrderItem(...)\n&#39;Gear (quantity 175) was replaced by Gear, (quantity 1175).\n&#39;\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;110072684   1175 Gear         at     5.17 =   6,074.75\n&#39;\n&#39;The order list was cleared.\n</code></pre><pre><code class=\"lang-cs\" name=\"KeyedCollection2#1\">using System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\n\n// This class derives from KeyedCollection and shows how to override\n// the protected ClearItems, InsertItem, RemoveItem, and SetItem \n// methods in order to change the behavior of the default Item \n// property and the Add, Clear, Insert, and Remove methods. The\n// class implements a Changed event, which is raised by all the\n// protected methods.\n//\n// SimpleOrder is a collection of OrderItem objects, and its key\n// is the PartNumber field of OrderItem. PartNumber is an Integer,\n// so SimpleOrder inherits KeyedCollection&lt;int, OrderItem&gt;.\n// (Note that the key of OrderItem cannot be changed; if it could \n// be changed, SimpleOrder would have to override ChangeItemKey.)\n//\npublic class SimpleOrder : KeyedCollection&lt;int, OrderItem&gt;\n{\n    public event EventHandler&lt;SimpleOrderChangedEventArgs&gt; Changed;\n\n    // This parameterless constructor calls the base class constructor\n    // that specifies a dictionary threshold of 0, so that the internal\n    // dictionary is created as soon as an item is added to the \n    // collection.\n    //\n    public SimpleOrder() : base(null, 0) {}\n    \n    // This is the only method that absolutely must be overridden,\n    // because without it the KeyedCollection cannot extract the\n    // keys from the items. \n    //\n    protected override int GetKeyForItem(OrderItem item)\n    {\n        // In this example, the key is the part number.\n        return item.PartNumber;\n    }\n\n    protected override void InsertItem(int index, OrderItem newItem)\n    {\n        base.InsertItem(index, newItem);\n\n        EventHandler&lt;SimpleOrderChangedEventArgs&gt; temp = Changed;\n        if (temp != null)\n        {\n            temp(this, new SimpleOrderChangedEventArgs(\n                ChangeType.Added, newItem, null));\n        }\n    }\n\n    protected override void SetItem(int index, OrderItem newItem)\n    {\n        OrderItem replaced = Items[index];\n        base.SetItem(index, newItem);\n\n        EventHandler&lt;SimpleOrderChangedEventArgs&gt; temp = Changed;\n        if (temp != null)\n        {\n            temp(this, new SimpleOrderChangedEventArgs(\n                ChangeType.Replaced, replaced, newItem));\n        }\n    }\n\n    protected override void RemoveItem(int index)\n    {\n        OrderItem removedItem = Items[index];\n        base.RemoveItem(index);\n\n        EventHandler&lt;SimpleOrderChangedEventArgs&gt; temp = Changed;\n        if (temp != null)\n        {\n            temp(this, new SimpleOrderChangedEventArgs(\n                ChangeType.Removed, removedItem, null));\n        }\n    }\n\n    protected override void ClearItems()\n    {\n        base.ClearItems();\n\n        EventHandler&lt;SimpleOrderChangedEventArgs&gt; temp = Changed;\n        if (temp != null)\n        {\n            temp(this, new SimpleOrderChangedEventArgs(\n                ChangeType.Cleared, null, null));\n        }\n    }\n}\n\n// Event argument for the Changed event.\n//\npublic class SimpleOrderChangedEventArgs : EventArgs\n{\n    private OrderItem _changedItem;\n    private ChangeType _changeType;\n    private OrderItem _replacedWith;\n\n    public OrderItem ChangedItem { get { return _changedItem; }}\n    public ChangeType ChangeType { get { return _changeType; }}\n    public OrderItem ReplacedWith { get { return _replacedWith; }}\n\n    public SimpleOrderChangedEventArgs(ChangeType change, \n        OrderItem item, OrderItem replacement)\n    {\n        _changeType = change;\n        _changedItem = item;\n        _replacedWith = replacement;\n    }\n}\n\npublic enum ChangeType\n{\n    Added, \n    Removed, \n    Replaced, \n    Cleared\n};\n\npublic class Demo\n{    \n    public static void Main()\n    {\n        SimpleOrder weekly = new SimpleOrder();\n        weekly.Changed += new \n            EventHandler&lt;SimpleOrderChangedEventArgs&gt;(ChangedHandler);\n\n        // The Add method, inherited from Collection, takes OrderItem.\n        //\n        weekly.Add(new OrderItem(110072674, &quot;Widget&quot;, 400, 45.17));\n        weekly.Add(new OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3));\n        weekly.Add(new OrderItem(101030411, &quot;Motor&quot;, 10, 237.5));\n        weekly.Add(new OrderItem(110072684, &quot;Gear&quot;, 175, 5.17));\n\n        Display(weekly);\n        \n        // The Contains method of KeyedCollection takes TKey.\n        //\n        Console.WriteLine(&quot;<br>Contains(101030411): {0}&quot;, \n            weekly.Contains(101030411));\n\n        // The default Item property of KeyedCollection takes the key\n        // type, Integer. The property is read-only.\n        //\n        Console.WriteLine(&quot;<br>weekly[101030411].Description: {0}&quot;, \n            weekly[101030411].Description);\n\n        // The Remove method of KeyedCollection takes a key.\n        //\n        Console.WriteLine(&quot;<br>Remove(101030411)&quot;);\n        weekly.Remove(101030411);\n\n        // The Insert method, inherited from Collection, takes an \n        // index and an OrderItem.\n        //\n        Console.WriteLine(&quot;<br>Insert(2, new OrderItem(...))&quot;);\n        weekly.Insert(2, new OrderItem(111033401, &quot;Nut&quot;, 10, .5));\n         \n        // The default Item property is overloaded. One overload comes\n        // from KeyedCollection&lt;int, OrderItem&gt;; that overload\n        // is read-only, and takes Integer because it retrieves by key. \n        // The other overload comes from Collection&lt;OrderItem&gt;, the \n        // base class of KeyedCollection&lt;int, OrderItem&gt;; it \n        // retrieves by index, so it also takes an Integer. The compiler\n        // uses the most-derived overload, from KeyedCollection, so the\n        // only way to access SimpleOrder by index is to cast it to\n        // Collection&lt;OrderItem&gt;. Otherwise the index is interpreted\n        // as a key, and KeyNotFoundException is thrown.\n        //\n        Collection&lt;OrderItem&gt; coweekly = weekly;\n        Console.WriteLine(&quot;<br>coweekly[2].Description: {0}&quot;, \n            coweekly[2].Description);\n \n        Console.WriteLine(&quot;<br>coweekly[2] = new OrderItem(...)&quot;);\n        coweekly[2] = new OrderItem(127700026, &quot;Crank&quot;, 27, 5.98);\n\n        OrderItem temp = coweekly[2];\n\n        // The IndexOf method, inherited from Collection&lt;OrderItem&gt;, \n        // takes an OrderItem instead of a key.\n        // \n        Console.WriteLine(&quot;<br>IndexOf(temp): {0}&quot;, weekly.IndexOf(temp));\n\n        // The inherited Remove method also takes an OrderItem.\n        //\n        Console.WriteLine(&quot;<br>Remove(temp)&quot;);\n        weekly.Remove(temp);\n\n        Console.WriteLine(&quot;<br>RemoveAt(0)&quot;);\n        weekly.RemoveAt(0);\n\n        // Increase the quantity for a line item.\n        Console.WriteLine(&quot;<br>coweekly(1) = New OrderItem(...)&quot;);\n        coweekly[1] = new OrderItem(coweekly[1].PartNumber, \n            coweekly[1].Description, coweekly[1].Quantity + 1000, \n            coweekly[1].UnitPrice);\n\n        Display(weekly);\n\n        Console.WriteLine();\n        weekly.Clear();\n    }\n    \n    private static void Display(SimpleOrder order)\n    {\n        Console.WriteLine();\n        foreach( OrderItem item in order )\n        {\n            Console.WriteLine(item);\n        }\n    }\n\n    private static void ChangedHandler(object source, \n        SimpleOrderChangedEventArgs e)\n    {\n\n        OrderItem item = e.ChangedItem;\n\n        if (e.ChangeType==ChangeType.Replaced)\n        {\n            OrderItem replacement = e.ReplacedWith;\n\n            Console.WriteLine(&quot;{0} (quantity {1}) was replaced &quot; +\n                &quot;by {2}, (quantity {3}).&quot;, item.Description, \n                item.Quantity, replacement.Description, \n                replacement.Quantity);\n        }\n        else if(e.ChangeType == ChangeType.Cleared)\n        {\n            Console.WriteLine(&quot;The order list was cleared.&quot;);\n        }\n        else\n        {\n            Console.WriteLine(&quot;{0} (quantity {1}) was {2}.&quot;, \n                item.Description, item.Quantity, e.ChangeType);\n        }\n    }\n}\n\n// This class represents a simple line item in an order. All the \n// values are immutable except quantity.\n// \npublic class OrderItem\n{\n    private int _partNumber;\n    private string _description;\n    private double _unitPrice;\n    private int _quantity;\n    \n    public int PartNumber { get { return _partNumber; }}\n    public string Description { get { return _description; }}\n    public double UnitPrice { get { return _unitPrice; }}\n    public int Quantity { get { return _quantity; }}\n    \n    public OrderItem(int partNumber, string description, int quantity, \n        double unitPrice)\n    {\n        _partNumber = partNumber;\n        _description = description;\n        _quantity = quantity;\n        _unitPrice = unitPrice;\n    }\n    \n    public override string ToString()\n    {\n        return String.Format(\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, \n            PartNumber, _quantity, Description, UnitPrice, \n            UnitPrice * _quantity);\n    }\n}\n\n/* This code example produces the following output:\n\nWidget (quantity 400) was Added.\nSprocket (quantity 27) was Added.\nMotor (quantity 10) was Added.\nGear (quantity 175) was Added.\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n101030411     10 Motor        at   237.50 =   2,375.00\n110072684    175 Gear         at     5.17 =     904.75\n\nContains(101030411): True\n\nweekly[101030411].Description: Motor\n\nRemove(101030411)\nMotor (quantity 10) was Removed.\n\nInsert(2, new OrderItem(...))\nNut (quantity 10) was Added.\n\ncoweekly[2].Description: Nut\n\ncoweekly[2] = new OrderItem(...)\nNut (quantity 10) was replaced by Crank, (quantity 27).\n\nIndexOf(temp): 2\n\nRemove(temp)\nCrank (quantity 27) was Removed.\n\nRemoveAt(0)\nWidget (quantity 400) was Removed.\n\ncoweekly(1) = New OrderItem(...)\nGear (quantity 175) was replaced by Gear, (quantity 1175).\n\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684   1175 Gear         at     5.17 =   6,074.75\n\nThe order list was cleared.\n */\n</code></pre><pre><code class=\"lang-cpp\" name=\"KeyedCollection2#1\">using namespace System;\nusing namespace System::Collections::Generic;\nusing namespace System::Collections::ObjectModel;\n\npublic enum class ChangeTypes\n{\n    Added,\n    Removed, \n    Replaced, \n    Cleared\n};\n\nref class SimpleOrderChangedEventArgs; \n\n// This class represents a simple line item in an order. All the \n// values are immutable except quantity.\n// \npublic ref class OrderItem\n{\nprivate:\n    int _quantity;\n\npublic:\n    initonly int PartNumber;\n    initonly String^ Description;\n    initonly double UnitPrice;\n        \n    OrderItem(int partNumber, String^ description, int quantity, \n        double unitPrice)\n    {\n        this-&gt;PartNumber = partNumber;\n        this-&gt;Description = description;\n        this-&gt;Quantity = quantity;\n        this-&gt;UnitPrice = unitPrice;\n    };\n    \n    property int Quantity    \n    {\n        int get() { return _quantity; };\n        void set(int value)\n        {\n            if (value &lt; 0)\n                throw gcnew ArgumentException(&quot;Quantity cannot be negative.&quot;);\n            \n            _quantity = value;\n        };\n    };\n        \n    virtual String^ ToString() override \n    {\n        return String::Format(\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, \n            PartNumber, _quantity, Description, UnitPrice, \n            UnitPrice * _quantity);\n    };\n};\n\n// Event argument for the Changed event.\n//\npublic ref class SimpleOrderChangedEventArgs : EventArgs\n{\npublic:\n    OrderItem^ ChangedItem;\n    initonly ChangeTypes ChangeType;\n    OrderItem^ ReplacedWith;\n\n    SimpleOrderChangedEventArgs(ChangeTypes change, \n        OrderItem^ item, OrderItem^ replacement)\n    {\n        this-&gt;ChangeType = change;\n        this-&gt;ChangedItem = item;\n        this-&gt;ReplacedWith = replacement;\n    }\n};\n\n// This class derives from KeyedCollection and shows how to override\n// the protected ClearItems, InsertItem, RemoveItem, and SetItem \n// methods in order to change the behavior of the default Item \n// property and the Add, Clear, Insert, and Remove methods. The\n// class implements a Changed event, which is raised by all the\n// protected methods.\n//\n// SimpleOrder is a collection of OrderItem objects, and its key\n// is the PartNumber field of OrderItem-&gt; PartNumber is an Integer,\n// so SimpleOrder inherits KeyedCollection&lt;int, OrderItem&gt;.\n// (Note that the key of OrderItem cannot be changed; if it could \n// be changed, SimpleOrder would have to override ChangeItemKey.)\n//\npublic ref class SimpleOrder : KeyedCollection&lt;int, OrderItem^&gt;\n{\npublic:\n    event EventHandler&lt;SimpleOrderChangedEventArgs^&gt;^ Changed;\n\n    // This parameterless constructor calls the base class constructor\n    // that specifies a dictionary threshold of 0, so that the internal\n    // dictionary is created as soon as an item is added to the \n    // collection.\n    //\n    SimpleOrder() : KeyedCollection&lt;int, OrderItem^&gt;(nullptr, 0) {};\n    \n    // This is the only method that absolutely must be overridden,\n    // because without it the KeyedCollection cannot extract the\n    // keys from the items. \n    //\nprotected:\n    virtual int GetKeyForItem(OrderItem^ item) override\n    {\n        // In this example, the key is the part number.\n        return item-&gt;PartNumber;\n    }\n\n    virtual void InsertItem(int index, OrderItem^ newItem) override \n    {\n        __super::InsertItem(index, newItem);\n\n        Changed(this, gcnew SimpleOrderChangedEventArgs(\n            ChangeTypes::Added, newItem, nullptr));\n    }\n\n    virtual void SetItem(int index, OrderItem^ newItem) override \n    {\n        OrderItem^ replaced = this-&gt;Items[index];\n        __super::SetItem(index, newItem);\n\n        Changed(this, gcnew SimpleOrderChangedEventArgs(\n            ChangeTypes::Replaced, replaced, newItem));\n    }\n\n    virtual void RemoveItem(int index) override \n    {\n        OrderItem^ removedItem = Items[index];\n        __super::RemoveItem(index);\n\n        Changed(this, gcnew SimpleOrderChangedEventArgs(\n            ChangeTypes::Removed, removedItem, nullptr));\n    }\n\n    virtual void ClearItems() override \n    {\n        __super::ClearItems();\n\n        Changed(this, gcnew SimpleOrderChangedEventArgs(\n            ChangeTypes::Cleared, nullptr, nullptr));\n    }\n\n    // This method uses the internal reference to the dictionary\n    // to test fo\npublic:\n    void AddOrMerge(OrderItem^ newItem)\n    {\n\n        int key = this-&gt;GetKeyForItem(newItem);\n        OrderItem^ existingItem = nullptr;\n\n        // The dictionary is not created until the first item is \n        // added, so it is necessary to test for null. Using \n        // AndAlso ensures that TryGetValue is not called if the\n        // dictionary does not exist.\n        //\n        if (this-&gt;Dictionary != nullptr &amp;&amp; \n            this-&gt;Dictionary-&gt;TryGetValue(key, existingItem))\n        {\n            existingItem-&gt;Quantity += newItem-&gt;Quantity;\n        }\n        else\n        {\n            this-&gt;Add(newItem);\n        }\n    }\n};\n\npublic ref class Demo\n{    \npublic:\n    static void Main()\n    {\n        SimpleOrder^ weekly = gcnew SimpleOrder();\n        weekly-&gt;Changed += gcnew \n            EventHandler&lt;SimpleOrderChangedEventArgs^&gt;(ChangedHandler);\n\n        // The Add method, inherited from Collection, takes OrderItem-&gt;\n        //\n        weekly-&gt;Add(gcnew OrderItem(110072674, &quot;Widget&quot;, 400, 45.17));\n        weekly-&gt;Add(gcnew OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3));\n        weekly-&gt;Add(gcnew OrderItem(101030411, &quot;Motor&quot;, 10, 237.5));\n        weekly-&gt;Add(gcnew OrderItem(110072684, &quot;Gear&quot;, 175, 5.17));\n\n        Display(weekly);\n        \n        // The Contains method of KeyedCollection takes TKey.\n        //\n        Console::WriteLine(&quot;<br>Contains(101030411): {0}&quot;, \n            weekly-&gt;Contains(101030411));\n\n        // The default Item property of KeyedCollection takes the key\n        // type, Integer. The property is read-only.\n        //\n        Console::WriteLine(&quot;<br>weekly[101030411]-&gt;Description: {0}&quot;, \n            weekly[101030411]-&gt;Description);\n\n        // The Remove method of KeyedCollection takes a key.\n        //\n        Console::WriteLine(&quot;<br>Remove(101030411)&quot;);\n        weekly-&gt;Remove(101030411);\n\n        // The Insert method, inherited from Collection, takes an \n        // index and an OrderItem.\n        //\n        Console::WriteLine(&quot;<br>Insert(2, gcnew OrderItem(...))&quot;);\n        weekly-&gt;Insert(2, gcnew OrderItem(111033401, &quot;Nut&quot;, 10, .5));\n         \n        // The default Item property is overloaded. One overload comes\n        // from KeyedCollection&lt;int, OrderItem&gt;; that overload\n        // is read-only, and takes Integer because it retrieves by key. \n        // The other overload comes from Collection&lt;OrderItem&gt;, the \n        // base class of KeyedCollection&lt;int, OrderItem&gt;; it \n        // retrieves by index, so it also takes an Integer. The compiler\n        // uses the most-derived overload, from KeyedCollection, so the\n        // only way to access SimpleOrder by index is to cast it to\n        // Collection&lt;OrderItem&gt;. Otherwise the index is interpreted\n        // as a key, and KeyNotFoundException is thrown.\n        //\n        Collection&lt;OrderItem^&gt;^ coweekly = weekly;\n        Console::WriteLine(&quot;<br>coweekly[2].Description: {0}&quot;, \n            coweekly[2]-&gt;Description);\n \n        Console::WriteLine(&quot;<br>coweekly[2] = gcnew OrderItem(...)&quot;);\n        coweekly[2] = gcnew OrderItem(127700026, &quot;Crank&quot;, 27, 5.98);\n\n        OrderItem^ temp = coweekly[2];\n\n        // The IndexOf method, inherited from Collection&lt;OrderItem&gt;, \n        // takes an OrderItem instead of a key.\n        // \n        Console::WriteLine(&quot;<br>IndexOf(temp): {0}&quot;, weekly-&gt;IndexOf(temp));\n\n        // The inherited Remove method also takes an OrderItem-&gt;\n        //\n        Console::WriteLine(&quot;<br>Remove(temp)&quot;);\n        weekly-&gt;Remove(temp);\n\n        Console::WriteLine(&quot;<br>RemoveAt(0)&quot;);\n        weekly-&gt;RemoveAt(0);\n\n        weekly-&gt;AddOrMerge(gcnew OrderItem(110072684, &quot;Gear&quot;, 1000, 5.17));\n\n        Display(weekly);\n\n        Console::WriteLine();\n        weekly-&gt;Clear();\n    }\n    \nprivate:\n    static void Display(SimpleOrder^ order)\n    {\n        Console::WriteLine();\n        for each( OrderItem^ item in order )\n        {\n            Console::WriteLine(item);\n        }\n    }\n\n    static void ChangedHandler(Object^ source, \n        SimpleOrderChangedEventArgs^ e)\n    {\n        OrderItem^ item = e-&gt;ChangedItem;\n\n        if (e-&gt;ChangeType == ChangeTypes::Replaced)\n        {\n            OrderItem^ replacement = e-&gt;ReplacedWith;\n\n            Console::WriteLine(&quot;{0} (quantity {1}) was replaced &quot; +\n                &quot;by {2}, (quantity {3}).&quot;, item-&gt;Description, \n                item-&gt;Quantity, replacement-&gt;Description, \n                replacement-&gt;Quantity);\n        }\n        else if(e-&gt;ChangeType == ChangeTypes::Cleared)\n        {\n            Console::WriteLine(&quot;The order list was cleared.&quot;);\n        }\n        else\n        {\n            Console::WriteLine(&quot;{0} (quantity {1}) was {2}.&quot;, \n                item-&gt;Description, item-&gt;Quantity, e-&gt;ChangeType);\n        }\n    }\n};\n\nvoid main()\n{\n    Demo::Main();\n}\n\n/* This code example produces the following output:\n\nWidget (quantity 400) was Added.\nSprocket (quantity 27) was Added.\nMotor (quantity 10) was Added.\nGear (quantity 175) was Added.\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n101030411     10 Motor        at   237.50 =   2,375.00\n110072684    175 Gear         at     5.17 =     904.75\n\nContains(101030411): True\n\nweekly[101030411]-&gt;Description: Motor\n\nRemove(101030411)\nMotor (quantity 10) was Removed.\n\nInsert(2, gcnew OrderItem(...))\nNut (quantity 10) was Added.\n\ncoweekly[2].Description: Nut\n\ncoweekly[2] = gcnew OrderItem(...)\nNut (quantity 10) was replaced by Crank, (quantity 27).\n\nIndexOf(temp): 2\n\nRemove(temp)\nCrank (quantity 27) was Removed.\n\nRemoveAt(0)\nWidget (quantity 400) was Removed.\n\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684   1175 Gear         at     5.17 =   6,074.75\n\nThe order list was cleared.\n */\n</code></pre><p> Example 2  </p>\n<p> The following code example shows how to override the protected <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_ChangeItemKey_\" data-linktype=\"relative-path\">ChangeItemKey</a> method to support mutable keys, and how to override the protected InsertItem, <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_RemoveItem_\" data-linktype=\"relative-path\">RemoveItem</a>, <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_ClearItems_\" data-linktype=\"relative-path\">ClearItems</a>, and <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_SetItem_\" data-linktype=\"relative-path\">SetItem</a> methods to maintain the integrity of the keys and the collection.  </p>\n<p> The code example creates the <code>MutableKeys</code> collection, which derives from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a>, and the <code>MutableKey</code> class. The <code>MutableKey</code> class has a settable <code>Key</code> property. When a new key is assigned to the property, the property setter calls the <code>internal</code> (<code>Friend</code> in Visual Basic) <code>ChangeKey</code> method of the collection to test whether the new key would conflict with an existing key. If so, an exception is thrown and the property value is not changed.  </p>\n<p> In order to maintain the connection between a <code>MutableKey</code> object and the <code>MutableKeys</code> collection and to prevent an object from being inserted into two collections, the <code>MutableKey</code> class has an <code>internal</code> (<code>Friend</code> in Visual Basic) <code>Collection</code> field. This field is maintained by the protected methods that provide custom behavior for adding and removing items from the collection, such as the InsertItem method. The field is set when the item is added to a collection and cleared when the item is removed.  </p>\n<pre><code class=\"lang-cs\" name=\"KeyedCollectionMutable#1\">using System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\n\n// This class demonstrates one way to use the ChangeItemKey\n// method to store objects with keys that can be changed. The \n// ChangeItemKey method is used to keep the internal lookup\n// Dictionary in sync with the keys of the stored objects. \n//\n// MutableKeys stores MutableKey objects, which have an Integer\n// Key property that can be set. Therefore, MutableKeys inherits\n// KeyedCollection(Of Integer, MutableKey).\n//\npublic class MutableKeys : KeyedCollection&lt;int, MutableKey&gt;\n{\n    // This parameterless constructor delegates to the base class \n    // constructor that specifies a dictionary threshold. A\n    // threshold of 0 means the internal Dictionary is created\n    // the first time an object is added.\n    //\n    public MutableKeys() : base(null, 0) {}\n    \n    protected override int GetKeyForItem(MutableKey item)\n    {\n        // The key is MutableKey.Key.\n        return item.Key;\n    }\n\n    protected override void InsertItem(int index, MutableKey newItem)\n    {\n        if (newItem.Collection != null) \n            throw new ArgumentException(&quot;The item already belongs to a collection.&quot;);\n\n        base.InsertItem(index, newItem);\n        newItem.Collection = this;\n    }\n\n    protected override void SetItem(int index, MutableKey newItem)\n    {\n        MutableKey replaced = Items[index];\n\n        if (newItem.Collection != null) \n            throw new ArgumentException(&quot;The item already belongs to a collection.&quot;);\n\n        base.SetItem(index, newItem);\n        newItem.Collection = this;\n        replaced.Collection = null;\n    }\n\n    protected override void RemoveItem(int index)\n    {\n        MutableKey removedItem = Items[index];\n\n        base.RemoveItem(index);\n        removedItem.Collection = null;\n    }\n\n    protected override void ClearItems()\n    {\n        foreach( MutableKey mk in Items )\n        {\n            mk.Collection = null;\n        }\n        \n        base.ClearItems();\n    }\n\n    internal void ChangeKey(MutableKey item, int newKey)\n    {\n        base.ChangeItemKey(item, newKey);\n    }\n    \n    public void Dump()\n    {\n        Console.WriteLine(&quot;<br>DUMP:&quot;);\n        if (Dictionary == null)\n        {\n            Console.WriteLine(&quot;    The dictionary has not been created.&quot;);\n        }\n        else\n        {\n            Console.WriteLine(&quot;    Dictionary entries&quot;);\n            Console.WriteLine(&quot;    ------------------&quot;);\n\n            foreach( KeyValuePair&lt;int, MutableKey&gt; kvp in Dictionary )\n            {\n                Console.WriteLine(&quot;    {0} : {1}&quot;, kvp.Key, kvp.Value);\n            }\n        }\n\n        Console.WriteLine(&quot;<br>    List of items&quot;);\n        Console.WriteLine(&quot;    -------------&quot;);\n\n        foreach( MutableKey mk in Items )\n        {\n            Console.WriteLine(&quot;    {0}&quot;, mk);\n        }\n    }\n}\n\npublic class Demo\n{\n    public static void Main()\n    {\n        MutableKeys mkeys = new MutableKeys();\n\n        // The Add method is inherited from Collection.\n        //\n        mkeys.Add(new MutableKey(110072674, &quot;Widget&quot;));\n        mkeys.Add(new MutableKey(110072675, &quot;Sprocket&quot;));\n\n        mkeys.Dump();\n    \n        Console.WriteLine(&quot;<br>Create and insert a new item:&quot;);\n        MutableKey test = new MutableKey(110072684, &quot;Gear&quot;);\n        mkeys.Insert(1, test);\n\n        mkeys.Dump();\n\n        try\n        {\n            Console.WriteLine(&quot;<br>Try to insert the item again:&quot;);\n            mkeys.Insert(1, test);\n        }\n        catch(ArgumentException ex)\n        {\n            Console.WriteLine(&quot;Error: {0}&quot;, ex.Message);\n        }\n\n        Console.WriteLine(&quot;<br>Change the Key property of the item:&quot;);\n        test.Key = 100000072;\n\n        mkeys.Dump();\n\n        try\n        {\n            Console.WriteLine(&quot;<br>Try to set the Key property to an existing key:&quot;);\n            test.Key = 110072674;\n        }\n        catch(ArgumentException ex)\n        {\n            Console.WriteLine(&quot;Error: {0}&quot;, ex.Message);\n        }\n\n        mkeys.Dump();\n    }\n    \n    private static void Display(MutableKeys order)\n    {\n        Console.WriteLine();\n        foreach( MutableKey item in order )\n        {\n            Console.WriteLine(item);\n        }\n    }\n}\n\n// This class has a key that can be changed.\n// \npublic class MutableKey\n{\n\n    public MutableKey(int newKey, string newValue)\n    {\n        _key = newKey;\n        Value = newValue;\n    } //New\n    \n    public string Value;\n    internal MutableKeys Collection;\n    \n    private int _key;\n    public int Key    \n    {\n        get\n        {\n            return _key;\n        }\n        set\n        {\n            if (Collection != null)\n            {\n                Collection.ChangeKey(this, value);\n            }\n\n            _key = value;\n        }\n    }\n\n    public override string ToString()\n    {\n        return String.Format(&quot;{0,9} {1}&quot;, _key, Value);\n    }\n        \n}\n\n/* This code example produces the following output:\n\nDUMP:\n    Dictionary entries\n    ------------------\n    110072674 : 110072674 Widget\n    110072675 : 110072675 Sprocket\n\n    List of items\n    -------------\n    110072674 Widget\n    110072675 Sprocket\n\nCreate and insert a new item:\n\nDUMP:\n    Dictionary entries\n    ------------------\n    110072674 : 110072674 Widget\n    110072675 : 110072675 Sprocket\n    110072684 : 110072684 Gear\n\n    List of items\n    -------------\n    110072674 Widget\n    110072684 Gear\n    110072675 Sprocket\n\nTry to insert the item again:\nError: The item already belongs to a collection.\n\nChange the Key property of the item:\n\nDUMP:\n    Dictionary entries\n    ------------------\n    110072674 : 110072674 Widget\n    110072675 : 110072675 Sprocket\n    100000072 : 100000072 Gear\n\n    List of items\n    -------------\n    110072674 Widget\n    100000072 Gear\n    110072675 Sprocket\n\nTry to set the Key property to an existing key:\nError: An item with the same key has already been added.\n\nDUMP:\n    Dictionary entries\n    ------------------\n    110072674 : 110072674 Widget\n    110072675 : 110072675 Sprocket\n    100000072 : 100000072 Gear\n\n    List of items\n    -------------\n    110072674 Widget\n    100000072 Gear\n    110072675 Sprocket\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"KeyedCollectionMutable#1\">Imports System\nImports System.Collections.Generic\nImports System.Collections.ObjectModel\n\n&#39; This class demonstrates one way to use the ChangeItemKey\n&#39; method to store objects with keys that can be changed. The \n&#39; ChangeItemKey method is used to keep the internal lookup\n&#39; Dictionary in sync with the keys of the stored objects. \n&#39;\n&#39; MutableKeys stores MutableKey objects, which have an Integer\n&#39; Key property that can be set. Therefore, MutableKeys inherits\n&#39; KeyedCollection(Of Integer, MutableKey).\n&#39;\nPublic Class MutableKeys\n    Inherits KeyedCollection(Of Integer, MutableKey)\n\n    &#39; This parameterless constructor delegates to the base class \n    &#39; constructor that specifies a dictionary threshold. A\n    &#39; threshold of 0 means the internal Dictionary is created\n    &#39; the first time an object is added.\n    &#39;\n    Public Sub New()\n        MyBase.New(Nothing, 0)\n    End Sub\n    \n    Protected Overrides Function GetKeyForItem( _\n        ByVal item As MutableKey) As Integer\n\n        &#39; The key is MutableKey.Key.\n        Return item.Key   \n    End Function\n\n    Protected Overrides Sub InsertItem( _\n        ByVal index As Integer, ByVal newItem As MutableKey)\n\n        If newItem.Collection IsNot Nothing Then _\n            Throw New ArgumentException(&quot;The item already belongs to a collection.&quot;)\n\n        MyBase.InsertItem(index, newItem)\n        newItem.Collection = Me\n    End Sub\n\n    Protected Overrides Sub SetItem(ByVal index As Integer, _\n        ByVal newItem As MutableKey)\n\n        Dim replaced As MutableKey = Items(index)\n\n        If newItem.Collection IsNot Nothing Then _\n            Throw New ArgumentException(&quot;The item already belongs to a collection.&quot;)\n\n        MyBase.SetItem(index, newItem)\n        newItem.Collection = Me\n        replaced.Collection = Nothing\n    End Sub\n\n    Protected Overrides Sub RemoveItem(ByVal index As Integer)\n        Dim removedItem As MutableKey = Items(index)\n\n        MyBase.RemoveItem(index)\n        removedItem.Collection = Nothing\n    End Sub\n\n    Protected Overrides Sub ClearItems()\n        For Each mk As MutableKey In Items\n            mk.Collection = Nothing\n        Next\n        \n        MyBase.ClearItems()\n    End Sub\n\n    Friend Sub ChangeKey(ByVal item As MutableKey, _\n        ByVal newKey As Integer)\n\n        MyBase.ChangeItemKey(item, newKey)\n    End Sub\n    \n    Public Sub Dump()\n        Console.WriteLine(vbLf &amp; &quot;DUMP:&quot;)\n        If Dictionary Is Nothing Then\n            Console.WriteLine(&quot;    The dictionary has not been created.&quot;)\n        Else\n            Console.WriteLine(&quot;    Dictionary entries&quot;)\n            Console.WriteLine(&quot;    ------------------&quot;)\n\n            For Each kvp As KeyValuePair(Of Integer, MutableKey) In Dictionary\n                Console.WriteLine(&quot;    {0} : {1}&quot;, kvp.Key, kvp.Value)\n            Next\n        End If\n\n        Console.WriteLine(vbLf &amp; &quot;    List of items&quot;)\n        Console.WriteLine(&quot;    -------------&quot;)\n\n        For Each mk As MutableKey In Items\n            Console.WriteLine(&quot;    {0}&quot;, mk)\n        Next\n    End Sub\n\nEnd Class\n\nPublic Class Demo\n    \n    Public Shared Sub Main() \n\n        Dim mkeys As New MutableKeys()\n\n        &#39; The Add method is inherited from Collection.\n        &#39;\n        mkeys.Add(New MutableKey(110072674, &quot;Widget&quot;))\n        mkeys.Add(New MutableKey(110072675, &quot;Sprocket&quot;))\n\n        mkeys.Dump() \n    \n        Console.WriteLine(vbLf &amp; &quot;Create and insert a new item:&quot;)\n        Dim test As New MutableKey(110072684, &quot;Gear&quot;)\n        mkeys.Insert(1, test)\n\n        mkeys.Dump()\n\n        Try\n            Console.WriteLine(vbLf &amp; &quot;Try to insert the item again:&quot;)\n            mkeys.Insert(1, test)\n        Catch ex As ArgumentException\n            Console.WriteLine(&quot;Error: {0}&quot;, ex.Message)\n        End Try\n\n        Console.WriteLine(vbLf &amp; &quot;Change the Key property of the item:&quot;)\n        test.Key = 100000072\n\n        mkeys.Dump()\n\n        Try\n            Console.WriteLine(vbLf &amp; &quot;Try to set the Key property to an existing key:&quot;)\n            test.Key = 110072674\n        Catch ex As ArgumentException\n            Console.WriteLine(&quot;Error: {0}&quot;, ex.Message)\n        End Try\n\n        mkeys.Dump()\n\n    End Sub\n    \n    Private Shared Sub Display(ByVal order As MutableKeys) \n        Console.WriteLine()\n        For Each item As MutableKey In  order\n            Console.WriteLine(item)\n        Next item\n    End Sub\nEnd Class\n\n&#39; This class has a key that can be changed.\n&#39; \nPublic Class MutableKey\n\n    Public Sub New(ByVal newKey As Integer, ByVal newValue As String)\n        _key = newKey\n        Value = newValue\n    End Sub &#39;New\n    \n    Public Value As String\n    Friend Collection As MutableKeys\n    \n    Private _key As Integer\n    Public Property Key As Integer \n        Get\n            Return _key\n        End Get\n        Set\n            If Collection IsNot Nothing Then\n                Collection.ChangeKey(Me, value)\n            End If\n\n            _key = value\n        End Set\n    End Property\n\n    Public Overrides Function ToString() As String \n        Return String.Format(&quot;{0,9} {1}&quot;, _key, Value)\n    End Function\n        \nEnd Class\n\n&#39; This code example produces the following output:\n&#39;\n&#39;DUMP:\n&#39;    Dictionary entries\n&#39;    ------------------\n&#39;    110072674 : 110072674 Widget\n&#39;    110072675 : 110072675 Sprocket\n&#39;\n&#39;    List of items\n&#39;    -------------\n&#39;    110072674 Widget\n&#39;    110072675 Sprocket\n&#39;\n&#39;Create and insert a new item:\n&#39;\n&#39;DUMP:\n&#39;    Dictionary entries\n&#39;    ------------------\n&#39;    110072674 : 110072674 Widget\n&#39;    110072675 : 110072675 Sprocket\n&#39;    110072684 : 110072684 Gear\n&#39;\n&#39;    List of items\n&#39;    -------------\n&#39;    110072674 Widget\n&#39;    110072684 Gear\n&#39;    110072675 Sprocket\n&#39;\n&#39;Try to insert the item again:\n&#39;Error: The item already belongs to a collection.\n&#39;\n&#39;Change the Key property of the item:\n&#39;\n&#39;DUMP:\n&#39;    Dictionary entries\n&#39;    ------------------\n&#39;    110072674 : 110072674 Widget\n&#39;    110072675 : 110072675 Sprocket\n&#39;    100000072 : 100000072 Gear\n&#39;\n&#39;    List of items\n&#39;    -------------\n&#39;    110072674 Widget\n&#39;    100000072 Gear\n&#39;    110072675 Sprocket\n&#39;\n&#39;Try to set the Key property to an existing key:\n&#39;Error: An item with the same key has already been added.\n&#39;\n&#39;DUMP:\n&#39;    Dictionary entries\n&#39;    ------------------\n&#39;    110072674 : 110072674 Widget\n&#39;    110072675 : 110072675 Sprocket\n&#39;    100000072 : 100000072 Gear\n&#39;\n&#39;    List of items\n&#39;    -------------\n&#39;    110072674 Widget\n&#39;    100000072 Gear\n&#39;    110072675 Sprocket\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Collections_ObjectModel_KeyedCollection_2_Remove__0_\">\r\n    \r\n            <a id=\"System_Collections_ObjectModel_KeyedCollection_2_Remove_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Remove(TKey)</div>        \r\n          </div>\r\n    \r\n            <p>Removes the element with the specified key from the <span class=\"xref\">stem.Collections.ObjectModel.KeyedCollection`2</span>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public bool Remove (TKey key);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>key</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><span class=\"xref\">TKey</span></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The key of the element to remove.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the element is successfully removed; otherwise, <code>false</code>.  This method also returns <code>false</code> if <code>key</code> is not found in the <span class=\"xref\">stem.Collections.ObjectModel.KeyedCollection`2</span>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>key</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The key of the element is also removed from the lookup dictionary.  </p>\n<p> If the number of elements has exceeded the dictionary creation threshold and the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> is using a lookup dictionary, it will continue to use a lookup dictionary even though the number of elements is again under the threshold.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> To customize the behavior of this method, override the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_RemoveItem_\" data-linktype=\"relative-path\">RemoveItem</a> method.  </p>\n</div>\n<p> This method is an O(<code>n</code>) operation, where <code>n</code> is <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Count_\" data-linktype=\"relative-path\">Count</a>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>This code example shows the minimum code necessary to derive a collection class from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a>: overriding the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_GetKeyForItem_\" data-linktype=\"relative-path\">GetKeyForItem</a> method and providing a public constructor that delegates to a base class constructor. The code example also demonstrates many of the properties and methods inherited from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> and <a class=\"xref\" href=\"system.collections.objectmodel.collection-1\" data-linktype=\"relative-path\">Collection&lt;T&gt;</a> classes.  </p>\n<p> The example demonstrates Remove method inherited from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a>, which removes the item with a specified key, and also the <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Remove_\" data-linktype=\"relative-path\">Remove</a> and <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_RemoveAt_\" data-linktype=\"relative-path\">RemoveAt</a> methods inherited from <a class=\"xref\" href=\"system.collections.objectmodel.collection-1\" data-linktype=\"relative-path\">Collection&lt;T&gt;</a>, which remove by object and by index respectively.  </p>\n<p> The <code>SimpleOrder</code> class is a very simple requisition list that contains <code>OrderItem</code> objects, each of which represents a line item in the order. The key of <code>OrderItem</code> is immutable, an important consideration for classes that derive from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a>. For a code example that uses mutable keys, see <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_ChangeItemKey_\" data-linktype=\"relative-path\">ChangeItemKey</a>.  </p>\n<pre><code class=\"lang-cpp\" name=\"KeyedCollection#1\">using namespace System;\nusing namespace System::Collections::Generic;\nusing namespace System::Collections::ObjectModel;\n\n// This class represents a simple line item in an order. All the \n// values are immutable except quantity.\n// \npublic ref class OrderItem\n{\nprivate:\n    int _quantity;\n    \npublic:\n    initonly int PartNumber;\n    initonly String^ Description;\n    initonly double UnitPrice;\n    \n    OrderItem(int partNumber, String^ description, \n        int quantity, double unitPrice)\n    {\n        this-&gt;PartNumber = partNumber;\n        this-&gt;Description = description;\n        this-&gt;Quantity = quantity;\n        this-&gt;UnitPrice = unitPrice;\n    } \n    \n    property int Quantity    \n    {\n        int get() { return _quantity; }\n        void set(int value)\n        {\n            if (value &lt; 0)\n                throw gcnew ArgumentException(&quot;Quantity cannot be negative.&quot;);\n            \n            _quantity = value;\n        }\n    }\n        \n    virtual String^ ToString() override \n    {\n        return String::Format(\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, \n            PartNumber, _quantity, Description, UnitPrice, \n            UnitPrice * _quantity);\n    }\n};\n\n// This class represents a very simple keyed list of OrderItems,\n// inheriting most of its behavior from the KeyedCollection and \n// Collection classes. The immediate base class is the constructed\n// type KeyedCollection&lt;int, OrderItem&gt;. When you inherit\n// from KeyedCollection, the second generic type argument is the \n// type that you want to store in the collection -- in this case\n// OrderItem. The first type argument is the type that you want\n// to use as a key. Its values must be calculated from OrderItem; \n// in this case it is the int field PartNumber, so SimpleOrder\n// inherits KeyedCollection&lt;int, OrderItem&gt;.\n//\npublic ref class SimpleOrder : KeyedCollection&lt;int, OrderItem^&gt;\n{\n    // The parameterless constructor of the base class creates a \n    // KeyedCollection with an internal dictionary. For this code \n    // example, no other constructors are exposed.\n    //\npublic:\n    SimpleOrder() {}\n    \n    // This is the only method that absolutely must be overridden,\n    // because without it the KeyedCollection cannot extract the\n    // keys from the items. The input parameter type is the \n    // second generic type argument, in this case OrderItem, and \n    // the return value type is the first generic type argument,\n    // in this case int.\n    //\nprotected:\n    virtual int GetKeyForItem(OrderItem^ item) override \n    {\n        // In this example, the key is the part number.\n        return item-&gt;PartNumber;\n    }\n};\n\npublic ref class Demo\n{    \npublic:\n    static void Main()\n    {\n        SimpleOrder^ weekly = gcnew SimpleOrder();\n\n        // The Add method, inherited from Collection, takes OrderItem.\n        //\n        weekly-&gt;Add(gcnew OrderItem(110072674, &quot;Widget&quot;, 400, 45.17));\n        weekly-&gt;Add(gcnew OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3));\n        weekly-&gt;Add(gcnew OrderItem(101030411, &quot;Motor&quot;, 10, 237.5));\n        weekly-&gt;Add(gcnew OrderItem(110072684, &quot;Gear&quot;, 175, 5.17));\n        \n        Display(weekly);\n    \n        // The Contains method of KeyedCollection takes the key, \n        // type, in this case int.\n        //\n        Console::WriteLine(&quot;<br>Contains(101030411): {0}&quot;, \n            weekly-&gt;Contains(101030411));\n\n        // The default Item property of KeyedCollection takes a key.\n        //\n        Console::WriteLine(&quot;<br>weekly(101030411)-&gt;Description: {0}&quot;, \n            weekly[101030411]-&gt;Description);\n\n        // The Remove method of KeyedCollection takes a key.\n        //\n        Console::WriteLine(&quot;<br>Remove(101030411)&quot;);\n        weekly-&gt;Remove(101030411);\n        Display(weekly);\n\n        // The Insert method, inherited from Collection, takes an \n        // index and an OrderItem.\n        //\n        Console::WriteLine(&quot;<br>Insert(2, New OrderItem(...))&quot;);\n        weekly-&gt;Insert(2, gcnew OrderItem(111033401, &quot;Nut&quot;, 10, .5));\n        Display(weekly);\n\n        // The default Item property is overloaded. One overload comes\n        // from KeyedCollection&lt;int, OrderItem&gt;; that overload\n        // is read-only, and takes Integer because it retrieves by key. \n        // The other overload comes from Collection&lt;OrderItem&gt;, the \n        // base class of KeyedCollection&lt;int, OrderItem&gt;; it \n        // retrieves by index, so it also takes an Integer. The compiler\n        // uses the most-derived overload, from KeyedCollection, so the\n        // only way to access SimpleOrder by index is to cast it to\n        // Collection&lt;OrderItem&gt;. Otherwise the index is interpreted\n        // as a key, and KeyNotFoundException is thrown.\n        //\n        Collection&lt;OrderItem^&gt;^ coweekly = weekly;\n        Console::WriteLine(&quot;<br>coweekly[2].Description: {0}&quot;, \n            coweekly[2]-&gt;Description);\n \n        Console::WriteLine(&quot;<br>coweekly[2] = gcnew OrderItem(...)&quot;);\n        coweekly[2] = gcnew OrderItem(127700026, &quot;Crank&quot;, 27, 5.98);\n\n        OrderItem^ temp = coweekly[2];\n\n        // The IndexOf method inherited from Collection&lt;OrderItem&gt; \n        // takes an OrderItem instead of a key\n        // \n        Console::WriteLine(&quot;<br>IndexOf(temp): {0}&quot;, weekly-&gt;IndexOf(temp));\n\n        // The inherited Remove method also takes an OrderItem.\n        //\n        Console::WriteLine(&quot;<br>Remove(temp)&quot;);\n        weekly-&gt;Remove(temp);\n        Display(weekly);\n\n        Console::WriteLine(&quot;<br>RemoveAt(0)&quot;);\n        weekly-&gt;RemoveAt(0);\n        Display(weekly);\n\n    }\n    \nprivate:\n    static void Display(SimpleOrder^ order)\n    {\n        Console::WriteLine();\n        for each( OrderItem^ item in order )\n        {\n            Console::WriteLine(item);\n        }\n    }\n};\n\nvoid main()\n{\n    Demo::Main();\n}\n\n/* This code example produces the following output:\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n101030411     10 Motor        at   237.50 =   2,375.00\n110072684    175 Gear         at     5.17 =     904.75\n\nContains(101030411): True\n\nweekly(101030411)-&gt;Description: Motor\n\nRemove(101030411)\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n\nInsert(2, New OrderItem(...))\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n111033401     10 Nut          at      .50 =       5.00\n110072684    175 Gear         at     5.17 =     904.75\n\ncoweekly(2)-&gt;Description: Nut\n\ncoweekly[2] = gcnew OrderItem(...)\n\nIndexOf(temp): 2\n\nRemove(temp)\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n\nRemoveAt(0)\n\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n */\n</code></pre><pre><code class=\"lang-cs\" name=\"KeyedCollection#1\">using System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\n\n// This class represents a very simple keyed list of OrderItems,\n// inheriting most of its behavior from the KeyedCollection and \n// Collection classes. The immediate base class is the constructed\n// type KeyedCollection&lt;int, OrderItem&gt;. When you inherit\n// from KeyedCollection, the second generic type argument is the \n// type that you want to store in the collection -- in this case\n// OrderItem. The first type argument is the type that you want\n// to use as a key. Its values must be calculated from OrderItem; \n// in this case it is the int field PartNumber, so SimpleOrder\n// inherits KeyedCollection&lt;int, OrderItem&gt;.\n//\npublic class SimpleOrder : KeyedCollection&lt;int, OrderItem&gt;\n{\n       \n    // This is the only method that absolutely must be overridden,\n    // because without it the KeyedCollection cannot extract the\n    // keys from the items. The input parameter type is the \n    // second generic type argument, in this case OrderItem, and \n    // the return value type is the first generic type argument,\n    // in this case int.\n    //\n    protected override int GetKeyForItem(OrderItem item)\n    {\n        // In this example, the key is the part number.\n        return item.PartNumber;\n    }\n}\n\npublic class Demo\n{    \n    public static void Main()\n    {\n        SimpleOrder weekly = new SimpleOrder();\n\n        // The Add method, inherited from Collection, takes OrderItem.\n        //\n        weekly.Add(new OrderItem(110072674, &quot;Widget&quot;, 400, 45.17));\n        weekly.Add(new OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3));\n        weekly.Add(new OrderItem(101030411, &quot;Motor&quot;, 10, 237.5));\n        weekly.Add(new OrderItem(110072684, &quot;Gear&quot;, 175, 5.17));\n        \n        Display(weekly);\n    \n        // The Contains method of KeyedCollection takes the key, \n        // type, in this case int.\n        //\n        Console.WriteLine(&quot;<br>Contains(101030411): {0}&quot;, \n            weekly.Contains(101030411));\n\n        // The default Item property of KeyedCollection takes a key.\n        //\n        Console.WriteLine(&quot;<br>weekly[101030411].Description: {0}&quot;, \n            weekly[101030411].Description);\n\n        // The Remove method of KeyedCollection takes a key.\n        //\n        Console.WriteLine(&quot;<br>Remove(101030411)&quot;);\n        weekly.Remove(101030411);\n        Display(weekly);\n\n        // The Insert method, inherited from Collection, takes an \n        // index and an OrderItem.\n        //\n        Console.WriteLine(&quot;<br>Insert(2, New OrderItem(...))&quot;);\n        weekly.Insert(2, new OrderItem(111033401, &quot;Nut&quot;, 10, .5));\n        Display(weekly);\n\n        // The default Item property is overloaded. One overload comes\n        // from KeyedCollection&lt;int, OrderItem&gt;; that overload\n        // is read-only, and takes Integer because it retrieves by key. \n        // The other overload comes from Collection&lt;OrderItem&gt;, the \n        // base class of KeyedCollection&lt;int, OrderItem&gt;; it \n        // retrieves by index, so it also takes an Integer. The compiler\n        // uses the most-derived overload, from KeyedCollection, so the\n        // only way to access SimpleOrder by index is to cast it to\n        // Collection&lt;OrderItem&gt;. Otherwise the index is interpreted\n        // as a key, and KeyNotFoundException is thrown.\n        //\n        Collection&lt;OrderItem&gt; coweekly = weekly;\n        Console.WriteLine(&quot;<br>coweekly[2].Description: {0}&quot;, \n            coweekly[2].Description);\n \n        Console.WriteLine(&quot;<br>coweekly[2] = new OrderItem(...)&quot;);\n        coweekly[2] = new OrderItem(127700026, &quot;Crank&quot;, 27, 5.98);\n\n        OrderItem temp = coweekly[2];\n\n        // The IndexOf method inherited from Collection&lt;OrderItem&gt; \n        // takes an OrderItem instead of a key\n        // \n        Console.WriteLine(&quot;<br>IndexOf(temp): {0}&quot;, weekly.IndexOf(temp));\n\n        // The inherited Remove method also takes an OrderItem.\n        //\n        Console.WriteLine(&quot;<br>Remove(temp)&quot;);\n        weekly.Remove(temp);\n        Display(weekly);\n\n        Console.WriteLine(&quot;<br>RemoveAt(0)&quot;);\n        weekly.RemoveAt(0);\n        Display(weekly);\n\n    }\n    \n    private static void Display(SimpleOrder order)\n    {\n        Console.WriteLine();\n        foreach( OrderItem item in order )\n        {\n            Console.WriteLine(item);\n        }\n    }\n}\n\n// This class represents a simple line item in an order. All the \n// values are immutable except quantity.\n// \npublic class OrderItem\n{\n    public readonly int PartNumber;\n    public readonly string Description;\n    public readonly double UnitPrice;\n    \n    private int _quantity = 0;\n    \n    public OrderItem(int partNumber, string description, \n        int quantity, double unitPrice)\n    {\n        this.PartNumber = partNumber;\n        this.Description = description;\n        this.Quantity = quantity;\n        this.UnitPrice = unitPrice;\n    } \n    \n    public int Quantity    \n    {\n        get { return _quantity; }\n        set\n        {\n            if (value&lt;0)\n                throw new ArgumentException(&quot;Quantity cannot be negative.&quot;);\n            \n            _quantity = value;\n        }\n    }\n        \n    public override string ToString()\n    {\n        return String.Format(\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, \n            PartNumber, _quantity, Description, UnitPrice, \n            UnitPrice * _quantity);\n    }\n}\n\n/* This code example produces the following output:\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n101030411     10 Motor        at   237.50 =   2,375.00\n110072684    175 Gear         at     5.17 =     904.75\n\nContains(101030411): True\n\nweekly[101030411].Description: Motor\n\nRemove(101030411)\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n\nInsert(2, New OrderItem(...))\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n111033401     10 Nut          at      .50 =       5.00\n110072684    175 Gear         at     5.17 =     904.75\n\ncoweekly[2].Description: Nut\n\ncoweekly[2] = new OrderItem(...)\n\nIndexOf(temp): 2\n\nRemove(temp)\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n\nRemoveAt(0)\n\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684    175 Gear         at     5.17 =     904.75\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"KeyedCollection#1\">Imports System\nImports System.Collections.Generic\nImports System.Collections.ObjectModel\n\n&#39; This class represents a very simple keyed list of OrderItems,\n&#39; inheriting most of its behavior from the KeyedCollection and \n&#39; Collection classes. The immediate base class is the constructed\n&#39; type KeyedCollection(Of Integer, OrderItem). When you inherit\n&#39; from KeyedCollection, the second generic type argument is the \n&#39; type that you want to store in the collection -- in this case\n&#39; OrderItem. The first generic argument is the type that you want\n&#39; to use as a key. Its values must be calculated from OrderItem; \n&#39; in this case it is the Integer field PartNumber, so SimpleOrder\n&#39; inherits KeyedCollection(Of Integer, OrderItem).\n&#39;\nPublic Class SimpleOrder\n    Inherits KeyedCollection(Of Integer, OrderItem)\n\n\n    &#39; This is the only method that absolutely must be overridden,\n    &#39; because without it the KeyedCollection cannot extract the\n    &#39; keys from the items. The input parameter type is the \n    &#39; second generic type argument, in this case OrderItem, and \n    &#39; the return value type is the first generic type argument,\n    &#39; in this case Integer.\n    &#39;\n    Protected Overrides Function GetKeyForItem( _\n        ByVal item As OrderItem) As Integer\n\n        &#39; In this example, the key is the part number.\n        Return item.PartNumber   \n    End Function\n\nEnd Class\n\nPublic Class Demo\n    \n    Public Shared Sub Main() \n        Dim weekly As New SimpleOrder()\n\n        &#39; The Add method, inherited from Collection, takes OrderItem.\n        &#39;\n        weekly.Add(New OrderItem(110072674, &quot;Widget&quot;, 400, 45.17))\n        weekly.Add(New OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3))\n        weekly.Add(New OrderItem(101030411, &quot;Motor&quot;, 10, 237.5))\n        weekly.Add(New OrderItem(110072684, &quot;Gear&quot;, 175, 5.17))\n        \n        Display(weekly)\n    \n        &#39; The Contains method of KeyedCollection takes TKey.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Contains(101030411): {0}&quot;, _\n            weekly.Contains(101030411))\n\n        &#39; The default Item property of KeyedCollection takes the key\n        &#39; type, Integer.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;weekly(101030411).Description: {0}&quot;, _\n            weekly(101030411).Description)\n\n        &#39; The Remove method of KeyedCollection takes a key.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Remove(101030411)&quot;)\n        weekly.Remove(101030411)\n        Display(weekly)\n\n        &#39; The Insert method, inherited from Collection, takes an \n        &#39; index and an OrderItem.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Insert(2, New OrderItem(...))&quot;)\n        weekly.Insert(2, New OrderItem(111033401, &quot;Nut&quot;, 10, .5))\n        Display(weekly)\n\n        &#39; The default Item property is overloaded. One overload comes\n        &#39; from KeyedCollection(Of Integer, OrderItem); that overload\n        &#39; is read-only, and takes Integer because it retrieves by key. \n        &#39; The other overload comes from Collection(Of OrderItem), the \n        &#39; base class of KeyedCollection(Of Integer, OrderItem); it \n        &#39; retrieves by index, so it also takes an Integer. The compiler\n        &#39; uses the most-derived overload, from KeyedCollection, so the\n        &#39; only way to access SimpleOrder by index is to cast it to\n        &#39; Collection(Of OrderItem). Otherwise the index is interpreted\n        &#39; as a key, and KeyNotFoundException is thrown.\n        &#39;\n        Dim coweekly As Collection(Of OrderItem) = weekly\n        Console.WriteLine(vbLf &amp; &quot;coweekly(2).Description: {0}&quot;, _\n            coweekly(2).Description)\n \n        Console.WriteLine(vbLf &amp; &quot;coweekly(2) = New OrderItem(...)&quot;)\n        coweekly(2) = New OrderItem(127700026, &quot;Crank&quot;, 27, 5.98)\n\n        Dim temp As OrderItem = coweekly(2)\n\n        &#39; The IndexOf method, inherited from Collection(Of OrderItem), \n        &#39; takes an OrderItem instead of a key.\n        &#39; \n        Console.WriteLine(vbLf &amp; &quot;IndexOf(temp): {0}&quot;, _\n            weekly.IndexOf(temp))\n\n        &#39; The inherited Remove method also takes an OrderItem.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Remove(temp)&quot;)\n        weekly.Remove(temp)\n        Display(weekly)\n\n        Console.WriteLine(vbLf &amp; &quot;RemoveAt(0)&quot;)\n        weekly.RemoveAt(0)\n        Display(weekly)\n\n    End Sub\n    \n    Private Shared Sub Display(ByVal order As SimpleOrder) \n        Console.WriteLine()\n        For Each item As OrderItem In  order\n            Console.WriteLine(item)\n        Next item\n    End Sub\nEnd Class\n\n&#39; This class represents a simple line item in an order. All the \n&#39; values are immutable except quantity.\n&#39; \nPublic Class OrderItem\n    Public ReadOnly PartNumber As Integer\n    Public ReadOnly Description As String\n    Public ReadOnly UnitPrice As Double\n    \n    Private _quantity As Integer = 0\n    \n    Public Sub New(ByVal partNumber As Integer, _\n                   ByVal description As String, _\n                   ByVal quantity As Integer, _\n                   ByVal unitPrice As Double) \n        Me.PartNumber = partNumber\n        Me.Description = description\n        Me.Quantity = quantity\n        Me.UnitPrice = unitPrice\n    End Sub &#39;New\n    \n    Public Property Quantity() As Integer \n        Get\n            Return _quantity\n        End Get\n        Set\n            If value &lt; 0 Then\n                Throw New ArgumentException(&quot;Quantity cannot be negative.&quot;)\n            End If\n            _quantity = value\n        End Set\n    End Property\n        \n    Public Overrides Function ToString() As String \n        Return String.Format( _\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, _\n            PartNumber, _quantity, Description, UnitPrice, _\n            UnitPrice * _quantity)\n    End Function\nEnd Class\n\n&#39; This code example produces the following output:\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;101030411     10 Motor        at   237.50 =   2,375.00\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;Contains(101030411): True\n&#39;\n&#39;weekly(101030411).Description: Motor\n&#39;\n&#39;Remove(101030411)\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;Insert(2, New OrderItem(...))\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;111033401     10 Nut          at      .50 =       5.00\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;coweekly(2).Description: Nut\n&#39;\n&#39;coweekly(2) = New OrderItem(...)\n&#39;\n&#39;IndexOf(temp): 2\n&#39;\n&#39;Remove(temp)\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;RemoveAt(0)\n&#39;\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;110072684    175 Gear         at     5.17 =     904.75\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Collections_ObjectModel_KeyedCollection_2_RemoveItem_System_Int32_\">\r\n    \r\n            <a id=\"System_Collections_ObjectModel_KeyedCollection_2_RemoveItem_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">RemoveItem(Int32)</div>        \r\n          </div>\r\n    \r\n            <p>Removes the element at the specified index of the <span class=\"xref\">stem.Collections.ObjectModel.KeyedCollection`2</span>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected override void RemoveItem (int index);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>index</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The index of the element to remove.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The key of the element is also removed from the lookup dictionary.  </p>\n<p> If the number of elements has exceeded the dictionary creation threshold and the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> is using a lookup dictionary, it will continue to use a lookup dictionary even though the number of elements is again under the threshold.  </p>\n<p> This method is an O(<code>n</code>) operation, where <code>n</code> is <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Count_\" data-linktype=\"relative-path\">Count</a>.  </p>\n<h2 id=\"notes-for-implementers\">Notes for Implementers</h2>\n<p> Override this method to provide customized behavior for the <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Remove__0_\" data-linktype=\"relative-path\">Remove(T)</a> and <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_RemoveAt_System_Int32_\" data-linktype=\"relative-path\">RemoveAt(Int32)</a> methods, inherited from the <a class=\"xref\" href=\"system.collections.objectmodel.collection-1\" data-linktype=\"relative-path\">Collection&lt;T&gt;</a> generic class, and the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_Remove__0_\" data-linktype=\"relative-path\">Remove(TKey)</a> method.  </p>\n<p> Call the base class implementation of this method to remove the item from the underlying collection and to update the lookup dictionary.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>This section contains two code examples that demonstrate overriding the RemoveItem method to provide custom behavior for removing objects from the collection. The first example adds a custom notification event and the second provides support for a collection of objects with mutable keys.  </p>\n<p> Example 1  </p>\n<p> The following code example shows how to override the protected <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_InsertItem_\" data-linktype=\"relative-path\">InsertItem</a>, RemoveItem, <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_ClearItems_\" data-linktype=\"relative-path\">ClearItems</a>, and <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_SetItem_\" data-linktype=\"relative-path\">SetItem</a> methods, to provide custom behavior for the <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Add_\" data-linktype=\"relative-path\">Add</a>, <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_Remove_\" data-linktype=\"relative-path\">Remove</a>, and <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Clear_\" data-linktype=\"relative-path\">Clear</a> methods, and for setting the default <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Item_\" data-linktype=\"relative-path\">Item</a> property (the indexer in C#). The custom behavior provided in this example is a notification event named <code>Changed</code>, which is raised at the end of each of the overridden methods.  </p>\n<p> The code example creates the <code>SimpleOrder</code> class, which derives from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> and represents a simple order form. The order form contains <code>OrderItem</code> objects representing items ordered. The code example also creates a <code>SimpleOrderChangedEventArgs</code> class to contain the event information, and an enumeration to identify the type of change.  </p>\n<p> The code example demonstrates the custom behavior by calling the properties and methods of the derived class, in the <code>Main</code> method of the <code>Demo</code> class.  </p>\n<p> This code example uses objects with immutable keys. For a code example that uses mutable keys, see <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_ChangeItemKey_\" data-linktype=\"relative-path\">ChangeItemKey</a>.  </p>\n<pre><code class=\"lang-vb\" name=\"KeyedCollection2#1\">Imports System\nImports System.Collections.Generic\nImports System.Collections.ObjectModel\n\n&#39; This class derives from KeyedCollection and shows how to override\n&#39; the protected ClearItems, InsertItem, RemoveItem, and SetItem \n&#39; methods in order to change the behavior of the default Item \n&#39; property and the Add, Clear, Insert, and Remove methods. The\n&#39; class implements a Changed event, which is raised by all the\n&#39; protected methods.\n&#39;\n&#39; SimpleOrder is a collection of OrderItem objects, and its key\n&#39; is the PartNumber field of OrderItem. PartNumber is an Integer,\n&#39; so SimpleOrder inherits KeyedCollection(Of Integer, OrderItem).\n&#39; (Note that the key of OrderItem cannot be changed; if it could \n&#39; be changed, SimpleOrder would have to override ChangeItemKey.)\n&#39;\nPublic Class SimpleOrder\n    Inherits KeyedCollection(Of Integer, OrderItem)\n\n    Public Event Changed As EventHandler(Of SimpleOrderChangedEventArgs)\n\n    &#39; This parameterless constructor calls the base class constructor\n    &#39; that specifies a dictionary threshold of 0, so that the internal\n    &#39; dictionary is created as soon as an item is added to the \n    &#39; collection.\n    &#39;\n    Public Sub New()\n        MyBase.New(Nothing, 0)\n    End Sub\n    \n    &#39; This is the only method that absolutely must be overridden,\n    &#39; because without it the KeyedCollection cannot extract the\n    &#39; keys from the items. \n    &#39;\n    Protected Overrides Function GetKeyForItem( _\n        ByVal item As OrderItem) As Integer\n\n        &#39; In this example, the key is the part number.\n        Return item.PartNumber   \n    End Function\n\n    Protected Overrides Sub InsertItem( _\n        ByVal index As Integer, ByVal newItem As OrderItem)\n\n        MyBase.InsertItem(index, newItem)\n\n        RaiseEvent Changed(Me, New SimpleOrderChangedEventArgs( _\n            ChangeType.Added, newItem, Nothing))\n    End Sub\n\n    Protected Overrides Sub SetItem(ByVal index As Integer, _\n        ByVal newItem As OrderItem)\n\n        Dim replaced As OrderItem = Items(index)\n        MyBase.SetItem(index, newItem)\n\n        RaiseEvent Changed(Me, New SimpleOrderChangedEventArgs( _\n            ChangeType.Replaced, replaced, newItem))\n    End Sub\n\n    Protected Overrides Sub RemoveItem(ByVal index As Integer)\n\n        Dim removedItem As OrderItem = Items(index)\n        MyBase.RemoveItem(index)\n\n        RaiseEvent Changed(Me, New SimpleOrderChangedEventArgs( _\n            ChangeType.Removed, removedItem, Nothing))\n    End Sub\n\n    Protected Overrides Sub ClearItems()\n        MyBase.ClearItems()\n\n        RaiseEvent Changed(Me, New SimpleOrderChangedEventArgs( _\n            ChangeType.Cleared, Nothing, Nothing))\n    End Sub\n\nEnd Class\n\n&#39; Event argument for the Changed event.\n&#39;\nPublic Class SimpleOrderChangedEventArgs\n    Inherits EventArgs\n\n    Private _changedItem As OrderItem\n    Private _changeType As ChangeType\n    Private _replacedWith As OrderItem\n\n    Public ReadOnly Property ChangedItem As OrderItem\n        Get\n            Return _changedItem\n        End Get\n    End Property\n\n    Public ReadOnly Property ChangeType As ChangeType\n        Get\n            Return _changeType\n        End Get\n    End Property\n\n    Public ReadOnly Property ReplacedWith As OrderItem\n        Get\n            Return _replacedWith\n        End Get\n    End Property\n\n    Public Sub New(ByVal change As ChangeType, ByVal item As OrderItem, _\n        ByVal replacement As OrderItem)\n\n        _changeType = change\n        _changedItem = item\n        _replacedWith = replacement\n    End Sub\nEnd Class\n\nPublic Enum ChangeType\n    Added\n    Removed\n    Replaced\n    Cleared\nEnd Enum\n\nPublic Class Demo\n    \n    Public Shared Sub Main() \n        Dim weekly As New SimpleOrder()\n        AddHandler weekly.Changed, AddressOf ChangedHandler\n\n        &#39; The Add method, inherited from Collection, takes OrderItem.\n        &#39;\n        weekly.Add(New OrderItem(110072674, &quot;Widget&quot;, 400, 45.17))\n        weekly.Add(New OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3))\n        weekly.Add(New OrderItem(101030411, &quot;Motor&quot;, 10, 237.5))\n        weekly.Add(New OrderItem(110072684, &quot;Gear&quot;, 175, 5.17))\n\n        Display(weekly)\n        \n        &#39; The Contains method of KeyedCollection takes TKey.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Contains(101030411): {0}&quot;, _\n            weekly.Contains(101030411))\n\n        &#39; The default Item property of KeyedCollection takes the key\n        &#39; type, Integer. The property is read-only.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;weekly(101030411).Description: {0}&quot;, _\n            weekly(101030411).Description)\n\n        &#39; The Remove method of KeyedCollection takes a key.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Remove(101030411)&quot;)\n        weekly.Remove(101030411)\n\n        &#39; The Insert method, inherited from Collection, takes an \n        &#39; index and an OrderItem.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Insert(2, New OrderItem(...))&quot;)\n        weekly.Insert(2, New OrderItem(111033401, &quot;Nut&quot;, 10, .5))\n         \n        &#39; The default Item property is overloaded. One overload comes\n        &#39; from KeyedCollection(Of Integer, OrderItem); that overload\n        &#39; is read-only, and takes Integer because it retrieves by key. \n        &#39; The other overload comes from Collection(Of OrderItem), the \n        &#39; base class of KeyedCollection(Of Integer, OrderItem); it \n        &#39; retrieves by index, so it also takes an Integer. The compiler\n        &#39; uses the most-derived overload, from KeyedCollection, so the\n        &#39; only way to access SimpleOrder by index is to cast it to\n        &#39; Collection(Of OrderItem). Otherwise the index is interpreted\n        &#39; as a key, and KeyNotFoundException is thrown.\n        &#39;\n        Dim coweekly As Collection(Of OrderItem) = weekly\n        Console.WriteLine(vbLf &amp; &quot;coweekly(2).Description: {0}&quot;, _\n            coweekly(2).Description)\n \n        Console.WriteLine(vbLf &amp; &quot;coweekly(2) = New OrderItem(...)&quot;)\n        coweekly(2) = New OrderItem(127700026, &quot;Crank&quot;, 27, 5.98)\n\n        Dim temp As OrderItem = coweekly(2)\n\n        &#39; The IndexOf method, inherited from Collection(Of OrderItem), \n        &#39; takes an OrderItem instead of a key.\n        &#39; \n        Console.WriteLine(vbLf &amp; &quot;IndexOf(temp): {0}&quot;, _\n            weekly.IndexOf(temp))\n\n        &#39; The inherited Remove method also takes an OrderItem.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Remove(temp)&quot;)\n        weekly.Remove(temp)\n\n        Console.WriteLine(vbLf &amp; &quot;RemoveAt(0)&quot;)\n        weekly.RemoveAt(0)\n\n        &#39; Increase the quantity for a line item.\n        Console.WriteLine(vbLf &amp; &quot;coweekly(1) = New OrderItem(...)&quot;)\n        coweekly(1) = New OrderItem(coweekly(1).PartNumber, _\n            coweekly(1).Description, coweekly(1).Quantity + 1000, _\n            coweekly(1).UnitPrice)\n\n        Display(weekly)\n\n        Console.WriteLine()\n        weekly.Clear()\n    End Sub\n    \n    Private Shared Sub Display(ByVal order As SimpleOrder) \n        Console.WriteLine()\n        For Each item As OrderItem In  order\n            Console.WriteLine(item)\n        Next item\n    End Sub\n\n    Private Shared Sub ChangedHandler(ByVal source As Object, _\n        ByVal e As SimpleOrderChangedEventArgs)\n\n        Dim item As OrderItem = e.ChangedItem\n\n        If e.ChangeType = ChangeType.Replaced Then\n            Dim replacement As OrderItem = e.ReplacedWith\n\n            Console.WriteLine(&quot;{0} (quantity {1}) was replaced &quot; &amp; _\n                &quot;by {2}, (quantity {3}).&quot;, item.Description, _\n                item.Quantity, replacement.Description, replacement.Quantity)\n\n        ElseIf e.ChangeType = ChangeType.Cleared Then\n            Console.WriteLine(&quot;The order list was cleared.&quot;)\n\n        Else\n            Console.WriteLine(&quot;{0} (quantity {1}) was {2}.&quot;, _\n                item.Description, item.Quantity, e.ChangeType)\n        End If\n    End Sub\nEnd Class\n\n&#39; This class represents a simple line item in an order. All the \n&#39; values are immutable except quantity.\n&#39; \nPublic Class OrderItem\n    \n    Private _partNumber As Integer\n    Private _description As String\n    Private _unitPrice As Double\n    Private _quantity As Integer\n\n    Public ReadOnly Property PartNumber As Integer\n        Get\n            Return _partNumber\n        End Get\n    End Property\n\n    Public ReadOnly Property Description As String\n        Get\n            Return _description\n        End Get\n    End Property\n\n    Public ReadOnly Property UnitPrice As Double\n        Get\n            Return _unitPrice\n        End Get\n    End Property\n    \n    Public ReadOnly Property Quantity() As Integer \n        Get\n            Return _quantity\n        End Get\n    End Property\n    \n    Public Sub New(ByVal partNumber As Integer, _\n                   ByVal description As String, _\n                   ByVal quantity As Integer, _\n                   ByVal unitPrice As Double) \n        _partNumber = partNumber\n        _description = description\n        _quantity = quantity\n        _unitPrice = unitPrice\n    End Sub &#39;New\n        \n    Public Overrides Function ToString() As String \n        Return String.Format( _\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, _\n            PartNumber, _quantity, Description, UnitPrice, _\n            UnitPrice * _quantity)\n    End Function\nEnd Class\n\n&#39; This code example produces the following output:\n&#39;\n&#39;Widget (quantity 400) was Added.\n&#39;Sprocket (quantity 27) was Added.\n&#39;Motor (quantity 10) was Added.\n&#39;Gear (quantity 175) was Added.\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;101030411     10 Motor        at   237.50 =   2,375.00\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;Contains(101030411): True\n&#39;\n&#39;weekly(101030411).Description: Motor\n&#39;\n&#39;Remove(101030411)\n&#39;Motor (quantity 10) was Removed.\n&#39;\n&#39;Insert(2, New OrderItem(...))\n&#39;Nut (quantity 10) was Added.\n&#39;\n&#39;coweekly(2).Description: Nut\n&#39;\n&#39;coweekly(2) = New OrderItem(...)\n&#39;Nut (quantity 10) was replaced by Crank, (quantity 27).\n&#39;\n&#39;IndexOf(temp): 2\n&#39;\n&#39;Remove(temp)\n&#39;Crank (quantity 27) was Removed.\n&#39;\n&#39;RemoveAt(0)\n&#39;Widget (quantity 400) was Removed.\n&#39;\n&#39;coweekly(1) = New OrderItem(...)\n&#39;Gear (quantity 175) was replaced by Gear, (quantity 1175).\n&#39;\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;110072684   1175 Gear         at     5.17 =   6,074.75\n&#39;\n&#39;The order list was cleared.\n</code></pre><pre><code class=\"lang-cs\" name=\"KeyedCollection2#1\">using System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\n\n// This class derives from KeyedCollection and shows how to override\n// the protected ClearItems, InsertItem, RemoveItem, and SetItem \n// methods in order to change the behavior of the default Item \n// property and the Add, Clear, Insert, and Remove methods. The\n// class implements a Changed event, which is raised by all the\n// protected methods.\n//\n// SimpleOrder is a collection of OrderItem objects, and its key\n// is the PartNumber field of OrderItem. PartNumber is an Integer,\n// so SimpleOrder inherits KeyedCollection&lt;int, OrderItem&gt;.\n// (Note that the key of OrderItem cannot be changed; if it could \n// be changed, SimpleOrder would have to override ChangeItemKey.)\n//\npublic class SimpleOrder : KeyedCollection&lt;int, OrderItem&gt;\n{\n    public event EventHandler&lt;SimpleOrderChangedEventArgs&gt; Changed;\n\n    // This parameterless constructor calls the base class constructor\n    // that specifies a dictionary threshold of 0, so that the internal\n    // dictionary is created as soon as an item is added to the \n    // collection.\n    //\n    public SimpleOrder() : base(null, 0) {}\n    \n    // This is the only method that absolutely must be overridden,\n    // because without it the KeyedCollection cannot extract the\n    // keys from the items. \n    //\n    protected override int GetKeyForItem(OrderItem item)\n    {\n        // In this example, the key is the part number.\n        return item.PartNumber;\n    }\n\n    protected override void InsertItem(int index, OrderItem newItem)\n    {\n        base.InsertItem(index, newItem);\n\n        EventHandler&lt;SimpleOrderChangedEventArgs&gt; temp = Changed;\n        if (temp != null)\n        {\n            temp(this, new SimpleOrderChangedEventArgs(\n                ChangeType.Added, newItem, null));\n        }\n    }\n\n    protected override void SetItem(int index, OrderItem newItem)\n    {\n        OrderItem replaced = Items[index];\n        base.SetItem(index, newItem);\n\n        EventHandler&lt;SimpleOrderChangedEventArgs&gt; temp = Changed;\n        if (temp != null)\n        {\n            temp(this, new SimpleOrderChangedEventArgs(\n                ChangeType.Replaced, replaced, newItem));\n        }\n    }\n\n    protected override void RemoveItem(int index)\n    {\n        OrderItem removedItem = Items[index];\n        base.RemoveItem(index);\n\n        EventHandler&lt;SimpleOrderChangedEventArgs&gt; temp = Changed;\n        if (temp != null)\n        {\n            temp(this, new SimpleOrderChangedEventArgs(\n                ChangeType.Removed, removedItem, null));\n        }\n    }\n\n    protected override void ClearItems()\n    {\n        base.ClearItems();\n\n        EventHandler&lt;SimpleOrderChangedEventArgs&gt; temp = Changed;\n        if (temp != null)\n        {\n            temp(this, new SimpleOrderChangedEventArgs(\n                ChangeType.Cleared, null, null));\n        }\n    }\n}\n\n// Event argument for the Changed event.\n//\npublic class SimpleOrderChangedEventArgs : EventArgs\n{\n    private OrderItem _changedItem;\n    private ChangeType _changeType;\n    private OrderItem _replacedWith;\n\n    public OrderItem ChangedItem { get { return _changedItem; }}\n    public ChangeType ChangeType { get { return _changeType; }}\n    public OrderItem ReplacedWith { get { return _replacedWith; }}\n\n    public SimpleOrderChangedEventArgs(ChangeType change, \n        OrderItem item, OrderItem replacement)\n    {\n        _changeType = change;\n        _changedItem = item;\n        _replacedWith = replacement;\n    }\n}\n\npublic enum ChangeType\n{\n    Added, \n    Removed, \n    Replaced, \n    Cleared\n};\n\npublic class Demo\n{    \n    public static void Main()\n    {\n        SimpleOrder weekly = new SimpleOrder();\n        weekly.Changed += new \n            EventHandler&lt;SimpleOrderChangedEventArgs&gt;(ChangedHandler);\n\n        // The Add method, inherited from Collection, takes OrderItem.\n        //\n        weekly.Add(new OrderItem(110072674, &quot;Widget&quot;, 400, 45.17));\n        weekly.Add(new OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3));\n        weekly.Add(new OrderItem(101030411, &quot;Motor&quot;, 10, 237.5));\n        weekly.Add(new OrderItem(110072684, &quot;Gear&quot;, 175, 5.17));\n\n        Display(weekly);\n        \n        // The Contains method of KeyedCollection takes TKey.\n        //\n        Console.WriteLine(&quot;<br>Contains(101030411): {0}&quot;, \n            weekly.Contains(101030411));\n\n        // The default Item property of KeyedCollection takes the key\n        // type, Integer. The property is read-only.\n        //\n        Console.WriteLine(&quot;<br>weekly[101030411].Description: {0}&quot;, \n            weekly[101030411].Description);\n\n        // The Remove method of KeyedCollection takes a key.\n        //\n        Console.WriteLine(&quot;<br>Remove(101030411)&quot;);\n        weekly.Remove(101030411);\n\n        // The Insert method, inherited from Collection, takes an \n        // index and an OrderItem.\n        //\n        Console.WriteLine(&quot;<br>Insert(2, new OrderItem(...))&quot;);\n        weekly.Insert(2, new OrderItem(111033401, &quot;Nut&quot;, 10, .5));\n         \n        // The default Item property is overloaded. One overload comes\n        // from KeyedCollection&lt;int, OrderItem&gt;; that overload\n        // is read-only, and takes Integer because it retrieves by key. \n        // The other overload comes from Collection&lt;OrderItem&gt;, the \n        // base class of KeyedCollection&lt;int, OrderItem&gt;; it \n        // retrieves by index, so it also takes an Integer. The compiler\n        // uses the most-derived overload, from KeyedCollection, so the\n        // only way to access SimpleOrder by index is to cast it to\n        // Collection&lt;OrderItem&gt;. Otherwise the index is interpreted\n        // as a key, and KeyNotFoundException is thrown.\n        //\n        Collection&lt;OrderItem&gt; coweekly = weekly;\n        Console.WriteLine(&quot;<br>coweekly[2].Description: {0}&quot;, \n            coweekly[2].Description);\n \n        Console.WriteLine(&quot;<br>coweekly[2] = new OrderItem(...)&quot;);\n        coweekly[2] = new OrderItem(127700026, &quot;Crank&quot;, 27, 5.98);\n\n        OrderItem temp = coweekly[2];\n\n        // The IndexOf method, inherited from Collection&lt;OrderItem&gt;, \n        // takes an OrderItem instead of a key.\n        // \n        Console.WriteLine(&quot;<br>IndexOf(temp): {0}&quot;, weekly.IndexOf(temp));\n\n        // The inherited Remove method also takes an OrderItem.\n        //\n        Console.WriteLine(&quot;<br>Remove(temp)&quot;);\n        weekly.Remove(temp);\n\n        Console.WriteLine(&quot;<br>RemoveAt(0)&quot;);\n        weekly.RemoveAt(0);\n\n        // Increase the quantity for a line item.\n        Console.WriteLine(&quot;<br>coweekly(1) = New OrderItem(...)&quot;);\n        coweekly[1] = new OrderItem(coweekly[1].PartNumber, \n            coweekly[1].Description, coweekly[1].Quantity + 1000, \n            coweekly[1].UnitPrice);\n\n        Display(weekly);\n\n        Console.WriteLine();\n        weekly.Clear();\n    }\n    \n    private static void Display(SimpleOrder order)\n    {\n        Console.WriteLine();\n        foreach( OrderItem item in order )\n        {\n            Console.WriteLine(item);\n        }\n    }\n\n    private static void ChangedHandler(object source, \n        SimpleOrderChangedEventArgs e)\n    {\n\n        OrderItem item = e.ChangedItem;\n\n        if (e.ChangeType==ChangeType.Replaced)\n        {\n            OrderItem replacement = e.ReplacedWith;\n\n            Console.WriteLine(&quot;{0} (quantity {1}) was replaced &quot; +\n                &quot;by {2}, (quantity {3}).&quot;, item.Description, \n                item.Quantity, replacement.Description, \n                replacement.Quantity);\n        }\n        else if(e.ChangeType == ChangeType.Cleared)\n        {\n            Console.WriteLine(&quot;The order list was cleared.&quot;);\n        }\n        else\n        {\n            Console.WriteLine(&quot;{0} (quantity {1}) was {2}.&quot;, \n                item.Description, item.Quantity, e.ChangeType);\n        }\n    }\n}\n\n// This class represents a simple line item in an order. All the \n// values are immutable except quantity.\n// \npublic class OrderItem\n{\n    private int _partNumber;\n    private string _description;\n    private double _unitPrice;\n    private int _quantity;\n    \n    public int PartNumber { get { return _partNumber; }}\n    public string Description { get { return _description; }}\n    public double UnitPrice { get { return _unitPrice; }}\n    public int Quantity { get { return _quantity; }}\n    \n    public OrderItem(int partNumber, string description, int quantity, \n        double unitPrice)\n    {\n        _partNumber = partNumber;\n        _description = description;\n        _quantity = quantity;\n        _unitPrice = unitPrice;\n    }\n    \n    public override string ToString()\n    {\n        return String.Format(\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, \n            PartNumber, _quantity, Description, UnitPrice, \n            UnitPrice * _quantity);\n    }\n}\n\n/* This code example produces the following output:\n\nWidget (quantity 400) was Added.\nSprocket (quantity 27) was Added.\nMotor (quantity 10) was Added.\nGear (quantity 175) was Added.\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n101030411     10 Motor        at   237.50 =   2,375.00\n110072684    175 Gear         at     5.17 =     904.75\n\nContains(101030411): True\n\nweekly[101030411].Description: Motor\n\nRemove(101030411)\nMotor (quantity 10) was Removed.\n\nInsert(2, new OrderItem(...))\nNut (quantity 10) was Added.\n\ncoweekly[2].Description: Nut\n\ncoweekly[2] = new OrderItem(...)\nNut (quantity 10) was replaced by Crank, (quantity 27).\n\nIndexOf(temp): 2\n\nRemove(temp)\nCrank (quantity 27) was Removed.\n\nRemoveAt(0)\nWidget (quantity 400) was Removed.\n\ncoweekly(1) = New OrderItem(...)\nGear (quantity 175) was replaced by Gear, (quantity 1175).\n\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684   1175 Gear         at     5.17 =   6,074.75\n\nThe order list was cleared.\n */\n</code></pre><pre><code class=\"lang-cpp\" name=\"KeyedCollection2#1\">using namespace System;\nusing namespace System::Collections::Generic;\nusing namespace System::Collections::ObjectModel;\n\npublic enum class ChangeTypes\n{\n    Added,\n    Removed, \n    Replaced, \n    Cleared\n};\n\nref class SimpleOrderChangedEventArgs; \n\n// This class represents a simple line item in an order. All the \n// values are immutable except quantity.\n// \npublic ref class OrderItem\n{\nprivate:\n    int _quantity;\n\npublic:\n    initonly int PartNumber;\n    initonly String^ Description;\n    initonly double UnitPrice;\n        \n    OrderItem(int partNumber, String^ description, int quantity, \n        double unitPrice)\n    {\n        this-&gt;PartNumber = partNumber;\n        this-&gt;Description = description;\n        this-&gt;Quantity = quantity;\n        this-&gt;UnitPrice = unitPrice;\n    };\n    \n    property int Quantity    \n    {\n        int get() { return _quantity; };\n        void set(int value)\n        {\n            if (value &lt; 0)\n                throw gcnew ArgumentException(&quot;Quantity cannot be negative.&quot;);\n            \n            _quantity = value;\n        };\n    };\n        \n    virtual String^ ToString() override \n    {\n        return String::Format(\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, \n            PartNumber, _quantity, Description, UnitPrice, \n            UnitPrice * _quantity);\n    };\n};\n\n// Event argument for the Changed event.\n//\npublic ref class SimpleOrderChangedEventArgs : EventArgs\n{\npublic:\n    OrderItem^ ChangedItem;\n    initonly ChangeTypes ChangeType;\n    OrderItem^ ReplacedWith;\n\n    SimpleOrderChangedEventArgs(ChangeTypes change, \n        OrderItem^ item, OrderItem^ replacement)\n    {\n        this-&gt;ChangeType = change;\n        this-&gt;ChangedItem = item;\n        this-&gt;ReplacedWith = replacement;\n    }\n};\n\n// This class derives from KeyedCollection and shows how to override\n// the protected ClearItems, InsertItem, RemoveItem, and SetItem \n// methods in order to change the behavior of the default Item \n// property and the Add, Clear, Insert, and Remove methods. The\n// class implements a Changed event, which is raised by all the\n// protected methods.\n//\n// SimpleOrder is a collection of OrderItem objects, and its key\n// is the PartNumber field of OrderItem-&gt; PartNumber is an Integer,\n// so SimpleOrder inherits KeyedCollection&lt;int, OrderItem&gt;.\n// (Note that the key of OrderItem cannot be changed; if it could \n// be changed, SimpleOrder would have to override ChangeItemKey.)\n//\npublic ref class SimpleOrder : KeyedCollection&lt;int, OrderItem^&gt;\n{\npublic:\n    event EventHandler&lt;SimpleOrderChangedEventArgs^&gt;^ Changed;\n\n    // This parameterless constructor calls the base class constructor\n    // that specifies a dictionary threshold of 0, so that the internal\n    // dictionary is created as soon as an item is added to the \n    // collection.\n    //\n    SimpleOrder() : KeyedCollection&lt;int, OrderItem^&gt;(nullptr, 0) {};\n    \n    // This is the only method that absolutely must be overridden,\n    // because without it the KeyedCollection cannot extract the\n    // keys from the items. \n    //\nprotected:\n    virtual int GetKeyForItem(OrderItem^ item) override\n    {\n        // In this example, the key is the part number.\n        return item-&gt;PartNumber;\n    }\n\n    virtual void InsertItem(int index, OrderItem^ newItem) override \n    {\n        __super::InsertItem(index, newItem);\n\n        Changed(this, gcnew SimpleOrderChangedEventArgs(\n            ChangeTypes::Added, newItem, nullptr));\n    }\n\n    virtual void SetItem(int index, OrderItem^ newItem) override \n    {\n        OrderItem^ replaced = this-&gt;Items[index];\n        __super::SetItem(index, newItem);\n\n        Changed(this, gcnew SimpleOrderChangedEventArgs(\n            ChangeTypes::Replaced, replaced, newItem));\n    }\n\n    virtual void RemoveItem(int index) override \n    {\n        OrderItem^ removedItem = Items[index];\n        __super::RemoveItem(index);\n\n        Changed(this, gcnew SimpleOrderChangedEventArgs(\n            ChangeTypes::Removed, removedItem, nullptr));\n    }\n\n    virtual void ClearItems() override \n    {\n        __super::ClearItems();\n\n        Changed(this, gcnew SimpleOrderChangedEventArgs(\n            ChangeTypes::Cleared, nullptr, nullptr));\n    }\n\n    // This method uses the internal reference to the dictionary\n    // to test fo\npublic:\n    void AddOrMerge(OrderItem^ newItem)\n    {\n\n        int key = this-&gt;GetKeyForItem(newItem);\n        OrderItem^ existingItem = nullptr;\n\n        // The dictionary is not created until the first item is \n        // added, so it is necessary to test for null. Using \n        // AndAlso ensures that TryGetValue is not called if the\n        // dictionary does not exist.\n        //\n        if (this-&gt;Dictionary != nullptr &amp;&amp; \n            this-&gt;Dictionary-&gt;TryGetValue(key, existingItem))\n        {\n            existingItem-&gt;Quantity += newItem-&gt;Quantity;\n        }\n        else\n        {\n            this-&gt;Add(newItem);\n        }\n    }\n};\n\npublic ref class Demo\n{    \npublic:\n    static void Main()\n    {\n        SimpleOrder^ weekly = gcnew SimpleOrder();\n        weekly-&gt;Changed += gcnew \n            EventHandler&lt;SimpleOrderChangedEventArgs^&gt;(ChangedHandler);\n\n        // The Add method, inherited from Collection, takes OrderItem-&gt;\n        //\n        weekly-&gt;Add(gcnew OrderItem(110072674, &quot;Widget&quot;, 400, 45.17));\n        weekly-&gt;Add(gcnew OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3));\n        weekly-&gt;Add(gcnew OrderItem(101030411, &quot;Motor&quot;, 10, 237.5));\n        weekly-&gt;Add(gcnew OrderItem(110072684, &quot;Gear&quot;, 175, 5.17));\n\n        Display(weekly);\n        \n        // The Contains method of KeyedCollection takes TKey.\n        //\n        Console::WriteLine(&quot;<br>Contains(101030411): {0}&quot;, \n            weekly-&gt;Contains(101030411));\n\n        // The default Item property of KeyedCollection takes the key\n        // type, Integer. The property is read-only.\n        //\n        Console::WriteLine(&quot;<br>weekly[101030411]-&gt;Description: {0}&quot;, \n            weekly[101030411]-&gt;Description);\n\n        // The Remove method of KeyedCollection takes a key.\n        //\n        Console::WriteLine(&quot;<br>Remove(101030411)&quot;);\n        weekly-&gt;Remove(101030411);\n\n        // The Insert method, inherited from Collection, takes an \n        // index and an OrderItem.\n        //\n        Console::WriteLine(&quot;<br>Insert(2, gcnew OrderItem(...))&quot;);\n        weekly-&gt;Insert(2, gcnew OrderItem(111033401, &quot;Nut&quot;, 10, .5));\n         \n        // The default Item property is overloaded. One overload comes\n        // from KeyedCollection&lt;int, OrderItem&gt;; that overload\n        // is read-only, and takes Integer because it retrieves by key. \n        // The other overload comes from Collection&lt;OrderItem&gt;, the \n        // base class of KeyedCollection&lt;int, OrderItem&gt;; it \n        // retrieves by index, so it also takes an Integer. The compiler\n        // uses the most-derived overload, from KeyedCollection, so the\n        // only way to access SimpleOrder by index is to cast it to\n        // Collection&lt;OrderItem&gt;. Otherwise the index is interpreted\n        // as a key, and KeyNotFoundException is thrown.\n        //\n        Collection&lt;OrderItem^&gt;^ coweekly = weekly;\n        Console::WriteLine(&quot;<br>coweekly[2].Description: {0}&quot;, \n            coweekly[2]-&gt;Description);\n \n        Console::WriteLine(&quot;<br>coweekly[2] = gcnew OrderItem(...)&quot;);\n        coweekly[2] = gcnew OrderItem(127700026, &quot;Crank&quot;, 27, 5.98);\n\n        OrderItem^ temp = coweekly[2];\n\n        // The IndexOf method, inherited from Collection&lt;OrderItem&gt;, \n        // takes an OrderItem instead of a key.\n        // \n        Console::WriteLine(&quot;<br>IndexOf(temp): {0}&quot;, weekly-&gt;IndexOf(temp));\n\n        // The inherited Remove method also takes an OrderItem-&gt;\n        //\n        Console::WriteLine(&quot;<br>Remove(temp)&quot;);\n        weekly-&gt;Remove(temp);\n\n        Console::WriteLine(&quot;<br>RemoveAt(0)&quot;);\n        weekly-&gt;RemoveAt(0);\n\n        weekly-&gt;AddOrMerge(gcnew OrderItem(110072684, &quot;Gear&quot;, 1000, 5.17));\n\n        Display(weekly);\n\n        Console::WriteLine();\n        weekly-&gt;Clear();\n    }\n    \nprivate:\n    static void Display(SimpleOrder^ order)\n    {\n        Console::WriteLine();\n        for each( OrderItem^ item in order )\n        {\n            Console::WriteLine(item);\n        }\n    }\n\n    static void ChangedHandler(Object^ source, \n        SimpleOrderChangedEventArgs^ e)\n    {\n        OrderItem^ item = e-&gt;ChangedItem;\n\n        if (e-&gt;ChangeType == ChangeTypes::Replaced)\n        {\n            OrderItem^ replacement = e-&gt;ReplacedWith;\n\n            Console::WriteLine(&quot;{0} (quantity {1}) was replaced &quot; +\n                &quot;by {2}, (quantity {3}).&quot;, item-&gt;Description, \n                item-&gt;Quantity, replacement-&gt;Description, \n                replacement-&gt;Quantity);\n        }\n        else if(e-&gt;ChangeType == ChangeTypes::Cleared)\n        {\n            Console::WriteLine(&quot;The order list was cleared.&quot;);\n        }\n        else\n        {\n            Console::WriteLine(&quot;{0} (quantity {1}) was {2}.&quot;, \n                item-&gt;Description, item-&gt;Quantity, e-&gt;ChangeType);\n        }\n    }\n};\n\nvoid main()\n{\n    Demo::Main();\n}\n\n/* This code example produces the following output:\n\nWidget (quantity 400) was Added.\nSprocket (quantity 27) was Added.\nMotor (quantity 10) was Added.\nGear (quantity 175) was Added.\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n101030411     10 Motor        at   237.50 =   2,375.00\n110072684    175 Gear         at     5.17 =     904.75\n\nContains(101030411): True\n\nweekly[101030411]-&gt;Description: Motor\n\nRemove(101030411)\nMotor (quantity 10) was Removed.\n\nInsert(2, gcnew OrderItem(...))\nNut (quantity 10) was Added.\n\ncoweekly[2].Description: Nut\n\ncoweekly[2] = gcnew OrderItem(...)\nNut (quantity 10) was replaced by Crank, (quantity 27).\n\nIndexOf(temp): 2\n\nRemove(temp)\nCrank (quantity 27) was Removed.\n\nRemoveAt(0)\nWidget (quantity 400) was Removed.\n\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684   1175 Gear         at     5.17 =   6,074.75\n\nThe order list was cleared.\n */\n</code></pre><p> Example 2  </p>\n<p> The following code example shows how to override the protected <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_ChangeItemKey_\" data-linktype=\"relative-path\">ChangeItemKey</a> method to support mutable keys, and how to override the protected <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_InsertItem_\" data-linktype=\"relative-path\">InsertItem</a>, RemoveItem, <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_ClearItems_\" data-linktype=\"relative-path\">ClearItems</a>, and <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_SetItem_\" data-linktype=\"relative-path\">SetItem</a> methods to maintain the integrity of the keys and the collection.  </p>\n<p> The code example creates the <code>MutableKeys</code> collection, which derives from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a>, and the <code>MutableKey</code> class. The <code>MutableKey</code> class has a settable <code>Key</code> property. When a new key is assigned to the property, the property setter calls the <code>internal</code> (<code>Friend</code> in Visual Basic) <code>ChangeKey</code> method of the collection to test whether the new key would conflict with an existing key. If so, an exception is thrown and the property value is not changed.  </p>\n<p> In order to maintain the connection between a <code>MutableKey</code> object and the <code>MutableKeys</code> collection and to prevent an object from being inserted into two collections, the <code>MutableKey</code> class has an <code>internal</code> (<code>Friend</code> in Visual Basic) <code>Collection</code> field. This field is maintained by the protected methods that provide custom behavior for adding and removing items from the collection, such as the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_InsertItem_\" data-linktype=\"relative-path\">InsertItem</a> method. The field is set when the item is added to a collection and cleared when the item is removed.  </p>\n<pre><code class=\"lang-cs\" name=\"KeyedCollectionMutable#1\">using System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\n\n// This class demonstrates one way to use the ChangeItemKey\n// method to store objects with keys that can be changed. The \n// ChangeItemKey method is used to keep the internal lookup\n// Dictionary in sync with the keys of the stored objects. \n//\n// MutableKeys stores MutableKey objects, which have an Integer\n// Key property that can be set. Therefore, MutableKeys inherits\n// KeyedCollection(Of Integer, MutableKey).\n//\npublic class MutableKeys : KeyedCollection&lt;int, MutableKey&gt;\n{\n    // This parameterless constructor delegates to the base class \n    // constructor that specifies a dictionary threshold. A\n    // threshold of 0 means the internal Dictionary is created\n    // the first time an object is added.\n    //\n    public MutableKeys() : base(null, 0) {}\n    \n    protected override int GetKeyForItem(MutableKey item)\n    {\n        // The key is MutableKey.Key.\n        return item.Key;\n    }\n\n    protected override void InsertItem(int index, MutableKey newItem)\n    {\n        if (newItem.Collection != null) \n            throw new ArgumentException(&quot;The item already belongs to a collection.&quot;);\n\n        base.InsertItem(index, newItem);\n        newItem.Collection = this;\n    }\n\n    protected override void SetItem(int index, MutableKey newItem)\n    {\n        MutableKey replaced = Items[index];\n\n        if (newItem.Collection != null) \n            throw new ArgumentException(&quot;The item already belongs to a collection.&quot;);\n\n        base.SetItem(index, newItem);\n        newItem.Collection = this;\n        replaced.Collection = null;\n    }\n\n    protected override void RemoveItem(int index)\n    {\n        MutableKey removedItem = Items[index];\n\n        base.RemoveItem(index);\n        removedItem.Collection = null;\n    }\n\n    protected override void ClearItems()\n    {\n        foreach( MutableKey mk in Items )\n        {\n            mk.Collection = null;\n        }\n        \n        base.ClearItems();\n    }\n\n    internal void ChangeKey(MutableKey item, int newKey)\n    {\n        base.ChangeItemKey(item, newKey);\n    }\n    \n    public void Dump()\n    {\n        Console.WriteLine(&quot;<br>DUMP:&quot;);\n        if (Dictionary == null)\n        {\n            Console.WriteLine(&quot;    The dictionary has not been created.&quot;);\n        }\n        else\n        {\n            Console.WriteLine(&quot;    Dictionary entries&quot;);\n            Console.WriteLine(&quot;    ------------------&quot;);\n\n            foreach( KeyValuePair&lt;int, MutableKey&gt; kvp in Dictionary )\n            {\n                Console.WriteLine(&quot;    {0} : {1}&quot;, kvp.Key, kvp.Value);\n            }\n        }\n\n        Console.WriteLine(&quot;<br>    List of items&quot;);\n        Console.WriteLine(&quot;    -------------&quot;);\n\n        foreach( MutableKey mk in Items )\n        {\n            Console.WriteLine(&quot;    {0}&quot;, mk);\n        }\n    }\n}\n\npublic class Demo\n{\n    public static void Main()\n    {\n        MutableKeys mkeys = new MutableKeys();\n\n        // The Add method is inherited from Collection.\n        //\n        mkeys.Add(new MutableKey(110072674, &quot;Widget&quot;));\n        mkeys.Add(new MutableKey(110072675, &quot;Sprocket&quot;));\n\n        mkeys.Dump();\n    \n        Console.WriteLine(&quot;<br>Create and insert a new item:&quot;);\n        MutableKey test = new MutableKey(110072684, &quot;Gear&quot;);\n        mkeys.Insert(1, test);\n\n        mkeys.Dump();\n\n        try\n        {\n            Console.WriteLine(&quot;<br>Try to insert the item again:&quot;);\n            mkeys.Insert(1, test);\n        }\n        catch(ArgumentException ex)\n        {\n            Console.WriteLine(&quot;Error: {0}&quot;, ex.Message);\n        }\n\n        Console.WriteLine(&quot;<br>Change the Key property of the item:&quot;);\n        test.Key = 100000072;\n\n        mkeys.Dump();\n\n        try\n        {\n            Console.WriteLine(&quot;<br>Try to set the Key property to an existing key:&quot;);\n            test.Key = 110072674;\n        }\n        catch(ArgumentException ex)\n        {\n            Console.WriteLine(&quot;Error: {0}&quot;, ex.Message);\n        }\n\n        mkeys.Dump();\n    }\n    \n    private static void Display(MutableKeys order)\n    {\n        Console.WriteLine();\n        foreach( MutableKey item in order )\n        {\n            Console.WriteLine(item);\n        }\n    }\n}\n\n// This class has a key that can be changed.\n// \npublic class MutableKey\n{\n\n    public MutableKey(int newKey, string newValue)\n    {\n        _key = newKey;\n        Value = newValue;\n    } //New\n    \n    public string Value;\n    internal MutableKeys Collection;\n    \n    private int _key;\n    public int Key    \n    {\n        get\n        {\n            return _key;\n        }\n        set\n        {\n            if (Collection != null)\n            {\n                Collection.ChangeKey(this, value);\n            }\n\n            _key = value;\n        }\n    }\n\n    public override string ToString()\n    {\n        return String.Format(&quot;{0,9} {1}&quot;, _key, Value);\n    }\n        \n}\n\n/* This code example produces the following output:\n\nDUMP:\n    Dictionary entries\n    ------------------\n    110072674 : 110072674 Widget\n    110072675 : 110072675 Sprocket\n\n    List of items\n    -------------\n    110072674 Widget\n    110072675 Sprocket\n\nCreate and insert a new item:\n\nDUMP:\n    Dictionary entries\n    ------------------\n    110072674 : 110072674 Widget\n    110072675 : 110072675 Sprocket\n    110072684 : 110072684 Gear\n\n    List of items\n    -------------\n    110072674 Widget\n    110072684 Gear\n    110072675 Sprocket\n\nTry to insert the item again:\nError: The item already belongs to a collection.\n\nChange the Key property of the item:\n\nDUMP:\n    Dictionary entries\n    ------------------\n    110072674 : 110072674 Widget\n    110072675 : 110072675 Sprocket\n    100000072 : 100000072 Gear\n\n    List of items\n    -------------\n    110072674 Widget\n    100000072 Gear\n    110072675 Sprocket\n\nTry to set the Key property to an existing key:\nError: An item with the same key has already been added.\n\nDUMP:\n    Dictionary entries\n    ------------------\n    110072674 : 110072674 Widget\n    110072675 : 110072675 Sprocket\n    100000072 : 100000072 Gear\n\n    List of items\n    -------------\n    110072674 Widget\n    100000072 Gear\n    110072675 Sprocket\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"KeyedCollectionMutable#1\">Imports System\nImports System.Collections.Generic\nImports System.Collections.ObjectModel\n\n&#39; This class demonstrates one way to use the ChangeItemKey\n&#39; method to store objects with keys that can be changed. The \n&#39; ChangeItemKey method is used to keep the internal lookup\n&#39; Dictionary in sync with the keys of the stored objects. \n&#39;\n&#39; MutableKeys stores MutableKey objects, which have an Integer\n&#39; Key property that can be set. Therefore, MutableKeys inherits\n&#39; KeyedCollection(Of Integer, MutableKey).\n&#39;\nPublic Class MutableKeys\n    Inherits KeyedCollection(Of Integer, MutableKey)\n\n    &#39; This parameterless constructor delegates to the base class \n    &#39; constructor that specifies a dictionary threshold. A\n    &#39; threshold of 0 means the internal Dictionary is created\n    &#39; the first time an object is added.\n    &#39;\n    Public Sub New()\n        MyBase.New(Nothing, 0)\n    End Sub\n    \n    Protected Overrides Function GetKeyForItem( _\n        ByVal item As MutableKey) As Integer\n\n        &#39; The key is MutableKey.Key.\n        Return item.Key   \n    End Function\n\n    Protected Overrides Sub InsertItem( _\n        ByVal index As Integer, ByVal newItem As MutableKey)\n\n        If newItem.Collection IsNot Nothing Then _\n            Throw New ArgumentException(&quot;The item already belongs to a collection.&quot;)\n\n        MyBase.InsertItem(index, newItem)\n        newItem.Collection = Me\n    End Sub\n\n    Protected Overrides Sub SetItem(ByVal index As Integer, _\n        ByVal newItem As MutableKey)\n\n        Dim replaced As MutableKey = Items(index)\n\n        If newItem.Collection IsNot Nothing Then _\n            Throw New ArgumentException(&quot;The item already belongs to a collection.&quot;)\n\n        MyBase.SetItem(index, newItem)\n        newItem.Collection = Me\n        replaced.Collection = Nothing\n    End Sub\n\n    Protected Overrides Sub RemoveItem(ByVal index As Integer)\n        Dim removedItem As MutableKey = Items(index)\n\n        MyBase.RemoveItem(index)\n        removedItem.Collection = Nothing\n    End Sub\n\n    Protected Overrides Sub ClearItems()\n        For Each mk As MutableKey In Items\n            mk.Collection = Nothing\n        Next\n        \n        MyBase.ClearItems()\n    End Sub\n\n    Friend Sub ChangeKey(ByVal item As MutableKey, _\n        ByVal newKey As Integer)\n\n        MyBase.ChangeItemKey(item, newKey)\n    End Sub\n    \n    Public Sub Dump()\n        Console.WriteLine(vbLf &amp; &quot;DUMP:&quot;)\n        If Dictionary Is Nothing Then\n            Console.WriteLine(&quot;    The dictionary has not been created.&quot;)\n        Else\n            Console.WriteLine(&quot;    Dictionary entries&quot;)\n            Console.WriteLine(&quot;    ------------------&quot;)\n\n            For Each kvp As KeyValuePair(Of Integer, MutableKey) In Dictionary\n                Console.WriteLine(&quot;    {0} : {1}&quot;, kvp.Key, kvp.Value)\n            Next\n        End If\n\n        Console.WriteLine(vbLf &amp; &quot;    List of items&quot;)\n        Console.WriteLine(&quot;    -------------&quot;)\n\n        For Each mk As MutableKey In Items\n            Console.WriteLine(&quot;    {0}&quot;, mk)\n        Next\n    End Sub\n\nEnd Class\n\nPublic Class Demo\n    \n    Public Shared Sub Main() \n\n        Dim mkeys As New MutableKeys()\n\n        &#39; The Add method is inherited from Collection.\n        &#39;\n        mkeys.Add(New MutableKey(110072674, &quot;Widget&quot;))\n        mkeys.Add(New MutableKey(110072675, &quot;Sprocket&quot;))\n\n        mkeys.Dump() \n    \n        Console.WriteLine(vbLf &amp; &quot;Create and insert a new item:&quot;)\n        Dim test As New MutableKey(110072684, &quot;Gear&quot;)\n        mkeys.Insert(1, test)\n\n        mkeys.Dump()\n\n        Try\n            Console.WriteLine(vbLf &amp; &quot;Try to insert the item again:&quot;)\n            mkeys.Insert(1, test)\n        Catch ex As ArgumentException\n            Console.WriteLine(&quot;Error: {0}&quot;, ex.Message)\n        End Try\n\n        Console.WriteLine(vbLf &amp; &quot;Change the Key property of the item:&quot;)\n        test.Key = 100000072\n\n        mkeys.Dump()\n\n        Try\n            Console.WriteLine(vbLf &amp; &quot;Try to set the Key property to an existing key:&quot;)\n            test.Key = 110072674\n        Catch ex As ArgumentException\n            Console.WriteLine(&quot;Error: {0}&quot;, ex.Message)\n        End Try\n\n        mkeys.Dump()\n\n    End Sub\n    \n    Private Shared Sub Display(ByVal order As MutableKeys) \n        Console.WriteLine()\n        For Each item As MutableKey In  order\n            Console.WriteLine(item)\n        Next item\n    End Sub\nEnd Class\n\n&#39; This class has a key that can be changed.\n&#39; \nPublic Class MutableKey\n\n    Public Sub New(ByVal newKey As Integer, ByVal newValue As String)\n        _key = newKey\n        Value = newValue\n    End Sub &#39;New\n    \n    Public Value As String\n    Friend Collection As MutableKeys\n    \n    Private _key As Integer\n    Public Property Key As Integer \n        Get\n            Return _key\n        End Get\n        Set\n            If Collection IsNot Nothing Then\n                Collection.ChangeKey(Me, value)\n            End If\n\n            _key = value\n        End Set\n    End Property\n\n    Public Overrides Function ToString() As String \n        Return String.Format(&quot;{0,9} {1}&quot;, _key, Value)\n    End Function\n        \nEnd Class\n\n&#39; This code example produces the following output:\n&#39;\n&#39;DUMP:\n&#39;    Dictionary entries\n&#39;    ------------------\n&#39;    110072674 : 110072674 Widget\n&#39;    110072675 : 110072675 Sprocket\n&#39;\n&#39;    List of items\n&#39;    -------------\n&#39;    110072674 Widget\n&#39;    110072675 Sprocket\n&#39;\n&#39;Create and insert a new item:\n&#39;\n&#39;DUMP:\n&#39;    Dictionary entries\n&#39;    ------------------\n&#39;    110072674 : 110072674 Widget\n&#39;    110072675 : 110072675 Sprocket\n&#39;    110072684 : 110072684 Gear\n&#39;\n&#39;    List of items\n&#39;    -------------\n&#39;    110072674 Widget\n&#39;    110072684 Gear\n&#39;    110072675 Sprocket\n&#39;\n&#39;Try to insert the item again:\n&#39;Error: The item already belongs to a collection.\n&#39;\n&#39;Change the Key property of the item:\n&#39;\n&#39;DUMP:\n&#39;    Dictionary entries\n&#39;    ------------------\n&#39;    110072674 : 110072674 Widget\n&#39;    110072675 : 110072675 Sprocket\n&#39;    100000072 : 100000072 Gear\n&#39;\n&#39;    List of items\n&#39;    -------------\n&#39;    110072674 Widget\n&#39;    100000072 Gear\n&#39;    110072675 Sprocket\n&#39;\n&#39;Try to set the Key property to an existing key:\n&#39;Error: An item with the same key has already been added.\n&#39;\n&#39;DUMP:\n&#39;    Dictionary entries\n&#39;    ------------------\n&#39;    110072674 : 110072674 Widget\n&#39;    110072675 : 110072675 Sprocket\n&#39;    100000072 : 100000072 Gear\n&#39;\n&#39;    List of items\n&#39;    -------------\n&#39;    110072674 Widget\n&#39;    100000072 Gear\n&#39;    110072675 Sprocket\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Collections_ObjectModel_KeyedCollection_2_SetItem_System_Int32__1_\">\r\n    \r\n            <a id=\"System_Collections_ObjectModel_KeyedCollection_2_SetItem_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">SetItem(Int32,TItem)</div>        \r\n          </div>\r\n    \r\n            <p>Replaces the item at the specified index with the specified item.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">protected override void SetItem (int index, TItem item);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>index</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The zero-based index of the item to be replaced.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>item</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><span class=\"xref\">TItem</span></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The new item.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The lookup dictionary is updated accordingly. That is, the key of the item that is being replaced is removed from the lookup dictionary, and the key of the new item is added.  </p>\n<p> This method is an O(1) operation.  </p>\n<h2 id=\"notes-for-implementers\">Notes for Implementers</h2>\n<p> Override this method to provide customized behavior for setting the <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Item_\" data-linktype=\"relative-path\">Item</a> property inherited from the <a class=\"xref\" href=\"system.collections.objectmodel.collection-1\" data-linktype=\"relative-path\">Collection&lt;T&gt;</a> generic class.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> This method does not affect the behavior of the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_Item_\" data-linktype=\"relative-path\">Item</a> property, which is read-only.  </p>\n</div>\n<p> Call the base class implementation of this method to set the item in the underlying collection and to update the lookup dictionary.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>This section contains two code examples that demonstrate overriding the SetItem method to provide custom behavior for setting the <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Item_\" data-linktype=\"relative-path\">Item</a> property. The first example adds a custom notification event and the second provides support for a collection of objects with mutable keys.  </p>\n<p> Example 1  </p>\n<p> The following code example shows how to override the protected <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_InsertItem_\" data-linktype=\"relative-path\">InsertItem</a>, <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_RemoveItem_\" data-linktype=\"relative-path\">RemoveItem</a>, <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_ClearItems_\" data-linktype=\"relative-path\">ClearItems</a>, and SetItem methods, to provide custom behavior for the <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Add_\" data-linktype=\"relative-path\">Add</a>, <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_Remove_\" data-linktype=\"relative-path\">Remove</a>, and <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Clear_\" data-linktype=\"relative-path\">Clear</a> methods, and for setting the default <a class=\"xref\" href=\"system.collections.objectmodel.collection-1#System_Collections_ObjectModel_Collection_1_Item_\" data-linktype=\"relative-path\">Item</a> property (the indexer in C#). The custom behavior provided in this example is a notification event named <code>Changed</code>, which is raised at the end of each of the overridden methods.  </p>\n<p> The code example creates the <code>SimpleOrder</code> class, which derives from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a> and represents a simple order form. The order form contains <code>OrderItem</code> objects representing items ordered. The code example also creates a <code>SimpleOrderChangedEventArgs</code> class to contain the event information, and an enumeration to identify the type of change.  </p>\n<p> The code example demonstrates the custom behavior by calling the properties and methods of the derived class, in the <code>Main</code> method of the <code>Demo</code> class.  </p>\n<p> This code example uses objects with immutable keys. For a code example that uses mutable keys, see <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_ChangeItemKey_\" data-linktype=\"relative-path\">ChangeItemKey</a>.  </p>\n<pre><code class=\"lang-vb\" name=\"KeyedCollection2#1\">Imports System\nImports System.Collections.Generic\nImports System.Collections.ObjectModel\n\n&#39; This class derives from KeyedCollection and shows how to override\n&#39; the protected ClearItems, InsertItem, RemoveItem, and SetItem \n&#39; methods in order to change the behavior of the default Item \n&#39; property and the Add, Clear, Insert, and Remove methods. The\n&#39; class implements a Changed event, which is raised by all the\n&#39; protected methods.\n&#39;\n&#39; SimpleOrder is a collection of OrderItem objects, and its key\n&#39; is the PartNumber field of OrderItem. PartNumber is an Integer,\n&#39; so SimpleOrder inherits KeyedCollection(Of Integer, OrderItem).\n&#39; (Note that the key of OrderItem cannot be changed; if it could \n&#39; be changed, SimpleOrder would have to override ChangeItemKey.)\n&#39;\nPublic Class SimpleOrder\n    Inherits KeyedCollection(Of Integer, OrderItem)\n\n    Public Event Changed As EventHandler(Of SimpleOrderChangedEventArgs)\n\n    &#39; This parameterless constructor calls the base class constructor\n    &#39; that specifies a dictionary threshold of 0, so that the internal\n    &#39; dictionary is created as soon as an item is added to the \n    &#39; collection.\n    &#39;\n    Public Sub New()\n        MyBase.New(Nothing, 0)\n    End Sub\n    \n    &#39; This is the only method that absolutely must be overridden,\n    &#39; because without it the KeyedCollection cannot extract the\n    &#39; keys from the items. \n    &#39;\n    Protected Overrides Function GetKeyForItem( _\n        ByVal item As OrderItem) As Integer\n\n        &#39; In this example, the key is the part number.\n        Return item.PartNumber   \n    End Function\n\n    Protected Overrides Sub InsertItem( _\n        ByVal index As Integer, ByVal newItem As OrderItem)\n\n        MyBase.InsertItem(index, newItem)\n\n        RaiseEvent Changed(Me, New SimpleOrderChangedEventArgs( _\n            ChangeType.Added, newItem, Nothing))\n    End Sub\n\n    Protected Overrides Sub SetItem(ByVal index As Integer, _\n        ByVal newItem As OrderItem)\n\n        Dim replaced As OrderItem = Items(index)\n        MyBase.SetItem(index, newItem)\n\n        RaiseEvent Changed(Me, New SimpleOrderChangedEventArgs( _\n            ChangeType.Replaced, replaced, newItem))\n    End Sub\n\n    Protected Overrides Sub RemoveItem(ByVal index As Integer)\n\n        Dim removedItem As OrderItem = Items(index)\n        MyBase.RemoveItem(index)\n\n        RaiseEvent Changed(Me, New SimpleOrderChangedEventArgs( _\n            ChangeType.Removed, removedItem, Nothing))\n    End Sub\n\n    Protected Overrides Sub ClearItems()\n        MyBase.ClearItems()\n\n        RaiseEvent Changed(Me, New SimpleOrderChangedEventArgs( _\n            ChangeType.Cleared, Nothing, Nothing))\n    End Sub\n\nEnd Class\n\n&#39; Event argument for the Changed event.\n&#39;\nPublic Class SimpleOrderChangedEventArgs\n    Inherits EventArgs\n\n    Private _changedItem As OrderItem\n    Private _changeType As ChangeType\n    Private _replacedWith As OrderItem\n\n    Public ReadOnly Property ChangedItem As OrderItem\n        Get\n            Return _changedItem\n        End Get\n    End Property\n\n    Public ReadOnly Property ChangeType As ChangeType\n        Get\n            Return _changeType\n        End Get\n    End Property\n\n    Public ReadOnly Property ReplacedWith As OrderItem\n        Get\n            Return _replacedWith\n        End Get\n    End Property\n\n    Public Sub New(ByVal change As ChangeType, ByVal item As OrderItem, _\n        ByVal replacement As OrderItem)\n\n        _changeType = change\n        _changedItem = item\n        _replacedWith = replacement\n    End Sub\nEnd Class\n\nPublic Enum ChangeType\n    Added\n    Removed\n    Replaced\n    Cleared\nEnd Enum\n\nPublic Class Demo\n    \n    Public Shared Sub Main() \n        Dim weekly As New SimpleOrder()\n        AddHandler weekly.Changed, AddressOf ChangedHandler\n\n        &#39; The Add method, inherited from Collection, takes OrderItem.\n        &#39;\n        weekly.Add(New OrderItem(110072674, &quot;Widget&quot;, 400, 45.17))\n        weekly.Add(New OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3))\n        weekly.Add(New OrderItem(101030411, &quot;Motor&quot;, 10, 237.5))\n        weekly.Add(New OrderItem(110072684, &quot;Gear&quot;, 175, 5.17))\n\n        Display(weekly)\n        \n        &#39; The Contains method of KeyedCollection takes TKey.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Contains(101030411): {0}&quot;, _\n            weekly.Contains(101030411))\n\n        &#39; The default Item property of KeyedCollection takes the key\n        &#39; type, Integer. The property is read-only.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;weekly(101030411).Description: {0}&quot;, _\n            weekly(101030411).Description)\n\n        &#39; The Remove method of KeyedCollection takes a key.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Remove(101030411)&quot;)\n        weekly.Remove(101030411)\n\n        &#39; The Insert method, inherited from Collection, takes an \n        &#39; index and an OrderItem.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Insert(2, New OrderItem(...))&quot;)\n        weekly.Insert(2, New OrderItem(111033401, &quot;Nut&quot;, 10, .5))\n         \n        &#39; The default Item property is overloaded. One overload comes\n        &#39; from KeyedCollection(Of Integer, OrderItem); that overload\n        &#39; is read-only, and takes Integer because it retrieves by key. \n        &#39; The other overload comes from Collection(Of OrderItem), the \n        &#39; base class of KeyedCollection(Of Integer, OrderItem); it \n        &#39; retrieves by index, so it also takes an Integer. The compiler\n        &#39; uses the most-derived overload, from KeyedCollection, so the\n        &#39; only way to access SimpleOrder by index is to cast it to\n        &#39; Collection(Of OrderItem). Otherwise the index is interpreted\n        &#39; as a key, and KeyNotFoundException is thrown.\n        &#39;\n        Dim coweekly As Collection(Of OrderItem) = weekly\n        Console.WriteLine(vbLf &amp; &quot;coweekly(2).Description: {0}&quot;, _\n            coweekly(2).Description)\n \n        Console.WriteLine(vbLf &amp; &quot;coweekly(2) = New OrderItem(...)&quot;)\n        coweekly(2) = New OrderItem(127700026, &quot;Crank&quot;, 27, 5.98)\n\n        Dim temp As OrderItem = coweekly(2)\n\n        &#39; The IndexOf method, inherited from Collection(Of OrderItem), \n        &#39; takes an OrderItem instead of a key.\n        &#39; \n        Console.WriteLine(vbLf &amp; &quot;IndexOf(temp): {0}&quot;, _\n            weekly.IndexOf(temp))\n\n        &#39; The inherited Remove method also takes an OrderItem.\n        &#39;\n        Console.WriteLine(vbLf &amp; &quot;Remove(temp)&quot;)\n        weekly.Remove(temp)\n\n        Console.WriteLine(vbLf &amp; &quot;RemoveAt(0)&quot;)\n        weekly.RemoveAt(0)\n\n        &#39; Increase the quantity for a line item.\n        Console.WriteLine(vbLf &amp; &quot;coweekly(1) = New OrderItem(...)&quot;)\n        coweekly(1) = New OrderItem(coweekly(1).PartNumber, _\n            coweekly(1).Description, coweekly(1).Quantity + 1000, _\n            coweekly(1).UnitPrice)\n\n        Display(weekly)\n\n        Console.WriteLine()\n        weekly.Clear()\n    End Sub\n    \n    Private Shared Sub Display(ByVal order As SimpleOrder) \n        Console.WriteLine()\n        For Each item As OrderItem In  order\n            Console.WriteLine(item)\n        Next item\n    End Sub\n\n    Private Shared Sub ChangedHandler(ByVal source As Object, _\n        ByVal e As SimpleOrderChangedEventArgs)\n\n        Dim item As OrderItem = e.ChangedItem\n\n        If e.ChangeType = ChangeType.Replaced Then\n            Dim replacement As OrderItem = e.ReplacedWith\n\n            Console.WriteLine(&quot;{0} (quantity {1}) was replaced &quot; &amp; _\n                &quot;by {2}, (quantity {3}).&quot;, item.Description, _\n                item.Quantity, replacement.Description, replacement.Quantity)\n\n        ElseIf e.ChangeType = ChangeType.Cleared Then\n            Console.WriteLine(&quot;The order list was cleared.&quot;)\n\n        Else\n            Console.WriteLine(&quot;{0} (quantity {1}) was {2}.&quot;, _\n                item.Description, item.Quantity, e.ChangeType)\n        End If\n    End Sub\nEnd Class\n\n&#39; This class represents a simple line item in an order. All the \n&#39; values are immutable except quantity.\n&#39; \nPublic Class OrderItem\n    \n    Private _partNumber As Integer\n    Private _description As String\n    Private _unitPrice As Double\n    Private _quantity As Integer\n\n    Public ReadOnly Property PartNumber As Integer\n        Get\n            Return _partNumber\n        End Get\n    End Property\n\n    Public ReadOnly Property Description As String\n        Get\n            Return _description\n        End Get\n    End Property\n\n    Public ReadOnly Property UnitPrice As Double\n        Get\n            Return _unitPrice\n        End Get\n    End Property\n    \n    Public ReadOnly Property Quantity() As Integer \n        Get\n            Return _quantity\n        End Get\n    End Property\n    \n    Public Sub New(ByVal partNumber As Integer, _\n                   ByVal description As String, _\n                   ByVal quantity As Integer, _\n                   ByVal unitPrice As Double) \n        _partNumber = partNumber\n        _description = description\n        _quantity = quantity\n        _unitPrice = unitPrice\n    End Sub &#39;New\n        \n    Public Overrides Function ToString() As String \n        Return String.Format( _\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, _\n            PartNumber, _quantity, Description, UnitPrice, _\n            UnitPrice * _quantity)\n    End Function\nEnd Class\n\n&#39; This code example produces the following output:\n&#39;\n&#39;Widget (quantity 400) was Added.\n&#39;Sprocket (quantity 27) was Added.\n&#39;Motor (quantity 10) was Added.\n&#39;Gear (quantity 175) was Added.\n&#39;\n&#39;110072674    400 Widget       at    45.17 =  18,068.00\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;101030411     10 Motor        at   237.50 =   2,375.00\n&#39;110072684    175 Gear         at     5.17 =     904.75\n&#39;\n&#39;Contains(101030411): True\n&#39;\n&#39;weekly(101030411).Description: Motor\n&#39;\n&#39;Remove(101030411)\n&#39;Motor (quantity 10) was Removed.\n&#39;\n&#39;Insert(2, New OrderItem(...))\n&#39;Nut (quantity 10) was Added.\n&#39;\n&#39;coweekly(2).Description: Nut\n&#39;\n&#39;coweekly(2) = New OrderItem(...)\n&#39;Nut (quantity 10) was replaced by Crank, (quantity 27).\n&#39;\n&#39;IndexOf(temp): 2\n&#39;\n&#39;Remove(temp)\n&#39;Crank (quantity 27) was Removed.\n&#39;\n&#39;RemoveAt(0)\n&#39;Widget (quantity 400) was Removed.\n&#39;\n&#39;coweekly(1) = New OrderItem(...)\n&#39;Gear (quantity 175) was replaced by Gear, (quantity 1175).\n&#39;\n&#39;110072675     27 Sprocket     at     5.30 =     143.10\n&#39;110072684   1175 Gear         at     5.17 =   6,074.75\n&#39;\n&#39;The order list was cleared.\n</code></pre><pre><code class=\"lang-cs\" name=\"KeyedCollection2#1\">using System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\n\n// This class derives from KeyedCollection and shows how to override\n// the protected ClearItems, InsertItem, RemoveItem, and SetItem \n// methods in order to change the behavior of the default Item \n// property and the Add, Clear, Insert, and Remove methods. The\n// class implements a Changed event, which is raised by all the\n// protected methods.\n//\n// SimpleOrder is a collection of OrderItem objects, and its key\n// is the PartNumber field of OrderItem. PartNumber is an Integer,\n// so SimpleOrder inherits KeyedCollection&lt;int, OrderItem&gt;.\n// (Note that the key of OrderItem cannot be changed; if it could \n// be changed, SimpleOrder would have to override ChangeItemKey.)\n//\npublic class SimpleOrder : KeyedCollection&lt;int, OrderItem&gt;\n{\n    public event EventHandler&lt;SimpleOrderChangedEventArgs&gt; Changed;\n\n    // This parameterless constructor calls the base class constructor\n    // that specifies a dictionary threshold of 0, so that the internal\n    // dictionary is created as soon as an item is added to the \n    // collection.\n    //\n    public SimpleOrder() : base(null, 0) {}\n    \n    // This is the only method that absolutely must be overridden,\n    // because without it the KeyedCollection cannot extract the\n    // keys from the items. \n    //\n    protected override int GetKeyForItem(OrderItem item)\n    {\n        // In this example, the key is the part number.\n        return item.PartNumber;\n    }\n\n    protected override void InsertItem(int index, OrderItem newItem)\n    {\n        base.InsertItem(index, newItem);\n\n        EventHandler&lt;SimpleOrderChangedEventArgs&gt; temp = Changed;\n        if (temp != null)\n        {\n            temp(this, new SimpleOrderChangedEventArgs(\n                ChangeType.Added, newItem, null));\n        }\n    }\n\n    protected override void SetItem(int index, OrderItem newItem)\n    {\n        OrderItem replaced = Items[index];\n        base.SetItem(index, newItem);\n\n        EventHandler&lt;SimpleOrderChangedEventArgs&gt; temp = Changed;\n        if (temp != null)\n        {\n            temp(this, new SimpleOrderChangedEventArgs(\n                ChangeType.Replaced, replaced, newItem));\n        }\n    }\n\n    protected override void RemoveItem(int index)\n    {\n        OrderItem removedItem = Items[index];\n        base.RemoveItem(index);\n\n        EventHandler&lt;SimpleOrderChangedEventArgs&gt; temp = Changed;\n        if (temp != null)\n        {\n            temp(this, new SimpleOrderChangedEventArgs(\n                ChangeType.Removed, removedItem, null));\n        }\n    }\n\n    protected override void ClearItems()\n    {\n        base.ClearItems();\n\n        EventHandler&lt;SimpleOrderChangedEventArgs&gt; temp = Changed;\n        if (temp != null)\n        {\n            temp(this, new SimpleOrderChangedEventArgs(\n                ChangeType.Cleared, null, null));\n        }\n    }\n}\n\n// Event argument for the Changed event.\n//\npublic class SimpleOrderChangedEventArgs : EventArgs\n{\n    private OrderItem _changedItem;\n    private ChangeType _changeType;\n    private OrderItem _replacedWith;\n\n    public OrderItem ChangedItem { get { return _changedItem; }}\n    public ChangeType ChangeType { get { return _changeType; }}\n    public OrderItem ReplacedWith { get { return _replacedWith; }}\n\n    public SimpleOrderChangedEventArgs(ChangeType change, \n        OrderItem item, OrderItem replacement)\n    {\n        _changeType = change;\n        _changedItem = item;\n        _replacedWith = replacement;\n    }\n}\n\npublic enum ChangeType\n{\n    Added, \n    Removed, \n    Replaced, \n    Cleared\n};\n\npublic class Demo\n{    \n    public static void Main()\n    {\n        SimpleOrder weekly = new SimpleOrder();\n        weekly.Changed += new \n            EventHandler&lt;SimpleOrderChangedEventArgs&gt;(ChangedHandler);\n\n        // The Add method, inherited from Collection, takes OrderItem.\n        //\n        weekly.Add(new OrderItem(110072674, &quot;Widget&quot;, 400, 45.17));\n        weekly.Add(new OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3));\n        weekly.Add(new OrderItem(101030411, &quot;Motor&quot;, 10, 237.5));\n        weekly.Add(new OrderItem(110072684, &quot;Gear&quot;, 175, 5.17));\n\n        Display(weekly);\n        \n        // The Contains method of KeyedCollection takes TKey.\n        //\n        Console.WriteLine(&quot;<br>Contains(101030411): {0}&quot;, \n            weekly.Contains(101030411));\n\n        // The default Item property of KeyedCollection takes the key\n        // type, Integer. The property is read-only.\n        //\n        Console.WriteLine(&quot;<br>weekly[101030411].Description: {0}&quot;, \n            weekly[101030411].Description);\n\n        // The Remove method of KeyedCollection takes a key.\n        //\n        Console.WriteLine(&quot;<br>Remove(101030411)&quot;);\n        weekly.Remove(101030411);\n\n        // The Insert method, inherited from Collection, takes an \n        // index and an OrderItem.\n        //\n        Console.WriteLine(&quot;<br>Insert(2, new OrderItem(...))&quot;);\n        weekly.Insert(2, new OrderItem(111033401, &quot;Nut&quot;, 10, .5));\n         \n        // The default Item property is overloaded. One overload comes\n        // from KeyedCollection&lt;int, OrderItem&gt;; that overload\n        // is read-only, and takes Integer because it retrieves by key. \n        // The other overload comes from Collection&lt;OrderItem&gt;, the \n        // base class of KeyedCollection&lt;int, OrderItem&gt;; it \n        // retrieves by index, so it also takes an Integer. The compiler\n        // uses the most-derived overload, from KeyedCollection, so the\n        // only way to access SimpleOrder by index is to cast it to\n        // Collection&lt;OrderItem&gt;. Otherwise the index is interpreted\n        // as a key, and KeyNotFoundException is thrown.\n        //\n        Collection&lt;OrderItem&gt; coweekly = weekly;\n        Console.WriteLine(&quot;<br>coweekly[2].Description: {0}&quot;, \n            coweekly[2].Description);\n \n        Console.WriteLine(&quot;<br>coweekly[2] = new OrderItem(...)&quot;);\n        coweekly[2] = new OrderItem(127700026, &quot;Crank&quot;, 27, 5.98);\n\n        OrderItem temp = coweekly[2];\n\n        // The IndexOf method, inherited from Collection&lt;OrderItem&gt;, \n        // takes an OrderItem instead of a key.\n        // \n        Console.WriteLine(&quot;<br>IndexOf(temp): {0}&quot;, weekly.IndexOf(temp));\n\n        // The inherited Remove method also takes an OrderItem.\n        //\n        Console.WriteLine(&quot;<br>Remove(temp)&quot;);\n        weekly.Remove(temp);\n\n        Console.WriteLine(&quot;<br>RemoveAt(0)&quot;);\n        weekly.RemoveAt(0);\n\n        // Increase the quantity for a line item.\n        Console.WriteLine(&quot;<br>coweekly(1) = New OrderItem(...)&quot;);\n        coweekly[1] = new OrderItem(coweekly[1].PartNumber, \n            coweekly[1].Description, coweekly[1].Quantity + 1000, \n            coweekly[1].UnitPrice);\n\n        Display(weekly);\n\n        Console.WriteLine();\n        weekly.Clear();\n    }\n    \n    private static void Display(SimpleOrder order)\n    {\n        Console.WriteLine();\n        foreach( OrderItem item in order )\n        {\n            Console.WriteLine(item);\n        }\n    }\n\n    private static void ChangedHandler(object source, \n        SimpleOrderChangedEventArgs e)\n    {\n\n        OrderItem item = e.ChangedItem;\n\n        if (e.ChangeType==ChangeType.Replaced)\n        {\n            OrderItem replacement = e.ReplacedWith;\n\n            Console.WriteLine(&quot;{0} (quantity {1}) was replaced &quot; +\n                &quot;by {2}, (quantity {3}).&quot;, item.Description, \n                item.Quantity, replacement.Description, \n                replacement.Quantity);\n        }\n        else if(e.ChangeType == ChangeType.Cleared)\n        {\n            Console.WriteLine(&quot;The order list was cleared.&quot;);\n        }\n        else\n        {\n            Console.WriteLine(&quot;{0} (quantity {1}) was {2}.&quot;, \n                item.Description, item.Quantity, e.ChangeType);\n        }\n    }\n}\n\n// This class represents a simple line item in an order. All the \n// values are immutable except quantity.\n// \npublic class OrderItem\n{\n    private int _partNumber;\n    private string _description;\n    private double _unitPrice;\n    private int _quantity;\n    \n    public int PartNumber { get { return _partNumber; }}\n    public string Description { get { return _description; }}\n    public double UnitPrice { get { return _unitPrice; }}\n    public int Quantity { get { return _quantity; }}\n    \n    public OrderItem(int partNumber, string description, int quantity, \n        double unitPrice)\n    {\n        _partNumber = partNumber;\n        _description = description;\n        _quantity = quantity;\n        _unitPrice = unitPrice;\n    }\n    \n    public override string ToString()\n    {\n        return String.Format(\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, \n            PartNumber, _quantity, Description, UnitPrice, \n            UnitPrice * _quantity);\n    }\n}\n\n/* This code example produces the following output:\n\nWidget (quantity 400) was Added.\nSprocket (quantity 27) was Added.\nMotor (quantity 10) was Added.\nGear (quantity 175) was Added.\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n101030411     10 Motor        at   237.50 =   2,375.00\n110072684    175 Gear         at     5.17 =     904.75\n\nContains(101030411): True\n\nweekly[101030411].Description: Motor\n\nRemove(101030411)\nMotor (quantity 10) was Removed.\n\nInsert(2, new OrderItem(...))\nNut (quantity 10) was Added.\n\ncoweekly[2].Description: Nut\n\ncoweekly[2] = new OrderItem(...)\nNut (quantity 10) was replaced by Crank, (quantity 27).\n\nIndexOf(temp): 2\n\nRemove(temp)\nCrank (quantity 27) was Removed.\n\nRemoveAt(0)\nWidget (quantity 400) was Removed.\n\ncoweekly(1) = New OrderItem(...)\nGear (quantity 175) was replaced by Gear, (quantity 1175).\n\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684   1175 Gear         at     5.17 =   6,074.75\n\nThe order list was cleared.\n */\n</code></pre><pre><code class=\"lang-cpp\" name=\"KeyedCollection2#1\">using namespace System;\nusing namespace System::Collections::Generic;\nusing namespace System::Collections::ObjectModel;\n\npublic enum class ChangeTypes\n{\n    Added,\n    Removed, \n    Replaced, \n    Cleared\n};\n\nref class SimpleOrderChangedEventArgs; \n\n// This class represents a simple line item in an order. All the \n// values are immutable except quantity.\n// \npublic ref class OrderItem\n{\nprivate:\n    int _quantity;\n\npublic:\n    initonly int PartNumber;\n    initonly String^ Description;\n    initonly double UnitPrice;\n        \n    OrderItem(int partNumber, String^ description, int quantity, \n        double unitPrice)\n    {\n        this-&gt;PartNumber = partNumber;\n        this-&gt;Description = description;\n        this-&gt;Quantity = quantity;\n        this-&gt;UnitPrice = unitPrice;\n    };\n    \n    property int Quantity    \n    {\n        int get() { return _quantity; };\n        void set(int value)\n        {\n            if (value &lt; 0)\n                throw gcnew ArgumentException(&quot;Quantity cannot be negative.&quot;);\n            \n            _quantity = value;\n        };\n    };\n        \n    virtual String^ ToString() override \n    {\n        return String::Format(\n            &quot;{0,9} {1,6} {2,-12} at {3,8:#,###.00} = {4,10:###,###.00}&quot;, \n            PartNumber, _quantity, Description, UnitPrice, \n            UnitPrice * _quantity);\n    };\n};\n\n// Event argument for the Changed event.\n//\npublic ref class SimpleOrderChangedEventArgs : EventArgs\n{\npublic:\n    OrderItem^ ChangedItem;\n    initonly ChangeTypes ChangeType;\n    OrderItem^ ReplacedWith;\n\n    SimpleOrderChangedEventArgs(ChangeTypes change, \n        OrderItem^ item, OrderItem^ replacement)\n    {\n        this-&gt;ChangeType = change;\n        this-&gt;ChangedItem = item;\n        this-&gt;ReplacedWith = replacement;\n    }\n};\n\n// This class derives from KeyedCollection and shows how to override\n// the protected ClearItems, InsertItem, RemoveItem, and SetItem \n// methods in order to change the behavior of the default Item \n// property and the Add, Clear, Insert, and Remove methods. The\n// class implements a Changed event, which is raised by all the\n// protected methods.\n//\n// SimpleOrder is a collection of OrderItem objects, and its key\n// is the PartNumber field of OrderItem-&gt; PartNumber is an Integer,\n// so SimpleOrder inherits KeyedCollection&lt;int, OrderItem&gt;.\n// (Note that the key of OrderItem cannot be changed; if it could \n// be changed, SimpleOrder would have to override ChangeItemKey.)\n//\npublic ref class SimpleOrder : KeyedCollection&lt;int, OrderItem^&gt;\n{\npublic:\n    event EventHandler&lt;SimpleOrderChangedEventArgs^&gt;^ Changed;\n\n    // This parameterless constructor calls the base class constructor\n    // that specifies a dictionary threshold of 0, so that the internal\n    // dictionary is created as soon as an item is added to the \n    // collection.\n    //\n    SimpleOrder() : KeyedCollection&lt;int, OrderItem^&gt;(nullptr, 0) {};\n    \n    // This is the only method that absolutely must be overridden,\n    // because without it the KeyedCollection cannot extract the\n    // keys from the items. \n    //\nprotected:\n    virtual int GetKeyForItem(OrderItem^ item) override\n    {\n        // In this example, the key is the part number.\n        return item-&gt;PartNumber;\n    }\n\n    virtual void InsertItem(int index, OrderItem^ newItem) override \n    {\n        __super::InsertItem(index, newItem);\n\n        Changed(this, gcnew SimpleOrderChangedEventArgs(\n            ChangeTypes::Added, newItem, nullptr));\n    }\n\n    virtual void SetItem(int index, OrderItem^ newItem) override \n    {\n        OrderItem^ replaced = this-&gt;Items[index];\n        __super::SetItem(index, newItem);\n\n        Changed(this, gcnew SimpleOrderChangedEventArgs(\n            ChangeTypes::Replaced, replaced, newItem));\n    }\n\n    virtual void RemoveItem(int index) override \n    {\n        OrderItem^ removedItem = Items[index];\n        __super::RemoveItem(index);\n\n        Changed(this, gcnew SimpleOrderChangedEventArgs(\n            ChangeTypes::Removed, removedItem, nullptr));\n    }\n\n    virtual void ClearItems() override \n    {\n        __super::ClearItems();\n\n        Changed(this, gcnew SimpleOrderChangedEventArgs(\n            ChangeTypes::Cleared, nullptr, nullptr));\n    }\n\n    // This method uses the internal reference to the dictionary\n    // to test fo\npublic:\n    void AddOrMerge(OrderItem^ newItem)\n    {\n\n        int key = this-&gt;GetKeyForItem(newItem);\n        OrderItem^ existingItem = nullptr;\n\n        // The dictionary is not created until the first item is \n        // added, so it is necessary to test for null. Using \n        // AndAlso ensures that TryGetValue is not called if the\n        // dictionary does not exist.\n        //\n        if (this-&gt;Dictionary != nullptr &amp;&amp; \n            this-&gt;Dictionary-&gt;TryGetValue(key, existingItem))\n        {\n            existingItem-&gt;Quantity += newItem-&gt;Quantity;\n        }\n        else\n        {\n            this-&gt;Add(newItem);\n        }\n    }\n};\n\npublic ref class Demo\n{    \npublic:\n    static void Main()\n    {\n        SimpleOrder^ weekly = gcnew SimpleOrder();\n        weekly-&gt;Changed += gcnew \n            EventHandler&lt;SimpleOrderChangedEventArgs^&gt;(ChangedHandler);\n\n        // The Add method, inherited from Collection, takes OrderItem-&gt;\n        //\n        weekly-&gt;Add(gcnew OrderItem(110072674, &quot;Widget&quot;, 400, 45.17));\n        weekly-&gt;Add(gcnew OrderItem(110072675, &quot;Sprocket&quot;, 27, 5.3));\n        weekly-&gt;Add(gcnew OrderItem(101030411, &quot;Motor&quot;, 10, 237.5));\n        weekly-&gt;Add(gcnew OrderItem(110072684, &quot;Gear&quot;, 175, 5.17));\n\n        Display(weekly);\n        \n        // The Contains method of KeyedCollection takes TKey.\n        //\n        Console::WriteLine(&quot;<br>Contains(101030411): {0}&quot;, \n            weekly-&gt;Contains(101030411));\n\n        // The default Item property of KeyedCollection takes the key\n        // type, Integer. The property is read-only.\n        //\n        Console::WriteLine(&quot;<br>weekly[101030411]-&gt;Description: {0}&quot;, \n            weekly[101030411]-&gt;Description);\n\n        // The Remove method of KeyedCollection takes a key.\n        //\n        Console::WriteLine(&quot;<br>Remove(101030411)&quot;);\n        weekly-&gt;Remove(101030411);\n\n        // The Insert method, inherited from Collection, takes an \n        // index and an OrderItem.\n        //\n        Console::WriteLine(&quot;<br>Insert(2, gcnew OrderItem(...))&quot;);\n        weekly-&gt;Insert(2, gcnew OrderItem(111033401, &quot;Nut&quot;, 10, .5));\n         \n        // The default Item property is overloaded. One overload comes\n        // from KeyedCollection&lt;int, OrderItem&gt;; that overload\n        // is read-only, and takes Integer because it retrieves by key. \n        // The other overload comes from Collection&lt;OrderItem&gt;, the \n        // base class of KeyedCollection&lt;int, OrderItem&gt;; it \n        // retrieves by index, so it also takes an Integer. The compiler\n        // uses the most-derived overload, from KeyedCollection, so the\n        // only way to access SimpleOrder by index is to cast it to\n        // Collection&lt;OrderItem&gt;. Otherwise the index is interpreted\n        // as a key, and KeyNotFoundException is thrown.\n        //\n        Collection&lt;OrderItem^&gt;^ coweekly = weekly;\n        Console::WriteLine(&quot;<br>coweekly[2].Description: {0}&quot;, \n            coweekly[2]-&gt;Description);\n \n        Console::WriteLine(&quot;<br>coweekly[2] = gcnew OrderItem(...)&quot;);\n        coweekly[2] = gcnew OrderItem(127700026, &quot;Crank&quot;, 27, 5.98);\n\n        OrderItem^ temp = coweekly[2];\n\n        // The IndexOf method, inherited from Collection&lt;OrderItem&gt;, \n        // takes an OrderItem instead of a key.\n        // \n        Console::WriteLine(&quot;<br>IndexOf(temp): {0}&quot;, weekly-&gt;IndexOf(temp));\n\n        // The inherited Remove method also takes an OrderItem-&gt;\n        //\n        Console::WriteLine(&quot;<br>Remove(temp)&quot;);\n        weekly-&gt;Remove(temp);\n\n        Console::WriteLine(&quot;<br>RemoveAt(0)&quot;);\n        weekly-&gt;RemoveAt(0);\n\n        weekly-&gt;AddOrMerge(gcnew OrderItem(110072684, &quot;Gear&quot;, 1000, 5.17));\n\n        Display(weekly);\n\n        Console::WriteLine();\n        weekly-&gt;Clear();\n    }\n    \nprivate:\n    static void Display(SimpleOrder^ order)\n    {\n        Console::WriteLine();\n        for each( OrderItem^ item in order )\n        {\n            Console::WriteLine(item);\n        }\n    }\n\n    static void ChangedHandler(Object^ source, \n        SimpleOrderChangedEventArgs^ e)\n    {\n        OrderItem^ item = e-&gt;ChangedItem;\n\n        if (e-&gt;ChangeType == ChangeTypes::Replaced)\n        {\n            OrderItem^ replacement = e-&gt;ReplacedWith;\n\n            Console::WriteLine(&quot;{0} (quantity {1}) was replaced &quot; +\n                &quot;by {2}, (quantity {3}).&quot;, item-&gt;Description, \n                item-&gt;Quantity, replacement-&gt;Description, \n                replacement-&gt;Quantity);\n        }\n        else if(e-&gt;ChangeType == ChangeTypes::Cleared)\n        {\n            Console::WriteLine(&quot;The order list was cleared.&quot;);\n        }\n        else\n        {\n            Console::WriteLine(&quot;{0} (quantity {1}) was {2}.&quot;, \n                item-&gt;Description, item-&gt;Quantity, e-&gt;ChangeType);\n        }\n    }\n};\n\nvoid main()\n{\n    Demo::Main();\n}\n\n/* This code example produces the following output:\n\nWidget (quantity 400) was Added.\nSprocket (quantity 27) was Added.\nMotor (quantity 10) was Added.\nGear (quantity 175) was Added.\n\n110072674    400 Widget       at    45.17 =  18,068.00\n110072675     27 Sprocket     at     5.30 =     143.10\n101030411     10 Motor        at   237.50 =   2,375.00\n110072684    175 Gear         at     5.17 =     904.75\n\nContains(101030411): True\n\nweekly[101030411]-&gt;Description: Motor\n\nRemove(101030411)\nMotor (quantity 10) was Removed.\n\nInsert(2, gcnew OrderItem(...))\nNut (quantity 10) was Added.\n\ncoweekly[2].Description: Nut\n\ncoweekly[2] = gcnew OrderItem(...)\nNut (quantity 10) was replaced by Crank, (quantity 27).\n\nIndexOf(temp): 2\n\nRemove(temp)\nCrank (quantity 27) was Removed.\n\nRemoveAt(0)\nWidget (quantity 400) was Removed.\n\n110072675     27 Sprocket     at     5.30 =     143.10\n110072684   1175 Gear         at     5.17 =   6,074.75\n\nThe order list was cleared.\n */\n</code></pre><p> Example 2  </p>\n<p> The following code example shows how to override the protected <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_ChangeItemKey_\" data-linktype=\"relative-path\">ChangeItemKey</a> method to support mutable keys, and how to override the protected <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_InsertItem_\" data-linktype=\"relative-path\">InsertItem</a>, <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_RemoveItem_\" data-linktype=\"relative-path\">RemoveItem</a>, <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_ClearItems_\" data-linktype=\"relative-path\">ClearItems</a>, and SetItem methods to maintain the integrity of the keys and the collection.  </p>\n<p> The code example creates the <code>MutableKeys</code> collection, which derives from <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2\" data-linktype=\"relative-path\">KeyedCollection&lt;TKey,TItem&gt;</a>, and the <code>MutableKey</code> class. The <code>MutableKey</code> class has a settable <code>Key</code> property. When a new key is assigned to the property, the property setter calls the <code>internal</code> (<code>Friend</code> in Visual Basic) <code>ChangeKey</code> method of the collection to test whether the new key would conflict with an existing key. If so, an exception is thrown and the property value is not changed.  </p>\n<p> In order to maintain the connection between a <code>MutableKey</code> object and the <code>MutableKeys</code> collection and to prevent an object from being inserted into two collections, the <code>MutableKey</code> class has an <code>internal</code> (<code>Friend</code> in Visual Basic) <code>Collection</code> field. This field is maintained by the protected methods that provide custom behavior for adding and removing items from the collection, such as the <a class=\"xref\" href=\"system.collections.objectmodel.keyedcollection-2#System_Collections_ObjectModel_KeyedCollection_2_InsertItem_\" data-linktype=\"relative-path\">InsertItem</a> method. The field is set when the item is added to a collection and cleared when the item is removed.  </p>\n<pre><code class=\"lang-cs\" name=\"KeyedCollectionMutable#1\">using System;\nusing System.Collections.Generic;\nusing System.Collections.ObjectModel;\n\n// This class demonstrates one way to use the ChangeItemKey\n// method to store objects with keys that can be changed. The \n// ChangeItemKey method is used to keep the internal lookup\n// Dictionary in sync with the keys of the stored objects. \n//\n// MutableKeys stores MutableKey objects, which have an Integer\n// Key property that can be set. Therefore, MutableKeys inherits\n// KeyedCollection(Of Integer, MutableKey).\n//\npublic class MutableKeys : KeyedCollection&lt;int, MutableKey&gt;\n{\n    // This parameterless constructor delegates to the base class \n    // constructor that specifies a dictionary threshold. A\n    // threshold of 0 means the internal Dictionary is created\n    // the first time an object is added.\n    //\n    public MutableKeys() : base(null, 0) {}\n    \n    protected override int GetKeyForItem(MutableKey item)\n    {\n        // The key is MutableKey.Key.\n        return item.Key;\n    }\n\n    protected override void InsertItem(int index, MutableKey newItem)\n    {\n        if (newItem.Collection != null) \n            throw new ArgumentException(&quot;The item already belongs to a collection.&quot;);\n\n        base.InsertItem(index, newItem);\n        newItem.Collection = this;\n    }\n\n    protected override void SetItem(int index, MutableKey newItem)\n    {\n        MutableKey replaced = Items[index];\n\n        if (newItem.Collection != null) \n            throw new ArgumentException(&quot;The item already belongs to a collection.&quot;);\n\n        base.SetItem(index, newItem);\n        newItem.Collection = this;\n        replaced.Collection = null;\n    }\n\n    protected override void RemoveItem(int index)\n    {\n        MutableKey removedItem = Items[index];\n\n        base.RemoveItem(index);\n        removedItem.Collection = null;\n    }\n\n    protected override void ClearItems()\n    {\n        foreach( MutableKey mk in Items )\n        {\n            mk.Collection = null;\n        }\n        \n        base.ClearItems();\n    }\n\n    internal void ChangeKey(MutableKey item, int newKey)\n    {\n        base.ChangeItemKey(item, newKey);\n    }\n    \n    public void Dump()\n    {\n        Console.WriteLine(&quot;<br>DUMP:&quot;);\n        if (Dictionary == null)\n        {\n            Console.WriteLine(&quot;    The dictionary has not been created.&quot;);\n        }\n        else\n        {\n            Console.WriteLine(&quot;    Dictionary entries&quot;);\n            Console.WriteLine(&quot;    ------------------&quot;);\n\n            foreach( KeyValuePair&lt;int, MutableKey&gt; kvp in Dictionary )\n            {\n                Console.WriteLine(&quot;    {0} : {1}&quot;, kvp.Key, kvp.Value);\n            }\n        }\n\n        Console.WriteLine(&quot;<br>    List of items&quot;);\n        Console.WriteLine(&quot;    -------------&quot;);\n\n        foreach( MutableKey mk in Items )\n        {\n            Console.WriteLine(&quot;    {0}&quot;, mk);\n        }\n    }\n}\n\npublic class Demo\n{\n    public static void Main()\n    {\n        MutableKeys mkeys = new MutableKeys();\n\n        // The Add method is inherited from Collection.\n        //\n        mkeys.Add(new MutableKey(110072674, &quot;Widget&quot;));\n        mkeys.Add(new MutableKey(110072675, &quot;Sprocket&quot;));\n\n        mkeys.Dump();\n    \n        Console.WriteLine(&quot;<br>Create and insert a new item:&quot;);\n        MutableKey test = new MutableKey(110072684, &quot;Gear&quot;);\n        mkeys.Insert(1, test);\n\n        mkeys.Dump();\n\n        try\n        {\n            Console.WriteLine(&quot;<br>Try to insert the item again:&quot;);\n            mkeys.Insert(1, test);\n        }\n        catch(ArgumentException ex)\n        {\n            Console.WriteLine(&quot;Error: {0}&quot;, ex.Message);\n        }\n\n        Console.WriteLine(&quot;<br>Change the Key property of the item:&quot;);\n        test.Key = 100000072;\n\n        mkeys.Dump();\n\n        try\n        {\n            Console.WriteLine(&quot;<br>Try to set the Key property to an existing key:&quot;);\n            test.Key = 110072674;\n        }\n        catch(ArgumentException ex)\n        {\n            Console.WriteLine(&quot;Error: {0}&quot;, ex.Message);\n        }\n\n        mkeys.Dump();\n    }\n    \n    private static void Display(MutableKeys order)\n    {\n        Console.WriteLine();\n        foreach( MutableKey item in order )\n        {\n            Console.WriteLine(item);\n        }\n    }\n}\n\n// This class has a key that can be changed.\n// \npublic class MutableKey\n{\n\n    public MutableKey(int newKey, string newValue)\n    {\n        _key = newKey;\n        Value = newValue;\n    } //New\n    \n    public string Value;\n    internal MutableKeys Collection;\n    \n    private int _key;\n    public int Key    \n    {\n        get\n        {\n            return _key;\n        }\n        set\n        {\n            if (Collection != null)\n            {\n                Collection.ChangeKey(this, value);\n            }\n\n            _key = value;\n        }\n    }\n\n    public override string ToString()\n    {\n        return String.Format(&quot;{0,9} {1}&quot;, _key, Value);\n    }\n        \n}\n\n/* This code example produces the following output:\n\nDUMP:\n    Dictionary entries\n    ------------------\n    110072674 : 110072674 Widget\n    110072675 : 110072675 Sprocket\n\n    List of items\n    -------------\n    110072674 Widget\n    110072675 Sprocket\n\nCreate and insert a new item:\n\nDUMP:\n    Dictionary entries\n    ------------------\n    110072674 : 110072674 Widget\n    110072675 : 110072675 Sprocket\n    110072684 : 110072684 Gear\n\n    List of items\n    -------------\n    110072674 Widget\n    110072684 Gear\n    110072675 Sprocket\n\nTry to insert the item again:\nError: The item already belongs to a collection.\n\nChange the Key property of the item:\n\nDUMP:\n    Dictionary entries\n    ------------------\n    110072674 : 110072674 Widget\n    110072675 : 110072675 Sprocket\n    100000072 : 100000072 Gear\n\n    List of items\n    -------------\n    110072674 Widget\n    100000072 Gear\n    110072675 Sprocket\n\nTry to set the Key property to an existing key:\nError: An item with the same key has already been added.\n\nDUMP:\n    Dictionary entries\n    ------------------\n    110072674 : 110072674 Widget\n    110072675 : 110072675 Sprocket\n    100000072 : 100000072 Gear\n\n    List of items\n    -------------\n    110072674 Widget\n    100000072 Gear\n    110072675 Sprocket\n */\n</code></pre><pre><code class=\"lang-vb\" name=\"KeyedCollectionMutable#1\">Imports System\nImports System.Collections.Generic\nImports System.Collections.ObjectModel\n\n&#39; This class demonstrates one way to use the ChangeItemKey\n&#39; method to store objects with keys that can be changed. The \n&#39; ChangeItemKey method is used to keep the internal lookup\n&#39; Dictionary in sync with the keys of the stored objects. \n&#39;\n&#39; MutableKeys stores MutableKey objects, which have an Integer\n&#39; Key property that can be set. Therefore, MutableKeys inherits\n&#39; KeyedCollection(Of Integer, MutableKey).\n&#39;\nPublic Class MutableKeys\n    Inherits KeyedCollection(Of Integer, MutableKey)\n\n    &#39; This parameterless constructor delegates to the base class \n    &#39; constructor that specifies a dictionary threshold. A\n    &#39; threshold of 0 means the internal Dictionary is created\n    &#39; the first time an object is added.\n    &#39;\n    Public Sub New()\n        MyBase.New(Nothing, 0)\n    End Sub\n    \n    Protected Overrides Function GetKeyForItem( _\n        ByVal item As MutableKey) As Integer\n\n        &#39; The key is MutableKey.Key.\n        Return item.Key   \n    End Function\n\n    Protected Overrides Sub InsertItem( _\n        ByVal index As Integer, ByVal newItem As MutableKey)\n\n        If newItem.Collection IsNot Nothing Then _\n            Throw New ArgumentException(&quot;The item already belongs to a collection.&quot;)\n\n        MyBase.InsertItem(index, newItem)\n        newItem.Collection = Me\n    End Sub\n\n    Protected Overrides Sub SetItem(ByVal index As Integer, _\n        ByVal newItem As MutableKey)\n\n        Dim replaced As MutableKey = Items(index)\n\n        If newItem.Collection IsNot Nothing Then _\n            Throw New ArgumentException(&quot;The item already belongs to a collection.&quot;)\n\n        MyBase.SetItem(index, newItem)\n        newItem.Collection = Me\n        replaced.Collection = Nothing\n    End Sub\n\n    Protected Overrides Sub RemoveItem(ByVal index As Integer)\n        Dim removedItem As MutableKey = Items(index)\n\n        MyBase.RemoveItem(index)\n        removedItem.Collection = Nothing\n    End Sub\n\n    Protected Overrides Sub ClearItems()\n        For Each mk As MutableKey In Items\n            mk.Collection = Nothing\n        Next\n        \n        MyBase.ClearItems()\n    End Sub\n\n    Friend Sub ChangeKey(ByVal item As MutableKey, _\n        ByVal newKey As Integer)\n\n        MyBase.ChangeItemKey(item, newKey)\n    End Sub\n    \n    Public Sub Dump()\n        Console.WriteLine(vbLf &amp; &quot;DUMP:&quot;)\n        If Dictionary Is Nothing Then\n            Console.WriteLine(&quot;    The dictionary has not been created.&quot;)\n        Else\n            Console.WriteLine(&quot;    Dictionary entries&quot;)\n            Console.WriteLine(&quot;    ------------------&quot;)\n\n            For Each kvp As KeyValuePair(Of Integer, MutableKey) In Dictionary\n                Console.WriteLine(&quot;    {0} : {1}&quot;, kvp.Key, kvp.Value)\n            Next\n        End If\n\n        Console.WriteLine(vbLf &amp; &quot;    List of items&quot;)\n        Console.WriteLine(&quot;    -------------&quot;)\n\n        For Each mk As MutableKey In Items\n            Console.WriteLine(&quot;    {0}&quot;, mk)\n        Next\n    End Sub\n\nEnd Class\n\nPublic Class Demo\n    \n    Public Shared Sub Main() \n\n        Dim mkeys As New MutableKeys()\n\n        &#39; The Add method is inherited from Collection.\n        &#39;\n        mkeys.Add(New MutableKey(110072674, &quot;Widget&quot;))\n        mkeys.Add(New MutableKey(110072675, &quot;Sprocket&quot;))\n\n        mkeys.Dump() \n    \n        Console.WriteLine(vbLf &amp; &quot;Create and insert a new item:&quot;)\n        Dim test As New MutableKey(110072684, &quot;Gear&quot;)\n        mkeys.Insert(1, test)\n\n        mkeys.Dump()\n\n        Try\n            Console.WriteLine(vbLf &amp; &quot;Try to insert the item again:&quot;)\n            mkeys.Insert(1, test)\n        Catch ex As ArgumentException\n            Console.WriteLine(&quot;Error: {0}&quot;, ex.Message)\n        End Try\n\n        Console.WriteLine(vbLf &amp; &quot;Change the Key property of the item:&quot;)\n        test.Key = 100000072\n\n        mkeys.Dump()\n\n        Try\n            Console.WriteLine(vbLf &amp; &quot;Try to set the Key property to an existing key:&quot;)\n            test.Key = 110072674\n        Catch ex As ArgumentException\n            Console.WriteLine(&quot;Error: {0}&quot;, ex.Message)\n        End Try\n\n        mkeys.Dump()\n\n    End Sub\n    \n    Private Shared Sub Display(ByVal order As MutableKeys) \n        Console.WriteLine()\n        For Each item As MutableKey In  order\n            Console.WriteLine(item)\n        Next item\n    End Sub\nEnd Class\n\n&#39; This class has a key that can be changed.\n&#39; \nPublic Class MutableKey\n\n    Public Sub New(ByVal newKey As Integer, ByVal newValue As String)\n        _key = newKey\n        Value = newValue\n    End Sub &#39;New\n    \n    Public Value As String\n    Friend Collection As MutableKeys\n    \n    Private _key As Integer\n    Public Property Key As Integer \n        Get\n            Return _key\n        End Get\n        Set\n            If Collection IsNot Nothing Then\n                Collection.ChangeKey(Me, value)\n            End If\n\n            _key = value\n        End Set\n    End Property\n\n    Public Overrides Function ToString() As String \n        Return String.Format(&quot;{0,9} {1}&quot;, _key, Value)\n    End Function\n        \nEnd Class\n\n&#39; This code example produces the following output:\n&#39;\n&#39;DUMP:\n&#39;    Dictionary entries\n&#39;    ------------------\n&#39;    110072674 : 110072674 Widget\n&#39;    110072675 : 110072675 Sprocket\n&#39;\n&#39;    List of items\n&#39;    -------------\n&#39;    110072674 Widget\n&#39;    110072675 Sprocket\n&#39;\n&#39;Create and insert a new item:\n&#39;\n&#39;DUMP:\n&#39;    Dictionary entries\n&#39;    ------------------\n&#39;    110072674 : 110072674 Widget\n&#39;    110072675 : 110072675 Sprocket\n&#39;    110072684 : 110072684 Gear\n&#39;\n&#39;    List of items\n&#39;    -------------\n&#39;    110072674 Widget\n&#39;    110072684 Gear\n&#39;    110072675 Sprocket\n&#39;\n&#39;Try to insert the item again:\n&#39;Error: The item already belongs to a collection.\n&#39;\n&#39;Change the Key property of the item:\n&#39;\n&#39;DUMP:\n&#39;    Dictionary entries\n&#39;    ------------------\n&#39;    110072674 : 110072674 Widget\n&#39;    110072675 : 110072675 Sprocket\n&#39;    100000072 : 100000072 Gear\n&#39;\n&#39;    List of items\n&#39;    -------------\n&#39;    110072674 Widget\n&#39;    100000072 Gear\n&#39;    110072675 Sprocket\n&#39;\n&#39;Try to set the Key property to an existing key:\n&#39;Error: An item with the same key has already been added.\n&#39;\n&#39;DUMP:\n&#39;    Dictionary entries\n&#39;    ------------------\n&#39;    110072674 : 110072674 Widget\n&#39;    110072675 : 110072675 Sprocket\n&#39;    100000072 : 100000072 Gear\n&#39;\n&#39;    List of items\n&#39;    -------------\n&#39;    110072674 Widget\n&#39;    100000072 Gear\n&#39;    110072675 Sprocket\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n","outputRootRelativePath":"./","pageMetadata":"<meta name=\"breadcrumb_path\" content=\"breadcrumb/toc1.json\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"fulldocset\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.fulldocset\">\r\n<meta name=\"ref_skeleton_gitcommit\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Collections.ObjectModel.KeyedCollection-2.yml\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Collections.ObjectModel.KeyedCollection-2.yml\">\r\n<meta name=\"APIName\" content=\"System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;\">\r\n<meta name=\"APIName\" content=\"System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;..ctor\">\r\n<meta name=\"APIName\" content=\"System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;.ChangeItemKey\">\r\n<meta name=\"APIName\" content=\"System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;.ClearItems\">\r\n<meta name=\"APIName\" content=\"System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;.Comparer\">\r\n<meta name=\"APIName\" content=\"System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;.Contains\">\r\n<meta name=\"APIName\" content=\"System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;.Dictionary\">\r\n<meta name=\"APIName\" content=\"System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;.GetKeyForItem\">\r\n<meta name=\"APIName\" content=\"System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;.InsertItem\">\r\n<meta name=\"APIName\" content=\"System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;.Item\">\r\n<meta name=\"APIName\" content=\"System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;.Remove\">\r\n<meta name=\"APIName\" content=\"System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;.RemoveItem\">\r\n<meta name=\"APIName\" content=\"System.Collections.ObjectModel.KeyedCollection&lt;TKey,TItem&gt;.SetItem\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-01 01:37 AM\">\r\n<meta name=\"document_id\" content=\"2f4a577f-9661-42ad-6474-679a348fdf47\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Provides the abstract base class for a collection whose keys are embedded in the values.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/System.Collections.ObjectModel/toc1.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Collections.ObjectModel.KeyedCollection`2\">\r\n","rawMetadata":{"breadcrumb_path":"breadcrumb/toc.json","search.ms_sitename":"Docs","search.ms_docsetname":"fulldocset","version":null,"_op_canonicalUrlPrefix":"https://ppe.docs.microsoft.com/en-us/fulldotnet/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":true,"depot_name":"MSDN.fulldocset","_op_gitRefSkeletonCommitHistory":[{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"use plugin in master","commit_sha":"501959ac03e19ac52a27aa4c6bbeb980f8b11c8c","commit_date":"2017-03-01 09:31:20 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"switch from platform to version","commit_sha":"78cdacb5ca782478af490a6b30c3a2cb2b6b873e","commit_date":"2017-02-28 15:09:51 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"update platforms","commit_sha":"39ad5a8919a59afc93a79ac4bd8e07c3b471b37a","commit_date":"2017-02-28 10:38:59 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"checkin yml","commit_sha":"da161b792852497df7140d7768cee2eccd9cb43f","commit_date":"2017-02-28 09:36:15 +0800"}],"ref_skeleton_gitcommit":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Collections.ObjectModel.KeyedCollection-2.yml","original_ref_skeleton_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Collections.ObjectModel.KeyedCollection-2.yml","open_to_public_contributors":true,"api_name":["System.Collections.ObjectModel.KeyedCollection<TKey,TItem>","System.Collections.ObjectModel.KeyedCollection<TKey,TItem>..ctor","System.Collections.ObjectModel.KeyedCollection<TKey,TItem>.ChangeItemKey","System.Collections.ObjectModel.KeyedCollection<TKey,TItem>.ClearItems","System.Collections.ObjectModel.KeyedCollection<TKey,TItem>.Comparer","System.Collections.ObjectModel.KeyedCollection<TKey,TItem>.Contains","System.Collections.ObjectModel.KeyedCollection<TKey,TItem>.Dictionary","System.Collections.ObjectModel.KeyedCollection<TKey,TItem>.GetKeyForItem","System.Collections.ObjectModel.KeyedCollection<TKey,TItem>.InsertItem","System.Collections.ObjectModel.KeyedCollection<TKey,TItem>.Item","System.Collections.ObjectModel.KeyedCollection<TKey,TItem>.Remove","System.Collections.ObjectModel.KeyedCollection<TKey,TItem>.RemoveItem","System.Collections.ObjectModel.KeyedCollection<TKey,TItem>.SetItem"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Collections.ObjectModel.KeyedCollection`2","System::Collections::ObjectModel::KeyedCollection`2","System.Collections.ObjectModel.KeyedCollection`2.#ctor","System::Collections::ObjectModel::KeyedCollection`2::#ctor","System.Collections.ObjectModel.KeyedCollection`2.ChangeItemKey","System::Collections::ObjectModel::KeyedCollection`2::ChangeItemKey","System.Collections.ObjectModel.KeyedCollection`2.ClearItems","System::Collections::ObjectModel::KeyedCollection`2::ClearItems","System.Collections.ObjectModel.KeyedCollection`2.Comparer","System::Collections::ObjectModel::KeyedCollection`2::Comparer","System.Collections.ObjectModel.KeyedCollection`2.Contains","System::Collections::ObjectModel::KeyedCollection`2::Contains","System.Collections.ObjectModel.KeyedCollection`2.Dictionary","System::Collections::ObjectModel::KeyedCollection`2::Dictionary","System.Collections.ObjectModel.KeyedCollection`2.GetKeyForItem","System::Collections::ObjectModel::KeyedCollection`2::GetKeyForItem","System.Collections.ObjectModel.KeyedCollection`2.InsertItem","System::Collections::ObjectModel::KeyedCollection`2::InsertItem","System.Collections.ObjectModel.KeyedCollection`2.Item","System::Collections::ObjectModel::KeyedCollection`2::Item","System.Collections.ObjectModel.KeyedCollection`2.Remove","System::Collections::ObjectModel::KeyedCollection`2::Remove","System.Collections.ObjectModel.KeyedCollection`2.RemoveItem","System::Collections::ObjectModel::KeyedCollection`2::RemoveItem","System.Collections.ObjectModel.KeyedCollection`2.SetItem","System::Collections::ObjectModel::KeyedCollection`2::SetItem"],"dev_langs":["csharp"],"updated_at":"2017-03-01 01:37 AM","document_id":"2f4a577f-9661-42ad-6474-679a348fdf47","content_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/xml/System.Collections.ObjectModel/KeyedCollection`2.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"KeyedCollection<TKey,TItem> class | Microsoft Docs","_op_ogTitle":"KeyedCollection<TKey,TItem> class","description":"Provides the abstract base class for a collection whose keys are embedded in the values.\n","toc_asset_id":"_splitted/System.Collections.ObjectModel/toc.json","toc_rel":"_splitted/System.Collections.ObjectModel/toc.json","source_url":"","ms.assetid":"System.Collections.ObjectModel.KeyedCollection`2","canonical_url":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.collections.objectmodel.keyedcollection-2","_op_canonicalUrl":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.collections.objectmodel.keyedcollection-2","fileRelativePath":"System.Collections.ObjectModel.KeyedCollection-2.html"},"themesRelativePathToOutputRoot":"_themes/"}