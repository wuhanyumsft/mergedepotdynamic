{"content":"\r\n<div style=\"display:none\">\r\n\t\r\n</div>\r\n\r\n  \r\n  <h1>\r\n    <span class=\"lang-csharp\">TcpListener</span>\r\n    \t\t\t\tClass\r\n  </h1>\r\n  \r\n  <h2 class=\"hiddenAnchor\">Definition</h2>\r\n  \r\n  <div class=\"metadata\">\r\n  \r\n  \r\n  </div>\r\n  \r\n  <div class=\"summaryHolder\">\r\n  \t<div class=\"summary\">\r\n  \t\t<p>Listens for connections from TCP network clients.</p>\n\r\n  \t</div>\r\n  </div><nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n    <h3>In this Article</h3>\r\n  </nav>\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\">public class TcpListener</code></pre>\r\n  \r\n  \r\n  \r\n  \r\n  \t<dl class=\"attributeList stack\">\r\n  \t\t<dt>Inheritance</dt><dd>\r\n  \t\t<div class=\"pdlHolder\">\r\n  \t\t\t<div class=\"pdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a></span></div>\r\n  \t\t\t<span class=\"lang-csharp\">TcpListener</span>\r\n  \t\t</div>\r\n  \t\t</dd>\r\n  \t</dl>\r\n  \r\n  \r\n  \r\n  \r\n  \t<h3 class=\"accented\">Inherited Members</h3>\r\n  \t<h4 class=\"accented\"></h4>\r\n  \t<div class=\"cdlHolder\">\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object,Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object,Object)</a></span></div>\r\n  \t\t\t<div class=\"cdl\"><span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a></span></div>\r\n  \t</div>\r\n  \r\n  \t<h2 class=\"accented\">Remarks</h2>\r\n  \t<p>The TcpListener class provides simple methods that listen for and accept incoming connection requests in blocking synchronous mode. You can use either a <a class=\"xref\" href=\"system.net.sockets.tcpclient\" data-linktype=\"relative-path\">TcpClient</a> or a <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> to connect with a TcpListener. Create a TcpListener using an <a class=\"xref\" href=\"system.net.ipendpoint\" data-linktype=\"relative-path\">IPEndPoint</a>, a Local IP address and port number, or just a port number. Specify <a class=\"xref\" href=\"system.net.ipaddress#System_Net_IPAddress_Any\" data-linktype=\"relative-path\">Any</a> for the local IP address and 0 for the local port number if you want the underlying service provider to assign those values for you. If you choose to do this, you can use the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_LocalEndpoint_\" data-linktype=\"relative-path\">LocalEndpoint</a> property to identify the assigned information, after the socket has connected.  </p>\n<p> Use the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_Start_\" data-linktype=\"relative-path\">Start</a> method to begin listening for incoming connection requests. <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_Start_\" data-linktype=\"relative-path\">Start</a> will queue incoming connections until you either call the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_Stop_\" data-linktype=\"relative-path\">Stop</a> method or it has queued <a class=\"xref\" href=\"system.net.sockets.socketoptionname\" data-linktype=\"relative-path\">SocketOptionName</a>. Use either <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptSocket_\" data-linktype=\"relative-path\">AcceptSocket</a> or <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptTcpClient_\" data-linktype=\"relative-path\">AcceptTcpClient</a> to pull a connection from the incoming connection request queue. These two methods will block. If you want to avoid blocking, you can use the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_Pending_\" data-linktype=\"relative-path\">Pending</a> method first to determine if connection requests are available in the queue.  </p>\n<p> Call the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_Stop_\" data-linktype=\"relative-path\">Stop</a> method to close the TcpListener.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_Stop_\" data-linktype=\"relative-path\">Stop</a> method does not close any accepted connections. You are responsible for closing these separately.</p>\n</div>\n\r\n  \r\n  \r\n  \t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Constructors\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Net_Sockets_TcpListener__ctor_System_Int32_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">TcpListener(Int32)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Initializes a new instance of the <a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a> class that listens on the specified port.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public TcpListener (int port);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>port</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The port on which to listen for incoming connection attempts.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>port</code> is not between <a class=\"xref\" href=\"system.net.ipendpoint#System_Net_IPEndPoint_MinPort\" data-linktype=\"relative-path\">MinPort</a> and <a class=\"xref\" href=\"system.net.ipendpoint#System_Net_IPEndPoint_MaxPort\" data-linktype=\"relative-path\">MaxPort</a>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This constructor is obsolete. Use the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener__ctor_System_Net_IPAddress_System_Int32_\" data-linktype=\"relative-path\">System.Net.Sockets.TcpListener.TcpListener(IPAddress,Int32)</a> or <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener__ctor_System_Net_IPEndPoint_\" data-linktype=\"relative-path\">System.Net.Sockets.TcpListener.TcpListener(IPEndPoint)</a> constructors.  </p>\n<p> This constructor allows you to specify the port number on which to listen for incoming connection attempts. With this constructor, the underlying service provider assigns the most appropriate network address. If you do not care which local port is used, you can specify 0 for the port number. In this case, the service provider will assign an available port number between 1024 and 5000. If you use this approach, you can discover what local network address and port number has been assigned by using the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_LocalEndpoint_\" data-linktype=\"relative-path\">LocalEndpoint</a> property.  </p>\n<p> Call the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_Start_\" data-linktype=\"relative-path\">Start</a> method to begin listening for incoming connection attempts.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Net_Sockets_TcpListener__ctor_System_Net_IPEndPoint_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">TcpListener(IPEndPoint)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Initializes a new instance of the <a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a> class with the specified local endpoint.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public TcpListener (System.Net.IPEndPoint localEP);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>localEP</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.net.ipendpoint\" data-linktype=\"relative-path\">IPEndPoint</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An <a class=\"xref\" href=\"system.net.ipendpoint\" data-linktype=\"relative-path\">IPEndPoint</a> that represents the local endpoint to which to bind the listener <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>localEP</code> is <code>null</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This constructor allows you to specify the local IP address and port number on which to listen for incoming connection attempts. Before using this constructor, you must create an <a class=\"xref\" href=\"system.net.ipendpoint\" data-linktype=\"relative-path\">IPEndPoint</a> using the desired local IP address and port number. Pass this <a class=\"xref\" href=\"system.net.ipendpoint\" data-linktype=\"relative-path\">IPEndPoint</a> to the constructor as the <code>localEP</code> parameter.  </p>\n<p> If you do not care which local address is assigned, you can create an <a class=\"xref\" href=\"system.net.ipendpoint\" data-linktype=\"relative-path\">IPEndPoint</a> using <a class=\"xref\" href=\"system.net.ipaddress#System_Net_IPAddress_Any\" data-linktype=\"relative-path\">System.Net.IPAddress.Any</a> as the address parameter, and the underlying service provider will assign the most appropriate network address. This might help simplify your application if you have multiple network interfaces. If you do not care which local port is used, you can create an <a class=\"xref\" href=\"system.net.ipendpoint\" data-linktype=\"relative-path\">IPEndPoint</a> using 0 for the port number. In this case, the service provider will assign an available port number between 1024 and 5000. If you use this approach, you can discover what local network address and port number has been assigned by using the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_LocalEndpoint_\" data-linktype=\"relative-path\">LocalEndpoint</a> property.  </p>\n<p> Call the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_Start_\" data-linktype=\"relative-path\">Start</a> method to begin listening for incoming connection attempts.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> This member outputs trace information when you enable network tracing in your application. For more information, see <a href=\"../Topic/Network%20Tracing%20in%20the%20.NET%20Framework.md\" data-linktype=\"relative-path\">Network Tracing in the .NET Framework</a>.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Net_Sockets_TcpListener__ctor_System_Net_IPAddress_System_Int32_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">TcpListener(IPAddress,Int32)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Initializes a new instance of the <a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a> class that listens for incoming connection attempts on the specified local IP address and port number.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public TcpListener (System.Net.IPAddress localaddr, int port);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>localaddr</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.net.ipaddress\" data-linktype=\"relative-path\">IPAddress</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An <a class=\"xref\" href=\"system.net.ipaddress\" data-linktype=\"relative-path\">IPAddress</a> that represents the local IP address.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>port</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The port on which to listen for incoming connection attempts.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>localaddr</code> is <code>null</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p><code>port</code> is not between <a class=\"xref\" href=\"system.net.ipendpoint#System_Net_IPEndPoint_MinPort\" data-linktype=\"relative-path\">MinPort</a> and <a class=\"xref\" href=\"system.net.ipendpoint#System_Net_IPEndPoint_MaxPort\" data-linktype=\"relative-path\">MaxPort</a>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This constructor allows you to specify the local IP address and port number on which to listen for incoming connection attempts. Before calling this constructor you must first create an <a class=\"xref\" href=\"system.net.ipaddress\" data-linktype=\"relative-path\">IPAddress</a> using the desired local address. Pass this <a class=\"xref\" href=\"system.net.ipaddress\" data-linktype=\"relative-path\">IPAddress</a> to the constructor as the <code>localaddr</code> parameter. If you do not care which local address is assigned, specify <a class=\"xref\" href=\"system.net.ipaddress#System_Net_IPAddress_Any\" data-linktype=\"relative-path\">System.Net.IPAddress.Any</a> for the <code>localaddr</code> parameter, and the underlying service provider will assign the most appropriate network address. This might help simplify your application if you have multiple network interfaces. If you do not care which local port is used, you can specify 0 for the port number. In this case, the service provider will assign an available port number between 1024 and 5000. If you use this approach, you can discover what local network address and port number has been assigned by using the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_LocalEndpoint_\" data-linktype=\"relative-path\">LocalEndpoint</a> property.  </p>\n<p> Call the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_Start_\" data-linktype=\"relative-path\">Start</a> method to begin listening for incoming connection attempts.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> This member outputs trace information when you enable network tracing in your application. For more information, see <a href=\"../Topic/Network%20Tracing%20in%20the%20.NET%20Framework.md\" data-linktype=\"relative-path\">Network Tracing in the .NET Framework</a>.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t  \r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Properties\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Net_Sockets_TcpListener_Active\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Active</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets a value that indicates whether <a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a> is actively listening for client connections.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">protected bool Active { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> if <a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a> is actively listening; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>Classes deriving from <a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a> can use this property to determine if the <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> is currently listening for incoming connection attempts. The <a class=\"xref\" href=\"system.net.sockets.tcpclient#System_Net_Sockets_TcpClient_Active_\" data-linktype=\"relative-path\">Active</a> property can be used to avoid redundant <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_Start_\" data-linktype=\"relative-path\">Start</a> attempts.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Net_Sockets_TcpListener_ExclusiveAddressUse\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">ExclusiveAddressUse</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets or sets a <a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a> value that specifies whether the <a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a> allows only one underlying socket to listen to a specific port.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public bool ExclusiveAddressUse { get; set; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> if the <a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a> allows only one <a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a> to listen to a specific port; otherwise, <code>false</code>. . The default is <code>true</code> for Windows Server 2003 and Windows XP Service Pack 2 and later, and <code>false</code> for all other versions.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a> has been started. Call the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_Stop\" data-linktype=\"relative-path\">Stop()</a> method and then set the <span class=\"xref\">stem.Net.Sockets.Socket.ExclusiveAddressUse*</span> property.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.net.sockets.socketexception\" data-linktype=\"relative-path\">SocketException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>An error occurred when attempting to access the underlying socket.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.objectdisposedexception\" data-linktype=\"relative-path\">ObjectDisposedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The underlying <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> has been closed.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>By default, multiple listeners can listen to a specific port. However, only one of the listeners can perform operations on the network traffic sent to the port. If more than one listener attempts to bind to a particular port, then the one with the more specific IP address handles the network traffic sent to that port. You can use the <a class=\"xref\" href=\"system.net.sockets.socket#System_Net_Sockets_Socket_ExclusiveAddressUse_\" data-linktype=\"relative-path\">ExclusiveAddressUse</a> property to prevent multiple listeners from listening to a specific port.  </p>\n<p> Set this property before calling <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_Start_\" data-linktype=\"relative-path\">Start</a>, or call the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_Stop_\" data-linktype=\"relative-path\">Stop</a> method and then set this property.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Net_Sockets_TcpListener_LocalEndpoint\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">LocalEndpoint</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets the underlying <a class=\"xref\" href=\"system.net.endpoint\" data-linktype=\"relative-path\">EndPoint</a> of the current <a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Net.EndPoint LocalEndpoint { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.net.endpoint\" data-linktype=\"relative-path\">EndPoint</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The <a class=\"xref\" href=\"system.net.endpoint\" data-linktype=\"relative-path\">EndPoint</a> to which the <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> is bound.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>You can use the LocalEndpoint property to identify the local network interface and port number being used to listen for incoming client connection requests, after a socket connection has been made. You must first cast this <a class=\"xref\" href=\"system.net.endpoint\" data-linktype=\"relative-path\">EndPoint</a> to an <a class=\"xref\" href=\"system.net.ipendpoint\" data-linktype=\"relative-path\">IPEndPoint</a>. You can then call the <a class=\"xref\" href=\"system.net.ipendpoint#System_Net_IPEndPoint_Address_\" data-linktype=\"relative-path\">Address</a> property to retrieve the local IP address, and the <a class=\"xref\" href=\"system.net.ipendpoint#System_Net_IPEndPoint_Port_\" data-linktype=\"relative-path\">Port</a> property to retrieve the local port number.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Net_Sockets_TcpListener_Server\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Server</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Gets the underlying network <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a>.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Net.Sockets.Socket Server { get; }</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Value</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The underlying <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p><a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a> creates a <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> to listen for incoming client connection requests. Classes deriving from <a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a> can use this property to get this <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a>. Use the underlying <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> returned by the Server property if you require access beyond that which <a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a> provides.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The Server property only returns the <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> used to listen for incoming client connection requests. Use the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptSocket_\" data-linktype=\"relative-path\">AcceptSocket</a> method to accept a pending connection request and obtain a <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> for sending and receiving data. You can also use the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptTcpClient_\" data-linktype=\"relative-path\">AcceptTcpClient</a> method to accept a pending connection request and obtain a <a class=\"xref\" href=\"system.net.sockets.tcpclient\" data-linktype=\"relative-path\">TcpClient</a> for sending and receiving data.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t  \r\n  \t\t</section>\t\t<section>\r\n  \t\t\t<h2 class=\"accented \">Methods\r\n  \t\t</h2>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Net_Sockets_TcpListener_AcceptSocket\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">AcceptSocket()</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Accepts a pending connection request.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Net.Sockets.Socket AcceptSocket ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> used to send and receive data.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The listener has not been started with a call to <span class=\"xref\">stem.Net.Sockets.TcpListener.Start*</span>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>AcceptSocket is a blocking method that returns a <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> that you can use to send and receive data. If you want to avoid blocking, use the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_Pending_\" data-linktype=\"relative-path\">Pending</a> method to determine if connection requests are available in the incoming connection queue.  </p>\n<p> The <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> returned is initialized with the IP address and port number of the remote host. You can use any of the <a class=\"xref\" href=\"system.net.sockets.socket#System_Net_Sockets_Socket_Send_\" data-linktype=\"relative-path\">Send</a> and <a class=\"xref\" href=\"system.net.sockets.socket#System_Net_Sockets_Socket_Receive_\" data-linktype=\"relative-path\">Receive</a> methods available in the <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> class to communicate with the remote host. When you are finished using the <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a>, be sure to call its <a class=\"xref\" href=\"system.net.sockets.socket#System_Net_Sockets_Socket_Close_\" data-linktype=\"relative-path\">Close</a> method. If your application is relatively simple, consider using the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptTcpClient_\" data-linktype=\"relative-path\">AcceptTcpClient</a> method rather than the AcceptSocket method. <a class=\"xref\" href=\"system.net.sockets.tcpclient\" data-linktype=\"relative-path\">TcpClient</a> provides you with simple methods for sending and receiving data over a network in blocking synchronous mode.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> This member outputs trace information when you enable network tracing in your application. For more information, see <a href=\"../Topic/Network%20Tracing%20in%20the%20.NET%20Framework.md\" data-linktype=\"relative-path\">Network Tracing in the .NET Framework</a>.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Net_Sockets_TcpListener_AcceptSocketAsync\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">AcceptSocketAsync()</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Accepts a pending connection request as an asynchronous operation.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Threading.Tasks.Task&lt;System.Net.Sockets.Socket&gt; AcceptSocketAsync ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.tasks.task-1\" data-linktype=\"relative-path\">Task</a>&lt;<a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a>&gt;</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>Returns <span class=\"xref\">stem.Threading.Tasks.Task`1</span>  </p>\n<p> The task object representing the asynchronous operation. The <span class=\"xref\">stem.Threading.Tasks.Task`1.Result*</span> property on the task object returns a <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> used to send and receive data.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The listener has not been started with a call to <span class=\"xref\">stem.Net.Sockets.TcpListener.Start*</span>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This operation will not block. The returned <a class=\"xref\" href=\"system.threading.tasks.task-1\" data-linktype=\"relative-path\">Task&lt;TResult&gt;</a> object will complete after the socket connection has been accepted.  </p>\n<p> The <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> returned in <a class=\"xref\" href=\"system.threading.tasks.task-1\" data-linktype=\"relative-path\">Task&lt;TResult&gt;</a> is initialized with the IP address and port number of the remote host. You can use any of the <a class=\"xref\" href=\"system.net.sockets.socket#System_Net_Sockets_Socket_Send_\" data-linktype=\"relative-path\">Send</a> and <a class=\"xref\" href=\"system.net.sockets.socket#System_Net_Sockets_Socket_Receive_\" data-linktype=\"relative-path\">Receive</a> methods available in the <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> class to communicate with the remote host. When you are finished using the <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a>, be sure to call its <a class=\"xref\" href=\"system.net.sockets.socket#System_Net_Sockets_Socket_Close_\" data-linktype=\"relative-path\">Close</a> method. If your application is relatively simple, consider using the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptTcpClient_\" data-linktype=\"relative-path\">AcceptTcpClient</a> method rather than the AcceptSocketAsync method. <a class=\"xref\" href=\"system.net.sockets.tcpclient\" data-linktype=\"relative-path\">TcpClient</a> provides you with simple methods for sending and receiving data over a network in blocking synchronous mode.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> This member outputs trace information when you enable network tracing in your application. For more information, see <a href=\"../Topic/Network%20Tracing%20in%20the%20.NET%20Framework.md\" data-linktype=\"relative-path\">Network Tracing in the .NET Framework</a>.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Net_Sockets_TcpListener_AcceptTcpClient\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">AcceptTcpClient()</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Accepts a pending connection request.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Net.Sockets.TcpClient AcceptTcpClient ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.net.sockets.tcpclient\" data-linktype=\"relative-path\">TcpClient</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <a class=\"xref\" href=\"system.net.sockets.tcpclient\" data-linktype=\"relative-path\">TcpClient</a> used to send and receive data.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The listener has not been started with a call to <span class=\"xref\">stem.Net.Sockets.TcpListener.Start*</span>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.net.sockets.socketexception\" data-linktype=\"relative-path\">SocketException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>Use the <span class=\"xref\">stem.Net.Sockets.SocketException.ErrorCode*</span> property to obtain the specific error code. When you have obtained this code, you can refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>AcceptTcpClient is a blocking method that returns a <a class=\"xref\" href=\"system.net.sockets.tcpclient\" data-linktype=\"relative-path\">TcpClient</a> that you can use to send and receive data. Use the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_Pending_\" data-linktype=\"relative-path\">Pending</a> method to determine if connection requests are available in the incoming connection queue if you want to avoid blocking.  </p>\n<p> Use the <a class=\"xref\" href=\"system.net.sockets.tcpclient#System_Net_Sockets_TcpClient_GetStream_\" data-linktype=\"relative-path\">GetStream</a> method to obtain the underlying <a class=\"xref\" href=\"system.net.sockets.networkstream\" data-linktype=\"relative-path\">NetworkStream</a> of the returned <a class=\"xref\" href=\"system.net.sockets.tcpclient\" data-linktype=\"relative-path\">TcpClient</a>. The <a class=\"xref\" href=\"system.net.sockets.networkstream\" data-linktype=\"relative-path\">NetworkStream</a> will provide you with methods for sending and receiving with the remote host. When you are through with the <a class=\"xref\" href=\"system.net.sockets.tcpclient\" data-linktype=\"relative-path\">TcpClient</a>, be sure to call its <a class=\"xref\" href=\"system.net.sockets.tcpclient#System_Net_Sockets_TcpClient_Close_\" data-linktype=\"relative-path\">Close</a> method. If you want greater flexibility than a <a class=\"xref\" href=\"system.net.sockets.tcpclient\" data-linktype=\"relative-path\">TcpClient</a> offers, consider using <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptSocket_\" data-linktype=\"relative-path\">AcceptSocket</a>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> This member outputs trace information when you enable network tracing in your application. For more information, see <a href=\"../Topic/Network%20Tracing%20in%20the%20.NET%20Framework.md\" data-linktype=\"relative-path\">Network Tracing in the .NET Framework</a>.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Net_Sockets_TcpListener_AcceptTcpClientAsync\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">AcceptTcpClientAsync()</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Accepts a pending connection request as an asynchronous operation.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Threading.Tasks.Task&lt;System.Net.Sockets.TcpClient&gt; AcceptTcpClientAsync ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.tasks.task-1\" data-linktype=\"relative-path\">Task</a>&lt;<a class=\"xref\" href=\"system.net.sockets.tcpclient\" data-linktype=\"relative-path\">TcpClient</a>&gt;</span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>Returns <span class=\"xref\">stem.Threading.Tasks.Task`1</span>  </p>\n<p> The task object representing the asynchronous operation. The <span class=\"xref\">stem.Threading.Tasks.Task`1.Result*</span> property on the task object returns a <a class=\"xref\" href=\"system.net.sockets.tcpclient\" data-linktype=\"relative-path\">TcpClient</a> used to send and receive data.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The listener has not been started with a call to <span class=\"xref\">stem.Net.Sockets.TcpListener.Start*</span>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.net.sockets.socketexception\" data-linktype=\"relative-path\">SocketException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>Use the <span class=\"xref\">stem.Net.Sockets.SocketException.ErrorCode*</span> property to obtain the specific error code. When you have obtained this code, you can refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This operation will not block. The returned <a class=\"xref\" href=\"system.threading.tasks.task-1\" data-linktype=\"relative-path\">Task&lt;TResult&gt;</a> object will complete after the TCP connection has been accepted.  </p>\n<p> Use the <a class=\"xref\" href=\"system.net.sockets.tcpclient#System_Net_Sockets_TcpClient_GetStream_\" data-linktype=\"relative-path\">GetStream</a> method to obtain the underlying <a class=\"xref\" href=\"system.net.sockets.networkstream\" data-linktype=\"relative-path\">NetworkStream</a> of the returned <a class=\"xref\" href=\"system.net.sockets.tcpclient\" data-linktype=\"relative-path\">TcpClient</a> in the <a class=\"xref\" href=\"system.threading.tasks.task-1\" data-linktype=\"relative-path\">Task&lt;TResult&gt;</a>. The <a class=\"xref\" href=\"system.net.sockets.networkstream\" data-linktype=\"relative-path\">NetworkStream</a> will provide you with methods for sending and receiving with the remote host. When you are through with the <a class=\"xref\" href=\"system.net.sockets.tcpclient\" data-linktype=\"relative-path\">TcpClient</a>, be sure to call its <a class=\"xref\" href=\"system.net.sockets.tcpclient#System_Net_Sockets_TcpClient_Close_\" data-linktype=\"relative-path\">Close</a> method. If you want greater flexibility than a <a class=\"xref\" href=\"system.net.sockets.tcpclient\" data-linktype=\"relative-path\">TcpClient</a> offers, consider using <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptSocket_\" data-linktype=\"relative-path\">AcceptSocket</a> or <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptSocketAsync_\" data-linktype=\"relative-path\">AcceptSocketAsync</a>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> This member outputs trace information when you enable network tracing in your application. For more information, see <a href=\"../Topic/Network%20Tracing%20in%20the%20.NET%20Framework.md\" data-linktype=\"relative-path\">Network Tracing in the .NET Framework</a>.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Net_Sockets_TcpListener_AllowNatTraversal_System_Boolean_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">AllowNatTraversal(Boolean)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Enables or disables Network Address Translation (NAT) traversal on a <a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a> instance.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void AllowNatTraversal (bool allowed);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>allowed</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A Boolean value that specifies whether to enable or disable NAT traversal.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The AllowNatTraversal method was called after calling the <span class=\"xref\">stem.Net.Sockets.TcpListener.Start*</span> method</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The AllowNatTraversal method is used to enable or disable NAT traversal for a <a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a> instance. NAT traversal may be provided using Teredo, 6to4, or an ISATAP tunnel.  </p>\n<p> When the <code>allowed</code> parameter is false, the <a class=\"xref\" href=\"system.net.sockets.socketoptionname\" data-linktype=\"relative-path\">SocketOptionName</a> option on the associated socket is set to <a class=\"xref\" href=\"system.net.sockets.ipprotectionlevel\" data-linktype=\"relative-path\">IPProtectionLevel</a>. This explicitly disables NAT traversal for a <a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a> instance.  </p>\n<p> When the <code>allowed</code> parameter is true, the <a class=\"xref\" href=\"system.net.sockets.socketoptionname\" data-linktype=\"relative-path\">SocketOptionName</a> option on the associated socket is set to <a class=\"xref\" href=\"system.net.sockets.ipprotectionlevel\" data-linktype=\"relative-path\">IPProtectionLevel</a>. This may allow NAT traversal for a <a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a> depending on firewall rules in place on the system.  </p>\n<p> The AllowNatTraversal method must be invoked prior to calling the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_Start_\" data-linktype=\"relative-path\">Start</a> method to begin listening for incoming connection requests (before the socket is bound). If AllowNatTraversal method is called after the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_Start_\" data-linktype=\"relative-path\">Start</a> method, then an <a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a> will be thrown.  </p>\n<p> A Teredo address is an IPv6 address with the prefix of 2001::/32. Teredo addresses can be returned through normal DNS name resolution or enumerated as an IPv6 address assigned to a local interface.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Net_Sockets_TcpListener_BeginAcceptSocket_System_AsyncCallback_System_Object_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">BeginAcceptSocket(AsyncCallback,Object)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Begins an asynchronous operation to accept an incoming connection attempt.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public IAsyncResult BeginAcceptSocket (AsyncCallback callback, object state);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>callback</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.asynccallback\" data-linktype=\"relative-path\">AsyncCallback</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An <a class=\"xref\" href=\"system.asynccallback\" data-linktype=\"relative-path\">AsyncCallback</a> delegate that references the method to invoke when the operation is complete.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>state</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A user-defined object containing information about the accept operation. This object is passed to the <code>callback</code> delegate when the operation is complete.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.iasyncresult\" data-linktype=\"relative-path\">IAsyncResult</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An <a class=\"xref\" href=\"system.iasyncresult\" data-linktype=\"relative-path\">IAsyncResult</a> that references the asynchronous creation of the <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.net.sockets.socketexception\" data-linktype=\"relative-path\">SocketException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>An error occurred while attempting to access the socket. See the Remarks section for more information.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.objectdisposedexception\" data-linktype=\"relative-path\">ObjectDisposedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> has been closed.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The asynchronous BeginAcceptSocket operation must be completed by calling the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_EndAcceptSocket_\" data-linktype=\"relative-path\">EndAcceptSocket</a> method. Typically, the method is invoked by the <code>callback</code> delegate.  </p>\n<p> This method does not block until the operation completes. To block until the operation completes, use the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptSocket_\" data-linktype=\"relative-path\">AcceptSocket</a> method.  </p>\n<p> For detailed information about using the asynchronous programming model, see <a href=\"../Topic/Calling%20Synchronous%20Methods%20Asynchronously.md\" data-linktype=\"relative-path\">Calling Synchronous Methods Asynchronously</a>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> You can call the <a class=\"xref\" href=\"system.net.sockets.socket#System_Net_Sockets_Socket_RemoteEndPoint_\" data-linktype=\"relative-path\">RemoteEndPoint</a> property of the returned <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> to identify the remote host&#39;s network address and port number.  </p>\n</div>\n<div class=\"NOTE\"><h5>Note</h5><p> If you receive a <a class=\"xref\" href=\"system.net.sockets.socketexception\" data-linktype=\"relative-path\">SocketException</a>, use the <a class=\"xref\" href=\"system.net.sockets.socketexception#System_Net_Sockets_SocketException_ErrorCode_\" data-linktype=\"relative-path\">ErrorCode</a> property to obtain the specific error code and refer to the Windows Sockets version 2 API error code documentation in the MSDN library at <a href=\"http://msdn.microsoft.com/library/\" data-linktype=\"external\">http://msdn.microsoft.com/library/</a> for a detailed description of the error.  </p>\n</div>\n<div class=\"NOTE\"><h5>Note</h5><p> This member outputs trace information when you enable network tracing in your application. For more information, see <a href=\"../Topic/Network%20Tracing%20in%20the%20.NET%20Framework.md\" data-linktype=\"relative-path\">Network Tracing in the .NET Framework</a>.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Net_Sockets_TcpListener_BeginAcceptTcpClient_System_AsyncCallback_System_Object_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">BeginAcceptTcpClient(AsyncCallback,Object)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Begins an asynchronous operation to accept an incoming connection attempt.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public IAsyncResult BeginAcceptTcpClient (AsyncCallback callback, object state);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>callback</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.asynccallback\" data-linktype=\"relative-path\">AsyncCallback</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An <a class=\"xref\" href=\"system.asynccallback\" data-linktype=\"relative-path\">AsyncCallback</a> delegate that references the method to invoke when the operation is complete.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>state</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A user-defined object containing information about the accept operation. This object is passed to the <code>callback</code> delegate when the operation is complete.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.iasyncresult\" data-linktype=\"relative-path\">IAsyncResult</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An <a class=\"xref\" href=\"system.iasyncresult\" data-linktype=\"relative-path\">IAsyncResult</a> that references the asynchronous creation of the <a class=\"xref\" href=\"system.net.sockets.tcpclient\" data-linktype=\"relative-path\">TcpClient</a>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.net.sockets.socketexception\" data-linktype=\"relative-path\">SocketException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>An error occurred while attempting to access the socket. See the Remarks section for more information.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.objectdisposedexception\" data-linktype=\"relative-path\">ObjectDisposedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> has been closed.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The asynchronous BeginAcceptTcpClient operation must be completed by calling the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_EndAcceptTcpClient_\" data-linktype=\"relative-path\">EndAcceptTcpClient</a> method. Typically, the method is invoked by the <code>callback</code> delegate.  </p>\n<p> This method does not block until the operation completes. To block until the operation completes, use the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptTcpClient_\" data-linktype=\"relative-path\">AcceptTcpClient</a> method.  </p>\n<p> For detailed information about using the asynchronous programming model, see <a href=\"../Topic/Calling%20Synchronous%20Methods%20Asynchronously.md\" data-linktype=\"relative-path\">Calling Synchronous Methods Asynchronously</a>.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> If you receive a <a class=\"xref\" href=\"system.net.sockets.socketexception\" data-linktype=\"relative-path\">SocketException</a>, use the <a class=\"xref\" href=\"system.net.sockets.socketexception#System_Net_Sockets_SocketException_ErrorCode_\" data-linktype=\"relative-path\">ErrorCode</a> property to obtain the specific error code and refer to the Windows Sockets version 2 API error code documentation in the MSDN library at <a href=\"http://msdn.microsoft.com/library/\" data-linktype=\"external\">http://msdn.microsoft.com/library/</a> for a detailed description of the error.  </p>\n</div>\n<div class=\"NOTE\"><h5>Note</h5><p> This member outputs trace information when you enable network tracing in your application. For more information, see <a href=\"../Topic/Network%20Tracing%20in%20the%20.NET%20Framework.md\" data-linktype=\"relative-path\">Network Tracing in the .NET Framework</a>.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Net_Sockets_TcpListener_Create_System_Int32_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Create(Int32)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Creates a new <a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a> instance to listen on the specified port.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public static System.Net.Sockets.TcpListener Create (int port);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>port</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The port on which to listen for incoming connection attempts.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>Returns <a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a>.  </p>\n<p> A new <a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a> instance to listen on the specified port.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Net_Sockets_TcpListener_EndAcceptSocket_System_IAsyncResult_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">EndAcceptSocket(IAsyncResult)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Asynchronously accepts an incoming connection attempt and creates a new <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> to handle remote host communication.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Net.Sockets.Socket EndAcceptSocket (IAsyncResult asyncResult);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>asyncResult</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.iasyncresult\" data-linktype=\"relative-path\">IAsyncResult</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An <a class=\"xref\" href=\"system.iasyncresult\" data-linktype=\"relative-path\">IAsyncResult</a> returned by a call to the <span class=\"xref\">stem.Net.Sockets.TcpListener.BeginAcceptSocket*</span> method.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a>.  </p>\n<p> The <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> used to send and receive data.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.objectdisposedexception\" data-linktype=\"relative-path\">ObjectDisposedException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The underlying <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> has been closed.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>asyncResult</code> parameter is <code>null</code>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The <code>asyncResult</code> parameter was not created by a call to the <span class=\"xref\">stem.Net.Sockets.TcpListener.BeginAcceptSocket*</span> method.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The EndAcceptSocket method was previously called.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.net.sockets.socketexception\" data-linktype=\"relative-path\">SocketException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>An error occurred while attempting to access the <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a>. See the Remarks section for more information.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This method blocks until the operation is complete. To perform this operation synchronously, use the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptSocket_\" data-linktype=\"relative-path\">AcceptSocket</a> method.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> You can call the <a class=\"xref\" href=\"system.net.sockets.socket#System_Net_Sockets_Socket_RemoteEndPoint_\" data-linktype=\"relative-path\">RemoteEndPoint</a> property of the returned <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> to identify the remote host&#39;s network address and port number.  </p>\n</div>\n<div class=\"NOTE\"><h5>Note</h5><p> If you receive a <a class=\"xref\" href=\"system.net.sockets.socketexception\" data-linktype=\"relative-path\">SocketException</a>, use the <a class=\"xref\" href=\"system.net.sockets.socketexception#System_Net_Sockets_SocketException_ErrorCode_\" data-linktype=\"relative-path\">ErrorCode</a> property to obtain the specific error code and refer to the Windows Sockets version 2 API error code documentation in the MSDN library at <a href=\"http://msdn.microsoft.com/library/\" data-linktype=\"external\">http://msdn.microsoft.com/library/</a> for a detailed description of the error.  </p>\n</div>\n<div class=\"NOTE\"><h5>Note</h5><p> This member outputs trace information when you enable network tracing in your application. For more information, see <a href=\"../Topic/Network%20Tracing%20in%20the%20.NET%20Framework.md\" data-linktype=\"relative-path\">Network Tracing in the .NET Framework</a>.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Net_Sockets_TcpListener_EndAcceptTcpClient_System_IAsyncResult_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">EndAcceptTcpClient(IAsyncResult)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Asynchronously accepts an incoming connection attempt and creates a new <a class=\"xref\" href=\"system.net.sockets.tcpclient\" data-linktype=\"relative-path\">TcpClient</a> to handle remote host communication.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public System.Net.Sockets.TcpClient EndAcceptTcpClient (IAsyncResult asyncResult);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>asyncResult</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.iasyncresult\" data-linktype=\"relative-path\">IAsyncResult</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>An <a class=\"xref\" href=\"system.iasyncresult\" data-linktype=\"relative-path\">IAsyncResult</a> returned by a call to the <span class=\"xref\">stem.Net.Sockets.TcpListener.BeginAcceptTcpClient*</span> method.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.net.sockets.tcpclient\" data-linktype=\"relative-path\">TcpClient</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>A <a class=\"xref\" href=\"system.net.sockets.tcpclient\" data-linktype=\"relative-path\">TcpClient</a>.  </p>\n<p> The <a class=\"xref\" href=\"system.net.sockets.tcpclient\" data-linktype=\"relative-path\">TcpClient</a> used to send and receive data.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This method blocks until the operation is complete. To perform this operation synchronously, use the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptTcpClient_\" data-linktype=\"relative-path\">AcceptTcpClient</a> method.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> You can call the <a class=\"xref\" href=\"system.net.sockets.socket#System_Net_Sockets_Socket_RemoteEndPoint_\" data-linktype=\"relative-path\">RemoteEndPoint</a> property of the underlying socket (<a class=\"xref\" href=\"system.net.sockets.tcpclient#System_Net_Sockets_TcpClient_Client_\" data-linktype=\"relative-path\">Client</a>) to identify the remote host&#39;s network address and port number.  </p>\n</div>\n<div class=\"NOTE\"><h5>Note</h5><p> If you receive a <a class=\"xref\" href=\"system.net.sockets.socketexception\" data-linktype=\"relative-path\">SocketException</a>, use the <a class=\"xref\" href=\"system.net.sockets.socketexception#System_Net_Sockets_SocketException_ErrorCode_\" data-linktype=\"relative-path\">ErrorCode</a> property to obtain the specific error code and refer to the Windows Sockets version 2 API error code documentation in the MSDN library at <a href=\"http://msdn.microsoft.com/library/\" data-linktype=\"external\">http://msdn.microsoft.com/library/</a> for a detailed description of the error.  </p>\n</div>\n<div class=\"NOTE\"><h5>Note</h5><p> This member outputs trace information when you enable network tracing in your application. For more information, see <a href=\"../Topic/Network%20Tracing%20in%20the%20.NET%20Framework.md\" data-linktype=\"relative-path\">Network Tracing in the .NET Framework</a>.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Net_Sockets_TcpListener_Pending\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Pending()</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Determines if there are pending connection requests.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public bool Pending ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"attributeList stack\">\r\n  \t\t\t\t\t\t\t\t<dt>Returns</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p><code>true</code> if connections are pending; otherwise, <code>false</code>.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The listener has not been started with a call to <span class=\"xref\">stem.Net.Sockets.TcpListener.Start*</span>.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>This non-blocking method determines if there are any pending connection requests. Because the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptSocket_\" data-linktype=\"relative-path\">AcceptSocket</a> and <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptTcpClient_\" data-linktype=\"relative-path\">AcceptTcpClient</a> methods block execution until the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_Start_\" data-linktype=\"relative-path\">Start</a> method has queued an incoming connection request, the Pending method can be used to determine if connections are available before attempting to accept them.</p>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Net_Sockets_TcpListener_Start\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Start()</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Starts listening for incoming connection requests.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void Start ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.net.sockets.socketexception\" data-linktype=\"relative-path\">SocketException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>Use the <span class=\"xref\">stem.Net.Sockets.SocketException.ErrorCode*</span> property to obtain the specific error code. When you have obtained this code, you can refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The Start method initializes the underlying <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a>, binds it to a local endpoint, and listens for incoming connection attempts. If a connection request is received, the Start method will queue the request and continue listening for additional requests until you call the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_Stop_\" data-linktype=\"relative-path\">Stop</a> method. If <a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a> receives a connection request after it has already queued the maximum number of connections, it will throw a <a class=\"xref\" href=\"system.net.sockets.socketexception\" data-linktype=\"relative-path\">SocketException</a> on the client.  </p>\n<p> To remove a connection from the incoming connection queue, use either the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptTcpClient_\" data-linktype=\"relative-path\">AcceptTcpClient</a> method or the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptSocket_\" data-linktype=\"relative-path\">AcceptSocket</a> method. The <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptTcpClient_\" data-linktype=\"relative-path\">AcceptTcpClient</a> method will remove a connection from the queue and return a <a class=\"xref\" href=\"system.net.sockets.tcpclient\" data-linktype=\"relative-path\">TcpClient</a> that you can use to send and receive data. The <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptSocket_\" data-linktype=\"relative-path\">AcceptSocket</a> method will return a <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> that you can use to do the same. If your application only requires synchronous I/O, use <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptTcpClient_\" data-linktype=\"relative-path\">AcceptTcpClient</a>. For more detailed behavioral control, use <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptSocket_\" data-linktype=\"relative-path\">AcceptSocket</a>. Both of these methods block until a connection request is available in the queue.  </p>\n<p> Use the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_Stop_\" data-linktype=\"relative-path\">Stop</a> method to close the <a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a> and stop listening. You are responsible for closing your accepted connections separately.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> This member outputs trace information when you enable network tracing in your application. For more information, see <a href=\"../Topic/Network%20Tracing%20in%20the%20.NET%20Framework.md\" data-linktype=\"relative-path\">Network Tracing in the .NET Framework</a>.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Net_Sockets_TcpListener_Start_System_Int32_\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Start(Int32)</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Starts listening for incoming connection requests with a maximum number of pending connection.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void Start (int backlog);</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t<dl class=\"parameterList\">\r\n  \t\t\t\t\t\t\t\t<dt>backlog</dt>\r\n  \t\t\t\t\t\t\t\t<dd>\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></span>\r\n  \t\t\t\t\t\t\t\t</dd>\r\n  \t\t\t\t\t\t\t</dl>\r\n  \t\t\t\t\t\t\t<p>The maximum length of the pending connections queue.</p>\n\r\n  \t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.net.sockets.socketexception\" data-linktype=\"relative-path\">SocketException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>An error occurred while accessing the socket. See the Remarks section for more information.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The<code> backlog</code> parameter is less than zero or exceeds the maximum number of permitted connections.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo stack\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>The underlying <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> is null.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>The <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_Start_\" data-linktype=\"relative-path\">Start</a> method initializes the underlying <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a>, binds it to a local endpoint, and listens for incoming connection attempts. If a connection request is received, <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_Start_\" data-linktype=\"relative-path\">Start</a> will queue the request and continue listening for additional requests until you call the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_Stop_\" data-linktype=\"relative-path\">Stop</a> method. If <a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a> receives a connection request after it has already queued the maximum number of connections it will throw a <a class=\"xref\" href=\"system.net.sockets.socketexception\" data-linktype=\"relative-path\">SocketException</a> on the client.  </p>\n<p> To remove a connection from the incoming connection queue, use either the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptTcpClient_\" data-linktype=\"relative-path\">AcceptTcpClient</a> method or the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptSocket_\" data-linktype=\"relative-path\">AcceptSocket</a> method. The <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptTcpClient_\" data-linktype=\"relative-path\">AcceptTcpClient</a> method will remove a connection from the queue and return a <a class=\"xref\" href=\"system.net.sockets.tcpclient\" data-linktype=\"relative-path\">TcpClient</a> that you can use to send and receive data. The <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptSocket_\" data-linktype=\"relative-path\">AcceptSocket</a> method will return a <a class=\"xref\" href=\"system.net.sockets.socket\" data-linktype=\"relative-path\">Socket</a> that you can use to do the same. If your application only requires synchronous I/O, use the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptTcpClient_\" data-linktype=\"relative-path\">AcceptTcpClient</a>. For more detailed behavioral control, use <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_AcceptSocket_\" data-linktype=\"relative-path\">AcceptSocket</a> method. Both of these methods block until a connection request is available in the queue.  </p>\n<p> Use the <a class=\"xref\" href=\"system.net.sockets.tcplistener#System_Net_Sockets_TcpListener_Stop_\" data-linktype=\"relative-path\">Stop</a> method to close the <a class=\"xref\" href=\"system.net.sockets.tcplistener\" data-linktype=\"relative-path\">TcpListener</a> and stop listening. You are responsible for closing your accepted connections separately.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> Use the <a class=\"xref\" href=\"system.net.sockets.socketexception#System_Net_Sockets_SocketException_ErrorCode_\" data-linktype=\"relative-path\">ErrorCode</a> property to obtain the specific error code and refer to the Windows Sockets version 2 API error code documentation in the MSDN library at <a href=\"http://msdn.microsoft.com/library/\" data-linktype=\"external\">http://msdn.microsoft.com/library/</a> for a detailed description of the error.  </p>\n</div>\n<div class=\"NOTE\"><h5>Note</h5><p> This member outputs trace information when you enable network tracing in your application. For more information, see <a href=\"../Topic/Network%20Tracing%20in%20the%20.NET%20Framework.md\" data-linktype=\"relative-path\">Network Tracing in the .NET Framework</a>.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberNameHolder\" id=\"System_Net_Sockets_TcpListener_Stop\">\r\n  \t\t\t\t\t<h3 class=\"accented\">\r\n  \t\t\t\t\t\t<span class=\"lang-csharp\">Stop()</span>        \r\n  \t\t\t\t\t</h3>\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\t\t<div class=\"memberInfo\">\r\n  \t\t\t\t\t<p>Closes the listener.</p>\n\r\n  \t\t\r\n  \t\t\t\t\t\t<pre class=\"wrap loading\"><code class=\"csharp lang-csharp\" dir=\"ltr\">public void Stop ();</code></pre>\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t\t<div class=\"propertyInfoTitle stack\">Exceptions</div>\r\n  \t\t\t\t\t\t\t\t<div class=\"propertyInfo\">\r\n  \t\t\t\t\t\t\t\t<div class=\"subtle\">\r\n  \t\t\t\t\t\t\t\t\t\t<span class=\"lang-csharp\"><a class=\"xref\" href=\"system.net.sockets.socketexception\" data-linktype=\"relative-path\">SocketException</a></span>\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\t\t\t\t\t\t<p>Use the <span class=\"xref\">stem.Net.Sockets.SocketException.ErrorCode*</span> property to obtain the specific error code. When you have obtained this code, you can refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</p>\n\r\n  \t\t\t\t\t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t\t\t\t\t<h4 class=\"accented\">Remarks</h4>\r\n  \t\t\t\t\t\t<p>Stop closes the listener. Any unaccepted connection requests in the queue will be lost. Remote hosts waiting for a connection to be accepted will throw a <a class=\"xref\" href=\"system.net.sockets.socketexception\" data-linktype=\"relative-path\">SocketException</a>. You are responsible for closing your accepted connections separately.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> This member outputs trace information when you enable network tracing in your application. For more information, see <a href=\"../Topic/Network%20Tracing%20in%20the%20.NET%20Framework.md\" data-linktype=\"relative-path\">Network Tracing in the .NET Framework</a>.</p>\n</div>\n\r\n  \t\t\r\n  \t\t\t\t</div>\r\n  \t\t\r\n  \t\t\r\n  \t\t  \r\n  \t\t</section>\r\n  \r\n  \r\n","outputRootRelativePath":"./","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"breadcrumb_path\" content=\"breadcrumb/toc.json\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"fulldocset\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.fulldocset\">\r\n<meta name=\"ref_skeleton_gitcommit\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Net.Sockets.TcpListener.yml\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Net.Sockets.TcpListener.yml\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TcpListener\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TcpListener..ctor\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TcpListener.AcceptSocket\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TcpListener.AcceptSocketAsync\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TcpListener.AcceptTcpClient\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TcpListener.AcceptTcpClientAsync\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TcpListener.Active\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TcpListener.AllowNatTraversal\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TcpListener.BeginAcceptSocket\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TcpListener.BeginAcceptTcpClient\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TcpListener.Create\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TcpListener.EndAcceptSocket\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TcpListener.EndAcceptTcpClient\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TcpListener.ExclusiveAddressUse\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TcpListener.LocalEndpoint\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TcpListener.Pending\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TcpListener.Server\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TcpListener.Start\">\r\n<meta name=\"APIName\" content=\"System.Net.Sockets.TcpListener.Stop\">\r\n<meta name=\"APILocation\" content=\"System.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-01 01:37 AM\">\r\n<meta name=\"document_id\" content=\"46f38f63-12e6-59dd-b4bb-b9979b26b9e7\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Listens for connections from TCP network clients.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/System.Net.Sockets/toc.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Net.Sockets.TcpListener\">\r\n","rawMetadata":{"author":"dotnet-bot","breadcrumb_path":"breadcrumb/toc.json","search.ms_sitename":"Docs","search.ms_docsetname":"fulldocset","version":null,"_op_canonicalUrlPrefix":"https://ppe.docs.microsoft.com/en-us/fulldotnet/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":true,"depot_name":"MSDN.fulldocset","_op_gitRefSkeletonCommitHistory":[{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"use plugin in master","commit_sha":"501959ac03e19ac52a27aa4c6bbeb980f8b11c8c","commit_date":"2017-03-01 09:31:20 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"switch from platform to version","commit_sha":"78cdacb5ca782478af490a6b30c3a2cb2b6b873e","commit_date":"2017-02-28 15:09:51 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"update platforms","commit_sha":"39ad5a8919a59afc93a79ac4bd8e07c3b471b37a","commit_date":"2017-02-28 10:38:59 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"checkin yml","commit_sha":"da161b792852497df7140d7768cee2eccd9cb43f","commit_date":"2017-02-28 09:36:15 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"delete ymls","commit_sha":"417c04fd1daf0cb211ec4909020356fc1fe69260","commit_date":"2017-02-27 14:12:48 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"update latest xml","commit_sha":"1e40a158586a88a698e0cb5342785002a56898b2","commit_date":"2017-02-24 16:20:57 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"add exceptions to reference section","commit_sha":"2f337ac32baa36b4ee4b5d8987b29dba4ce77336","commit_date":"2017-02-24 11:22:25 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"transform see cref and fix paramref format","commit_sha":"3d0ea34483c97ac77f4020a7f294757d67a5c1d4","commit_date":"2017-02-23 10:03:17 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"fix param transform, fix escaped xref","commit_sha":"2af997a764c82488dfa824f1c7bc4d736757d943","commit_date":"2017-02-22 17:04:48 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"convert exceptions","commit_sha":"0a5bf3370731dd35a596c91081e5dc82e2eace3a","commit_date":"2017-02-22 11:54:30 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"remove _yml from url","commit_sha":"f9314af8858edb8c329d223328490093aef4f55f","commit_date":"2017-02-17 15:31:12 +0800"}],"ref_skeleton_gitcommit":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Net.Sockets.TcpListener.yml","original_ref_skeleton_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Net.Sockets.TcpListener.yml","open_to_public_contributors":true,"api_name":["System.Net.Sockets.TcpListener","System.Net.Sockets.TcpListener..ctor","System.Net.Sockets.TcpListener.AcceptSocket","System.Net.Sockets.TcpListener.AcceptSocketAsync","System.Net.Sockets.TcpListener.AcceptTcpClient","System.Net.Sockets.TcpListener.AcceptTcpClientAsync","System.Net.Sockets.TcpListener.Active","System.Net.Sockets.TcpListener.AllowNatTraversal","System.Net.Sockets.TcpListener.BeginAcceptSocket","System.Net.Sockets.TcpListener.BeginAcceptTcpClient","System.Net.Sockets.TcpListener.Create","System.Net.Sockets.TcpListener.EndAcceptSocket","System.Net.Sockets.TcpListener.EndAcceptTcpClient","System.Net.Sockets.TcpListener.ExclusiveAddressUse","System.Net.Sockets.TcpListener.LocalEndpoint","System.Net.Sockets.TcpListener.Pending","System.Net.Sockets.TcpListener.Server","System.Net.Sockets.TcpListener.Start","System.Net.Sockets.TcpListener.Stop"],"api_location":["System.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Net.Sockets.TcpListener","System::Net::Sockets::TcpListener","System.Net.Sockets.TcpListener.#ctor","System::Net::Sockets::TcpListener::#ctor","System.Net.Sockets.TcpListener.AcceptSocket","System::Net::Sockets::TcpListener::AcceptSocket","System.Net.Sockets.TcpListener.AcceptSocketAsync","System::Net::Sockets::TcpListener::AcceptSocketAsync","System.Net.Sockets.TcpListener.AcceptTcpClient","System::Net::Sockets::TcpListener::AcceptTcpClient","System.Net.Sockets.TcpListener.AcceptTcpClientAsync","System::Net::Sockets::TcpListener::AcceptTcpClientAsync","System.Net.Sockets.TcpListener.Active","System::Net::Sockets::TcpListener::Active","System.Net.Sockets.TcpListener.AllowNatTraversal","System::Net::Sockets::TcpListener::AllowNatTraversal","System.Net.Sockets.TcpListener.BeginAcceptSocket","System::Net::Sockets::TcpListener::BeginAcceptSocket","System.Net.Sockets.TcpListener.BeginAcceptTcpClient","System::Net::Sockets::TcpListener::BeginAcceptTcpClient","System.Net.Sockets.TcpListener.Create","System::Net::Sockets::TcpListener::Create","System.Net.Sockets.TcpListener.EndAcceptSocket","System::Net::Sockets::TcpListener::EndAcceptSocket","System.Net.Sockets.TcpListener.EndAcceptTcpClient","System::Net::Sockets::TcpListener::EndAcceptTcpClient","System.Net.Sockets.TcpListener.ExclusiveAddressUse","System::Net::Sockets::TcpListener::ExclusiveAddressUse","System.Net.Sockets.TcpListener.LocalEndpoint","System::Net::Sockets::TcpListener::LocalEndpoint","System.Net.Sockets.TcpListener.Pending","System::Net::Sockets::TcpListener::Pending","System.Net.Sockets.TcpListener.Server","System::Net::Sockets::TcpListener::Server","System.Net.Sockets.TcpListener.Start","System::Net::Sockets::TcpListener::Start","System.Net.Sockets.TcpListener.Stop","System::Net::Sockets::TcpListener::Stop"],"dev_langs":["csharp"],"updated_at":"2017-03-01 01:37 AM","document_id":"46f38f63-12e6-59dd-b4bb-b9979b26b9e7","content_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/xml/System.Net.Sockets/TcpListener.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"TcpListener class | Microsoft Docs","_op_ogTitle":"TcpListener class","description":"Listens for connections from TCP network clients.\n","toc_asset_id":"_splitted/System.Net.Sockets/toc.json","toc_rel":"_splitted/System.Net.Sockets/toc.json","source_url":"","ms.assetid":"System.Net.Sockets.TcpListener","canonical_url":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.net.sockets.tcplistener","_op_canonicalUrl":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.net.sockets.tcplistener","fileRelativePath":"System.Net.Sockets.TcpListener.html"},"themesRelativePathToOutputRoot":"_themes/"}