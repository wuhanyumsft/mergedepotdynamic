{"content":"    \r\n    <h1 id=\"System_Reflection_Emit_ILGenerator\">\r\n      <span class=\"lang-csharp\">ILGenerator</span>\r\n        Class\r\n    </h1>\r\n    \r\n    \r\n    <nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n      <h3>In this Article</h3>\r\n    </nav><div class=\"summary\">\r\n    \t<p>Generates Microsoft intermediate language (MSIL) instructions.</p>\n\r\n    </div><h2>Syntax</h2>\r\n    \r\n    \t<h3>Declaration</h3>\r\n    \t<pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]\n[System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._ILGenerator))]\n[System.Runtime.InteropServices.ComVisible(true)]\npublic class ILGenerator : System.Runtime.InteropServices._ILGenerator</code></pre>\r\n    \r\n    \r\n    \r\n    <h3>Inheritance Hierarchy</h3>\r\n    <ul class=\"inheritance\">\r\n        <li class=\"l0\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a>\r\n          </div>\r\n        </li>\r\n      <li class=\"l1\">\r\n        <div class=\"xref\">\r\n          <div class=\"lang-csharp\">ILGenerator</div>\r\n        </div>\r\n      </li>\r\n    </ul>\r\n    \r\n      <div class=\"referencebox inheritedMembers\">\r\n        <h3>Inherited Members</h3>\r\n        <h4></h4>\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a>\r\n          </div>\r\n          \r\n      </div>\r\n    \r\n    \r\n      <h2>Remarks</h2>\r\n      <p>ILGenerator is used to generate method bodies for methods and constructors in dynamic assemblies (represented by the <a class=\"xref\" href=\"system.reflection.emit.methodbuilder\" data-linktype=\"relative-path\">MethodBuilder</a> and <a class=\"xref\" href=\"system.reflection.emit.constructorbuilder\" data-linktype=\"relative-path\">ConstructorBuilder</a> classes) and for standalone dynamic methods (represented by the <a class=\"xref\" href=\"system.reflection.emit.dynamicmethod\" data-linktype=\"relative-path\">DynamicMethod</a> class). To obtain an ILGenerator, use the <a class=\"xref\" href=\"system.reflection.emit.constructorbuilder#System_Reflection_Emit_ConstructorBuilder_GetILGenerator_\" data-linktype=\"relative-path\">GetILGenerator</a>, <a class=\"xref\" href=\"system.reflection.emit.dynamicmethod#System_Reflection_Emit_DynamicMethod_GetILGenerator_\" data-linktype=\"relative-path\">GetILGenerator</a>, and <a class=\"xref\" href=\"system.reflection.emit.methodbuilder#System_Reflection_Emit_MethodBuilder_GetILGenerator_\" data-linktype=\"relative-path\">GetILGenerator</a> methods.  </p>\n<p> MSIL is used as input to a just-in-time (JIT) compiler.</p>\n\r\n    \r\n    \r\n    <h2>Properties\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_ILOffset\" data-linktype=\"self-bookmark\">ILOffset</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the current offset, in bytes, in the Microsoft intermediate language (MSIL) stream that is being emitted by the <a class=\"xref\" href=\"system.reflection.emit.ilgenerator\" data-linktype=\"relative-path\">ILGenerator</a>.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Methods\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_BeginCatchBlock_System_Type_\" data-linktype=\"self-bookmark\">BeginCatchBlock(Type)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Begins a catch block.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_BeginExceptFilterBlock\" data-linktype=\"self-bookmark\">BeginExceptFilterBlock()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Begins an exception block for a filtered exception.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_BeginExceptionBlock\" data-linktype=\"self-bookmark\">BeginExceptionBlock()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Begins an exception block for a non-filtered exception.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_BeginFaultBlock\" data-linktype=\"self-bookmark\">BeginFaultBlock()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Begins an exception fault block in the Microsoft intermediate language (MSIL) stream.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_BeginFinallyBlock\" data-linktype=\"self-bookmark\">BeginFinallyBlock()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Begins a finally block in the Microsoft intermediate language (MSIL) instruction stream.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_BeginScope\" data-linktype=\"self-bookmark\">BeginScope()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Begins a lexical scope.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_DeclareLocal_System_Type_\" data-linktype=\"self-bookmark\">DeclareLocal(Type)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Declares a local variable of the specified type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_DeclareLocal_System_Type_System_Boolean_\" data-linktype=\"self-bookmark\">DeclareLocal(Type,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Declares a local variable of the specified type, optionally pinning the object referred to by the variable.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_DefineLabel\" data-linktype=\"self-bookmark\">DefineLabel()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Declares a new label.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_\" data-linktype=\"self-bookmark\">Emit(OpCode)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Puts the specified instruction onto the stream of instructions.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Byte_\" data-linktype=\"self-bookmark\">Emit(OpCode,Byte)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Puts the specified instruction and character argument onto the Microsoft intermediate language (MSIL) stream of instructions.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Double_\" data-linktype=\"self-bookmark\">Emit(OpCode,Double)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Int16_\" data-linktype=\"self-bookmark\">Emit(OpCode,Int16)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Int32_\" data-linktype=\"self-bookmark\">Emit(OpCode,Int32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Int64_\" data-linktype=\"self-bookmark\">Emit(OpCode,Int64)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Reflection_ConstructorInfo_\" data-linktype=\"self-bookmark\">Emit(OpCode,ConstructorInfo)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Puts the specified instruction and metadata token for the specified constructor onto the Microsoft intermediate language (MSIL) stream of instructions.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Reflection_Emit_Label_\" data-linktype=\"self-bookmark\">Emit(OpCode,Label)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream and leaves space to include a label when fixes are done.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Reflection_Emit_Label___\" data-linktype=\"self-bookmark\">Emit(OpCode,Label[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream and leaves space to include a label when fixes are done.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Reflection_Emit_LocalBuilder_\" data-linktype=\"self-bookmark\">Emit(OpCode,LocalBuilder)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the index of the given local variable.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Reflection_Emit_SignatureHelper_\" data-linktype=\"self-bookmark\">Emit(OpCode,SignatureHelper)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Puts the specified instruction and a signature token onto the Microsoft intermediate language (MSIL) stream of instructions.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Reflection_FieldInfo_\" data-linktype=\"self-bookmark\">Emit(OpCode,FieldInfo)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Puts the specified instruction and metadata token for the specified field onto the Microsoft intermediate language (MSIL) stream of instructions.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Reflection_MethodInfo_\" data-linktype=\"self-bookmark\">Emit(OpCode,MethodInfo)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the metadata token for the given method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_SByte_\" data-linktype=\"self-bookmark\">Emit(OpCode,SByte)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Puts the specified instruction and character argument onto the Microsoft intermediate language (MSIL) stream of instructions.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Single_\" data-linktype=\"self-bookmark\">Emit(OpCode,Single)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_String_\" data-linktype=\"self-bookmark\">Emit(OpCode,String)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the metadata token for the given string.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Type_\" data-linktype=\"self-bookmark\">Emit(OpCode,Type)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the metadata token for the given type.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_EmitCall_System_Reflection_Emit_OpCode_System_Reflection_MethodInfo_System_Type___\" data-linktype=\"self-bookmark\">EmitCall(OpCode,MethodInfo,Type[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Puts a <code>call</code> or <code>callvirt</code> instruction onto the Microsoft intermediate language (MSIL) stream to call a <code>varargs</code> method.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_EmitCalli_System_Reflection_Emit_OpCode_System_Runtime_InteropServices_CallingConvention_System_Type_System_Type___\" data-linktype=\"self-bookmark\">EmitCalli(OpCode,CallingConvention,Type,Type[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Puts a <a class=\"xref\" href=\"system.reflection.emit.opcodes#System_Reflection_Emit_OpCodes_Calli\" data-linktype=\"relative-path\">Calli</a> instruction onto the Microsoft intermediate language (MSIL) stream, specifying an unmanaged calling convention for the indirect call.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_EmitCalli_System_Reflection_Emit_OpCode_System_Reflection_CallingConventions_System_Type_System_Type___System_Type___\" data-linktype=\"self-bookmark\">EmitCalli(OpCode,CallingConventions,Type,Type[],Type[])</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Puts a <a class=\"xref\" href=\"system.reflection.emit.opcodes#System_Reflection_Emit_OpCodes_Calli\" data-linktype=\"relative-path\">Calli</a> instruction onto the Microsoft intermediate language (MSIL) stream, specifying a managed calling convention for the indirect call.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_EmitWriteLine_System_Reflection_Emit_LocalBuilder_\" data-linktype=\"self-bookmark\">EmitWriteLine(LocalBuilder)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Emits the Microsoft intermediate language (MSIL) necessary to call <span class=\"xref\">stem.Console.WriteLine*</span> with the given local variable.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_EmitWriteLine_System_Reflection_FieldInfo_\" data-linktype=\"self-bookmark\">EmitWriteLine(FieldInfo)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Emits the Microsoft intermediate language (MSIL) necessary to call <span class=\"xref\">stem.Console.WriteLine*</span> with the given field.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_EmitWriteLine_System_String_\" data-linktype=\"self-bookmark\">EmitWriteLine(String)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Emits the Microsoft intermediate language (MSIL) to call <span class=\"xref\">stem.Console.WriteLine*</span> with a string.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_EndExceptionBlock\" data-linktype=\"self-bookmark\">EndExceptionBlock()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Ends an exception block.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_EndScope\" data-linktype=\"self-bookmark\">EndScope()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Ends a lexical scope.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_MarkLabel_System_Reflection_Emit_Label_\" data-linktype=\"self-bookmark\">MarkLabel(Label)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Marks the Microsoft intermediate language (MSIL) stream&#39;s current position with the given label.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_MarkSequencePoint_System_Diagnostics_SymbolStore_ISymbolDocumentWriter_System_Int32_System_Int32_System_Int32_System_Int32_\" data-linktype=\"self-bookmark\">MarkSequencePoint(ISymbolDocumentWriter,Int32,Int32,Int32,Int32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Marks a sequence point in the Microsoft intermediate language (MSIL) stream.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_ThrowException_System_Type_\" data-linktype=\"self-bookmark\">ThrowException(Type)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Emits an instruction to throw an exception.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_UsingNamespace_System_String_\" data-linktype=\"self-bookmark\">UsingNamespace(String)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Specifies the namespace to be used in evaluating locals and watches for the current active lexical scope.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Explicit Interface Implementations\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_System_Runtime_InteropServices__ILGenerator_GetIDsOfNames_System_Guid__System_IntPtr_System_UInt32_System_UInt32_System_IntPtr_\" data-linktype=\"self-bookmark\">_ILGenerator.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Maps a set of names to a corresponding set of dispatch identifiers.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_System_Runtime_InteropServices__ILGenerator_GetTypeInfo_System_UInt32_System_UInt32_System_IntPtr_\" data-linktype=\"self-bookmark\">_ILGenerator.GetTypeInfo(UInt32,UInt32,IntPtr)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Retrieves the type information for an object, which can then be used to get the type information for an interface.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_System_Runtime_InteropServices__ILGenerator_GetTypeInfoCount_System_UInt32__\" data-linktype=\"self-bookmark\">_ILGenerator.GetTypeInfoCount(UInt32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Reflection_Emit_ILGenerator_System_Runtime_InteropServices__ILGenerator_Invoke_System_UInt32_System_Guid__System_UInt32_System_Int16_System_IntPtr_System_IntPtr_System_IntPtr_System_IntPtr_\" data-linktype=\"self-bookmark\">_ILGenerator.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Provides access to properties and methods exposed by an object.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"properties\">\r\n        <h2>Properties\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_ILOffset\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_ILOffset_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ILOffset</div>        \r\n          </div>\r\n    \r\n            <p>Gets the current offset, in bytes, in the Microsoft intermediate language (MSIL) stream that is being emitted by the <a class=\"xref\" href=\"system.reflection.emit.ilgenerator\" data-linktype=\"relative-path\">ILGenerator</a>.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual int ILOffset { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </div>\r\n                  <p>The offset in the MSIL stream at which the next instruction will be emitted.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is transparent, and can be called from partially trusted code.  </p>\n<p> If the ILOffset property is accessed before any MSIL instructions have been emitted, it returns 0 (zero).  </p>\n<p> When MSIL is generated for dynamic languages, this property can be used to map offsets in the MSIL stream to source code line numbers. The resulting information can be used to provide stack traces when exceptions are thrown.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"methods\">\r\n        <h2>Methods\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_BeginCatchBlock_System_Type_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_BeginCatchBlock_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">BeginCatchBlock(Type)</div>        \r\n          </div>\r\n    \r\n            <p>Begins a catch block.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void BeginCatchBlock (Type exceptionType);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>exceptionType</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents the exception.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p>The catch block is within a filtered exception.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>exceptionType</code> is <code>null</code>, and the exception filter block has not returned a value that indicates that finally blocks should be run until this catch block is located.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The Microsoft intermediate language (MSIL) being generated is not currently in an exception block.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Emits a branch instruction to the end of the current exception block.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> If the filter exception block returns the <code>constant exception_execute_handler</code> (see the documentation for the Common Language Infrastructure Instruction Set), the argument to the <code>BeginCatchBlock</code> is not checked.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The code sample below demonstrates the contextual usage of the <code>BeginCatchBlock</code> method.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Reflection.Emit.ILGenerator.ThrowException Example#1\">Imports System\nImports System.Reflection\nImports System.Reflection.Emit\n\nClass ILThrowExceptionDemo\n   \n   Public Shared Sub Main()\n            \n      Dim current As AppDomain = AppDomain.CurrentDomain\n      Dim myAsmName As New AssemblyName()\n      myAsmName.Name = &quot;AdderExceptionAsm&quot;\n      Dim myAsmBldr As AssemblyBuilder = _\n                 current.DefineDynamicAssembly(myAsmName, _\n                     AssemblyBuilderAccess.RunAndSave)\n      \n      Dim myModBldr As ModuleBuilder = _\n                     myAsmBldr.DefineDynamicModule(myAsmName.Name, _\n                         myAsmName.Name &amp; &quot;.dll&quot;)\n      \n      Dim myTypeBldr As TypeBuilder = myModBldr.DefineType(&quot;Adder&quot;)\n      \n      Dim adderParams() As Type = {GetType(Integer), GetType(Integer)}\n      \n      &#39; This method will add two numbers which are 100 or less. If either of the\n      &#39; passed integer vales are greater than 100, it will throw an exception.\n      Dim adderBldr As MethodBuilder = myTypeBldr.DefineMethod(&quot;DoAdd&quot;, _\n                  MethodAttributes.Public Or MethodAttributes.Static, _\n                  GetType(Integer), adderParams)\n      Dim adderIL As ILGenerator = adderBldr.GetILGenerator()\n\n      &#39; Types and methods used in the code to throw, catch, and\n      &#39; display OverflowException. Note that if the catch block were\n      &#39; for a more general type, such as Exception, we would need \n      &#39; a MethodInfo for that type&#39;s ToString method.\n      &#39; \n      Dim overflow As Type = GetType(OverflowException)\n      Dim exCtorInfo As ConstructorInfo = overflow.GetConstructor( _\n                     New Type() {GetType(String)})\n      Dim exToStrMI As MethodInfo = overflow.GetMethod(&quot;ToString&quot;)\n      Dim writeLineMI As MethodInfo = GetType(Console).GetMethod(&quot;WriteLine&quot;, _\n                     New Type() {GetType(String), _\n                            GetType(Object)})\n      \n      Dim tmp1 As LocalBuilder = adderIL.DeclareLocal(GetType(Integer))\n      Dim tmp2 As LocalBuilder = adderIL.DeclareLocal(overflow)\n      \n      &#39; In order to successfully branch, we need to create labels\n      &#39; representing the offset IL instruction block to branch to.\n      &#39; These labels, when the MarkLabel(Label) method is invoked,\n      &#39; will specify the IL instruction to branch to.\n      &#39;\n      Dim failed As Label = adderIL.DefineLabel()\n      Dim endOfMthd As Label = adderIL.DefineLabel()\n\n      &#39; Begin the try block.      \n      Dim exBlock As Label = adderIL.BeginExceptionBlock()\n\n      &#39; First, load argument 0 and the integer value of &quot;100&quot; onto the\n      &#39; stack. If arg0 &gt; 100, branch to the label &quot;failed&quot;, which is marked\n      &#39; as the address of the block that throws an exception.\n      &#39;\n      adderIL.Emit(OpCodes.Ldarg_0)\n      adderIL.Emit(OpCodes.Ldc_I4_S, 100)\n      adderIL.Emit(OpCodes.Bgt_S, failed)\n      \n      &#39; Now, check to see if argument 1 was greater than 100. If it was,\n      &#39; branch to &quot;failed.&quot; Otherwise, fall through and perform the addition,\n      &#39; branching unconditionally to the instruction at the label &quot;endOfMthd&quot;.\n      &#39;\n      adderIL.Emit(OpCodes.Ldarg_1)\n      adderIL.Emit(OpCodes.Ldc_I4_S, 100)\n      adderIL.Emit(OpCodes.Bgt_S, failed)\n      \n      adderIL.Emit(OpCodes.Ldarg_0)\n      adderIL.Emit(OpCodes.Ldarg_1)\n      adderIL.Emit(OpCodes.Add_Ovf_Un)\n      &#39; Store the result of the addition.\n      adderIL.Emit(OpCodes.Stloc_S, tmp1)\n      adderIL.Emit(OpCodes.Br_S, endOfMthd)\n      \n      &#39; If one of the arguments was greater than 100, we need to throw an\n      &#39; exception. We&#39;ll use &quot;OverflowException&quot; with a customized message.\n      &#39; First, we load our message onto the stack, and then create a new\n      &#39; exception object using the constructor overload that accepts a\n      &#39; string message.\n      adderIL.MarkLabel(failed)\n      adderIL.Emit(OpCodes.Ldstr, &quot;Cannot accept values over 100 for add.&quot;)\n      adderIL.Emit(OpCodes.Newobj, exCtorInfo)\n      \n      &#39; Throw the exception now on the stack.\n      adderIL.ThrowException(overflow)\n      \n      &#39; Start the catch block for OverflowException.\n      &#39;\n      adderIL.BeginCatchBlock(overflow)\n\n      &#39; When we enter the catch block, the thrown exception \n      &#39; is on the stack. Store it, then load the format string\n      &#39; for WriteLine. \n      &#39;\n      adderIL.Emit(OpCodes.Stloc_S, tmp2)\n      adderIL.Emit(OpCodes.Ldstr, &quot;Caught {0}&quot;)\n\n      &#39; Push the thrown exception back on the stack, then \n      &#39; call its ToString() method. Note that if this catch block\n      &#39; were for a more general exception type, like Exception,\n      &#39; it would be necessary to use the ToString for that type.\n      &#39;\n      adderIL.Emit(OpCodes.Ldloc_S, tmp2)\n      adderIL.EmitCall(OpCodes.Callvirt, exToStrMI, Nothing)\n      \n      &#39; The format string and the return value from ToString() are\n      &#39; now on the stack. Call WriteLine(string, object).\n      &#39;\n      adderIL.EmitCall(OpCodes.Call, writeLineMI, Nothing)\n      \n      &#39; Since our function has to return an integer value, load -1 onto\n      &#39; the stack to indicate an error, and store it in local variable\n      &#39; tmp1.\n      adderIL.Emit(OpCodes.Ldc_I4_M1)\n      adderIL.Emit(OpCodes.Stloc_S, tmp1)\n      \n      &#39; End the exception handling block.\n\n      adderIL.EndExceptionBlock()\n      \n      &#39; The end of the method. If no exception was thrown, the correct value\n      &#39; will be saved in tmp1. If an exception was thrown, tmp1 will be equal\n      &#39; to -1. Either way, we&#39;ll load the value of tmp1 onto the stack and return.\n      &#39;\n      adderIL.MarkLabel(endOfMthd)\n      adderIL.Emit(OpCodes.Ldloc_S, tmp1)\n      adderIL.Emit(OpCodes.Ret)\n      \n      Dim adderType As Type = myTypeBldr.CreateType()\n\n      Dim addIns As Object = Activator.CreateInstance(adderType)\n      \n      Dim addParams(1) As Object\n      \n      Console.Write(&quot;Enter an integer value: &quot;)\n      addParams(0) = CType(Convert.ToInt32(Console.ReadLine()), Object)\n      \n      Console.Write(&quot;Enter another integer value: &quot;)\n      addParams(1) = CType(Convert.ToInt32(Console.ReadLine()), Object)\n      \n      Console.WriteLine(&quot;If either integer was &gt; 100, an exception will be thrown.&quot;)\n      Console.WriteLine(&quot;---&quot;)\n      \n      Console.WriteLine(&quot;{0} + {1} = {2}&quot;, addParams(0), addParams(1), _\n         adderType.InvokeMember(&quot;DoAdd&quot;, BindingFlags.InvokeMethod, _\n                  Nothing, addIns, addParams))\n   End Sub \n\nEnd Class \n\n&#39; This code example produces output similar to the following:\n&#39;\n&#39;Enter an integer value: 24\n&#39;Enter another integer value: 101\n&#39;If either integer was &gt; 100, an exception will be thrown.\n&#39;---\n&#39;Caught System.OverflowException: Arithmetic operation resulted in an overflow.\n&#39;   at Adder.DoAdd(Int32 , Int32 )\n&#39;24 + 101 = -1\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Reflection.Emit.ILGenerator.ThrowException Example#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Reflection;\nusing namespace System::Reflection::Emit;\n\nint main()\n{\n   AppDomain^ myDomain = Thread::GetDomain();\n   AssemblyName^ myAsmName = gcnew AssemblyName;\n   myAsmName-&gt;Name = &quot;AdderExceptionAsm&quot;;\n   AssemblyBuilder^ myAsmBldr = myDomain-&gt;DefineDynamicAssembly( myAsmName, \n      AssemblyBuilderAccess::RunAndSave );\n   ModuleBuilder^ myModBldr = myAsmBldr-&gt;DefineDynamicModule( myAsmName-&gt;Name,\n      myAsmName-&gt;Name + &quot;.dll&quot; );\n   TypeBuilder^ myTypeBldr = myModBldr-&gt;DefineType( &quot;Adder&quot; );\n   array&lt;Type^&gt;^adderParams = {int::typeid,int::typeid};\n   \n   // This method will add two numbers which are 100 or less. If either of the\n   // passed integer vales are greater than 100, it will throw an exception.\n   MethodBuilder^ adderBldr = myTypeBldr-&gt;DefineMethod( &quot;DoAdd&quot;, \n      static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::Static), \n      int::typeid, adderParams );\n   ILGenerator^ adderIL = adderBldr-&gt;GetILGenerator();\n   \n   // Types and methods used in the code to throw, catch, and\n   // display OverflowException. Note that if the catch block were\n   // for a more general type, such as Exception, we would need \n   // a MethodInfo for that type&#39;s ToString method.\n   // \n   Type^ overflow = OverflowException::typeid;\n   ConstructorInfo^ exCtorInfo = overflow-&gt;GetConstructor( \n      gcnew array&lt;Type^&gt; { String::typeid });\n   MethodInfo^ exToStrMI = overflow-&gt;GetMethod( &quot;ToString&quot; );\n   MethodInfo^ writeLineMI = Console::typeid-&gt;GetMethod( &quot;WriteLine&quot;, \n      gcnew array&lt;Type^&gt; { String::typeid, Object::typeid } );\n\n   LocalBuilder^ tmp1 = adderIL-&gt;DeclareLocal( int::typeid );\n   LocalBuilder^ tmp2 = adderIL-&gt;DeclareLocal( overflow );\n\n   // In order to successfully branch, we need to create labels\n   // representing the offset IL instruction block to branch to.\n   // These labels, when the MarkLabel(Label) method is invoked,\n   // will specify the IL instruction to branch to.\n   //\n   Label failed = adderIL-&gt;DefineLabel();\n   Label endOfMthd = adderIL-&gt;DefineLabel();\n\n   // Begin the try block.\n   Label exBlock = adderIL-&gt;BeginExceptionBlock();\n   \n   // First, load argument 0 and the integer value of S&quot;100&quot; onto the\n   // stack. If arg0 &gt; 100, branch to the label S&quot;failed&quot;, which is marked\n   // as the address of the block that throws an exception.\n   adderIL-&gt;Emit( OpCodes::Ldarg_0 );\n   adderIL-&gt;Emit( OpCodes::Ldc_I4_S, 100 );\n   adderIL-&gt;Emit( OpCodes::Bgt_S, failed );\n   \n   // Now, check to see if argument 1 was greater than 100. If it was,\n   // branch to S&quot;failed.&quot; Otherwise, fall through and perform the addition,\n   // branching unconditionally to the instruction at the label S&quot;endOfMthd&quot;.\n   adderIL-&gt;Emit( OpCodes::Ldarg_1 );\n   adderIL-&gt;Emit( OpCodes::Ldc_I4_S, 100 );\n   adderIL-&gt;Emit( OpCodes::Bgt_S, failed );\n\n   adderIL-&gt;Emit( OpCodes::Ldarg_0 );\n   adderIL-&gt;Emit( OpCodes::Ldarg_1 );\n   adderIL-&gt;Emit( OpCodes::Add_Ovf_Un );\n   // Store the result of the addition.\n   adderIL-&gt;Emit( OpCodes::Stloc_S, tmp1 );\n   adderIL-&gt;Emit( OpCodes::Br_S, endOfMthd );\n   \n   // If one of the arguments was greater than 100, we need to throw an\n   // exception. We&#39;ll use &quot;OverflowException&quot; with a customized message.\n   // First, we load our message onto the stack, and then create a new\n   // exception Object using the constructor overload that accepts a\n   // String* message.\n   adderIL-&gt;MarkLabel( failed );\n   adderIL-&gt;Emit( OpCodes::Ldstr, &quot;Cannot accept values over 100 for add.&quot; );\n   adderIL-&gt;Emit( OpCodes::Newobj, exCtorInfo );\n   \n   // We&#39;re going to need to refer to that exception Object later, so let&#39;s\n   // store it in a temporary variable. Since the store function pops the\n   // the value/reference off the stack, and we&#39;ll need it to throw the\n   // exception, we will subsequently load it back onto the stack as well.\n   adderIL-&gt;Emit( OpCodes::Stloc_S, tmp2 );\n   adderIL-&gt;Emit( OpCodes::Ldloc_S, tmp2 );\n   \n   // Throw the exception now on the stack.\n   adderIL-&gt;ThrowException( overflow );\n   \n   // Start the catch block for OverflowException.\n   //\n   adderIL-&gt;BeginCatchBlock( overflow );\n   \n   // When we enter the catch block, the thrown exception \n   // is on the stack. Store it, then load the format string\n   // for WriteLine. \n   //\n   adderIL-&gt;Emit(OpCodes::Stloc_S, tmp2);\n   adderIL-&gt;Emit(OpCodes::Ldstr, &quot;Caught {0}&quot;);\n\n   // Push the thrown exception back on the stack, then \n   // call its ToString() method. Note that if this catch block\n   // were for a more general exception type, like Exception,\n   // it would be necessary to use the ToString for that type.\n   //\n   adderIL-&gt;Emit(OpCodes::Ldloc_S, tmp2);\n   adderIL-&gt;EmitCall(OpCodes::Callvirt, exToStrMI, nullptr);\n      \n   // The format string and the return value from ToString() are\n   // now on the stack. Call WriteLine(string, object).\n   //\n   adderIL-&gt;EmitCall( OpCodes::Call, writeLineMI, nullptr );\n   \n   // Since our function has to return an integer value, we&#39;ll load -1 onto\n   // the stack to indicate an error, and store it in local variable tmp1.\n   adderIL-&gt;Emit( OpCodes::Ldc_I4_M1 );\n   adderIL-&gt;Emit( OpCodes::Stloc_S, tmp1 );\n   \n   // End the exception handling block.\n   adderIL-&gt;EndExceptionBlock();\n   \n   // The end of the method. If no exception was thrown, the correct value\n   // will be saved in tmp1. If an exception was thrown, tmp1 will be equal\n   // to -1. Either way, we&#39;ll load the value of tmp1 onto the stack and return.\n   adderIL-&gt;MarkLabel( endOfMthd );\n   adderIL-&gt;Emit( OpCodes::Ldloc_S, tmp1 );\n   adderIL-&gt;Emit( OpCodes::Ret );\n\n   Type^ adderType = myTypeBldr-&gt;CreateType();\n\n   Object^ addIns = Activator::CreateInstance( adderType );\n\n   array&lt;Object^&gt;^addParams = gcnew array&lt;Object^&gt;(2);\n\n   Console::Write( &quot;Enter an integer value: &quot; );\n   addParams[ 0 ] = Convert::ToInt32( Console::ReadLine() );\n\n   Console::Write( &quot;Enter another integer value: &quot; );\n   addParams[ 1 ] = Convert::ToInt32( Console::ReadLine() );\n\n   Console::WriteLine( &quot;If either integer was &gt; 100, an exception will be thrown.&quot; );\n\n   Console::WriteLine( &quot;---&quot; );\n   Console::WriteLine( &quot; {0} + {1} = {2}&quot;, addParams[ 0 ], addParams[ 1 ], adderType-&gt;InvokeMember( &quot;DoAdd&quot;, BindingFlags::InvokeMethod, nullptr, addIns, addParams ) );\n}\n\n/* This code produces output similar to the following:\n\nEnter an integer value: 24\nEnter another integer value: 101\nIf either integer was &gt; 100, an exception will be thrown.\n---\nCaught System.OverflowException: Arithmetic operation resulted in an overflow.\n   at Adder.DoAdd(Int32 , Int32 )\n 24 + 101 = -1\n */\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Reflection.Emit.ILGenerator.ThrowException Example#1\">using System;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\nclass ILThrowExceptionDemo \n{\n   public static void Main()\n   {\n      AppDomain current = AppDomain.CurrentDomain;\n      AssemblyName myAsmName = new AssemblyName();\n      myAsmName.Name = &quot;AdderExceptionAsm&quot;;\n      AssemblyBuilder myAsmBldr = current.DefineDynamicAssembly(myAsmName,\n                               AssemblyBuilderAccess.RunAndSave);\n\n      ModuleBuilder myModBldr = myAsmBldr.DefineDynamicModule(myAsmName.Name, \n                         myAsmName.Name + &quot;.dll&quot;);\n\n      TypeBuilder myTypeBldr = myModBldr.DefineType(&quot;Adder&quot;);\n\n      Type[] adderParams = new Type[] {typeof(int), typeof(int)};\n\n      // This method will add two numbers which are 100 or less. If either of the\n      // passed integer vales are greater than 100, it will throw an exception.\n\n      MethodBuilder adderBldr = myTypeBldr.DefineMethod(&quot;DoAdd&quot;,\n                         MethodAttributes.Public |\n                         MethodAttributes.Static,\n                         typeof(int),\n                         adderParams);\n      ILGenerator adderIL = adderBldr.GetILGenerator();\n \n      // Types and methods used in the code to throw, catch, and\n      // display OverflowException. Note that if the catch block were\n      // for a more general type, such as Exception, we would need \n      // a MethodInfo for that type&#39;s ToString method.\n      // \n      Type overflow = typeof(OverflowException);\n      ConstructorInfo exCtorInfo = overflow.GetConstructor(\n                        new Type[]\n                        {typeof(string)});\n      MethodInfo exToStrMI = overflow.GetMethod(&quot;ToString&quot;);\n      MethodInfo writeLineMI = typeof(Console).GetMethod(&quot;WriteLine&quot;,\n                        new Type[] \n                        {typeof(string),\n                         typeof(object)});\n                                                    \n      LocalBuilder tmp1 = adderIL.DeclareLocal(typeof(int));   \n      LocalBuilder tmp2 = adderIL.DeclareLocal(overflow);\n\n      // In order to successfully branch, we need to create labels\n      // representing the offset IL instruction block to branch to.\n      // These labels, when the MarkLabel(Label) method is invoked,\n      // will specify the IL instruction to branch to.\n      //\n      Label failed = adderIL.DefineLabel();\n      Label endOfMthd = adderIL.DefineLabel();\n\n      // Begin the try block.\n      Label exBlock = adderIL.BeginExceptionBlock();\n\n      // First, load argument 0 and the integer value of &quot;100&quot; onto the\n      // stack. If arg0 &gt; 100, branch to the label &quot;failed&quot;, which is marked\n      // as the address of the block that throws an exception.\n      //\n      adderIL.Emit(OpCodes.Ldarg_0);\n      adderIL.Emit(OpCodes.Ldc_I4_S, 100);\n      adderIL.Emit(OpCodes.Bgt_S, failed); \n\n      // Now, check to see if argument 1 was greater than 100. If it was,\n      // branch to &quot;failed.&quot; Otherwise, fall through and perform the addition,\n      // branching unconditionally to the instruction at the label &quot;endOfMthd&quot;.\n      //\n      adderIL.Emit(OpCodes.Ldarg_1);\n      adderIL.Emit(OpCodes.Ldc_I4_S, 100);\n      adderIL.Emit(OpCodes.Bgt_S, failed);\n\n      adderIL.Emit(OpCodes.Ldarg_0);\n      adderIL.Emit(OpCodes.Ldarg_1);\n      adderIL.Emit(OpCodes.Add_Ovf_Un);\n      // Store the result of the addition.\n      adderIL.Emit(OpCodes.Stloc_S, tmp1);\n      adderIL.Emit(OpCodes.Br_S, endOfMthd);\n\n      // If one of the arguments was greater than 100, we need to throw an\n      // exception. We&#39;ll use &quot;OverflowException&quot; with a customized message.\n      // First, we load our message onto the stack, and then create a new\n      // exception object using the constructor overload that accepts a\n      // string message.\n      //\n      adderIL.MarkLabel(failed);\n      adderIL.Emit(OpCodes.Ldstr, &quot;Cannot accept values over 100 for add.&quot;);\n      adderIL.Emit(OpCodes.Newobj, exCtorInfo);\n\n      // We&#39;re going to need to refer to that exception object later, so let&#39;s\n      // store it in a temporary variable. Since the store function pops the\n      // the value/reference off the stack, and we&#39;ll need it to throw the\n      // exception, we will subsequently load it back onto the stack as well.\n\n      adderIL.Emit(OpCodes.Stloc_S, tmp2);\n      adderIL.Emit(OpCodes.Ldloc_S, tmp2);\n\n      // Throw the exception now on the stack.\n\n      adderIL.ThrowException(overflow);\n      \n      // Start the catch block for OverflowException.\n      //\n      adderIL.BeginCatchBlock(overflow);\n\n      // When we enter the catch block, the thrown exception \n      // is on the stack. Store it, then load the format string\n      // for WriteLine. \n      //\n      adderIL.Emit(OpCodes.Stloc_S, tmp2);\n      adderIL.Emit(OpCodes.Ldstr, &quot;Caught {0}&quot;);\n\n      // Push the thrown exception back on the stack, then \n      // call its ToString() method. Note that if this catch block\n      // were for a more general exception type, like Exception,\n      // it would be necessary to use the ToString for that type.\n      //\n      adderIL.Emit(OpCodes.Ldloc_S, tmp2);\n      adderIL.EmitCall(OpCodes.Callvirt, exToStrMI, null);\n      \n      // The format string and the return value from ToString() are\n      // now on the stack. Call WriteLine(string, object).\n      //\n      adderIL.EmitCall(OpCodes.Call, writeLineMI, null);\n\n      // Since our function has to return an integer value, we&#39;ll load -1 onto\n      // the stack to indicate an error, and store it in local variable tmp1.\n      //\n      adderIL.Emit(OpCodes.Ldc_I4_M1);\n      adderIL.Emit(OpCodes.Stloc_S, tmp1);\n\n      // End the exception handling block.\n\n      adderIL.EndExceptionBlock();   \n\n      // The end of the method. If no exception was thrown, the correct value\n      // will be saved in tmp1. If an exception was thrown, tmp1 will be equal\n      // to -1. Either way, we&#39;ll load the value of tmp1 onto the stack and return.\n      //\n      adderIL.MarkLabel(endOfMthd);\n      adderIL.Emit(OpCodes.Ldloc_S, tmp1);\n      adderIL.Emit(OpCodes.Ret);\n   \n      Type adderType = myTypeBldr.CreateType();\n\n      object addIns = Activator.CreateInstance(adderType); \n\n      object[] addParams = new object[2];\n\n      Console.Write(&quot;Enter an integer value: &quot;);\n      addParams[0] = (object)Convert.ToInt32(Console.ReadLine());\n\n      Console.Write(&quot;Enter another integer value: &quot;);\n      addParams[1] = (object)Convert.ToInt32(Console.ReadLine());\n\n      Console.WriteLine(&quot;If either integer was &gt; 100, an exception will be thrown.&quot;);\n      Console.WriteLine(&quot;---&quot;);\n\n      Console.WriteLine(&quot;{0} + {1} = {2}&quot;,\n            addParams[0], addParams[1],\n            adderType.InvokeMember(&quot;DoAdd&quot;,\n               BindingFlags.InvokeMethod,\n               null,\n               addIns,\n               addParams)); \n   }\n}\n\n/* This code produces output similar to the following:\n\nEnter an integer value: 24\nEnter another integer value: 101\nIf either integer was &gt; 100, an exception will be thrown.\n---\nCaught System.OverflowException: Arithmetic operation resulted in an overflow.\n   at Adder.DoAdd(Int32 , Int32 )\n 24 + 101 = -1\n */\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_BeginExceptFilterBlock\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_BeginExceptFilterBlock_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">BeginExceptFilterBlock()</div>        \r\n          </div>\r\n    \r\n            <p>Begins an exception block for a filtered exception.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void BeginExceptFilterBlock ();</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The Microsoft intermediate language (MSIL) being generated is not currently in an exception block.  </p>\n<p> -or-  </p>\n<p> This <a class=\"xref\" href=\"system.reflection.emit.ilgenerator\" data-linktype=\"relative-path\">ILGenerator</a> belongs to a <a class=\"xref\" href=\"system.reflection.emit.dynamicmethod\" data-linktype=\"relative-path\">DynamicMethod</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Emits a branch instruction to the end of the current exception block.  </p>\n<p> If the current <a class=\"xref\" href=\"system.reflection.emit.ilgenerator\" data-linktype=\"relative-path\">ILGenerator</a> is associated with a <a class=\"xref\" href=\"system.reflection.emit.dynamicmethod\" data-linktype=\"relative-path\">DynamicMethod</a> object, emitting filtered exception blocks is not supported. <a class=\"xref\" href=\"system.reflection.emit.dynamicilinfo\" data-linktype=\"relative-path\">DynamicILInfo</a> can be used to construct a dynamic method that uses filtered exception blocks.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_BeginExceptionBlock\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_BeginExceptionBlock_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">BeginExceptionBlock()</div>        \r\n          </div>\r\n    \r\n            <p>Begins an exception block for a non-filtered exception.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual System.Reflection.Emit.Label BeginExceptionBlock ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.label\" data-linktype=\"relative-path\">Label</a></div>\r\n                  </div>\r\n                  <p>The label for the end of the block. This will leave you in the correct place to execute finally blocks or to finish the try.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Creating an exception block records some information, but does not actually emit any Microsoft intermediate language (MSIL) onto the stream.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The code sample below demonstrates the contextual usage of the <code>BeginExceptionBlock</code> method.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Reflection.Emit.ILGenerator.ThrowException Example#1\">Imports System\nImports System.Reflection\nImports System.Reflection.Emit\n\nClass ILThrowExceptionDemo\n   \n   Public Shared Sub Main()\n            \n      Dim current As AppDomain = AppDomain.CurrentDomain\n      Dim myAsmName As New AssemblyName()\n      myAsmName.Name = &quot;AdderExceptionAsm&quot;\n      Dim myAsmBldr As AssemblyBuilder = _\n                 current.DefineDynamicAssembly(myAsmName, _\n                     AssemblyBuilderAccess.RunAndSave)\n      \n      Dim myModBldr As ModuleBuilder = _\n                     myAsmBldr.DefineDynamicModule(myAsmName.Name, _\n                         myAsmName.Name &amp; &quot;.dll&quot;)\n      \n      Dim myTypeBldr As TypeBuilder = myModBldr.DefineType(&quot;Adder&quot;)\n      \n      Dim adderParams() As Type = {GetType(Integer), GetType(Integer)}\n      \n      &#39; This method will add two numbers which are 100 or less. If either of the\n      &#39; passed integer vales are greater than 100, it will throw an exception.\n      Dim adderBldr As MethodBuilder = myTypeBldr.DefineMethod(&quot;DoAdd&quot;, _\n                  MethodAttributes.Public Or MethodAttributes.Static, _\n                  GetType(Integer), adderParams)\n      Dim adderIL As ILGenerator = adderBldr.GetILGenerator()\n\n      &#39; Types and methods used in the code to throw, catch, and\n      &#39; display OverflowException. Note that if the catch block were\n      &#39; for a more general type, such as Exception, we would need \n      &#39; a MethodInfo for that type&#39;s ToString method.\n      &#39; \n      Dim overflow As Type = GetType(OverflowException)\n      Dim exCtorInfo As ConstructorInfo = overflow.GetConstructor( _\n                     New Type() {GetType(String)})\n      Dim exToStrMI As MethodInfo = overflow.GetMethod(&quot;ToString&quot;)\n      Dim writeLineMI As MethodInfo = GetType(Console).GetMethod(&quot;WriteLine&quot;, _\n                     New Type() {GetType(String), _\n                            GetType(Object)})\n      \n      Dim tmp1 As LocalBuilder = adderIL.DeclareLocal(GetType(Integer))\n      Dim tmp2 As LocalBuilder = adderIL.DeclareLocal(overflow)\n      \n      &#39; In order to successfully branch, we need to create labels\n      &#39; representing the offset IL instruction block to branch to.\n      &#39; These labels, when the MarkLabel(Label) method is invoked,\n      &#39; will specify the IL instruction to branch to.\n      &#39;\n      Dim failed As Label = adderIL.DefineLabel()\n      Dim endOfMthd As Label = adderIL.DefineLabel()\n\n      &#39; Begin the try block.      \n      Dim exBlock As Label = adderIL.BeginExceptionBlock()\n\n      &#39; First, load argument 0 and the integer value of &quot;100&quot; onto the\n      &#39; stack. If arg0 &gt; 100, branch to the label &quot;failed&quot;, which is marked\n      &#39; as the address of the block that throws an exception.\n      &#39;\n      adderIL.Emit(OpCodes.Ldarg_0)\n      adderIL.Emit(OpCodes.Ldc_I4_S, 100)\n      adderIL.Emit(OpCodes.Bgt_S, failed)\n      \n      &#39; Now, check to see if argument 1 was greater than 100. If it was,\n      &#39; branch to &quot;failed.&quot; Otherwise, fall through and perform the addition,\n      &#39; branching unconditionally to the instruction at the label &quot;endOfMthd&quot;.\n      &#39;\n      adderIL.Emit(OpCodes.Ldarg_1)\n      adderIL.Emit(OpCodes.Ldc_I4_S, 100)\n      adderIL.Emit(OpCodes.Bgt_S, failed)\n      \n      adderIL.Emit(OpCodes.Ldarg_0)\n      adderIL.Emit(OpCodes.Ldarg_1)\n      adderIL.Emit(OpCodes.Add_Ovf_Un)\n      &#39; Store the result of the addition.\n      adderIL.Emit(OpCodes.Stloc_S, tmp1)\n      adderIL.Emit(OpCodes.Br_S, endOfMthd)\n      \n      &#39; If one of the arguments was greater than 100, we need to throw an\n      &#39; exception. We&#39;ll use &quot;OverflowException&quot; with a customized message.\n      &#39; First, we load our message onto the stack, and then create a new\n      &#39; exception object using the constructor overload that accepts a\n      &#39; string message.\n      adderIL.MarkLabel(failed)\n      adderIL.Emit(OpCodes.Ldstr, &quot;Cannot accept values over 100 for add.&quot;)\n      adderIL.Emit(OpCodes.Newobj, exCtorInfo)\n      \n      &#39; Throw the exception now on the stack.\n      adderIL.ThrowException(overflow)\n      \n      &#39; Start the catch block for OverflowException.\n      &#39;\n      adderIL.BeginCatchBlock(overflow)\n\n      &#39; When we enter the catch block, the thrown exception \n      &#39; is on the stack. Store it, then load the format string\n      &#39; for WriteLine. \n      &#39;\n      adderIL.Emit(OpCodes.Stloc_S, tmp2)\n      adderIL.Emit(OpCodes.Ldstr, &quot;Caught {0}&quot;)\n\n      &#39; Push the thrown exception back on the stack, then \n      &#39; call its ToString() method. Note that if this catch block\n      &#39; were for a more general exception type, like Exception,\n      &#39; it would be necessary to use the ToString for that type.\n      &#39;\n      adderIL.Emit(OpCodes.Ldloc_S, tmp2)\n      adderIL.EmitCall(OpCodes.Callvirt, exToStrMI, Nothing)\n      \n      &#39; The format string and the return value from ToString() are\n      &#39; now on the stack. Call WriteLine(string, object).\n      &#39;\n      adderIL.EmitCall(OpCodes.Call, writeLineMI, Nothing)\n      \n      &#39; Since our function has to return an integer value, load -1 onto\n      &#39; the stack to indicate an error, and store it in local variable\n      &#39; tmp1.\n      adderIL.Emit(OpCodes.Ldc_I4_M1)\n      adderIL.Emit(OpCodes.Stloc_S, tmp1)\n      \n      &#39; End the exception handling block.\n\n      adderIL.EndExceptionBlock()\n      \n      &#39; The end of the method. If no exception was thrown, the correct value\n      &#39; will be saved in tmp1. If an exception was thrown, tmp1 will be equal\n      &#39; to -1. Either way, we&#39;ll load the value of tmp1 onto the stack and return.\n      &#39;\n      adderIL.MarkLabel(endOfMthd)\n      adderIL.Emit(OpCodes.Ldloc_S, tmp1)\n      adderIL.Emit(OpCodes.Ret)\n      \n      Dim adderType As Type = myTypeBldr.CreateType()\n\n      Dim addIns As Object = Activator.CreateInstance(adderType)\n      \n      Dim addParams(1) As Object\n      \n      Console.Write(&quot;Enter an integer value: &quot;)\n      addParams(0) = CType(Convert.ToInt32(Console.ReadLine()), Object)\n      \n      Console.Write(&quot;Enter another integer value: &quot;)\n      addParams(1) = CType(Convert.ToInt32(Console.ReadLine()), Object)\n      \n      Console.WriteLine(&quot;If either integer was &gt; 100, an exception will be thrown.&quot;)\n      Console.WriteLine(&quot;---&quot;)\n      \n      Console.WriteLine(&quot;{0} + {1} = {2}&quot;, addParams(0), addParams(1), _\n         adderType.InvokeMember(&quot;DoAdd&quot;, BindingFlags.InvokeMethod, _\n                  Nothing, addIns, addParams))\n   End Sub \n\nEnd Class \n\n&#39; This code example produces output similar to the following:\n&#39;\n&#39;Enter an integer value: 24\n&#39;Enter another integer value: 101\n&#39;If either integer was &gt; 100, an exception will be thrown.\n&#39;---\n&#39;Caught System.OverflowException: Arithmetic operation resulted in an overflow.\n&#39;   at Adder.DoAdd(Int32 , Int32 )\n&#39;24 + 101 = -1\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Reflection.Emit.ILGenerator.ThrowException Example#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Reflection;\nusing namespace System::Reflection::Emit;\n\nint main()\n{\n   AppDomain^ myDomain = Thread::GetDomain();\n   AssemblyName^ myAsmName = gcnew AssemblyName;\n   myAsmName-&gt;Name = &quot;AdderExceptionAsm&quot;;\n   AssemblyBuilder^ myAsmBldr = myDomain-&gt;DefineDynamicAssembly( myAsmName, \n      AssemblyBuilderAccess::RunAndSave );\n   ModuleBuilder^ myModBldr = myAsmBldr-&gt;DefineDynamicModule( myAsmName-&gt;Name,\n      myAsmName-&gt;Name + &quot;.dll&quot; );\n   TypeBuilder^ myTypeBldr = myModBldr-&gt;DefineType( &quot;Adder&quot; );\n   array&lt;Type^&gt;^adderParams = {int::typeid,int::typeid};\n   \n   // This method will add two numbers which are 100 or less. If either of the\n   // passed integer vales are greater than 100, it will throw an exception.\n   MethodBuilder^ adderBldr = myTypeBldr-&gt;DefineMethod( &quot;DoAdd&quot;, \n      static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::Static), \n      int::typeid, adderParams );\n   ILGenerator^ adderIL = adderBldr-&gt;GetILGenerator();\n   \n   // Types and methods used in the code to throw, catch, and\n   // display OverflowException. Note that if the catch block were\n   // for a more general type, such as Exception, we would need \n   // a MethodInfo for that type&#39;s ToString method.\n   // \n   Type^ overflow = OverflowException::typeid;\n   ConstructorInfo^ exCtorInfo = overflow-&gt;GetConstructor( \n      gcnew array&lt;Type^&gt; { String::typeid });\n   MethodInfo^ exToStrMI = overflow-&gt;GetMethod( &quot;ToString&quot; );\n   MethodInfo^ writeLineMI = Console::typeid-&gt;GetMethod( &quot;WriteLine&quot;, \n      gcnew array&lt;Type^&gt; { String::typeid, Object::typeid } );\n\n   LocalBuilder^ tmp1 = adderIL-&gt;DeclareLocal( int::typeid );\n   LocalBuilder^ tmp2 = adderIL-&gt;DeclareLocal( overflow );\n\n   // In order to successfully branch, we need to create labels\n   // representing the offset IL instruction block to branch to.\n   // These labels, when the MarkLabel(Label) method is invoked,\n   // will specify the IL instruction to branch to.\n   //\n   Label failed = adderIL-&gt;DefineLabel();\n   Label endOfMthd = adderIL-&gt;DefineLabel();\n\n   // Begin the try block.\n   Label exBlock = adderIL-&gt;BeginExceptionBlock();\n   \n   // First, load argument 0 and the integer value of S&quot;100&quot; onto the\n   // stack. If arg0 &gt; 100, branch to the label S&quot;failed&quot;, which is marked\n   // as the address of the block that throws an exception.\n   adderIL-&gt;Emit( OpCodes::Ldarg_0 );\n   adderIL-&gt;Emit( OpCodes::Ldc_I4_S, 100 );\n   adderIL-&gt;Emit( OpCodes::Bgt_S, failed );\n   \n   // Now, check to see if argument 1 was greater than 100. If it was,\n   // branch to S&quot;failed.&quot; Otherwise, fall through and perform the addition,\n   // branching unconditionally to the instruction at the label S&quot;endOfMthd&quot;.\n   adderIL-&gt;Emit( OpCodes::Ldarg_1 );\n   adderIL-&gt;Emit( OpCodes::Ldc_I4_S, 100 );\n   adderIL-&gt;Emit( OpCodes::Bgt_S, failed );\n\n   adderIL-&gt;Emit( OpCodes::Ldarg_0 );\n   adderIL-&gt;Emit( OpCodes::Ldarg_1 );\n   adderIL-&gt;Emit( OpCodes::Add_Ovf_Un );\n   // Store the result of the addition.\n   adderIL-&gt;Emit( OpCodes::Stloc_S, tmp1 );\n   adderIL-&gt;Emit( OpCodes::Br_S, endOfMthd );\n   \n   // If one of the arguments was greater than 100, we need to throw an\n   // exception. We&#39;ll use &quot;OverflowException&quot; with a customized message.\n   // First, we load our message onto the stack, and then create a new\n   // exception Object using the constructor overload that accepts a\n   // String* message.\n   adderIL-&gt;MarkLabel( failed );\n   adderIL-&gt;Emit( OpCodes::Ldstr, &quot;Cannot accept values over 100 for add.&quot; );\n   adderIL-&gt;Emit( OpCodes::Newobj, exCtorInfo );\n   \n   // We&#39;re going to need to refer to that exception Object later, so let&#39;s\n   // store it in a temporary variable. Since the store function pops the\n   // the value/reference off the stack, and we&#39;ll need it to throw the\n   // exception, we will subsequently load it back onto the stack as well.\n   adderIL-&gt;Emit( OpCodes::Stloc_S, tmp2 );\n   adderIL-&gt;Emit( OpCodes::Ldloc_S, tmp2 );\n   \n   // Throw the exception now on the stack.\n   adderIL-&gt;ThrowException( overflow );\n   \n   // Start the catch block for OverflowException.\n   //\n   adderIL-&gt;BeginCatchBlock( overflow );\n   \n   // When we enter the catch block, the thrown exception \n   // is on the stack. Store it, then load the format string\n   // for WriteLine. \n   //\n   adderIL-&gt;Emit(OpCodes::Stloc_S, tmp2);\n   adderIL-&gt;Emit(OpCodes::Ldstr, &quot;Caught {0}&quot;);\n\n   // Push the thrown exception back on the stack, then \n   // call its ToString() method. Note that if this catch block\n   // were for a more general exception type, like Exception,\n   // it would be necessary to use the ToString for that type.\n   //\n   adderIL-&gt;Emit(OpCodes::Ldloc_S, tmp2);\n   adderIL-&gt;EmitCall(OpCodes::Callvirt, exToStrMI, nullptr);\n      \n   // The format string and the return value from ToString() are\n   // now on the stack. Call WriteLine(string, object).\n   //\n   adderIL-&gt;EmitCall( OpCodes::Call, writeLineMI, nullptr );\n   \n   // Since our function has to return an integer value, we&#39;ll load -1 onto\n   // the stack to indicate an error, and store it in local variable tmp1.\n   adderIL-&gt;Emit( OpCodes::Ldc_I4_M1 );\n   adderIL-&gt;Emit( OpCodes::Stloc_S, tmp1 );\n   \n   // End the exception handling block.\n   adderIL-&gt;EndExceptionBlock();\n   \n   // The end of the method. If no exception was thrown, the correct value\n   // will be saved in tmp1. If an exception was thrown, tmp1 will be equal\n   // to -1. Either way, we&#39;ll load the value of tmp1 onto the stack and return.\n   adderIL-&gt;MarkLabel( endOfMthd );\n   adderIL-&gt;Emit( OpCodes::Ldloc_S, tmp1 );\n   adderIL-&gt;Emit( OpCodes::Ret );\n\n   Type^ adderType = myTypeBldr-&gt;CreateType();\n\n   Object^ addIns = Activator::CreateInstance( adderType );\n\n   array&lt;Object^&gt;^addParams = gcnew array&lt;Object^&gt;(2);\n\n   Console::Write( &quot;Enter an integer value: &quot; );\n   addParams[ 0 ] = Convert::ToInt32( Console::ReadLine() );\n\n   Console::Write( &quot;Enter another integer value: &quot; );\n   addParams[ 1 ] = Convert::ToInt32( Console::ReadLine() );\n\n   Console::WriteLine( &quot;If either integer was &gt; 100, an exception will be thrown.&quot; );\n\n   Console::WriteLine( &quot;---&quot; );\n   Console::WriteLine( &quot; {0} + {1} = {2}&quot;, addParams[ 0 ], addParams[ 1 ], adderType-&gt;InvokeMember( &quot;DoAdd&quot;, BindingFlags::InvokeMethod, nullptr, addIns, addParams ) );\n}\n\n/* This code produces output similar to the following:\n\nEnter an integer value: 24\nEnter another integer value: 101\nIf either integer was &gt; 100, an exception will be thrown.\n---\nCaught System.OverflowException: Arithmetic operation resulted in an overflow.\n   at Adder.DoAdd(Int32 , Int32 )\n 24 + 101 = -1\n */\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Reflection.Emit.ILGenerator.ThrowException Example#1\">using System;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\nclass ILThrowExceptionDemo \n{\n   public static void Main()\n   {\n      AppDomain current = AppDomain.CurrentDomain;\n      AssemblyName myAsmName = new AssemblyName();\n      myAsmName.Name = &quot;AdderExceptionAsm&quot;;\n      AssemblyBuilder myAsmBldr = current.DefineDynamicAssembly(myAsmName,\n                               AssemblyBuilderAccess.RunAndSave);\n\n      ModuleBuilder myModBldr = myAsmBldr.DefineDynamicModule(myAsmName.Name, \n                         myAsmName.Name + &quot;.dll&quot;);\n\n      TypeBuilder myTypeBldr = myModBldr.DefineType(&quot;Adder&quot;);\n\n      Type[] adderParams = new Type[] {typeof(int), typeof(int)};\n\n      // This method will add two numbers which are 100 or less. If either of the\n      // passed integer vales are greater than 100, it will throw an exception.\n\n      MethodBuilder adderBldr = myTypeBldr.DefineMethod(&quot;DoAdd&quot;,\n                         MethodAttributes.Public |\n                         MethodAttributes.Static,\n                         typeof(int),\n                         adderParams);\n      ILGenerator adderIL = adderBldr.GetILGenerator();\n \n      // Types and methods used in the code to throw, catch, and\n      // display OverflowException. Note that if the catch block were\n      // for a more general type, such as Exception, we would need \n      // a MethodInfo for that type&#39;s ToString method.\n      // \n      Type overflow = typeof(OverflowException);\n      ConstructorInfo exCtorInfo = overflow.GetConstructor(\n                        new Type[]\n                        {typeof(string)});\n      MethodInfo exToStrMI = overflow.GetMethod(&quot;ToString&quot;);\n      MethodInfo writeLineMI = typeof(Console).GetMethod(&quot;WriteLine&quot;,\n                        new Type[] \n                        {typeof(string),\n                         typeof(object)});\n                                                    \n      LocalBuilder tmp1 = adderIL.DeclareLocal(typeof(int));   \n      LocalBuilder tmp2 = adderIL.DeclareLocal(overflow);\n\n      // In order to successfully branch, we need to create labels\n      // representing the offset IL instruction block to branch to.\n      // These labels, when the MarkLabel(Label) method is invoked,\n      // will specify the IL instruction to branch to.\n      //\n      Label failed = adderIL.DefineLabel();\n      Label endOfMthd = adderIL.DefineLabel();\n\n      // Begin the try block.\n      Label exBlock = adderIL.BeginExceptionBlock();\n\n      // First, load argument 0 and the integer value of &quot;100&quot; onto the\n      // stack. If arg0 &gt; 100, branch to the label &quot;failed&quot;, which is marked\n      // as the address of the block that throws an exception.\n      //\n      adderIL.Emit(OpCodes.Ldarg_0);\n      adderIL.Emit(OpCodes.Ldc_I4_S, 100);\n      adderIL.Emit(OpCodes.Bgt_S, failed); \n\n      // Now, check to see if argument 1 was greater than 100. If it was,\n      // branch to &quot;failed.&quot; Otherwise, fall through and perform the addition,\n      // branching unconditionally to the instruction at the label &quot;endOfMthd&quot;.\n      //\n      adderIL.Emit(OpCodes.Ldarg_1);\n      adderIL.Emit(OpCodes.Ldc_I4_S, 100);\n      adderIL.Emit(OpCodes.Bgt_S, failed);\n\n      adderIL.Emit(OpCodes.Ldarg_0);\n      adderIL.Emit(OpCodes.Ldarg_1);\n      adderIL.Emit(OpCodes.Add_Ovf_Un);\n      // Store the result of the addition.\n      adderIL.Emit(OpCodes.Stloc_S, tmp1);\n      adderIL.Emit(OpCodes.Br_S, endOfMthd);\n\n      // If one of the arguments was greater than 100, we need to throw an\n      // exception. We&#39;ll use &quot;OverflowException&quot; with a customized message.\n      // First, we load our message onto the stack, and then create a new\n      // exception object using the constructor overload that accepts a\n      // string message.\n      //\n      adderIL.MarkLabel(failed);\n      adderIL.Emit(OpCodes.Ldstr, &quot;Cannot accept values over 100 for add.&quot;);\n      adderIL.Emit(OpCodes.Newobj, exCtorInfo);\n\n      // We&#39;re going to need to refer to that exception object later, so let&#39;s\n      // store it in a temporary variable. Since the store function pops the\n      // the value/reference off the stack, and we&#39;ll need it to throw the\n      // exception, we will subsequently load it back onto the stack as well.\n\n      adderIL.Emit(OpCodes.Stloc_S, tmp2);\n      adderIL.Emit(OpCodes.Ldloc_S, tmp2);\n\n      // Throw the exception now on the stack.\n\n      adderIL.ThrowException(overflow);\n      \n      // Start the catch block for OverflowException.\n      //\n      adderIL.BeginCatchBlock(overflow);\n\n      // When we enter the catch block, the thrown exception \n      // is on the stack. Store it, then load the format string\n      // for WriteLine. \n      //\n      adderIL.Emit(OpCodes.Stloc_S, tmp2);\n      adderIL.Emit(OpCodes.Ldstr, &quot;Caught {0}&quot;);\n\n      // Push the thrown exception back on the stack, then \n      // call its ToString() method. Note that if this catch block\n      // were for a more general exception type, like Exception,\n      // it would be necessary to use the ToString for that type.\n      //\n      adderIL.Emit(OpCodes.Ldloc_S, tmp2);\n      adderIL.EmitCall(OpCodes.Callvirt, exToStrMI, null);\n      \n      // The format string and the return value from ToString() are\n      // now on the stack. Call WriteLine(string, object).\n      //\n      adderIL.EmitCall(OpCodes.Call, writeLineMI, null);\n\n      // Since our function has to return an integer value, we&#39;ll load -1 onto\n      // the stack to indicate an error, and store it in local variable tmp1.\n      //\n      adderIL.Emit(OpCodes.Ldc_I4_M1);\n      adderIL.Emit(OpCodes.Stloc_S, tmp1);\n\n      // End the exception handling block.\n\n      adderIL.EndExceptionBlock();   \n\n      // The end of the method. If no exception was thrown, the correct value\n      // will be saved in tmp1. If an exception was thrown, tmp1 will be equal\n      // to -1. Either way, we&#39;ll load the value of tmp1 onto the stack and return.\n      //\n      adderIL.MarkLabel(endOfMthd);\n      adderIL.Emit(OpCodes.Ldloc_S, tmp1);\n      adderIL.Emit(OpCodes.Ret);\n   \n      Type adderType = myTypeBldr.CreateType();\n\n      object addIns = Activator.CreateInstance(adderType); \n\n      object[] addParams = new object[2];\n\n      Console.Write(&quot;Enter an integer value: &quot;);\n      addParams[0] = (object)Convert.ToInt32(Console.ReadLine());\n\n      Console.Write(&quot;Enter another integer value: &quot;);\n      addParams[1] = (object)Convert.ToInt32(Console.ReadLine());\n\n      Console.WriteLine(&quot;If either integer was &gt; 100, an exception will be thrown.&quot;);\n      Console.WriteLine(&quot;---&quot;);\n\n      Console.WriteLine(&quot;{0} + {1} = {2}&quot;,\n            addParams[0], addParams[1],\n            adderType.InvokeMember(&quot;DoAdd&quot;,\n               BindingFlags.InvokeMethod,\n               null,\n               addIns,\n               addParams)); \n   }\n}\n\n/* This code produces output similar to the following:\n\nEnter an integer value: 24\nEnter another integer value: 101\nIf either integer was &gt; 100, an exception will be thrown.\n---\nCaught System.OverflowException: Arithmetic operation resulted in an overflow.\n   at Adder.DoAdd(Int32 , Int32 )\n 24 + 101 = -1\n */\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_BeginFaultBlock\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_BeginFaultBlock_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">BeginFaultBlock()</div>        \r\n          </div>\r\n    \r\n            <p>Begins an exception fault block in the Microsoft intermediate language (MSIL) stream.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void BeginFaultBlock ();</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The MSIL being generated is not currently in an exception block.  </p>\n<p> -or-  </p>\n<p> This <a class=\"xref\" href=\"system.reflection.emit.ilgenerator\" data-linktype=\"relative-path\">ILGenerator</a> belongs to a <a class=\"xref\" href=\"system.reflection.emit.dynamicmethod\" data-linktype=\"relative-path\">DynamicMethod</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the current <a class=\"xref\" href=\"system.reflection.emit.ilgenerator\" data-linktype=\"relative-path\">ILGenerator</a> is associated with a <a class=\"xref\" href=\"system.reflection.emit.dynamicmethod\" data-linktype=\"relative-path\">DynamicMethod</a> object, emitting exception fault blocks is not supported. <a class=\"xref\" href=\"system.reflection.emit.dynamicilinfo\" data-linktype=\"relative-path\">DynamicILInfo</a> can be used to construct a dynamic method that uses exception fault blocks.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code sample illustrates the use of <code>BeginFaultBlock</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"ILGenerator_BeginFaultBlock#1\">using System;\nusing System.Threading;\nusing System.Reflection;\nusing System.Reflection.Emit;\nusing System.Security.Permissions;\n\npublic class ILGenerator_BeginFaultBlock\n{\n   public static Type AddType()\n   {\n      // Create an assembly.\n      AssemblyName myAssemblyName = new AssemblyName();\n      myAssemblyName.Name = &quot;AdderExceptionAsm&quot;;\n\n      // Create dynamic assembly.\n      AppDomain myAppDomain = Thread.GetDomain();\n      AssemblyBuilder myAssemblyBuilder = myAppDomain.DefineDynamicAssembly(myAssemblyName,\n         AssemblyBuilderAccess.Run);\n\n      // Create a dynamic module.\n      ModuleBuilder myModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;AdderExceptionMod&quot;);\n      TypeBuilder myTypeBuilder = myModuleBuilder.DefineType(&quot;Adder&quot;);\n      Type[] myAdderParams = new Type[] {typeof(int), typeof(int)};\n\n      // Method to add two numbers.\n      MethodBuilder myMethodBuilder = myTypeBuilder.DefineMethod(&quot;DoAdd&quot;,MethodAttributes.Public |\n         MethodAttributes.Static,typeof(int),myAdderParams);\n      ILGenerator myAdderIL = myMethodBuilder.GetILGenerator();\n\n      // Create constructor.\n      ConstructorInfo myConstructorInfo = typeof(OverflowException).GetConstructor(\n         new Type[]{typeof(string)});\n      MethodInfo myExToStrMI = typeof(OverflowException).GetMethod(&quot;ToString&quot;);\n      MethodInfo myWriteLineMI = typeof(Console).GetMethod(&quot;WriteLine&quot;,new Type[]\n         {typeof(string),typeof(object)});\n\n      // Declare local variable.\n      LocalBuilder myLocalBuilder1 = myAdderIL.DeclareLocal(typeof(int));\n      LocalBuilder myLocalBuilder2 = myAdderIL.DeclareLocal(typeof(OverflowException));\n\n      // Define label.\n      Label myFailedLabel = myAdderIL.DefineLabel();\n      Label myEndOfMethodLabel = myAdderIL.DefineLabel();\n\n      // Begin exception block.\n      Label myLabel = myAdderIL.BeginExceptionBlock();\n\n      myAdderIL.Emit(OpCodes.Ldarg_0);\n      myAdderIL.Emit(OpCodes.Ldc_I4_S, 10);\n      myAdderIL.Emit(OpCodes.Bgt_S, myFailedLabel);\n\n      myAdderIL.Emit(OpCodes.Ldarg_1);\n      myAdderIL.Emit(OpCodes.Ldc_I4_S, 10);\n      myAdderIL.Emit(OpCodes.Bgt_S, myFailedLabel);\n\n      myAdderIL.Emit(OpCodes.Ldarg_0);\n      myAdderIL.Emit(OpCodes.Ldarg_1);\n      myAdderIL.Emit(OpCodes.Add_Ovf_Un);\n      myAdderIL.Emit(OpCodes.Stloc_S, myLocalBuilder1);\n      myAdderIL.Emit(OpCodes.Br_S, myEndOfMethodLabel);\n\n      myAdderIL.MarkLabel(myFailedLabel);\n      myAdderIL.Emit(OpCodes.Ldstr, &quot;Cannot accept values over 10 for addition.&quot;);\n      myAdderIL.Emit(OpCodes.Newobj, myConstructorInfo);\n\n      myAdderIL.Emit(OpCodes.Stloc_S, myLocalBuilder2);\n      myAdderIL.Emit(OpCodes.Ldloc_S, myLocalBuilder2);\n\n      // Call fault block.\n      myAdderIL.BeginFaultBlock();\n      Console.WriteLine(&quot;Fault block called.&quot;);\n      //Throw exception.\n      myAdderIL.ThrowException(typeof(NotSupportedException));\n\n      // Call finally block.\n      myAdderIL.BeginFinallyBlock();\n      \n      myAdderIL.Emit(OpCodes.Ldstr, &quot;{0}&quot;);\n      myAdderIL.Emit(OpCodes.Ldloc_S, myLocalBuilder2);\n      myAdderIL.EmitCall(OpCodes.Callvirt, myExToStrMI, null);\n      myAdderIL.EmitCall(OpCodes.Call, myWriteLineMI, null);\n      myAdderIL.Emit(OpCodes.Ldc_I4_M1);\n      myAdderIL.Emit(OpCodes.Stloc_S, myLocalBuilder1);\n\n      // End exception block.\n      myAdderIL.EndExceptionBlock();\n\n      myAdderIL.MarkLabel(myEndOfMethodLabel);\n      myAdderIL.Emit(OpCodes.Ldloc_S, myLocalBuilder1);\n      myAdderIL.Emit(OpCodes.Ret);\n\n      return myTypeBuilder.CreateType();\n   }\n   [PermissionSetAttribute(SecurityAction.Demand, Name=&quot;FullTrust&quot;)]\n   public static void Main()\n   {\n      Type myAddType = AddType();\n      object myObject1 = Activator.CreateInstance(myAddType);\n      object[] myObject2 = new object[]{11,12};\n      \n      // Invoke member.\n      myAddType.InvokeMember(&quot;DoAdd&quot;,BindingFlags.InvokeMethod,null,myObject1,myObject2);\n   }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"ILGenerator_BeginFaultBlock#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Reflection;\nusing namespace System::Reflection::Emit;\n\nType^ AddType()\n{\n   // Create an assembly.\n   AssemblyName^ myAssemblyName = gcnew AssemblyName;\n   myAssemblyName-&gt;Name = &quot;AdderExceptionAsm&quot;;\n\n   // Create dynamic assembly.\n   AppDomain^ myAppDomain = Thread::GetDomain();\n   AssemblyBuilder^ myAssemblyBuilder = myAppDomain-&gt;DefineDynamicAssembly( myAssemblyName, AssemblyBuilderAccess::Run );\n\n   // Create a dynamic module.\n   ModuleBuilder^ myModuleBuilder = myAssemblyBuilder-&gt;DefineDynamicModule( &quot;AdderExceptionMod&quot; );\n   TypeBuilder^ myTypeBuilder = myModuleBuilder-&gt;DefineType( &quot;Adder&quot; );\n   array&lt;Type^&gt;^myAdderParams = {int::typeid,int::typeid};\n\n   // Method to add two numbers.\n   MethodBuilder^ myMethodBuilder = myTypeBuilder-&gt;DefineMethod( &quot;DoAdd&quot;, static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::Static), int::typeid, myAdderParams );\n   ILGenerator^ myAdderIL = myMethodBuilder-&gt;GetILGenerator();\n\n   // Create constructor.\n   array&lt;Type^&gt;^temp0 = {String::typeid};\n   ConstructorInfo^ myConstructorInfo = OverflowException::typeid-&gt;GetConstructor( temp0 );\n   MethodInfo^ myExToStrMI = OverflowException::typeid-&gt;GetMethod( &quot;ToString&quot; );\n   array&lt;Type^&gt;^temp1 = {String::typeid,Object::typeid};\n   MethodInfo^ myWriteLineMI = Console::typeid-&gt;GetMethod( &quot;WriteLine&quot;, temp1 );\n\n   // Declare local variable.\n   LocalBuilder^ myLocalBuilder1 = myAdderIL-&gt;DeclareLocal( int::typeid );\n   LocalBuilder^ myLocalBuilder2 = myAdderIL-&gt;DeclareLocal( OverflowException::typeid );\n\n   // Define label.\n   Label myFailedLabel = myAdderIL-&gt;DefineLabel();\n   Label myEndOfMethodLabel = myAdderIL-&gt;DefineLabel();\n\n   // Begin exception block.\n   Label myLabel = myAdderIL-&gt;BeginExceptionBlock();\n   myAdderIL-&gt;Emit( OpCodes::Ldarg_0 );\n   myAdderIL-&gt;Emit( OpCodes::Ldc_I4_S, 10 );\n   myAdderIL-&gt;Emit( OpCodes::Bgt_S, myFailedLabel );\n   myAdderIL-&gt;Emit( OpCodes::Ldarg_1 );\n   myAdderIL-&gt;Emit( OpCodes::Ldc_I4_S, 10 );\n   myAdderIL-&gt;Emit( OpCodes::Bgt_S, myFailedLabel );\n   myAdderIL-&gt;Emit( OpCodes::Ldarg_0 );\n   myAdderIL-&gt;Emit( OpCodes::Ldarg_1 );\n   myAdderIL-&gt;Emit( OpCodes::Add_Ovf_Un );\n   myAdderIL-&gt;Emit( OpCodes::Stloc_S, myLocalBuilder1 );\n   myAdderIL-&gt;Emit( OpCodes::Br_S, myEndOfMethodLabel );\n   myAdderIL-&gt;MarkLabel( myFailedLabel );\n   myAdderIL-&gt;Emit( OpCodes::Ldstr, &quot;Cannot accept values over 10 for addition.&quot; );\n   myAdderIL-&gt;Emit( OpCodes::Newobj, myConstructorInfo );\n   myAdderIL-&gt;Emit( OpCodes::Stloc_S, myLocalBuilder2 );\n   myAdderIL-&gt;Emit( OpCodes::Ldloc_S, myLocalBuilder2 );\n\n   // Call fault block.\n   myAdderIL-&gt;BeginFaultBlock();\n   Console::WriteLine( &quot;Fault block called.&quot; );\n\n   //Throw exception.\n   myAdderIL-&gt;ThrowException( NotSupportedException::typeid );\n\n   // Call finally block.\n   myAdderIL-&gt;BeginFinallyBlock();\n   myAdderIL-&gt;Emit( OpCodes::Ldstr, &quot;{0}&quot; );\n   myAdderIL-&gt;Emit( OpCodes::Ldloc_S, myLocalBuilder2 );\n   myAdderIL-&gt;EmitCall( OpCodes::Callvirt, myExToStrMI, nullptr );\n   myAdderIL-&gt;EmitCall( OpCodes::Call, myWriteLineMI, nullptr );\n   myAdderIL-&gt;Emit( OpCodes::Ldc_I4_M1 );\n   myAdderIL-&gt;Emit( OpCodes::Stloc_S, myLocalBuilder1 );\n\n   // End exception block.\n   myAdderIL-&gt;EndExceptionBlock();\n   myAdderIL-&gt;MarkLabel( myEndOfMethodLabel );\n   myAdderIL-&gt;Emit( OpCodes::Ldloc_S, myLocalBuilder1 );\n   myAdderIL-&gt;Emit( OpCodes::Ret );\n   return myTypeBuilder-&gt;CreateType();\n}\n\nint main()\n{\n   Type^ myAddType = AddType();\n   Object^ myObject1 = Activator::CreateInstance( myAddType );\n   array&lt;Object^&gt;^myObject2 = {11,12};\n\n   // Invoke member.\n   myAddType-&gt;InvokeMember( &quot;DoAdd&quot;, BindingFlags::InvokeMethod, nullptr, myObject1, myObject2 );\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"ILGenerator_BeginFaultBlock#1\">Imports System\nImports System.Threading\nImports System.Reflection\nImports System.Reflection.Emit\nImports System.Security.Permissions\n\nPublic Class ILGenerator_BeginFaultBlock\n   Public Shared Function AddType() As Type\n      &#39; Create an assembly.\n      Dim myAssemblyName As New AssemblyName()\n      myAssemblyName.Name = &quot;AdderExceptionAsm&quot;\n      \n      &#39; Create dynamic assembly.\n      Dim myAppDomain As AppDomain = Thread.GetDomain()\n      Dim myAssemblyBuilder As AssemblyBuilder = myAppDomain.DefineDynamicAssembly _ \n                                              (myAssemblyName, AssemblyBuilderAccess.Run)\n      \n      &#39; Create a dynamic module.\n      Dim myModuleBuilder As ModuleBuilder = myAssemblyBuilder.DefineDynamicModule _ \n                                                (&quot;AdderExceptionMod&quot;)\n      Dim myTypeBuilder As TypeBuilder = myModuleBuilder.DefineType(&quot;Adder&quot;)\n      Dim myAdderParams() As Type = {GetType(Integer), GetType(Integer)}\n      \n      &#39; Method to add two numbers.\n      Dim myMethodBuilder As MethodBuilder = myTypeBuilder.DefineMethod _ \n               (&quot;DoAdd&quot;, MethodAttributes.Public Or MethodAttributes.Static, GetType(Integer), _\n                                                  myAdderParams)\n      Dim myAdderIL As ILGenerator = myMethodBuilder.GetILGenerator()\n      \n      &#39; Create constructor.\n      Dim myConstructorInfo As ConstructorInfo = GetType(OverflowException).GetConstructor _ \n                                                   (New Type() {GetType(String)})\n      Dim myExToStrMI As MethodInfo = GetType(OverflowException).GetMethod(&quot;ToString&quot;)\n      Dim myWriteLineMI As MethodInfo = GetType(Console).GetMethod _ \n                                  (&quot;WriteLine&quot;, New Type() {GetType(String), GetType(Object)})\n      \n      &#39; Declare local variable.\n      Dim myLocalBuilder1 As LocalBuilder = myAdderIL.DeclareLocal(GetType(Integer))\n      Dim myLocalBuilder2 As LocalBuilder = myAdderIL.DeclareLocal(GetType(OverflowException))\n      \n      &#39; Define label.\n      Dim myFailedLabel As Label = myAdderIL.DefineLabel()\n      Dim myEndOfMethodLabel As Label = myAdderIL.DefineLabel()\n      \n      &#39; Begin exception block.\n      Dim myLabel As Label = myAdderIL.BeginExceptionBlock()\n      \n      myAdderIL.Emit(OpCodes.Ldarg_0)\n      myAdderIL.Emit(OpCodes.Ldc_I4_S, 10)\n      myAdderIL.Emit(OpCodes.Bgt_S, myFailedLabel)\n      \n      myAdderIL.Emit(OpCodes.Ldarg_1)\n      myAdderIL.Emit(OpCodes.Ldc_I4_S, 10)\n      myAdderIL.Emit(OpCodes.Bgt_S, myFailedLabel)\n      \n      myAdderIL.Emit(OpCodes.Ldarg_0)\n      myAdderIL.Emit(OpCodes.Ldarg_1)\n      myAdderIL.Emit(OpCodes.Add_Ovf_Un)\n      myAdderIL.Emit(OpCodes.Stloc_S, myLocalBuilder1)\n      myAdderIL.Emit(OpCodes.Br_S, myEndOfMethodLabel)\n      \n      myAdderIL.MarkLabel(myFailedLabel)\n      myAdderIL.Emit(OpCodes.Ldstr, &quot;Cannot accept values over 10 for addition.&quot;)\n      myAdderIL.Emit(OpCodes.Newobj, myConstructorInfo)\n      \n      myAdderIL.Emit(OpCodes.Stloc_S, myLocalBuilder2)\n      myAdderIL.Emit(OpCodes.Ldloc_S, myLocalBuilder2)\n      \n      &#39; Call fault block.\n      myAdderIL.BeginFaultBlock()\n      Console.WriteLine(&quot;Fault block called.&quot;)\n      &#39;Throw exception.\n      myAdderIL.ThrowException(GetType(NotSupportedException))\n      \n      &#39; Call finally block.\n      myAdderIL.BeginFinallyBlock()\n      \n      myAdderIL.Emit(OpCodes.Ldstr, &quot;{0}&quot;)\n      myAdderIL.Emit(OpCodes.Ldloc_S, myLocalBuilder2)\n      myAdderIL.EmitCall(OpCodes.Callvirt, myExToStrMI, Nothing)\n      myAdderIL.EmitCall(OpCodes.Call, myWriteLineMI, Nothing)\n      myAdderIL.Emit(OpCodes.Ldc_I4_M1)\n      myAdderIL.Emit(OpCodes.Stloc_S, myLocalBuilder1)\n      \n      &#39; End exception block.\n      myAdderIL.EndExceptionBlock()\n      \n      myAdderIL.MarkLabel(myEndOfMethodLabel)\n      myAdderIL.Emit(OpCodes.Ldloc_S, myLocalBuilder1)\n      myAdderIL.Emit(OpCodes.Ret)\n      \n      Return myTypeBuilder.CreateType()\n   End Function &#39;AddType\n   \n   &lt;PermissionSetAttribute(SecurityAction.Demand, Name:=&quot;FullTrust&quot;)&gt; _   \n   Public Shared Sub Main()\n      Dim myAddType As Type = AddType()\n      Dim myObject1 As Object = Activator.CreateInstance(myAddType)\n      Dim myObject2() As Object = {11, 12}\n      \n      &#39; Invoke member.\n      myAddType.InvokeMember(&quot;DoAdd&quot;, BindingFlags.InvokeMethod, Nothing, myObject1, myObject2)\n   End Sub &#39;Main\nEnd Class &#39;ILGenerator_BeginFaultBlock\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_BeginFinallyBlock\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_BeginFinallyBlock_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">BeginFinallyBlock()</div>        \r\n          </div>\r\n    \r\n            <p>Begins a finally block in the Microsoft intermediate language (MSIL) instruction stream.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void BeginFinallyBlock ();</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The MSIL being generated is not currently in an exception block.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code sample illustrates the use of <code>BeginFinallyBlock</code>.  </p>\n<pre><code class=\"lang-cpp\" name=\"ILGenerator_BeginFinallyBlock_2#2\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Reflection;\nusing namespace System::Reflection::Emit;\n\npublic ref class ILGenerator_BeginFinallyBlock\n{\npublic:\n   static Type^ AddType()\n   {\n      // Create an assembly.\n      AssemblyName^ myAssemblyName = gcnew AssemblyName;\n      myAssemblyName-&gt;Name = &quot;AdderExceptionAsm&quot;;\n\n      // Create dynamic assembly.\n      AppDomain^ myAppDomain = Thread::GetDomain();\n      AssemblyBuilder^ myAssemblyBuilder = myAppDomain-&gt;DefineDynamicAssembly( myAssemblyName, AssemblyBuilderAccess::Run );\n\n      // Create a dynamic module.\n      ModuleBuilder^ myModuleBuilder = myAssemblyBuilder-&gt;DefineDynamicModule( &quot;AdderExceptionMod&quot; );\n      TypeBuilder^ myTypeBuilder = myModuleBuilder-&gt;DefineType( &quot;Adder&quot; );\n      array&lt;Type^&gt;^adderParams = {int::typeid,int::typeid};\n\n      // Define method to add two numbers.\n      MethodBuilder^ myMethodBuilder = myTypeBuilder-&gt;DefineMethod( &quot;DoAdd&quot;, static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::Static), int::typeid, adderParams );\n      ILGenerator^ myAdderIL = myMethodBuilder-&gt;GetILGenerator();\n\n      // Create constructor.\n      array&lt;Type^&gt;^type1 = {String::typeid};\n      ConstructorInfo^ myConstructorInfo = OverflowException::typeid-&gt;GetConstructor( type1 );\n      MethodInfo^ myExToStrMI = OverflowException::typeid-&gt;GetMethod( &quot;ToString&quot; );\n      array&lt;Type^&gt;^type2 = {String::typeid,Object::typeid};\n      MethodInfo^ myWriteLineMI = Console::typeid-&gt;GetMethod( &quot;WriteLine&quot;, type2 );\n\n      // Declare local variable.\n      LocalBuilder^ myLocalBuilder1 = myAdderIL-&gt;DeclareLocal( int::typeid );\n      LocalBuilder^ myLocalBuilder2 = myAdderIL-&gt;DeclareLocal( OverflowException::typeid );\n\n      // Define label.\n      Label myFailedLabel = myAdderIL-&gt;DefineLabel();\n      Label myEndOfMethodLabel = myAdderIL-&gt;DefineLabel();\n\n      // Begin exception block.\n      Label myLabel = myAdderIL-&gt;BeginExceptionBlock();\n      myAdderIL-&gt;Emit( OpCodes::Ldarg_0 );\n      myAdderIL-&gt;Emit( OpCodes::Ldc_I4_S, 10 );\n      myAdderIL-&gt;Emit( OpCodes::Bgt_S, myFailedLabel );\n      myAdderIL-&gt;Emit( OpCodes::Ldarg_1 );\n      myAdderIL-&gt;Emit( OpCodes::Ldc_I4_S, 10 );\n      myAdderIL-&gt;Emit( OpCodes::Bgt_S, myFailedLabel );\n      myAdderIL-&gt;Emit( OpCodes::Ldarg_0 );\n      myAdderIL-&gt;Emit( OpCodes::Ldarg_1 );\n      myAdderIL-&gt;Emit( OpCodes::Add_Ovf_Un );\n      myAdderIL-&gt;Emit( OpCodes::Stloc_S, myLocalBuilder1 );\n      myAdderIL-&gt;Emit( OpCodes::Br_S, myEndOfMethodLabel );\n      myAdderIL-&gt;MarkLabel( myFailedLabel );\n      myAdderIL-&gt;Emit( OpCodes::Ldstr, &quot;Cannot accept values over 10 for add.&quot; );\n      myAdderIL-&gt;Emit( OpCodes::Newobj, myConstructorInfo );\n      myAdderIL-&gt;Emit( OpCodes::Stloc_S, myLocalBuilder2 );\n      myAdderIL-&gt;Emit( OpCodes::Ldloc_S, myLocalBuilder2 );\n\n      // Throw the exception.\n      myAdderIL-&gt;ThrowException( OverflowException::typeid );\n\n      // Call &#39;BeginExceptFilterBlock&#39;.\n      myAdderIL-&gt;BeginExceptFilterBlock();\n      myAdderIL-&gt;EmitWriteLine( &quot;Except filter block called.&quot; );\n\n      // Call catch block.\n      myAdderIL-&gt;BeginCatchBlock( nullptr );\n\n      // Call other catch block.\n      myAdderIL-&gt;BeginCatchBlock( OverflowException::typeid );\n      myAdderIL-&gt;Emit( OpCodes::Ldstr, &quot;{0}&quot; );\n      myAdderIL-&gt;Emit( OpCodes::Ldloc_S, myLocalBuilder2 );\n      myAdderIL-&gt;EmitCall( OpCodes::Callvirt, myExToStrMI, nullptr );\n      myAdderIL-&gt;EmitCall( OpCodes::Call, myWriteLineMI, nullptr );\n      myAdderIL-&gt;Emit( OpCodes::Ldc_I4_M1 );\n      myAdderIL-&gt;Emit( OpCodes::Stloc_S, myLocalBuilder1 );\n\n      // Call finally block.\n      myAdderIL-&gt;BeginFinallyBlock();\n      myAdderIL-&gt;EmitWriteLine( &quot;Finally block called.&quot; );\n\n      // End the exception block.\n      myAdderIL-&gt;EndExceptionBlock();\n      myAdderIL-&gt;MarkLabel( myEndOfMethodLabel );\n      myAdderIL-&gt;Emit( OpCodes::Ldloc_S, myLocalBuilder1 );\n      myAdderIL-&gt;Emit( OpCodes::Ret );\n      return myTypeBuilder-&gt;CreateType();\n   }\n};\n\nint main()\n{\n   Type^ myAddType = ILGenerator_BeginFinallyBlock::AddType();\n   Object^ myObject1 = Activator::CreateInstance( myAddType );\n   array&lt;Object^&gt;^myObject2 = {15,15};\n   myAddType-&gt;InvokeMember( &quot;DoAdd&quot;, BindingFlags::InvokeMethod, nullptr, myObject1, myObject2 );\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"ILGenerator_BeginFinallyBlock_2#2\">Imports System\nImports System.Threading\nImports System.Reflection\nImports System.Reflection.Emit\nImports System.Security.Permissions\n\nPublic Class ILGenerator_BeginFinallyBlock\n   Public Shared Function AddType() As Type\n      &#39; Create an assembly.\n      Dim myAssemblyName As New AssemblyName()\n      myAssemblyName.Name = &quot;AdderExceptionAsm&quot;\n\n      &#39; Create dynamic assembly.\n      Dim myAppDomain As AppDomain = Thread.GetDomain()\n      Dim myAssemblyBuilder As AssemblyBuilder = _\n            myAppDomain.DefineDynamicAssembly(myAssemblyName, AssemblyBuilderAccess.Run)\n\n      &#39; Create a dynamic module.\n      Dim myModuleBuilder As ModuleBuilder = _\n            myAssemblyBuilder.DefineDynamicModule(&quot;AdderExceptionMod&quot;)\n      Dim myTypeBuilder As TypeBuilder = myModuleBuilder.DefineType(&quot;Adder&quot;)\n      Dim adderParams() As Type = {GetType(Integer), GetType(Integer)}\n\n      &#39; Define method to add two numbers.\n      Dim myMethodBuilder As MethodBuilder = _\n            myTypeBuilder.DefineMethod(&quot;DoAdd&quot;, MethodAttributes.Public Or _\n            MethodAttributes.Static, GetType(Integer), adderParams)\n      Dim myAdderIL As ILGenerator = myMethodBuilder.GetILGenerator()\n\n      &#39; Create constructor.\n      Dim myConstructorInfo As ConstructorInfo = _\n            GetType(OverflowException).GetConstructor(New Type() {GetType(String)})\n      Dim myExToStrMI As MethodInfo = GetType(OverflowException).GetMethod(&quot;ToString&quot;)\n      Dim myWriteLineMI As MethodInfo = _\n            GetType(Console).GetMethod(&quot;WriteLine&quot;, New Type() {GetType(String), GetType(Object)})\n\n      &#39; Declare local variable.\n      Dim myLocalBuilder1 As LocalBuilder = myAdderIL.DeclareLocal(GetType(Integer))\n      Dim myLocalBuilder2 As LocalBuilder = myAdderIL.DeclareLocal(GetType(OverflowException))\n\n      &#39; Define label.\n      Dim myFailedLabel As Label = myAdderIL.DefineLabel()\n      Dim myEndOfMethodLabel As Label = myAdderIL.DefineLabel()\n\n      &#39; Begin exception block.\n      Dim myLabel As Label = myAdderIL.BeginExceptionBlock()\n\n      myAdderIL.Emit(OpCodes.Ldarg_0)\n      myAdderIL.Emit(OpCodes.Ldc_I4_S, 10)\n      myAdderIL.Emit(OpCodes.Bgt_S, myFailedLabel)\n\n      myAdderIL.Emit(OpCodes.Ldarg_1)\n      myAdderIL.Emit(OpCodes.Ldc_I4_S, 10)\n      myAdderIL.Emit(OpCodes.Bgt_S, myFailedLabel)\n\n      myAdderIL.Emit(OpCodes.Ldarg_0)\n      myAdderIL.Emit(OpCodes.Ldarg_1)\n      myAdderIL.Emit(OpCodes.Add_Ovf_Un)\n      myAdderIL.Emit(OpCodes.Stloc_S, myLocalBuilder1)\n      myAdderIL.Emit(OpCodes.Br_S, myEndOfMethodLabel)\n\n      myAdderIL.MarkLabel(myFailedLabel)\n      myAdderIL.Emit(OpCodes.Ldstr, &quot;Cannot accept values over 10 for add.&quot;)\n      myAdderIL.Emit(OpCodes.Newobj, myConstructorInfo)\n\n      myAdderIL.Emit(OpCodes.Stloc_S, myLocalBuilder2)\n      myAdderIL.Emit(OpCodes.Ldloc_S, myLocalBuilder2)\n\n      &#39; Throw the exception.\n      myAdderIL.ThrowException(GetType(OverflowException))\n\n      &#39; Call &#39;BeginExceptFilterBlock&#39;.\n      myAdderIL.BeginExceptFilterBlock()\n      myAdderIL.EmitWriteLine(&quot;Except filter block called.&quot;)\n\n      &#39; Call catch block.\n      myAdderIL.BeginCatchBlock(Nothing)\n\n      &#39; Call other catch block.\n      myAdderIL.BeginCatchBlock(GetType(OverflowException))\n\n      myAdderIL.Emit(OpCodes.Ldstr, &quot;{0}&quot;)\n      myAdderIL.Emit(OpCodes.Ldloc_S, myLocalBuilder2)\n      myAdderIL.EmitCall(OpCodes.Callvirt, myExToStrMI, Nothing)\n      myAdderIL.EmitCall(OpCodes.Call, myWriteLineMI, Nothing)\n      myAdderIL.Emit(OpCodes.Ldc_I4_M1)\n      myAdderIL.Emit(OpCodes.Stloc_S, myLocalBuilder1)\n\n      &#39; Call finally block.\n      myAdderIL.BeginFinallyBlock()\n      myAdderIL.EmitWriteLine(&quot;Finally block called.&quot;)\n\n      &#39; End the exception block.\n      myAdderIL.EndExceptionBlock()\n\n      myAdderIL.MarkLabel(myEndOfMethodLabel)\n      myAdderIL.Emit(OpCodes.Ldloc_S, myLocalBuilder1)\n      myAdderIL.Emit(OpCodes.Ret)\n\n      Return myTypeBuilder.CreateType()\n   End Function &#39;AddType\n\n   &lt;PermissionSetAttribute(SecurityAction.Demand, Name:=&quot;FullTrust&quot;)&gt; _\n   Public Shared Sub Main()\n      Dim myAddType As Type = AddType()\n      Dim myObject1 As Object = Activator.CreateInstance(myAddType)\n      Dim myObject2() As Object = {15, 15}\n      myAddType.InvokeMember(&quot;DoAdd&quot;, BindingFlags.InvokeMethod, Nothing, myObject1, myObject2)\n   End Sub &#39;Main\nEnd Class &#39;ILGenerator_BeginFinallyBlock\n</code></pre><pre><code class=\"lang-cs\" name=\"ILGenerator_BeginFinallyBlock_2#2\">using System;\nusing System.Threading;\nusing System.Reflection;\nusing System.Reflection.Emit;\nusing System.Security.Permissions;\n\npublic class ILGenerator_BeginFinallyBlock\n{\n   public static Type AddType()\n   {\n      // Create an assembly.\n      AssemblyName myAssemblyName = new AssemblyName();\n      myAssemblyName.Name = &quot;AdderExceptionAsm&quot;;\n\n      // Create dynamic assembly.\n      AppDomain myAppDomain = Thread.GetDomain();\n      AssemblyBuilder myAssemblyBuilder = myAppDomain.DefineDynamicAssembly(myAssemblyName,\n         AssemblyBuilderAccess.Run);\n\n      // Create a dynamic module.\n      ModuleBuilder myModuleBuilder = myAssemblyBuilder.DefineDynamicModule(&quot;AdderExceptionMod&quot;);\n      TypeBuilder myTypeBuilder = myModuleBuilder.DefineType(&quot;Adder&quot;);\n      Type[] adderParams = new Type[] {typeof(int), typeof(int)};\n\n      // Define method to add two numbers.\n      MethodBuilder myMethodBuilder = myTypeBuilder.DefineMethod(&quot;DoAdd&quot;,MethodAttributes.Public |\n         MethodAttributes.Static,typeof(int),adderParams);\n      ILGenerator myAdderIL = myMethodBuilder.GetILGenerator();\n\n      // Create constructor.\n      ConstructorInfo myConstructorInfo = typeof(OverflowException).GetConstructor(\n         new Type[]{typeof(string)});\n      MethodInfo myExToStrMI = typeof(OverflowException).GetMethod(&quot;ToString&quot;);\n      MethodInfo myWriteLineMI = typeof(Console).GetMethod(&quot;WriteLine&quot;,new Type[]\n         {typeof(string),typeof(object)});\n\n      // Declare local variable.\n      LocalBuilder myLocalBuilder1 = myAdderIL.DeclareLocal(typeof(int));\n      LocalBuilder myLocalBuilder2 = myAdderIL.DeclareLocal(typeof(OverflowException));\n\n      // Define label.\n      Label myFailedLabel = myAdderIL.DefineLabel();\n      Label myEndOfMethodLabel = myAdderIL.DefineLabel();\n\n      // Begin exception block.\n      Label myLabel = myAdderIL.BeginExceptionBlock();\n\n      myAdderIL.Emit(OpCodes.Ldarg_0);\n      myAdderIL.Emit(OpCodes.Ldc_I4_S, 10);\n      myAdderIL.Emit(OpCodes.Bgt_S, myFailedLabel);\n\n      myAdderIL.Emit(OpCodes.Ldarg_1);\n      myAdderIL.Emit(OpCodes.Ldc_I4_S, 10);\n      myAdderIL.Emit(OpCodes.Bgt_S, myFailedLabel);\n\n      myAdderIL.Emit(OpCodes.Ldarg_0);\n      myAdderIL.Emit(OpCodes.Ldarg_1);\n      myAdderIL.Emit(OpCodes.Add_Ovf_Un);\n      myAdderIL.Emit(OpCodes.Stloc_S, myLocalBuilder1);\n      myAdderIL.Emit(OpCodes.Br_S, myEndOfMethodLabel);\n\n      myAdderIL.MarkLabel(myFailedLabel);\n      myAdderIL.Emit(OpCodes.Ldstr, &quot;Cannot accept values over 10 for add.&quot;);\n      myAdderIL.Emit(OpCodes.Newobj, myConstructorInfo);\n\n      myAdderIL.Emit(OpCodes.Stloc_S, myLocalBuilder2);\n      myAdderIL.Emit(OpCodes.Ldloc_S, myLocalBuilder2);\n\n      // Throw the exception.\n      myAdderIL.ThrowException(typeof(OverflowException));\n\n      // Call &#39;BeginExceptFilterBlock&#39;.\n      myAdderIL.BeginExceptFilterBlock();\n      myAdderIL.EmitWriteLine(&quot;Except filter block called.&quot;);\n\n      // Call catch block.\n      myAdderIL.BeginCatchBlock(null);\n      \n      // Call other catch block.\n      myAdderIL.BeginCatchBlock(typeof(OverflowException));\n\n      myAdderIL.Emit(OpCodes.Ldstr, &quot;{0}&quot;);\n      myAdderIL.Emit(OpCodes.Ldloc_S, myLocalBuilder2);\n      myAdderIL.EmitCall(OpCodes.Callvirt, myExToStrMI, null);\n      myAdderIL.EmitCall(OpCodes.Call, myWriteLineMI, null);\n      myAdderIL.Emit(OpCodes.Ldc_I4_M1);\n      myAdderIL.Emit(OpCodes.Stloc_S, myLocalBuilder1);\n\n      // Call finally block.\n      myAdderIL.BeginFinallyBlock();\n      myAdderIL.EmitWriteLine(&quot;Finally block called.&quot;);\n\n      // End the exception block.\n      myAdderIL.EndExceptionBlock();\n\n      myAdderIL.MarkLabel(myEndOfMethodLabel);\n      myAdderIL.Emit(OpCodes.Ldloc_S, myLocalBuilder1);\n      myAdderIL.Emit(OpCodes.Ret);\n\n      return myTypeBuilder.CreateType();\n   }\n   [PermissionSetAttribute(SecurityAction.Demand, Name=&quot;FullTrust&quot;)]\n   public static void Main()\n   {\n      Type myAddType = AddType();\n      object myObject1 = Activator.CreateInstance(myAddType);\n      object[] myObject2 = new object[]{15,15};\n      myAddType.InvokeMember(&quot;DoAdd&quot;, BindingFlags.InvokeMethod,\n         null, myObject1, myObject2);\n   }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_BeginScope\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_BeginScope_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">BeginScope()</div>        \r\n          </div>\r\n    \r\n            <p>Begins a lexical scope.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void BeginScope ();</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>This <a class=\"xref\" href=\"system.reflection.emit.ilgenerator\" data-linktype=\"relative-path\">ILGenerator</a> belongs to a <a class=\"xref\" href=\"system.reflection.emit.dynamicmethod\" data-linktype=\"relative-path\">DynamicMethod</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is used to emit symbolic information. Local variables declared after BeginScope are scoped until the corresponding <a class=\"xref\" href=\"system.reflection.emit.ilgenerator#System_Reflection_Emit_ILGenerator_EndScope_\" data-linktype=\"relative-path\">EndScope</a> is called.  </p>\n<p> If the current <a class=\"xref\" href=\"system.reflection.emit.ilgenerator\" data-linktype=\"relative-path\">ILGenerator</a> is associated with a <a class=\"xref\" href=\"system.reflection.emit.dynamicmethod\" data-linktype=\"relative-path\">DynamicMethod</a> object, it does not support symbolic information.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code sample illustrates the use of <code>BeginScope</code> and <code>EndScope</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"ILGenerator_Begin_EndScope#2\">         // Get the current AppDomain.\n         AppDomain myAppDomain = AppDomain.CurrentDomain;\n         AssemblyName myAssemblyName = new AssemblyName();\n         myAssemblyName.Name = &quot;SampleAssembly&quot;;\n\n         // Create a dynamic assembly &#39;myAssembly&#39; with access mode &#39;Run&#39;.\n         AssemblyBuilder myAssembly = myAppDomain.DefineDynamicAssembly(\n                                 myAssemblyName, AssemblyBuilderAccess.Run);\n         // Create a dynamic module &#39;myModule&#39; in &#39;myAssembly&#39;.\n         ModuleBuilder myModule=myAssembly.DefineDynamicModule(&quot;MyDynamicModule&quot;,true);\n         // Define a public class &#39;MyDynamicClass&#39;.\n         TypeBuilder myTypeBuilder = myModule.DefineType(&quot;MyDynamicClass&quot;,\n                                          TypeAttributes.Public);\n         // Define a public string field.\n         FieldBuilder myField = myTypeBuilder.DefineField(&quot;MyDynamicField&quot;, \n                                  typeof(String), FieldAttributes.Public);\n         // Create the constructor.\n         Type[] myConstructorArgs = {typeof(String)};\n         ConstructorBuilder myConstructor = myTypeBuilder.DefineConstructor(\n            MethodAttributes.Public, CallingConventions.Standard, myConstructorArgs);\n\n         // Generate IL for &#39;myConstructor&#39;.\n         ILGenerator myConstructorIL = myConstructor.GetILGenerator();\n         // Emit the necessary opcodes.\n         myConstructorIL.Emit(OpCodes.Ldarg_0);\n         ConstructorInfo mySuperConstructor = typeof(Object).GetConstructor(new Type[0]);\n         myConstructorIL.Emit(OpCodes.Call, mySuperConstructor);\n         myConstructorIL.Emit(OpCodes.Ldarg_0);\n         myConstructorIL.Emit(OpCodes.Ldarg_1);\n         myConstructorIL.Emit(OpCodes.Stfld, myField);\n         myConstructorIL.Emit(OpCodes.Ret);\n\n         // Define a dynamic method named &#39;MyDynamicMethod&#39;.\n         MethodBuilder myMethod = myTypeBuilder.DefineMethod(&quot;MyDynamicMethod&quot;,\n            MethodAttributes.Public, typeof(String), null);\n         // Generate IL for &#39;myMethod&#39;.\n         ILGenerator myMethodIL = myMethod.GetILGenerator();\n\n         // Begin the scope for a local variable.\n         myMethodIL.BeginScope();\n\n         LocalBuilder myLocalBuilder = myMethodIL.DeclareLocal(typeof(int));\n         Console.WriteLine(&quot;<br>Trying to access the local variable within the scope.&quot;);\n         Console.WriteLine(&quot;&#39;myLocalBuilder&#39; type is: {0}&quot;, myLocalBuilder.LocalType);\n         myMethodIL.Emit(OpCodes.Ldstr, &quot;Local value&quot;);\n         myMethodIL.Emit(OpCodes.Stloc_0, myLocalBuilder);\n         \n         // End the scope of &#39;myLocalBuilder&#39;.\n         myMethodIL.EndScope();\n\n         // Access the local variable outside the scope.\n         Console.WriteLine(&quot;<br>Trying to access the local variable outside the scope:&quot;);\n         myMethodIL.Emit(OpCodes.Stloc_0, myLocalBuilder);\n         myMethodIL.Emit(OpCodes.Ldloc_0 );\n         myMethodIL.Emit(OpCodes.Ret );\n\n         // Create &#39;MyDynamicClass&#39; class.\n         Type myType1 = myTypeBuilder.CreateType();\n</code></pre><pre><code class=\"lang-cpp\" name=\"ILGenerator_Begin_EndScope#2\">      // Get the current AppDomain.\n      AppDomain^ myAppDomain = AppDomain::CurrentDomain;\n      AssemblyName^ myAssemblyName = gcnew AssemblyName;\n      myAssemblyName-&gt;Name = &quot;SampleAssembly&quot;;\n\n      // Create a dynamic assembly &#39;myAssembly&#39; with access mode &#39;Run&#39;.\n      AssemblyBuilder^ myAssembly = myAppDomain-&gt;DefineDynamicAssembly( myAssemblyName, AssemblyBuilderAccess::Run );\n\n      // Create a dynamic module &#39;myModule&#39; in &#39;myAssembly&#39;.\n      ModuleBuilder^ myModule = myAssembly-&gt;DefineDynamicModule( &quot;MyDynamicModule&quot;, true );\n\n      // Define a public class &#39;MyDynamicClass&#39;.\n      TypeBuilder^ myTypeBuilder = myModule-&gt;DefineType( &quot;MyDynamicClass&quot;, TypeAttributes::Public );\n\n      // Define a public string field.\n      FieldBuilder^ myField = myTypeBuilder-&gt;DefineField( &quot;MyDynamicField&quot;, String::typeid, FieldAttributes::Public );\n\n      // Create the constructor.\n      array&lt;Type^&gt;^myConstructorArgs = {String::typeid};\n      ConstructorBuilder^ myConstructor = myTypeBuilder-&gt;DefineConstructor( MethodAttributes::Public, CallingConventions::Standard, myConstructorArgs );\n\n      // Generate IL for &#39;myConstructor&#39;.\n      ILGenerator^ myConstructorIL = myConstructor-&gt;GetILGenerator();\n\n      // Emit the necessary opcodes.\n      myConstructorIL-&gt;Emit( OpCodes::Ldarg_0 );\n      ConstructorInfo^ mySuperConstructor = Object::typeid-&gt;GetConstructor( gcnew array&lt;Type^&gt;(0) );\n      myConstructorIL-&gt;Emit( OpCodes::Call, mySuperConstructor );\n      myConstructorIL-&gt;Emit( OpCodes::Ldarg_0 );\n      myConstructorIL-&gt;Emit( OpCodes::Ldarg_1 );\n      myConstructorIL-&gt;Emit( OpCodes::Stfld, myField );\n      myConstructorIL-&gt;Emit( OpCodes::Ret );\n\n      // Define a dynamic method named &#39;MyDynamicMethod&#39;.\n      MethodBuilder^ myMethod = myTypeBuilder-&gt;DefineMethod( &quot;MyDynamicMethod&quot;, MethodAttributes::Public, String::typeid, nullptr );\n\n      // Generate IL for &#39;myMethod&#39;.\n      ILGenerator^ myMethodIL = myMethod-&gt;GetILGenerator();\n\n      // Begin the scope for a local variable.\n      myMethodIL-&gt;BeginScope();\n      LocalBuilder^ myLocalBuilder = myMethodIL-&gt;DeclareLocal( int::typeid );\n      Console::WriteLine( &quot;<br>Trying to access the local variable within the scope.&quot; );\n      Console::WriteLine( &quot;&#39;myLocalBuilder&#39; type is :{0}&quot;, myLocalBuilder-&gt;LocalType );\n      myMethodIL-&gt;Emit( OpCodes::Ldstr, &quot;Local value&quot; );\n      myMethodIL-&gt;Emit( OpCodes::Stloc_0, myLocalBuilder );\n\n      // End the scope of &#39;myLocalBuilder&#39;.\n      myMethodIL-&gt;EndScope();\n\n      // Access the local variable outside the scope.\n      Console::WriteLine( &quot;<br>Trying to access the local variable outside the scope:<br>&quot; );\n      myMethodIL-&gt;Emit( OpCodes::Stloc_0, myLocalBuilder );\n      myMethodIL-&gt;Emit( OpCodes::Ldloc_0 );\n      myMethodIL-&gt;Emit( OpCodes::Ret );\n\n      // Create &#39;MyDynamicClass&#39; class.\n      Type^ myType1 = myTypeBuilder-&gt;CreateType();\n</code></pre><pre><code class=\"lang-vb\" name=\"ILGenerator_Begin_EndScope#2\">         &#39; Get the current AppDomain.\n         Dim myAppDomain As AppDomain = AppDomain.CurrentDomain\n         Dim myAssemblyName As New AssemblyName()\n         myAssemblyName.Name = &quot;SampleAssembly&quot;\n         \n         &#39; Create a dynamic assembly &#39;myAssembly&#39; with access mode &#39;Run&#39;.\n         Dim myAssembly As AssemblyBuilder = myAppDomain.DefineDynamicAssembly(myAssemblyName, _\n                                                                     AssemblyBuilderAccess.Run)\n         &#39; Create a dynamic module &#39;myModule&#39; in &#39;myAssembly&#39;.\n         Dim myModule As ModuleBuilder = myAssembly.DefineDynamicModule(&quot;MyDynamicModule&quot;, True)\n         &#39; Define a public class &#39;MyDynamicClass&#39;.\n         Dim myTypeBuilder As TypeBuilder = myModule.DefineType(&quot;MyDynamicClass&quot;, _\n                                                                        TypeAttributes.Public)\n         &#39; Define a public string field.\n         Dim myField As FieldBuilder = myTypeBuilder.DefineField(&quot;MyDynamicField&quot;, GetType(String), _\n                                                                        FieldAttributes.Public)\n         &#39; Create the constructor.\n         Dim myConstructorArgs As Type() = {GetType(String)}\n         Dim myConstructor As ConstructorBuilder = myTypeBuilder.DefineConstructor _\n                        (MethodAttributes.Public, CallingConventions.Standard, myConstructorArgs)\n         \n         &#39; Generate IL for &#39;myConstructor&#39;.\n         Dim myConstructorIL As ILGenerator = myConstructor.GetILGenerator()\n         &#39; Emit the necessary opcodes.\n         myConstructorIL.Emit(OpCodes.Ldarg_0)\n         Dim mySuperConstructor As ConstructorInfo = GetType(Object).GetConstructor(New Type() {})\n         myConstructorIL.Emit(OpCodes.Call, mySuperConstructor)\n         myConstructorIL.Emit(OpCodes.Ldarg_0)\n         myConstructorIL.Emit(OpCodes.Ldarg_1)\n         myConstructorIL.Emit(OpCodes.Stfld, myField)\n         myConstructorIL.Emit(OpCodes.Ret)\n         \n         &#39; Define a dynamic method named &#39;MyDynamicMethod&#39;.\n         Dim myMethod As MethodBuilder = myTypeBuilder.DefineMethod(&quot;MyDynamicMethod&quot;, _\n                                 MethodAttributes.Public, GetType(String), Nothing)\n         &#39; Generate IL for &#39;myMethod&#39;.\n         Dim myMethodIL As ILGenerator = myMethod.GetILGenerator()\n         \n         &#39; Begin the scope for a local variable.\n         myMethodIL.BeginScope()\n         \n         Dim myLocalBuilder As LocalBuilder = myMethodIL.DeclareLocal(GetType(Integer))\n         Console.WriteLine(ControlChars.NewLine + &quot;Trying to access the local variable within&quot; + _\n                                                                              &quot; the scope.&quot;)\n         Console.WriteLine(&quot;&#39;myLocalBuilder&#39; type is: {0}&quot;, myLocalBuilder.LocalType)\n         myMethodIL.Emit(OpCodes.Ldstr, &quot;Local value&quot;)\n         myMethodIL.Emit(OpCodes.Stloc_0, myLocalBuilder)\n         \n         &#39; End the scope of &#39;myLocalBuilder&#39;.\n         myMethodIL.EndScope()\n         \n         &#39; Access the local variable outside the scope.\n         Console.WriteLine(ControlChars.NewLine + &quot;Trying to access the local variable outside &quot; + _\n                                                   &quot;the scope:&quot;)\n         myMethodIL.Emit(OpCodes.Stloc_0, myLocalBuilder)\n         myMethodIL.Emit(OpCodes.Ldloc_0)\n         myMethodIL.Emit(OpCodes.Ret)\n         \n         &#39; Create &#39;MyDynamicClass&#39; class.\n         Dim myType1 As Type = myTypeBuilder.CreateType()\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_DeclareLocal_System_Type_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_DeclareLocal_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">DeclareLocal(Type)</div>        \r\n          </div>\r\n    \r\n            <p>Declares a local variable of the specified type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual System.Reflection.Emit.LocalBuilder DeclareLocal (Type localType);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>localType</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents the type of the local variable.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.localbuilder\" data-linktype=\"relative-path\">LocalBuilder</a></div>\r\n                  </div>\r\n                  <p>The declared local variable.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>localType</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The containing type has been created by the <span class=\"xref\">stem.Reflection.Emit.TypeBuilder.CreateType*</span> method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The local variable is created in the current lexical scope; for example, if code is being emitted in a <code>for</code> loop (<code>For</code> loop in Visual Basic), the scope of the variable is the loop.  </p>\n<p> A local variable created with this overload is not pinned. To create a pinned variable for use with unmanaged pointers, use the <a class=\"xref\" href=\"system.reflection.emit.ilgenerator#System_Reflection_Emit_ILGenerator_DeclareLocal_System_Type_System_Boolean_\" data-linktype=\"relative-path\">DeclareLocal(Type,Boolean)</a> method overload.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates the use of the <code>DeclareLocal</code> method. This code is part of a larger code example for the <a class=\"xref\" href=\"system.reflection.emit.localbuilder\" data-linktype=\"relative-path\">LocalBuilder</a> class.  </p>\n<pre><code class=\"lang-cs\" name=\"LocalBuilder_Sample_SetLocalSymInfo#2\">        // Create local variables named myString and myInt.\n        LocalBuilder myLB1 = myMethodIL.DeclareLocal(typeof(string));\n        myLB1.SetLocalSymInfo(&quot;myString&quot;);\n        Console.WriteLine(&quot;local &#39;myString&#39; type is: {0}&quot;, myLB1.LocalType);\n\n        LocalBuilder myLB2 = myMethodIL.DeclareLocal(typeof(int));\n        myLB2.SetLocalSymInfo(&quot;myInt&quot;, 1, 2);\n        Console.WriteLine(&quot;local &#39;myInt&#39; type is: {0}&quot;, myLB2.LocalType);\n</code></pre><pre><code class=\"lang-vb\" name=\"LocalBuilder_Sample_SetLocalSymInfo#2\">        &#39; Create local variables named myString and myInt.\n        Dim myLB1 As LocalBuilder = myMethodIL.DeclareLocal(GetType(String))\n        myLB1.SetLocalSymInfo(&quot;myString&quot;)\n        Console.WriteLine(&quot;local &#39;myString&#39; type is: {0}&quot;, myLB1.LocalType)\n\n        Dim myLB2 As LocalBuilder = myMethodIL.DeclareLocal(GetType(Integer))\n        myLB2.SetLocalSymInfo(&quot;myInt&quot;, 1, 2)\n        Console.WriteLine(&quot;local &#39;myInt&#39; type is: {0}&quot;, myLB2.LocalType)\n</code></pre><pre><code class=\"lang-cpp\" name=\"LocalBuilder_Sample_SetLocalSymInfo#2\">    // Create local variables named myString and myInt.\n    LocalBuilder^ myLB1 = myMethodIL-&gt;DeclareLocal( String::typeid );\n    myLB1-&gt;SetLocalSymInfo( &quot;myString&quot; );\n    Console::WriteLine( &quot;local &#39;myString&#39; type is: {0}&quot;, myLB1-&gt;LocalType );\n\n    LocalBuilder^ myLB2 = myMethodIL-&gt;DeclareLocal( int::typeid );\n    myLB2-&gt;SetLocalSymInfo( &quot;myInt&quot;, 1, 2 );\n    Console::WriteLine( &quot;local &#39;myInt&#39; type is: {0}&quot;, myLB2-&gt;LocalType );\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_DeclareLocal_System_Type_System_Boolean_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_DeclareLocal_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">DeclareLocal(Type,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Declares a local variable of the specified type, optionally pinning the object referred to by the variable.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual System.Reflection.Emit.LocalBuilder DeclareLocal (Type localType, bool pinned);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>localType</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> object that represents the type of the local variable.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>pinned</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to pin the object in memory; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.localbuilder\" data-linktype=\"relative-path\">LocalBuilder</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"system.reflection.emit.localbuilder\" data-linktype=\"relative-path\">LocalBuilder</a> object that represents the local variable.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>localType</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The containing type has been created by the <span class=\"xref\">stem.Reflection.Emit.TypeBuilder.CreateType*</span> method.  </p>\n<p> -or-  </p>\n<p> The method body of the enclosing method has been created by the <span class=\"xref\">stem.Reflection.Emit.MethodBuilder.CreateMethodBody*</span> method.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The method with which this <a class=\"xref\" href=\"system.reflection.emit.ilgenerator\" data-linktype=\"relative-path\">ILGenerator</a> is associated is not represented by a <a class=\"xref\" href=\"system.reflection.emit.methodbuilder\" data-linktype=\"relative-path\">MethodBuilder</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The local variable is created in the current lexical scope; for example, if code is being emitted in a <code>for</code> loop (<code>For</code> loop in Visual Basic), the scope of the variable is the loop.  </p>\n<p> In unsafe code, an object must be pinned before it can be referred to by an unmanaged pointer. While the referenced object is pinned, it cannot be moved by garbage collection.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_DefineLabel\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_DefineLabel_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">DefineLabel()</div>        \r\n          </div>\r\n    \r\n            <p>Declares a new label.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual System.Reflection.Emit.Label DefineLabel ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.label\" data-linktype=\"relative-path\">Label</a></div>\r\n                  </div>\r\n                  <p>Returns a new label that can be used as a token for branching.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>To set the position of the label within the stream, you must call <a class=\"xref\" href=\"system.reflection.emit.ilgenerator#System_Reflection_Emit_ILGenerator_MarkLabel_\" data-linktype=\"relative-path\">MarkLabel</a>.  </p>\n<p> This is just a token and does not yet represent any particular location within the stream.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The code sample below demonstrates the contextual usage of the <code>DefineLabel</code> method.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Reflection.Emit.Label Example#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Reflection;\nusing namespace System::Reflection::Emit;\nType^ BuildAdderType()\n{\n   AppDomain^ myDomain = Thread::GetDomain();\n   AssemblyName^ myAsmName = gcnew AssemblyName;\n   myAsmName-&gt;Name = &quot;AdderExceptionAsm&quot;;\n   AssemblyBuilder^ myAsmBldr = myDomain-&gt;DefineDynamicAssembly( myAsmName, AssemblyBuilderAccess::Run );\n   ModuleBuilder^ myModBldr = myAsmBldr-&gt;DefineDynamicModule( &quot;AdderExceptionMod&quot; );\n   TypeBuilder^ myTypeBldr = myModBldr-&gt;DefineType( &quot;Adder&quot; );\n   array&lt;Type^&gt;^adderParams = {int::typeid,int::typeid};\n   \n   // This method will add two numbers which are 100 or less. If either of the\n   // passed integer vales are greater than 100, it will return the value of -1.\n   MethodBuilder^ adderBldr = myTypeBldr-&gt;DefineMethod( &quot;DoAdd&quot;, static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::Static), int::typeid, adderParams );\n   ILGenerator^ adderIL = adderBldr-&gt;GetILGenerator();\n   \n   // In order to successfully branch, we need to create labels\n   // representing the offset IL instruction block to branch to.\n   // These labels, when the MarkLabel(Label) method is invoked,\n   // will specify the IL instruction to branch to.\n   Label failed = adderIL-&gt;DefineLabel();\n   Label endOfMthd = adderIL-&gt;DefineLabel();\n   \n   // First, load argument 0 and the integer value of &quot;100&quot; onto the\n   // stack. If arg0 &gt; 100, branch to the label &quot;failed&quot;, which is marked\n   // as the address of the block that loads -1 onto the stack, bypassing\n   // the addition.\n   adderIL-&gt;Emit( OpCodes::Ldarg_0 );\n   adderIL-&gt;Emit( OpCodes::Ldc_I4_S, 100 );\n   adderIL-&gt;Emit( OpCodes::Bgt_S, failed );\n   \n   // Now, check to see if argument 1 was greater than 100. If it was,\n   // branch to &quot;failed.&quot; Otherwise, fall through and perform the addition,\n   // branching unconditionally to the instruction at the label &quot;endOfMthd&quot;.\n   adderIL-&gt;Emit( OpCodes::Ldarg_1 );\n   adderIL-&gt;Emit( OpCodes::Ldc_I4_S, 100 );\n   adderIL-&gt;Emit( OpCodes::Bgt_S, failed );\n   adderIL-&gt;Emit( OpCodes::Ldarg_0 );\n   adderIL-&gt;Emit( OpCodes::Ldarg_1 );\n   adderIL-&gt;Emit( OpCodes::Add_Ovf_Un );\n   adderIL-&gt;Emit( OpCodes::Br_S, endOfMthd );\n   \n   // If this label is branched to (the failure case), load -1 onto the stack\n   // and fall through to the return opcode.\n   adderIL-&gt;MarkLabel( failed );\n   adderIL-&gt;Emit( OpCodes::Ldc_I4_M1 );\n   \n   // The end of the method. If both values were less than 100, the\n   // correct result will return. If one of the arguments was greater\n   // than 100, the result will be -1.\n   adderIL-&gt;MarkLabel( endOfMthd );\n   adderIL-&gt;Emit( OpCodes::Ret );\n   return myTypeBldr-&gt;CreateType();\n}\n\nint main()\n{\n   Type^ adderType = BuildAdderType();\n   Object^ addIns = Activator::CreateInstance( adderType );\n   array&lt;Object^&gt;^addParams = gcnew array&lt;Object^&gt;(2);\n   Console::Write( &quot;Enter an integer value: &quot; );\n   addParams[ 0 ] = Convert::ToInt32( Console::ReadLine() );\n   Console::Write( &quot;Enter another integer value: &quot; );\n   addParams[ 1 ] = Convert::ToInt32( Console::ReadLine() );\n   Console::WriteLine( &quot;---&quot; );\n   int adderResult =  safe_cast&lt;int&gt;(adderType-&gt;InvokeMember( &quot;DoAdd&quot;, BindingFlags::InvokeMethod, nullptr, addIns, addParams ));\n   if ( adderResult != -1 )\n   {\n      Console::WriteLine( &quot; {0} + {1} = {2}&quot;, addParams[ 0 ], addParams[ 1 ], adderResult );\n   }\n   else\n   {\n      Console::WriteLine( &quot;One of the integers to add was greater than 100!&quot; );\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Reflection.Emit.Label Example#1\">Imports System\nImports System.Threading\nImports System.Reflection\nImports System.Reflection.Emit\n\n _\n\nClass ILLabelDemo\n   \n   \n   Public Shared Function BuildAdderType() As Type\n      \n      Dim myDomain As AppDomain = Thread.GetDomain()\n      Dim myAsmName As New AssemblyName()\n      myAsmName.Name = &quot;AdderExceptionAsm&quot;\n      Dim myAsmBldr As AssemblyBuilder = myDomain.DefineDynamicAssembly(myAsmName, _\n\t\t\t\t\t \t\tAssemblyBuilderAccess.Run)\n      \n      Dim myModBldr As ModuleBuilder = myAsmBldr.DefineDynamicModule(&quot;AdderExceptionMod&quot;)\n      \n      Dim myTypeBldr As TypeBuilder = myModBldr.DefineType(&quot;Adder&quot;)\n      \n      Dim adderParams() As Type = {GetType(Integer), GetType(Integer)}\n      \n      &#39; This method will add two numbers which are 100 or less. If either of the\n      &#39; passed integer vales are greater than 100, it will return the value of -1.\n\n      Dim adderBldr As MethodBuilder = myTypeBldr.DefineMethod(&quot;DoAdd&quot;, _\n\t\t\t\t\t\tMethodAttributes.Public Or MethodAttributes.Static, _\n\t\t\t\t\t\tGetType(Integer), adderParams)\n      Dim adderIL As ILGenerator = adderBldr.GetILGenerator()\n      \n      &#39; In order to successfully branch, we need to create labels\n      &#39; representing the offset IL instruction block to branch to.\n      &#39; These labels, when the MarkLabel(Label) method is invoked,\n      &#39; will specify the IL instruction to branch to.\n\n      Dim failed As Label = adderIL.DefineLabel()\n      Dim endOfMthd As Label = adderIL.DefineLabel()\n      \n      &#39; First, load argument 0 and the integer value of &quot;100&quot; onto the\n      &#39; stack. If arg0 &gt; 100, branch to the label &quot;failed&quot;, which is marked\n      &#39; as the address of the block that loads -1 onto the stack, bypassing\n      &#39; the addition.\n\n      adderIL.Emit(OpCodes.Ldarg_0)\n      adderIL.Emit(OpCodes.Ldc_I4_S, 100)\n      adderIL.Emit(OpCodes.Bgt_S, failed)\n      \n      &#39; Now, check to see if argument 1 was greater than 100. If it was,\n      &#39; branch to &quot;failed.&quot; Otherwise, fall through and perform the addition,\n      &#39; branching unconditionally to the instruction at the label &quot;endOfMthd&quot;.\n\n      adderIL.Emit(OpCodes.Ldarg_1)\n      adderIL.Emit(OpCodes.Ldc_I4_S, 100)\n      adderIL.Emit(OpCodes.Bgt_S, failed)\n      \n      adderIL.Emit(OpCodes.Ldarg_0)\n      adderIL.Emit(OpCodes.Ldarg_1)\n      adderIL.Emit(OpCodes.Add_Ovf_Un)\n      adderIL.Emit(OpCodes.Br_S, endOfMthd)\n      \n      &#39; If this label is branched to (the failure case), load -1 onto the stack\n      &#39; and fall through to the return opcode.\n\n      adderIL.MarkLabel(failed)\n      adderIL.Emit(OpCodes.Ldc_I4_M1)\n      \n      &#39; The end of the method. If both values were less than 100, the\n      &#39; correct result will return. If one of the arguments was greater\n      &#39; than 100, the result will be -1. \n\n      adderIL.MarkLabel(endOfMthd)\n      adderIL.Emit(OpCodes.Ret)\n      \n      Return myTypeBldr.CreateType()\n\n   End Function &#39;BuildAdderType\n    \n   \n   Public Shared Sub Main()\n      \n      Dim adderType As Type = BuildAdderType()\n      \n      Dim addIns As Object = Activator.CreateInstance(adderType)\n      \n      Dim addParams(1) As Object\n      \n      Console.Write(&quot;Enter an integer value: &quot;)\n      addParams(0) = CType(Convert.ToInt32(Console.ReadLine()), Object)\n      \n      Console.Write(&quot;Enter another integer value: &quot;)\n      addParams(1) = CType(Convert.ToInt32(Console.ReadLine()), Object)\n      \n      Console.WriteLine(&quot;---&quot;)\n      \n      Dim adderResult As Integer = CInt(adderType.InvokeMember(&quot;DoAdd&quot;, _\n\t\t\t\t\tBindingFlags.InvokeMethod, Nothing, _\n\t\t\t\t\taddIns, addParams))\n      \n      If adderResult &lt;&gt; - 1 Then\n         \n         Console.WriteLine(&quot;{0} + {1} = {2}&quot;, addParams(0), addParams(1), adderResult)\n      \n      Else\n         \n         Console.WriteLine(&quot;One of the integers to add was greater than 100!&quot;)\n      End If \n   End Sub &#39;Main\nEnd Class &#39;ILLabelDemo \n\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Reflection.Emit.Label Example#1\">\nusing System;\nusing System.Threading;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\nclass ILLabelDemo {\n\n   public static Type BuildAdderType() {\n\n  \tAppDomain myDomain = Thread.GetDomain();\n  \tAssemblyName myAsmName = new AssemblyName();\n  \tmyAsmName.Name = &quot;AdderExceptionAsm&quot;;\n  \tAssemblyBuilder myAsmBldr = myDomain.DefineDynamicAssembly(myAsmName,\n\t\t\t\t\t       \t     AssemblyBuilderAccess.Run);\n\n  \tModuleBuilder myModBldr = myAsmBldr.DefineDynamicModule(&quot;AdderExceptionMod&quot;);\n\n  \tTypeBuilder myTypeBldr = myModBldr.DefineType(&quot;Adder&quot;);\n\n \tType[] adderParams = new Type[] {typeof(int), typeof(int)};\n\n\t// This method will add two numbers which are 100 or less. If either of the\n\t// passed integer vales are greater than 100, it will return the value of -1.\n\n\tMethodBuilder adderBldr = myTypeBldr.DefineMethod(&quot;DoAdd&quot;,\n\t\t\t\t\t\t\tMethodAttributes.Public |\n\t\t\t\t\t\t   \tMethodAttributes.Static,\n\t\t\t\t\t\t   \ttypeof(int),\n\t\t\t\t\t\t   \tadderParams);\n\tILGenerator adderIL = adderBldr.GetILGenerator();\n\n\t// In order to successfully branch, we need to create labels\n\t// representing the offset IL instruction block to branch to.\n\t// These labels, when the MarkLabel(Label) method is invoked,\n\t// will specify the IL instruction to branch to.\n\t\t\t\t\t\t\t\t   \t\t\t\t\t\t\t\t\n\tLabel failed = adderIL.DefineLabel();\n\tLabel endOfMthd = adderIL.DefineLabel();\n\n\t// First, load argument 0 and the integer value of &quot;100&quot; onto the\n\t// stack. If arg0 &gt; 100, branch to the label &quot;failed&quot;, which is marked\n\t// as the address of the block that loads -1 onto the stack, bypassing\n\t// the addition.\n\n\tadderIL.Emit(OpCodes.Ldarg_0);\n\tadderIL.Emit(OpCodes.Ldc_I4_S, 100);\n\tadderIL.Emit(OpCodes.Bgt_S, failed); \n\n\t// Now, check to see if argument 1 was greater than 100. If it was,\n\t// branch to &quot;failed.&quot; Otherwise, fall through and perform the addition,\n\t// branching unconditionally to the instruction at the label &quot;endOfMthd&quot;.\n\n\tadderIL.Emit(OpCodes.Ldarg_1);\n\tadderIL.Emit(OpCodes.Ldc_I4_S, 100);\n\tadderIL.Emit(OpCodes.Bgt_S, failed);\n\n\tadderIL.Emit(OpCodes.Ldarg_0);\n\tadderIL.Emit(OpCodes.Ldarg_1);\n\tadderIL.Emit(OpCodes.Add_Ovf_Un);\n\tadderIL.Emit(OpCodes.Br_S, endOfMthd);\n\n\t// If this label is branched to (the failure case), load -1 onto the stack\n\t// and fall through to the return opcode.\n\tadderIL.MarkLabel(failed);\n\tadderIL.Emit(OpCodes.Ldc_I4_M1);\n\n\t// The end of the method. If both values were less than 100, the\n\t// correct result will return. If one of the arguments was greater\n\t// than 100, the result will be -1. \n\n\tadderIL.MarkLabel(endOfMthd);\n\tadderIL.Emit(OpCodes.Ret);\n\t\n\treturn myTypeBldr.CreateType();\n\n   }\n\n   public static void Main() {\n\n\tType adderType = BuildAdderType();\n\n\tobject addIns = Activator.CreateInstance(adderType); \n\n\tobject[] addParams = new object[2];\n\n\tConsole.Write(&quot;Enter an integer value: &quot;);\n\taddParams[0] = (object)Convert.ToInt32(Console.ReadLine());\n\n\tConsole.Write(&quot;Enter another integer value: &quot;);\n\taddParams[1] = (object)Convert.ToInt32(Console.ReadLine());\n\n\tConsole.WriteLine(&quot;---&quot;);\n\n\tint adderResult = (int)adderType.InvokeMember(&quot;DoAdd&quot;,\n\t\t\t\t\tBindingFlags.InvokeMethod,\n\t\t\t\t\tnull,\n\t\t\t\t\taddIns,\n\t\t\t\t\taddParams); \n\n\tif (adderResult != -1) {\n\n\t\tConsole.WriteLine(&quot;{0} + {1} = {2}&quot;, addParams[0], addParams[1],\n\t\t\t\t  adderResult);\n\n\t} else {\n\n\t\tConsole.WriteLine(&quot;One of the integers to add was greater than 100!&quot;);\n\n\t}\t\t\n            \n   }\n\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_Emit_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Emit(OpCode)</div>        \r\n          </div>\r\n    \r\n            <p>Puts the specified instruction onto the stream of instructions.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void Emit (System.Reflection.Emit.OpCode opcode);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>opcode</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.opcode\" data-linktype=\"relative-path\">OpCode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The Microsoft Intermediate Language (MSIL) instruction to be put onto the stream.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the <code>opcode</code> parameter requires an argument, the caller must ensure that the argument length matches the length of the declared parameter. Otherwise, results will be unpredictable. For example, if the Emit instruction requires a 2-byte operand and the caller supplies a 4-byte operand, the runtime will emit two additional bytes to the instruction stream. These extra bytes will be <a class=\"xref\" href=\"system.reflection.emit.opcodes#System_Reflection_Emit_OpCodes_Nop\" data-linktype=\"relative-path\">Nop</a> instructions.  </p>\n<p> The instruction values are defined in <a class=\"xref\" href=\"system.reflection.emit.opcodes\" data-linktype=\"relative-path\">OpCodes</a>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The code sample below demonstrates the use of <code>Emit</code> to generate MSIL output via an instance of <a class=\"xref\" href=\"system.reflection.emit.ilgenerator\" data-linktype=\"relative-path\">ILGenerator</a>.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Reflection.Emit.ILGenerator.Emit Example 2#1\">\nusing System;\nusing System.Threading;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\nclass DynamicJumpTableDemo\n\n{\n\n   public static Type BuildMyType()\n   {\n\tAppDomain myDomain = Thread.GetDomain();\n\tAssemblyName myAsmName = new AssemblyName();\n\tmyAsmName.Name = &quot;MyDynamicAssembly&quot;;\n\n\tAssemblyBuilder myAsmBuilder = myDomain.DefineDynamicAssembly(\n\t\t\t\t\t\tmyAsmName,\n\t\t\t\t\t\tAssemblyBuilderAccess.Run);\n\tModuleBuilder myModBuilder = myAsmBuilder.DefineDynamicModule(\n\t\t\t\t\t\t&quot;MyJumpTableDemo&quot;);\n\n\tTypeBuilder myTypeBuilder = myModBuilder.DefineType(&quot;JumpTableDemo&quot;,\n\t\t\t\t\t\t\tTypeAttributes.Public);\n\tMethodBuilder myMthdBuilder = myTypeBuilder.DefineMethod(&quot;SwitchMe&quot;, \n\t\t\t\t             MethodAttributes.Public |\n\t\t\t\t             MethodAttributes.Static,\n                                             typeof(string), \n                                             new Type[] {typeof(int)});\n\n\tILGenerator myIL = myMthdBuilder.GetILGenerator();\n\n\tLabel defaultCase = myIL.DefineLabel();\t\n\tLabel endOfMethod = myIL.DefineLabel();\t\n\n\t// We are initializing our jump table. Note that the labels\n\t// will be placed later using the MarkLabel method. \n\n\tLabel[] jumpTable = new Label[] { myIL.DefineLabel(),\n\t\t\t\t\t  myIL.DefineLabel(),\n\t\t\t\t\t  myIL.DefineLabel(),\n\t\t\t\t\t  myIL.DefineLabel(),\n\t\t\t\t\t  myIL.DefineLabel() };\n\n\t// arg0, the number we passed, is pushed onto the stack.\n\t// In this case, due to the design of the code sample,\n\t// the value pushed onto the stack happens to match the\n\t// index of the label (in IL terms, the index of the offset\n\t// in the jump table). If this is not the case, such as\n\t// when switching based on non-integer values, rules for the correspondence\n\t// between the possible case values and each index of the offsets\n\t// must be established outside of the ILGenerator.Emit calls,\n\t// much as a compiler would.\n\n\tmyIL.Emit(OpCodes.Ldarg_0);\n\tmyIL.Emit(OpCodes.Switch, jumpTable);\n\t\n\t// Branch on default case\n\tmyIL.Emit(OpCodes.Br_S, defaultCase);\n\n\t// Case arg0 = 0\n\tmyIL.MarkLabel(jumpTable[0]); \n\tmyIL.Emit(OpCodes.Ldstr, &quot;are no bananas&quot;);\n\tmyIL.Emit(OpCodes.Br_S, endOfMethod);\n\n\t// Case arg0 = 1\n\tmyIL.MarkLabel(jumpTable[1]); \n\tmyIL.Emit(OpCodes.Ldstr, &quot;is one banana&quot;);\n\tmyIL.Emit(OpCodes.Br_S, endOfMethod);\n\n\t// Case arg0 = 2\n\tmyIL.MarkLabel(jumpTable[2]); \n\tmyIL.Emit(OpCodes.Ldstr, &quot;are two bananas&quot;);\n\tmyIL.Emit(OpCodes.Br_S, endOfMethod);\n\n\t// Case arg0 = 3\n\tmyIL.MarkLabel(jumpTable[3]); \n\tmyIL.Emit(OpCodes.Ldstr, &quot;are three bananas&quot;);\n\tmyIL.Emit(OpCodes.Br_S, endOfMethod);\n\n\t// Case arg0 = 4\n\tmyIL.MarkLabel(jumpTable[4]); \n\tmyIL.Emit(OpCodes.Ldstr, &quot;are four bananas&quot;);\n\tmyIL.Emit(OpCodes.Br_S, endOfMethod);\n\n\t// Default case\n\tmyIL.MarkLabel(defaultCase);\n\tmyIL.Emit(OpCodes.Ldstr, &quot;are many bananas&quot;);\n\n\tmyIL.MarkLabel(endOfMethod);\n\tmyIL.Emit(OpCodes.Ret);\n\t\n\treturn myTypeBuilder.CreateType();\n\n   }\n\n   public static void Main()\n   {\n\tType myType = BuildMyType();\n\t\n\tConsole.Write(&quot;Enter an integer between 0 and 5: &quot;);\n\tint theValue = Convert.ToInt32(Console.ReadLine());\n\n\tConsole.WriteLine(&quot;---&quot;);\n\tObject myInstance = Activator.CreateInstance(myType, new object[0]);\t\n\tConsole.WriteLine(&quot;Yes, there {0} today!&quot;, myType.InvokeMember(&quot;SwitchMe&quot;,\n\t\t\t  \t\t           BindingFlags.InvokeMethod,\n\t\t\t  \t\t           null,\n\t\t\t  \t\t           myInstance,\n\t\t\t  \t\t           new object[] {theValue}));  \n\t\t\t  \n   }\n\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Reflection.Emit.ILGenerator.Emit Example 2#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Reflection;\nusing namespace System::Reflection::Emit;\nType^ BuildMyType()\n{\n   AppDomain^ myDomain = Thread::GetDomain();\n   AssemblyName^ myAsmName = gcnew AssemblyName;\n   myAsmName-&gt;Name = &quot;MyDynamicAssembly&quot;;\n   AssemblyBuilder^ myAsmBuilder = myDomain-&gt;DefineDynamicAssembly( myAsmName, AssemblyBuilderAccess::Run );\n   ModuleBuilder^ myModBuilder = myAsmBuilder-&gt;DefineDynamicModule( &quot;MyJumpTableDemo&quot; );\n   TypeBuilder^ myTypeBuilder = myModBuilder-&gt;DefineType( &quot;JumpTableDemo&quot;, TypeAttributes::Public );\n   array&lt;Type^&gt;^temp0 = {int::typeid};\n   MethodBuilder^ myMthdBuilder = myTypeBuilder-&gt;DefineMethod( &quot;SwitchMe&quot;, static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::Static), String::typeid, temp0 );\n   ILGenerator^ myIL = myMthdBuilder-&gt;GetILGenerator();\n   Label defaultCase = myIL-&gt;DefineLabel();\n   Label endOfMethod = myIL-&gt;DefineLabel();\n   \n   // We are initializing our jump table. Note that the labels\n   // will be placed later using the MarkLabel method.\n   array&lt;Label&gt;^jumpTable = gcnew array&lt;Label&gt;(5);\n   jumpTable[ 0 ] = myIL-&gt;DefineLabel();\n   jumpTable[ 1 ] = myIL-&gt;DefineLabel();\n   jumpTable[ 2 ] = myIL-&gt;DefineLabel();\n   jumpTable[ 3 ] = myIL-&gt;DefineLabel();\n   jumpTable[ 4 ] = myIL-&gt;DefineLabel();\n   \n   // arg0, the number we passed, is pushed onto the stack.\n   // In this case, due to the design of the code sample,\n   // the value pushed onto the stack happens to match the\n   // index of the label (in IL terms, the index of the offset\n   // in the jump table). If this is not the case, such as\n   // when switching based on non-integer values, rules for the correspondence\n   // between the possible case values and each index of the offsets\n   // must be established outside of the ILGenerator::Emit calls,\n   // much as a compiler would.\n   myIL-&gt;Emit( OpCodes::Ldarg_0 );\n   myIL-&gt;Emit( OpCodes::Switch, jumpTable );\n   \n   // Branch on default case\n   myIL-&gt;Emit( OpCodes::Br_S, defaultCase );\n   \n   // Case arg0 = 0\n   myIL-&gt;MarkLabel( jumpTable[ 0 ] );\n   myIL-&gt;Emit( OpCodes::Ldstr, &quot;are no bananas&quot; );\n   myIL-&gt;Emit( OpCodes::Br_S, endOfMethod );\n   \n   // Case arg0 = 1\n   myIL-&gt;MarkLabel( jumpTable[ 1 ] );\n   myIL-&gt;Emit( OpCodes::Ldstr, &quot;is one banana&quot; );\n   myIL-&gt;Emit( OpCodes::Br_S, endOfMethod );\n   \n   // Case arg0 = 2\n   myIL-&gt;MarkLabel( jumpTable[ 2 ] );\n   myIL-&gt;Emit( OpCodes::Ldstr, &quot;are two bananas&quot; );\n   myIL-&gt;Emit( OpCodes::Br_S, endOfMethod );\n   \n   // Case arg0 = 3\n   myIL-&gt;MarkLabel( jumpTable[ 3 ] );\n   myIL-&gt;Emit( OpCodes::Ldstr, &quot;are three bananas&quot; );\n   myIL-&gt;Emit( OpCodes::Br_S, endOfMethod );\n   \n   // Case arg0 = 4\n   myIL-&gt;MarkLabel( jumpTable[ 4 ] );\n   myIL-&gt;Emit( OpCodes::Ldstr, &quot;are four bananas&quot; );\n   myIL-&gt;Emit( OpCodes::Br_S, endOfMethod );\n   \n   // Default case\n   myIL-&gt;MarkLabel( defaultCase );\n   myIL-&gt;Emit( OpCodes::Ldstr, &quot;are many bananas&quot; );\n   myIL-&gt;MarkLabel( endOfMethod );\n   myIL-&gt;Emit( OpCodes::Ret );\n   return myTypeBuilder-&gt;CreateType();\n}\n\nint main()\n{\n   Type^ myType = BuildMyType();\n   Console::Write( &quot;Enter an integer between 0 and 5: &quot; );\n   int theValue = Convert::ToInt32( Console::ReadLine() );\n   Console::WriteLine( &quot;---&quot; );\n   Object^ myInstance = Activator::CreateInstance( myType, gcnew array&lt;Object^&gt;(0) );\n   array&lt;Object^&gt;^temp1 = {theValue};\n   Console::WriteLine( &quot;Yes, there {0} today!&quot;, myType-&gt;InvokeMember( &quot;SwitchMe&quot;, BindingFlags::InvokeMethod, nullptr, myInstance, temp1 ) );\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Reflection.Emit.ILGenerator.Emit Example 2#1\">\nImports System\nImports System.Threading\nImports System.Reflection\nImports System.Reflection.Emit\n\n _\n\nClass DynamicJumpTableDemo\n   \n   Public Shared Function BuildMyType() As Type\n\n      Dim myDomain As AppDomain = Thread.GetDomain()\n      Dim myAsmName As New AssemblyName()\n      myAsmName.Name = &quot;MyDynamicAssembly&quot;\n      \n      Dim myAsmBuilder As AssemblyBuilder = myDomain.DefineDynamicAssembly(myAsmName, _\n\t\t\t\t\t\t\tAssemblyBuilderAccess.Run)\n      Dim myModBuilder As ModuleBuilder = myAsmBuilder.DefineDynamicModule(&quot;MyJumpTableDemo&quot;)\n      \n      Dim myTypeBuilder As TypeBuilder = myModBuilder.DefineType(&quot;JumpTableDemo&quot;, _\n\t\t\t\t\t\t\t\t TypeAttributes.Public)\n      Dim myMthdBuilder As MethodBuilder = myTypeBuilder.DefineMethod(&quot;SwitchMe&quot;, _\n\t\t\t\t\t\tMethodAttributes.Public Or MethodAttributes.Static, _\n\t\t\t\t\t\tGetType(String), New Type() {GetType(Integer)})\n      \n      Dim myIL As ILGenerator = myMthdBuilder.GetILGenerator()\n      \n      Dim defaultCase As Label = myIL.DefineLabel()\n      Dim endOfMethod As Label = myIL.DefineLabel()\n      \n      &#39; We are initializing our jump table. Note that the labels\n      &#39; will be placed later using the MarkLabel method. \n\n      Dim jumpTable() As Label = {myIL.DefineLabel(), _\n\t\t\t\t  myIL.DefineLabel(), _\n\t\t\t\t  myIL.DefineLabel(), _\n\t\t\t\t  myIL.DefineLabel(), _\n\t\t\t\t  myIL.DefineLabel()}\n      \n      &#39; arg0, the number we passed, is pushed onto the stack.\n      &#39; In this case, due to the design of the code sample,\n      &#39; the value pushed onto the stack happens to match the\n      &#39; index of the label (in IL terms, the index of the offset\n      &#39; in the jump table). If this is not the case, such as\n      &#39; when switching based on non-integer values, rules for the correspondence\n      &#39; between the possible case values and each index of the offsets\n      &#39; must be established outside of the ILGenerator.Emit calls,\n      &#39; much as a compiler would.\n\n      myIL.Emit(OpCodes.Ldarg_0)\n      myIL.Emit(OpCodes.Switch, jumpTable)\n      \n      &#39; Branch on default case\n      myIL.Emit(OpCodes.Br_S, defaultCase)\n      \n      &#39; Case arg0 = 0\n      myIL.MarkLabel(jumpTable(0))\n      myIL.Emit(OpCodes.Ldstr, &quot;are no bananas&quot;)\n      myIL.Emit(OpCodes.Br_S, endOfMethod)\n      \n      &#39; Case arg0 = 1\n      myIL.MarkLabel(jumpTable(1))\n      myIL.Emit(OpCodes.Ldstr, &quot;is one banana&quot;)\n      myIL.Emit(OpCodes.Br_S, endOfMethod)\n      \n      &#39; Case arg0 = 2\n      myIL.MarkLabel(jumpTable(2))\n      myIL.Emit(OpCodes.Ldstr, &quot;are two bananas&quot;)\n      myIL.Emit(OpCodes.Br_S, endOfMethod)\n      \n      &#39; Case arg0 = 3\n      myIL.MarkLabel(jumpTable(3))\n      myIL.Emit(OpCodes.Ldstr, &quot;are three bananas&quot;)\n      myIL.Emit(OpCodes.Br_S, endOfMethod)\n      \n      &#39; Case arg0 = 4\n      myIL.MarkLabel(jumpTable(4))\n      myIL.Emit(OpCodes.Ldstr, &quot;are four bananas&quot;)\n      myIL.Emit(OpCodes.Br_S, endOfMethod)\n      \n      &#39; Default case\n      myIL.MarkLabel(defaultCase)\n      myIL.Emit(OpCodes.Ldstr, &quot;are many bananas&quot;)\n      \n      myIL.MarkLabel(endOfMethod)\n      myIL.Emit(OpCodes.Ret)\n      \n      Return myTypeBuilder.CreateType()\n\n   End Function &#39;BuildMyType\n    \n   \n   Public Shared Sub Main()\n\n      Dim myType As Type = BuildMyType()\n      \n      Console.Write(&quot;Enter an integer between 0 and 5: &quot;)\n      Dim theValue As Integer = Convert.ToInt32(Console.ReadLine())\n      \n      Console.WriteLine(&quot;---&quot;)\n      Dim myInstance As [Object] = Activator.CreateInstance(myType, New Object() {})\n      Console.WriteLine(&quot;Yes, there {0} today!&quot;, myType.InvokeMember(&quot;SwitchMe&quot;, _\n\t\t\t\t\t\t BindingFlags.InvokeMethod, Nothing, _\n\t\t\t\t\t         myInstance, New Object() {theValue}))\n\n   End Sub &#39;Main\n\nEnd Class &#39;DynamicJumpTableDemo\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Byte_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_Emit_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Emit(OpCode,Byte)</div>        \r\n          </div>\r\n    \r\n            <p>Puts the specified instruction and character argument onto the Microsoft intermediate language (MSIL) stream of instructions.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void Emit (System.Reflection.Emit.OpCode opcode, byte arg);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>opcode</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.opcode\" data-linktype=\"relative-path\">OpCode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The MSIL instruction to be put onto the stream.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>arg</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.byte\" data-linktype=\"relative-path\">Byte</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The character argument pushed onto the stream immediately after the instruction.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The instruction values are defined in the <code>OpCodes</code> enumeration.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Double_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_Emit_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Emit(OpCode,Double)</div>        \r\n          </div>\r\n    \r\n            <p>Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void Emit (System.Reflection.Emit.OpCode opcode, double arg);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>opcode</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.opcode\" data-linktype=\"relative-path\">OpCode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The MSIL instruction to be put onto the stream. Defined in the <code>OpCodes</code> enumeration.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>arg</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.double\" data-linktype=\"relative-path\">Double</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The numerical argument pushed onto the stream immediately after the instruction.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The instruction values are defined in the <code>OpCodes</code> enumeration.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Int16_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_Emit_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Emit(OpCode,Int16)</div>        \r\n          </div>\r\n    \r\n            <p>Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void Emit (System.Reflection.Emit.OpCode opcode, short arg);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>opcode</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.opcode\" data-linktype=\"relative-path\">OpCode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The MSIL instruction to be emitted onto the stream.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>arg</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int16\" data-linktype=\"relative-path\">Int16</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <code>Int</code> argument pushed onto the stream immediately after the instruction.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The instruction values are defined in the <code>OpCodes</code> enumeration.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Int32_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_Emit_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Emit(OpCode,Int32)</div>        \r\n          </div>\r\n    \r\n            <p>Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void Emit (System.Reflection.Emit.OpCode opcode, int arg);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>opcode</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.opcode\" data-linktype=\"relative-path\">OpCode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The MSIL instruction to be put onto the stream.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>arg</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The numerical argument pushed onto the stream immediately after the instruction.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The instruction values are defined in the <code>OpCodes</code> enumeration.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Int64_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_Emit_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Emit(OpCode,Int64)</div>        \r\n          </div>\r\n    \r\n            <p>Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void Emit (System.Reflection.Emit.OpCode opcode, long arg);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>opcode</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.opcode\" data-linktype=\"relative-path\">OpCode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The MSIL instruction to be put onto the stream.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>arg</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The numerical argument pushed onto the stream immediately after the instruction.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The instruction values are defined in the <code>OpCodes</code> enumeration.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Reflection_ConstructorInfo_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_Emit_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Emit(OpCode,ConstructorInfo)</div>        \r\n          </div>\r\n    \r\n            <p>Puts the specified instruction and metadata token for the specified constructor onto the Microsoft intermediate language (MSIL) stream of instructions.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.ConstructorInfo con);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>opcode</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.opcode\" data-linktype=\"relative-path\">OpCode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The MSIL instruction to be emitted onto the stream.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>con</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.constructorinfo\" data-linktype=\"relative-path\">ConstructorInfo</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <code>ConstructorInfo</code> representing a constructor.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>con</code> is <code>null</code>. This exception is new in the .NET Framework 4.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The instruction values are defined in the <code>OpCodes</code> enumeration.  </p>\n<p> The location of <code>con</code> is recorded so that the instruction stream can be patched if necessary when persisting the module to a portable executable (PE) file.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Reflection_Emit_Label_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_Emit_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Emit(OpCode,Label)</div>        \r\n          </div>\r\n    \r\n            <p>Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream and leaves space to include a label when fixes are done.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.Label label);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>opcode</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.opcode\" data-linktype=\"relative-path\">OpCode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The MSIL instruction to be emitted onto the stream.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>label</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.label\" data-linktype=\"relative-path\">Label</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The label to which to branch from this location.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The instruction values are defined in the <code>OpCodes</code> enumeration.  </p>\n<p> Labels are created using <a class=\"xref\" href=\"system.reflection.emit.ilgenerator#System_Reflection_Emit_ILGenerator_DefineLabel_\" data-linktype=\"relative-path\">DefineLabel</a>, and their location within the stream is fixed by using <a class=\"xref\" href=\"system.reflection.emit.ilgenerator#System_Reflection_Emit_ILGenerator_MarkLabel_\" data-linktype=\"relative-path\">MarkLabel</a>. If a single-byte instruction is used, the label can represent a jump of at most 127 bytes along the stream. <code>opcode</code> must represent a branch instruction. Because branches are relative instructions, <code>label</code> will be replaced with the correct offset to branch during the fixup process.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The code sample below illustrates the creation of a dynamic method with a jump table. The jump table is built using an array of <a class=\"xref\" href=\"system.reflection.emit.label\" data-linktype=\"relative-path\">Label</a>.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Reflection.Emit.ILGenerator.Emit Example 2#1\">\nusing System;\nusing System.Threading;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\nclass DynamicJumpTableDemo\n\n{\n\n   public static Type BuildMyType()\n   {\n\tAppDomain myDomain = Thread.GetDomain();\n\tAssemblyName myAsmName = new AssemblyName();\n\tmyAsmName.Name = &quot;MyDynamicAssembly&quot;;\n\n\tAssemblyBuilder myAsmBuilder = myDomain.DefineDynamicAssembly(\n\t\t\t\t\t\tmyAsmName,\n\t\t\t\t\t\tAssemblyBuilderAccess.Run);\n\tModuleBuilder myModBuilder = myAsmBuilder.DefineDynamicModule(\n\t\t\t\t\t\t&quot;MyJumpTableDemo&quot;);\n\n\tTypeBuilder myTypeBuilder = myModBuilder.DefineType(&quot;JumpTableDemo&quot;,\n\t\t\t\t\t\t\tTypeAttributes.Public);\n\tMethodBuilder myMthdBuilder = myTypeBuilder.DefineMethod(&quot;SwitchMe&quot;, \n\t\t\t\t             MethodAttributes.Public |\n\t\t\t\t             MethodAttributes.Static,\n                                             typeof(string), \n                                             new Type[] {typeof(int)});\n\n\tILGenerator myIL = myMthdBuilder.GetILGenerator();\n\n\tLabel defaultCase = myIL.DefineLabel();\t\n\tLabel endOfMethod = myIL.DefineLabel();\t\n\n\t// We are initializing our jump table. Note that the labels\n\t// will be placed later using the MarkLabel method. \n\n\tLabel[] jumpTable = new Label[] { myIL.DefineLabel(),\n\t\t\t\t\t  myIL.DefineLabel(),\n\t\t\t\t\t  myIL.DefineLabel(),\n\t\t\t\t\t  myIL.DefineLabel(),\n\t\t\t\t\t  myIL.DefineLabel() };\n\n\t// arg0, the number we passed, is pushed onto the stack.\n\t// In this case, due to the design of the code sample,\n\t// the value pushed onto the stack happens to match the\n\t// index of the label (in IL terms, the index of the offset\n\t// in the jump table). If this is not the case, such as\n\t// when switching based on non-integer values, rules for the correspondence\n\t// between the possible case values and each index of the offsets\n\t// must be established outside of the ILGenerator.Emit calls,\n\t// much as a compiler would.\n\n\tmyIL.Emit(OpCodes.Ldarg_0);\n\tmyIL.Emit(OpCodes.Switch, jumpTable);\n\t\n\t// Branch on default case\n\tmyIL.Emit(OpCodes.Br_S, defaultCase);\n\n\t// Case arg0 = 0\n\tmyIL.MarkLabel(jumpTable[0]); \n\tmyIL.Emit(OpCodes.Ldstr, &quot;are no bananas&quot;);\n\tmyIL.Emit(OpCodes.Br_S, endOfMethod);\n\n\t// Case arg0 = 1\n\tmyIL.MarkLabel(jumpTable[1]); \n\tmyIL.Emit(OpCodes.Ldstr, &quot;is one banana&quot;);\n\tmyIL.Emit(OpCodes.Br_S, endOfMethod);\n\n\t// Case arg0 = 2\n\tmyIL.MarkLabel(jumpTable[2]); \n\tmyIL.Emit(OpCodes.Ldstr, &quot;are two bananas&quot;);\n\tmyIL.Emit(OpCodes.Br_S, endOfMethod);\n\n\t// Case arg0 = 3\n\tmyIL.MarkLabel(jumpTable[3]); \n\tmyIL.Emit(OpCodes.Ldstr, &quot;are three bananas&quot;);\n\tmyIL.Emit(OpCodes.Br_S, endOfMethod);\n\n\t// Case arg0 = 4\n\tmyIL.MarkLabel(jumpTable[4]); \n\tmyIL.Emit(OpCodes.Ldstr, &quot;are four bananas&quot;);\n\tmyIL.Emit(OpCodes.Br_S, endOfMethod);\n\n\t// Default case\n\tmyIL.MarkLabel(defaultCase);\n\tmyIL.Emit(OpCodes.Ldstr, &quot;are many bananas&quot;);\n\n\tmyIL.MarkLabel(endOfMethod);\n\tmyIL.Emit(OpCodes.Ret);\n\t\n\treturn myTypeBuilder.CreateType();\n\n   }\n\n   public static void Main()\n   {\n\tType myType = BuildMyType();\n\t\n\tConsole.Write(&quot;Enter an integer between 0 and 5: &quot;);\n\tint theValue = Convert.ToInt32(Console.ReadLine());\n\n\tConsole.WriteLine(&quot;---&quot;);\n\tObject myInstance = Activator.CreateInstance(myType, new object[0]);\t\n\tConsole.WriteLine(&quot;Yes, there {0} today!&quot;, myType.InvokeMember(&quot;SwitchMe&quot;,\n\t\t\t  \t\t           BindingFlags.InvokeMethod,\n\t\t\t  \t\t           null,\n\t\t\t  \t\t           myInstance,\n\t\t\t  \t\t           new object[] {theValue}));  \n\t\t\t  \n   }\n\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Reflection.Emit.ILGenerator.Emit Example 2#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Reflection;\nusing namespace System::Reflection::Emit;\nType^ BuildMyType()\n{\n   AppDomain^ myDomain = Thread::GetDomain();\n   AssemblyName^ myAsmName = gcnew AssemblyName;\n   myAsmName-&gt;Name = &quot;MyDynamicAssembly&quot;;\n   AssemblyBuilder^ myAsmBuilder = myDomain-&gt;DefineDynamicAssembly( myAsmName, AssemblyBuilderAccess::Run );\n   ModuleBuilder^ myModBuilder = myAsmBuilder-&gt;DefineDynamicModule( &quot;MyJumpTableDemo&quot; );\n   TypeBuilder^ myTypeBuilder = myModBuilder-&gt;DefineType( &quot;JumpTableDemo&quot;, TypeAttributes::Public );\n   array&lt;Type^&gt;^temp0 = {int::typeid};\n   MethodBuilder^ myMthdBuilder = myTypeBuilder-&gt;DefineMethod( &quot;SwitchMe&quot;, static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::Static), String::typeid, temp0 );\n   ILGenerator^ myIL = myMthdBuilder-&gt;GetILGenerator();\n   Label defaultCase = myIL-&gt;DefineLabel();\n   Label endOfMethod = myIL-&gt;DefineLabel();\n   \n   // We are initializing our jump table. Note that the labels\n   // will be placed later using the MarkLabel method.\n   array&lt;Label&gt;^jumpTable = gcnew array&lt;Label&gt;(5);\n   jumpTable[ 0 ] = myIL-&gt;DefineLabel();\n   jumpTable[ 1 ] = myIL-&gt;DefineLabel();\n   jumpTable[ 2 ] = myIL-&gt;DefineLabel();\n   jumpTable[ 3 ] = myIL-&gt;DefineLabel();\n   jumpTable[ 4 ] = myIL-&gt;DefineLabel();\n   \n   // arg0, the number we passed, is pushed onto the stack.\n   // In this case, due to the design of the code sample,\n   // the value pushed onto the stack happens to match the\n   // index of the label (in IL terms, the index of the offset\n   // in the jump table). If this is not the case, such as\n   // when switching based on non-integer values, rules for the correspondence\n   // between the possible case values and each index of the offsets\n   // must be established outside of the ILGenerator::Emit calls,\n   // much as a compiler would.\n   myIL-&gt;Emit( OpCodes::Ldarg_0 );\n   myIL-&gt;Emit( OpCodes::Switch, jumpTable );\n   \n   // Branch on default case\n   myIL-&gt;Emit( OpCodes::Br_S, defaultCase );\n   \n   // Case arg0 = 0\n   myIL-&gt;MarkLabel( jumpTable[ 0 ] );\n   myIL-&gt;Emit( OpCodes::Ldstr, &quot;are no bananas&quot; );\n   myIL-&gt;Emit( OpCodes::Br_S, endOfMethod );\n   \n   // Case arg0 = 1\n   myIL-&gt;MarkLabel( jumpTable[ 1 ] );\n   myIL-&gt;Emit( OpCodes::Ldstr, &quot;is one banana&quot; );\n   myIL-&gt;Emit( OpCodes::Br_S, endOfMethod );\n   \n   // Case arg0 = 2\n   myIL-&gt;MarkLabel( jumpTable[ 2 ] );\n   myIL-&gt;Emit( OpCodes::Ldstr, &quot;are two bananas&quot; );\n   myIL-&gt;Emit( OpCodes::Br_S, endOfMethod );\n   \n   // Case arg0 = 3\n   myIL-&gt;MarkLabel( jumpTable[ 3 ] );\n   myIL-&gt;Emit( OpCodes::Ldstr, &quot;are three bananas&quot; );\n   myIL-&gt;Emit( OpCodes::Br_S, endOfMethod );\n   \n   // Case arg0 = 4\n   myIL-&gt;MarkLabel( jumpTable[ 4 ] );\n   myIL-&gt;Emit( OpCodes::Ldstr, &quot;are four bananas&quot; );\n   myIL-&gt;Emit( OpCodes::Br_S, endOfMethod );\n   \n   // Default case\n   myIL-&gt;MarkLabel( defaultCase );\n   myIL-&gt;Emit( OpCodes::Ldstr, &quot;are many bananas&quot; );\n   myIL-&gt;MarkLabel( endOfMethod );\n   myIL-&gt;Emit( OpCodes::Ret );\n   return myTypeBuilder-&gt;CreateType();\n}\n\nint main()\n{\n   Type^ myType = BuildMyType();\n   Console::Write( &quot;Enter an integer between 0 and 5: &quot; );\n   int theValue = Convert::ToInt32( Console::ReadLine() );\n   Console::WriteLine( &quot;---&quot; );\n   Object^ myInstance = Activator::CreateInstance( myType, gcnew array&lt;Object^&gt;(0) );\n   array&lt;Object^&gt;^temp1 = {theValue};\n   Console::WriteLine( &quot;Yes, there {0} today!&quot;, myType-&gt;InvokeMember( &quot;SwitchMe&quot;, BindingFlags::InvokeMethod, nullptr, myInstance, temp1 ) );\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Reflection.Emit.ILGenerator.Emit Example 2#1\">\nImports System\nImports System.Threading\nImports System.Reflection\nImports System.Reflection.Emit\n\n _\n\nClass DynamicJumpTableDemo\n   \n   Public Shared Function BuildMyType() As Type\n\n      Dim myDomain As AppDomain = Thread.GetDomain()\n      Dim myAsmName As New AssemblyName()\n      myAsmName.Name = &quot;MyDynamicAssembly&quot;\n      \n      Dim myAsmBuilder As AssemblyBuilder = myDomain.DefineDynamicAssembly(myAsmName, _\n\t\t\t\t\t\t\tAssemblyBuilderAccess.Run)\n      Dim myModBuilder As ModuleBuilder = myAsmBuilder.DefineDynamicModule(&quot;MyJumpTableDemo&quot;)\n      \n      Dim myTypeBuilder As TypeBuilder = myModBuilder.DefineType(&quot;JumpTableDemo&quot;, _\n\t\t\t\t\t\t\t\t TypeAttributes.Public)\n      Dim myMthdBuilder As MethodBuilder = myTypeBuilder.DefineMethod(&quot;SwitchMe&quot;, _\n\t\t\t\t\t\tMethodAttributes.Public Or MethodAttributes.Static, _\n\t\t\t\t\t\tGetType(String), New Type() {GetType(Integer)})\n      \n      Dim myIL As ILGenerator = myMthdBuilder.GetILGenerator()\n      \n      Dim defaultCase As Label = myIL.DefineLabel()\n      Dim endOfMethod As Label = myIL.DefineLabel()\n      \n      &#39; We are initializing our jump table. Note that the labels\n      &#39; will be placed later using the MarkLabel method. \n\n      Dim jumpTable() As Label = {myIL.DefineLabel(), _\n\t\t\t\t  myIL.DefineLabel(), _\n\t\t\t\t  myIL.DefineLabel(), _\n\t\t\t\t  myIL.DefineLabel(), _\n\t\t\t\t  myIL.DefineLabel()}\n      \n      &#39; arg0, the number we passed, is pushed onto the stack.\n      &#39; In this case, due to the design of the code sample,\n      &#39; the value pushed onto the stack happens to match the\n      &#39; index of the label (in IL terms, the index of the offset\n      &#39; in the jump table). If this is not the case, such as\n      &#39; when switching based on non-integer values, rules for the correspondence\n      &#39; between the possible case values and each index of the offsets\n      &#39; must be established outside of the ILGenerator.Emit calls,\n      &#39; much as a compiler would.\n\n      myIL.Emit(OpCodes.Ldarg_0)\n      myIL.Emit(OpCodes.Switch, jumpTable)\n      \n      &#39; Branch on default case\n      myIL.Emit(OpCodes.Br_S, defaultCase)\n      \n      &#39; Case arg0 = 0\n      myIL.MarkLabel(jumpTable(0))\n      myIL.Emit(OpCodes.Ldstr, &quot;are no bananas&quot;)\n      myIL.Emit(OpCodes.Br_S, endOfMethod)\n      \n      &#39; Case arg0 = 1\n      myIL.MarkLabel(jumpTable(1))\n      myIL.Emit(OpCodes.Ldstr, &quot;is one banana&quot;)\n      myIL.Emit(OpCodes.Br_S, endOfMethod)\n      \n      &#39; Case arg0 = 2\n      myIL.MarkLabel(jumpTable(2))\n      myIL.Emit(OpCodes.Ldstr, &quot;are two bananas&quot;)\n      myIL.Emit(OpCodes.Br_S, endOfMethod)\n      \n      &#39; Case arg0 = 3\n      myIL.MarkLabel(jumpTable(3))\n      myIL.Emit(OpCodes.Ldstr, &quot;are three bananas&quot;)\n      myIL.Emit(OpCodes.Br_S, endOfMethod)\n      \n      &#39; Case arg0 = 4\n      myIL.MarkLabel(jumpTable(4))\n      myIL.Emit(OpCodes.Ldstr, &quot;are four bananas&quot;)\n      myIL.Emit(OpCodes.Br_S, endOfMethod)\n      \n      &#39; Default case\n      myIL.MarkLabel(defaultCase)\n      myIL.Emit(OpCodes.Ldstr, &quot;are many bananas&quot;)\n      \n      myIL.MarkLabel(endOfMethod)\n      myIL.Emit(OpCodes.Ret)\n      \n      Return myTypeBuilder.CreateType()\n\n   End Function &#39;BuildMyType\n    \n   \n   Public Shared Sub Main()\n\n      Dim myType As Type = BuildMyType()\n      \n      Console.Write(&quot;Enter an integer between 0 and 5: &quot;)\n      Dim theValue As Integer = Convert.ToInt32(Console.ReadLine())\n      \n      Console.WriteLine(&quot;---&quot;)\n      Dim myInstance As [Object] = Activator.CreateInstance(myType, New Object() {})\n      Console.WriteLine(&quot;Yes, there {0} today!&quot;, myType.InvokeMember(&quot;SwitchMe&quot;, _\n\t\t\t\t\t\t BindingFlags.InvokeMethod, Nothing, _\n\t\t\t\t\t         myInstance, New Object() {theValue}))\n\n   End Sub &#39;Main\n\nEnd Class &#39;DynamicJumpTableDemo\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Reflection_Emit_Label___\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_Emit_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Emit(OpCode,Label[])</div>        \r\n          </div>\r\n    \r\n            <p>Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream and leaves space to include a label when fixes are done.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.Label[] labels);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>opcode</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.opcode\" data-linktype=\"relative-path\">OpCode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The MSIL instruction to be emitted onto the stream.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>labels</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.label\" data-linktype=\"relative-path\">Label</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The array of label objects to which to branch from this location. All of the labels will be used.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>con</code> is <code>null</code>. This exception is new in the .NET Framework 4.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Emits a switch table.  </p>\n<p> The instruction values are defined in the <code>OpCodes</code> enumeration.  </p>\n<p> Labels are created using <a class=\"xref\" href=\"system.reflection.emit.ilgenerator#System_Reflection_Emit_ILGenerator_DefineLabel_\" data-linktype=\"relative-path\">DefineLabel</a> and their location within the stream is fixed by using <a class=\"xref\" href=\"system.reflection.emit.ilgenerator#System_Reflection_Emit_ILGenerator_MarkLabel_\" data-linktype=\"relative-path\">MarkLabel</a>. If a single-byte instruction is used, the label can represent a jump of at most 127 bytes along the stream. <code>opcode</code> must represent a branch instruction. Because branches are relative instructions, <code>label</code> will be replaced with the correct offset to branch during the fixup process.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The code sample below illustrates the creation of a dynamic method with a jump table. The jump table is built using an array of <a class=\"xref\" href=\"system.reflection.emit.label\" data-linktype=\"relative-path\">Label</a>.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Reflection.Emit.ILGenerator.Emit Example 2#1\">\nusing System;\nusing System.Threading;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\nclass DynamicJumpTableDemo\n\n{\n\n   public static Type BuildMyType()\n   {\n\tAppDomain myDomain = Thread.GetDomain();\n\tAssemblyName myAsmName = new AssemblyName();\n\tmyAsmName.Name = &quot;MyDynamicAssembly&quot;;\n\n\tAssemblyBuilder myAsmBuilder = myDomain.DefineDynamicAssembly(\n\t\t\t\t\t\tmyAsmName,\n\t\t\t\t\t\tAssemblyBuilderAccess.Run);\n\tModuleBuilder myModBuilder = myAsmBuilder.DefineDynamicModule(\n\t\t\t\t\t\t&quot;MyJumpTableDemo&quot;);\n\n\tTypeBuilder myTypeBuilder = myModBuilder.DefineType(&quot;JumpTableDemo&quot;,\n\t\t\t\t\t\t\tTypeAttributes.Public);\n\tMethodBuilder myMthdBuilder = myTypeBuilder.DefineMethod(&quot;SwitchMe&quot;, \n\t\t\t\t             MethodAttributes.Public |\n\t\t\t\t             MethodAttributes.Static,\n                                             typeof(string), \n                                             new Type[] {typeof(int)});\n\n\tILGenerator myIL = myMthdBuilder.GetILGenerator();\n\n\tLabel defaultCase = myIL.DefineLabel();\t\n\tLabel endOfMethod = myIL.DefineLabel();\t\n\n\t// We are initializing our jump table. Note that the labels\n\t// will be placed later using the MarkLabel method. \n\n\tLabel[] jumpTable = new Label[] { myIL.DefineLabel(),\n\t\t\t\t\t  myIL.DefineLabel(),\n\t\t\t\t\t  myIL.DefineLabel(),\n\t\t\t\t\t  myIL.DefineLabel(),\n\t\t\t\t\t  myIL.DefineLabel() };\n\n\t// arg0, the number we passed, is pushed onto the stack.\n\t// In this case, due to the design of the code sample,\n\t// the value pushed onto the stack happens to match the\n\t// index of the label (in IL terms, the index of the offset\n\t// in the jump table). If this is not the case, such as\n\t// when switching based on non-integer values, rules for the correspondence\n\t// between the possible case values and each index of the offsets\n\t// must be established outside of the ILGenerator.Emit calls,\n\t// much as a compiler would.\n\n\tmyIL.Emit(OpCodes.Ldarg_0);\n\tmyIL.Emit(OpCodes.Switch, jumpTable);\n\t\n\t// Branch on default case\n\tmyIL.Emit(OpCodes.Br_S, defaultCase);\n\n\t// Case arg0 = 0\n\tmyIL.MarkLabel(jumpTable[0]); \n\tmyIL.Emit(OpCodes.Ldstr, &quot;are no bananas&quot;);\n\tmyIL.Emit(OpCodes.Br_S, endOfMethod);\n\n\t// Case arg0 = 1\n\tmyIL.MarkLabel(jumpTable[1]); \n\tmyIL.Emit(OpCodes.Ldstr, &quot;is one banana&quot;);\n\tmyIL.Emit(OpCodes.Br_S, endOfMethod);\n\n\t// Case arg0 = 2\n\tmyIL.MarkLabel(jumpTable[2]); \n\tmyIL.Emit(OpCodes.Ldstr, &quot;are two bananas&quot;);\n\tmyIL.Emit(OpCodes.Br_S, endOfMethod);\n\n\t// Case arg0 = 3\n\tmyIL.MarkLabel(jumpTable[3]); \n\tmyIL.Emit(OpCodes.Ldstr, &quot;are three bananas&quot;);\n\tmyIL.Emit(OpCodes.Br_S, endOfMethod);\n\n\t// Case arg0 = 4\n\tmyIL.MarkLabel(jumpTable[4]); \n\tmyIL.Emit(OpCodes.Ldstr, &quot;are four bananas&quot;);\n\tmyIL.Emit(OpCodes.Br_S, endOfMethod);\n\n\t// Default case\n\tmyIL.MarkLabel(defaultCase);\n\tmyIL.Emit(OpCodes.Ldstr, &quot;are many bananas&quot;);\n\n\tmyIL.MarkLabel(endOfMethod);\n\tmyIL.Emit(OpCodes.Ret);\n\t\n\treturn myTypeBuilder.CreateType();\n\n   }\n\n   public static void Main()\n   {\n\tType myType = BuildMyType();\n\t\n\tConsole.Write(&quot;Enter an integer between 0 and 5: &quot;);\n\tint theValue = Convert.ToInt32(Console.ReadLine());\n\n\tConsole.WriteLine(&quot;---&quot;);\n\tObject myInstance = Activator.CreateInstance(myType, new object[0]);\t\n\tConsole.WriteLine(&quot;Yes, there {0} today!&quot;, myType.InvokeMember(&quot;SwitchMe&quot;,\n\t\t\t  \t\t           BindingFlags.InvokeMethod,\n\t\t\t  \t\t           null,\n\t\t\t  \t\t           myInstance,\n\t\t\t  \t\t           new object[] {theValue}));  \n\t\t\t  \n   }\n\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Reflection.Emit.ILGenerator.Emit Example 2#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Reflection;\nusing namespace System::Reflection::Emit;\nType^ BuildMyType()\n{\n   AppDomain^ myDomain = Thread::GetDomain();\n   AssemblyName^ myAsmName = gcnew AssemblyName;\n   myAsmName-&gt;Name = &quot;MyDynamicAssembly&quot;;\n   AssemblyBuilder^ myAsmBuilder = myDomain-&gt;DefineDynamicAssembly( myAsmName, AssemblyBuilderAccess::Run );\n   ModuleBuilder^ myModBuilder = myAsmBuilder-&gt;DefineDynamicModule( &quot;MyJumpTableDemo&quot; );\n   TypeBuilder^ myTypeBuilder = myModBuilder-&gt;DefineType( &quot;JumpTableDemo&quot;, TypeAttributes::Public );\n   array&lt;Type^&gt;^temp0 = {int::typeid};\n   MethodBuilder^ myMthdBuilder = myTypeBuilder-&gt;DefineMethod( &quot;SwitchMe&quot;, static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::Static), String::typeid, temp0 );\n   ILGenerator^ myIL = myMthdBuilder-&gt;GetILGenerator();\n   Label defaultCase = myIL-&gt;DefineLabel();\n   Label endOfMethod = myIL-&gt;DefineLabel();\n   \n   // We are initializing our jump table. Note that the labels\n   // will be placed later using the MarkLabel method.\n   array&lt;Label&gt;^jumpTable = gcnew array&lt;Label&gt;(5);\n   jumpTable[ 0 ] = myIL-&gt;DefineLabel();\n   jumpTable[ 1 ] = myIL-&gt;DefineLabel();\n   jumpTable[ 2 ] = myIL-&gt;DefineLabel();\n   jumpTable[ 3 ] = myIL-&gt;DefineLabel();\n   jumpTable[ 4 ] = myIL-&gt;DefineLabel();\n   \n   // arg0, the number we passed, is pushed onto the stack.\n   // In this case, due to the design of the code sample,\n   // the value pushed onto the stack happens to match the\n   // index of the label (in IL terms, the index of the offset\n   // in the jump table). If this is not the case, such as\n   // when switching based on non-integer values, rules for the correspondence\n   // between the possible case values and each index of the offsets\n   // must be established outside of the ILGenerator::Emit calls,\n   // much as a compiler would.\n   myIL-&gt;Emit( OpCodes::Ldarg_0 );\n   myIL-&gt;Emit( OpCodes::Switch, jumpTable );\n   \n   // Branch on default case\n   myIL-&gt;Emit( OpCodes::Br_S, defaultCase );\n   \n   // Case arg0 = 0\n   myIL-&gt;MarkLabel( jumpTable[ 0 ] );\n   myIL-&gt;Emit( OpCodes::Ldstr, &quot;are no bananas&quot; );\n   myIL-&gt;Emit( OpCodes::Br_S, endOfMethod );\n   \n   // Case arg0 = 1\n   myIL-&gt;MarkLabel( jumpTable[ 1 ] );\n   myIL-&gt;Emit( OpCodes::Ldstr, &quot;is one banana&quot; );\n   myIL-&gt;Emit( OpCodes::Br_S, endOfMethod );\n   \n   // Case arg0 = 2\n   myIL-&gt;MarkLabel( jumpTable[ 2 ] );\n   myIL-&gt;Emit( OpCodes::Ldstr, &quot;are two bananas&quot; );\n   myIL-&gt;Emit( OpCodes::Br_S, endOfMethod );\n   \n   // Case arg0 = 3\n   myIL-&gt;MarkLabel( jumpTable[ 3 ] );\n   myIL-&gt;Emit( OpCodes::Ldstr, &quot;are three bananas&quot; );\n   myIL-&gt;Emit( OpCodes::Br_S, endOfMethod );\n   \n   // Case arg0 = 4\n   myIL-&gt;MarkLabel( jumpTable[ 4 ] );\n   myIL-&gt;Emit( OpCodes::Ldstr, &quot;are four bananas&quot; );\n   myIL-&gt;Emit( OpCodes::Br_S, endOfMethod );\n   \n   // Default case\n   myIL-&gt;MarkLabel( defaultCase );\n   myIL-&gt;Emit( OpCodes::Ldstr, &quot;are many bananas&quot; );\n   myIL-&gt;MarkLabel( endOfMethod );\n   myIL-&gt;Emit( OpCodes::Ret );\n   return myTypeBuilder-&gt;CreateType();\n}\n\nint main()\n{\n   Type^ myType = BuildMyType();\n   Console::Write( &quot;Enter an integer between 0 and 5: &quot; );\n   int theValue = Convert::ToInt32( Console::ReadLine() );\n   Console::WriteLine( &quot;---&quot; );\n   Object^ myInstance = Activator::CreateInstance( myType, gcnew array&lt;Object^&gt;(0) );\n   array&lt;Object^&gt;^temp1 = {theValue};\n   Console::WriteLine( &quot;Yes, there {0} today!&quot;, myType-&gt;InvokeMember( &quot;SwitchMe&quot;, BindingFlags::InvokeMethod, nullptr, myInstance, temp1 ) );\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Reflection.Emit.ILGenerator.Emit Example 2#1\">\nImports System\nImports System.Threading\nImports System.Reflection\nImports System.Reflection.Emit\n\n _\n\nClass DynamicJumpTableDemo\n   \n   Public Shared Function BuildMyType() As Type\n\n      Dim myDomain As AppDomain = Thread.GetDomain()\n      Dim myAsmName As New AssemblyName()\n      myAsmName.Name = &quot;MyDynamicAssembly&quot;\n      \n      Dim myAsmBuilder As AssemblyBuilder = myDomain.DefineDynamicAssembly(myAsmName, _\n\t\t\t\t\t\t\tAssemblyBuilderAccess.Run)\n      Dim myModBuilder As ModuleBuilder = myAsmBuilder.DefineDynamicModule(&quot;MyJumpTableDemo&quot;)\n      \n      Dim myTypeBuilder As TypeBuilder = myModBuilder.DefineType(&quot;JumpTableDemo&quot;, _\n\t\t\t\t\t\t\t\t TypeAttributes.Public)\n      Dim myMthdBuilder As MethodBuilder = myTypeBuilder.DefineMethod(&quot;SwitchMe&quot;, _\n\t\t\t\t\t\tMethodAttributes.Public Or MethodAttributes.Static, _\n\t\t\t\t\t\tGetType(String), New Type() {GetType(Integer)})\n      \n      Dim myIL As ILGenerator = myMthdBuilder.GetILGenerator()\n      \n      Dim defaultCase As Label = myIL.DefineLabel()\n      Dim endOfMethod As Label = myIL.DefineLabel()\n      \n      &#39; We are initializing our jump table. Note that the labels\n      &#39; will be placed later using the MarkLabel method. \n\n      Dim jumpTable() As Label = {myIL.DefineLabel(), _\n\t\t\t\t  myIL.DefineLabel(), _\n\t\t\t\t  myIL.DefineLabel(), _\n\t\t\t\t  myIL.DefineLabel(), _\n\t\t\t\t  myIL.DefineLabel()}\n      \n      &#39; arg0, the number we passed, is pushed onto the stack.\n      &#39; In this case, due to the design of the code sample,\n      &#39; the value pushed onto the stack happens to match the\n      &#39; index of the label (in IL terms, the index of the offset\n      &#39; in the jump table). If this is not the case, such as\n      &#39; when switching based on non-integer values, rules for the correspondence\n      &#39; between the possible case values and each index of the offsets\n      &#39; must be established outside of the ILGenerator.Emit calls,\n      &#39; much as a compiler would.\n\n      myIL.Emit(OpCodes.Ldarg_0)\n      myIL.Emit(OpCodes.Switch, jumpTable)\n      \n      &#39; Branch on default case\n      myIL.Emit(OpCodes.Br_S, defaultCase)\n      \n      &#39; Case arg0 = 0\n      myIL.MarkLabel(jumpTable(0))\n      myIL.Emit(OpCodes.Ldstr, &quot;are no bananas&quot;)\n      myIL.Emit(OpCodes.Br_S, endOfMethod)\n      \n      &#39; Case arg0 = 1\n      myIL.MarkLabel(jumpTable(1))\n      myIL.Emit(OpCodes.Ldstr, &quot;is one banana&quot;)\n      myIL.Emit(OpCodes.Br_S, endOfMethod)\n      \n      &#39; Case arg0 = 2\n      myIL.MarkLabel(jumpTable(2))\n      myIL.Emit(OpCodes.Ldstr, &quot;are two bananas&quot;)\n      myIL.Emit(OpCodes.Br_S, endOfMethod)\n      \n      &#39; Case arg0 = 3\n      myIL.MarkLabel(jumpTable(3))\n      myIL.Emit(OpCodes.Ldstr, &quot;are three bananas&quot;)\n      myIL.Emit(OpCodes.Br_S, endOfMethod)\n      \n      &#39; Case arg0 = 4\n      myIL.MarkLabel(jumpTable(4))\n      myIL.Emit(OpCodes.Ldstr, &quot;are four bananas&quot;)\n      myIL.Emit(OpCodes.Br_S, endOfMethod)\n      \n      &#39; Default case\n      myIL.MarkLabel(defaultCase)\n      myIL.Emit(OpCodes.Ldstr, &quot;are many bananas&quot;)\n      \n      myIL.MarkLabel(endOfMethod)\n      myIL.Emit(OpCodes.Ret)\n      \n      Return myTypeBuilder.CreateType()\n\n   End Function &#39;BuildMyType\n    \n   \n   Public Shared Sub Main()\n\n      Dim myType As Type = BuildMyType()\n      \n      Console.Write(&quot;Enter an integer between 0 and 5: &quot;)\n      Dim theValue As Integer = Convert.ToInt32(Console.ReadLine())\n      \n      Console.WriteLine(&quot;---&quot;)\n      Dim myInstance As [Object] = Activator.CreateInstance(myType, New Object() {})\n      Console.WriteLine(&quot;Yes, there {0} today!&quot;, myType.InvokeMember(&quot;SwitchMe&quot;, _\n\t\t\t\t\t\t BindingFlags.InvokeMethod, Nothing, _\n\t\t\t\t\t         myInstance, New Object() {theValue}))\n\n   End Sub &#39;Main\n\nEnd Class &#39;DynamicJumpTableDemo\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Reflection_Emit_LocalBuilder_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_Emit_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Emit(OpCode,LocalBuilder)</div>        \r\n          </div>\r\n    \r\n            <p>Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the index of the given local variable.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.LocalBuilder local);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>opcode</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.opcode\" data-linktype=\"relative-path\">OpCode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The MSIL instruction to be emitted onto the stream.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>local</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.localbuilder\" data-linktype=\"relative-path\">LocalBuilder</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A local variable.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p>The parent method of the <code>local</code> parameter does not match the method associated with this <a class=\"xref\" href=\"system.reflection.emit.ilgenerator\" data-linktype=\"relative-path\">ILGenerator</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>local</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p><code>opcode</code> is a single-byte instruction, and <code>local</code> represents a local variable with an index greater than <code>Byte.MaxValue</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The instruction values are defined in the <code>OpCodes</code> enumeration.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Reflection_Emit_SignatureHelper_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_Emit_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Emit(OpCode,SignatureHelper)</div>        \r\n          </div>\r\n    \r\n            <p>Puts the specified instruction and a signature token onto the Microsoft intermediate language (MSIL) stream of instructions.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.Emit.SignatureHelper signature);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>opcode</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.opcode\" data-linktype=\"relative-path\">OpCode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The MSIL instruction to be emitted onto the stream.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>signature</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.signaturehelper\" data-linktype=\"relative-path\">SignatureHelper</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A helper for constructing a signature token.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>signature</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The instruction values are defined in the <code>OpCodes</code> enumeration.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Reflection_FieldInfo_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_Emit_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Emit(OpCode,FieldInfo)</div>        \r\n          </div>\r\n    \r\n            <p>Puts the specified instruction and metadata token for the specified field onto the Microsoft intermediate language (MSIL) stream of instructions.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.FieldInfo field);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>opcode</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.opcode\" data-linktype=\"relative-path\">OpCode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The MSIL instruction to be emitted onto the stream.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>field</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.fieldinfo\" data-linktype=\"relative-path\">FieldInfo</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <code>FieldInfo</code> representing a field.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The instruction values are defined in the <code>OpCodes</code> enumeration. The location of <code>field</code> is recorded so that the instruction stream can be patched if necessary when persisting the module to a portable executable (PE) file.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Reflection_MethodInfo_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_Emit_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Emit(OpCode,MethodInfo)</div>        \r\n          </div>\r\n    \r\n            <p>Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the metadata token for the given method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void Emit (System.Reflection.Emit.OpCode opcode, System.Reflection.MethodInfo meth);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>opcode</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.opcode\" data-linktype=\"relative-path\">OpCode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The MSIL instruction to be emitted onto the stream.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>meth</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <code>MethodInfo</code> representing a method.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>meth</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p><code>meth</code> is a generic method for which the <span class=\"xref\">stem.Reflection.MethodInfo.IsGenericMethodDefinition*</span> property is <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The instruction values are defined in the <code>OpCodes</code> enumeration.  </p>\n<p> The location of <code>meth</code> is recorded so that the instruction stream can be patched if necessary when persisting the module to a portable executable (PE) file.  </p>\n<p> If <code>meth</code> represents a generic method, it must be a generic method definition. That is, its &lt;xref:System.Reflection.MethodInfo.IsGenericMethodDefinition%2A?displayProperty=fullName&gt; property must be <code>true</code>.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_SByte_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_Emit_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Emit(OpCode,SByte)</div>        \r\n          </div>\r\n    \r\n            <p>Puts the specified instruction and character argument onto the Microsoft intermediate language (MSIL) stream of instructions.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void Emit (System.Reflection.Emit.OpCode opcode, sbyte arg);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>opcode</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.opcode\" data-linktype=\"relative-path\">OpCode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The MSIL instruction to be put onto the stream.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>arg</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.sbyte\" data-linktype=\"relative-path\">SByte</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The character argument pushed onto the stream immediately after the instruction.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The instruction values are defined in the <code>OpCodes</code> enumeration.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Single_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_Emit_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Emit(OpCode,Single)</div>        \r\n          </div>\r\n    \r\n            <p>Puts the specified instruction and numerical argument onto the Microsoft intermediate language (MSIL) stream of instructions.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void Emit (System.Reflection.Emit.OpCode opcode, float arg);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>opcode</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.opcode\" data-linktype=\"relative-path\">OpCode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The MSIL instruction to be put onto the stream.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>arg</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.single\" data-linktype=\"relative-path\">Single</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <code>Single</code> argument pushed onto the stream immediately after the instruction.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The instruction values are defined in the <code>OpCodes</code> enumeration.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_String_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_Emit_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Emit(OpCode,String)</div>        \r\n          </div>\r\n    \r\n            <p>Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the metadata token for the given string.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void Emit (System.Reflection.Emit.OpCode opcode, string str);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>opcode</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.opcode\" data-linktype=\"relative-path\">OpCode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The MSIL instruction to be emitted onto the stream.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>str</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <code>String</code> to be emitted.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The instruction values are defined in the <code>OpCodes</code> enumeration. The location of <code>str</code> is recorded for future fixups if the module is persisted to a portable executable (PE) file.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Type_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_Emit_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Emit(OpCode,Type)</div>        \r\n          </div>\r\n    \r\n            <p>Puts the specified instruction onto the Microsoft intermediate language (MSIL) stream followed by the metadata token for the given type.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void Emit (System.Reflection.Emit.OpCode opcode, Type cls);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>opcode</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.opcode\" data-linktype=\"relative-path\">OpCode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The MSIL instruction to be put onto the stream.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>cls</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <code>Type</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>cls</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The instruction values are defined in the <code>OpCodes</code> enumeration. The location of <code>cls</code> is recorded so that the token can be patched if necessary when persisting the module to a portable executable (PE) file.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_EmitCall_System_Reflection_Emit_OpCode_System_Reflection_MethodInfo_System_Type___\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_EmitCall_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">EmitCall(OpCode,MethodInfo,Type[])</div>        \r\n          </div>\r\n    \r\n            <p>Puts a <code>call</code> or <code>callvirt</code> instruction onto the Microsoft intermediate language (MSIL) stream to call a <code>varargs</code> method.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void EmitCall (System.Reflection.Emit.OpCode opcode, System.Reflection.MethodInfo methodInfo, Type[] optionalParameterTypes);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>opcode</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.opcode\" data-linktype=\"relative-path\">OpCode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The MSIL instruction to be emitted onto the stream. Must be <a class=\"xref\" href=\"system.reflection.emit.opcodes#System_Reflection_Emit_OpCodes_Call\" data-linktype=\"relative-path\">Call</a>, <a class=\"xref\" href=\"system.reflection.emit.opcodes#System_Reflection_Emit_OpCodes_Callvirt\" data-linktype=\"relative-path\">Callvirt</a>, or <a class=\"xref\" href=\"system.reflection.emit.opcodes#System_Reflection_Emit_OpCodes_Newobj\" data-linktype=\"relative-path\">Newobj</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>methodInfo</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.methodinfo\" data-linktype=\"relative-path\">MethodInfo</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <code>varargs</code> method to be called.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>optionalParameterTypes</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The types of the optional arguments if the method is a <code>varargs</code> method; otherwise, <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>opcode</code> does not specify a method call.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>methodInfo</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The calling convention for the method is not <code>varargs</code>, but optional parameter types are supplied. This exception is thrown in the .NET Framework versions 1.0 and 1.1, In subsequent versions, no exception is thrown.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The EmitCall method is used to emit calls to <code>varargs</code> methods because there is no overload of the <a class=\"xref\" href=\"system.reflection.emit.ilgenerator#System_Reflection_Emit_ILGenerator_Emit_\" data-linktype=\"relative-path\">Emit</a> method that specifies the parameter types of the variable arguments.  </p>\n<p> To emit calls to methods that do not use the <a class=\"xref\" href=\"system.reflection.callingconventions\" data-linktype=\"relative-path\">CallingConventions</a> calling convention, use the <a class=\"xref\" href=\"system.reflection.emit.ilgenerator#System_Reflection_Emit_ILGenerator_Emit_System_Reflection_Emit_OpCode_System_Reflection_MethodInfo_\" data-linktype=\"relative-path\">Emit(OpCode,MethodInfo)</a> method overload.  </p>\n<h2 id=\"version-information\">Version Information</h2>\n<p> Beginning with the .NET Framework version 2.0, the EmitCall method does not throw an exception when optional parameter types are specified for a method that is not <code>varargs</code>. <a class=\"xref\" href=\"system.invalidprogramexception\" data-linktype=\"relative-path\">InvalidProgramException</a> is thrown when the call is executed.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example emits two methods, a <code>varargs</code> method and a method that calls the <code>varargs</code> method. The <code>EmitCall</code> method is used to emit the call to the <code>varargs</code> method.  </p>\n<pre><code class=\"lang-vb\" name=\"Emit.ArgIterator#1\">Imports System\nImports System.Reflection\nImports System.Reflection.Emit\n\nClass Example\n    \n    Shared Sub Main() \n\n        Dim name As String = &quot;InMemory&quot;\n        \n        Dim asmBldr As AssemblyBuilder = AppDomain.CurrentDomain.DefineDynamicAssembly( _\n            New AssemblyName(name), AssemblyBuilderAccess.Run)\n        Dim modBldr As ModuleBuilder = asmBldr.DefineDynamicModule(name)\n        \n        Dim tb As TypeBuilder = modBldr.DefineType(&quot;DemoVararg&quot;)\n        \n        &#39; Create a vararg method with no return value and one \n        &#39; string argument. (The string argument type is the only\n        &#39; element of an array of Type objects.)\n        &#39;\n        Dim mb1 As MethodBuilder = tb.DefineMethod(&quot;VarargMethod&quot;, _\n            MethodAttributes.Public Or MethodAttributes.Static, _\n            CallingConventions.VarArgs, _\n            Nothing, _\n            New Type() {GetType(String)})\n        \n        Dim il1 As ILGenerator = mb1.GetILGenerator()\n        \n        Dim locAi As LocalBuilder = il1.DeclareLocal(GetType(ArgIterator))\n        Dim locNext As LocalBuilder = il1.DeclareLocal(GetType(Boolean))\n        \n        Dim labelCheckCondition As Label = il1.DefineLabel()\n        Dim labelNext As Label = il1.DefineLabel()\n        \n        &#39; Load the fixed argument and print it.\n        il1.Emit(OpCodes.Ldarg_0)\n        il1.Emit(OpCodes.Call, GetType(Console).GetMethod(&quot;Write&quot;, _\n            New Type() {GetType(String)}))\n        \n        &#39; Load the address of the local variable represented by\n        &#39; locAi, which will hold the ArgIterator.\n        il1.Emit(OpCodes.Ldloca_S, locAi)\n        \n        &#39; Load the address of the argument list, and call the \n        &#39; ArgIterator constructor that takes an array of runtime\n        &#39; argument handles. \n        il1.Emit(OpCodes.Arglist)\n        il1.Emit(OpCodes.Call, GetType(ArgIterator).GetConstructor( _\n            New Type() {GetType(RuntimeArgumentHandle)}))\n        \n        &#39; Enter the loop at the point where the remaining argument\n        &#39; count is tested.\n        il1.Emit(OpCodes.Br_S, labelCheckCondition)\n        \n        &#39; At the top of the loop, call GetNextArg to get the next \n        &#39; argument from the ArgIterator. Convert the typed reference\n        &#39; to an object reference and write the object to the console.\n        il1.MarkLabel(labelNext)\n        il1.Emit(OpCodes.Ldloca_S, locAi)\n        il1.Emit(OpCodes.Call, _\n            GetType(ArgIterator).GetMethod(&quot;GetNextArg&quot;, Type.EmptyTypes))\n        il1.Emit(OpCodes.Call, GetType(TypedReference).GetMethod(&quot;ToObject&quot;))\n        il1.Emit(OpCodes.Call, _\n            GetType(Console).GetMethod(&quot;Write&quot;, New Type() {GetType(Object)}))\n        \n        il1.MarkLabel(labelCheckCondition)\n        il1.Emit(OpCodes.Ldloca_S, locAi)\n        il1.Emit(OpCodes.Call, _\n            GetType(ArgIterator).GetMethod(&quot;GetRemainingCount&quot;))\n        \n        &#39; If the remaining count is greater than zero, go to\n        &#39; the top of the loop.\n        il1.Emit(OpCodes.Ldc_I4_0)\n        il1.Emit(OpCodes.Cgt)\n        il1.Emit(OpCodes.Stloc_1)\n        il1.Emit(OpCodes.Ldloc_1)\n        il1.Emit(OpCodes.Brtrue_S, labelNext)\n        \n        il1.Emit(OpCodes.Ret)\n        \n        &#39; Create a method that contains a call to the vararg \n        &#39; method.\n        Dim mb2 As MethodBuilder = tb.DefineMethod(&quot;CallVarargMethod&quot;, _\n            MethodAttributes.Public Or MethodAttributes.Static, _\n            CallingConventions.Standard, _\n            Nothing, _\n            Type.EmptyTypes)\n\n        Dim il2 As ILGenerator = mb2.GetILGenerator()\n        \n        &#39; Push arguments on the stack: one for the fixed string\n        &#39; parameter, and two for the list.\n        il2.Emit(OpCodes.Ldstr, &quot;Hello &quot;)\n        il2.Emit(OpCodes.Ldstr, &quot;world &quot;)\n        il2.Emit(OpCodes.Ldc_I4, 2006)\n        \n        &#39; Call the vararg method, specifying the types of the \n        &#39; arguments in the list.\n        il2.EmitCall(OpCodes.Call, mb1, _\n            New Type() {GetType(String), GetType(Integer)})\n        \n        il2.Emit(OpCodes.Ret)\n        \n        Dim myType As Type = tb.CreateType()\n        myType.GetMethod(&quot;CallVarargMethod&quot;).Invoke(Nothing, Nothing)\n    \n    End Sub \nEnd Class \n\n&#39; This code example produces the following output:\n&#39;\n&#39;Hello world 2006\n&#39; \n</code></pre><pre><code class=\"lang-cpp\" name=\"Emit.ArgIterator#1\">using namespace System;\nusing namespace System::Reflection;\nusing namespace System::Reflection::Emit;\n\nvoid main() \n{\n    String^ name = &quot;InMemory&quot;;\n\n    AssemblyBuilder^ asmBldr = \n       AppDomain::CurrentDomain-&gt;DefineDynamicAssembly(gcnew AssemblyName(name), \n          AssemblyBuilderAccess::Run);\n    ModuleBuilder^ modBldr = asmBldr-&gt;DefineDynamicModule(name); \n\n    TypeBuilder^ tb = modBldr-&gt;DefineType(&quot;DemoVararg&quot;);\n\n    // Create a vararg method with no return value and one \n    // string argument. (The string argument type is the only\n    // element of an array of Type objects.)\n    //\n    MethodBuilder^ mb1 = tb-&gt;DefineMethod(&quot;VarargMethod&quot;,\n        MethodAttributes::Public | MethodAttributes::Static,\n        CallingConventions::VarArgs,\n        nullptr, \n        gcnew array&lt;Type^&gt; { String::typeid });\n\n    ILGenerator^ il1 = mb1-&gt;GetILGenerator();\n\n    LocalBuilder^ locAi = il1-&gt;DeclareLocal(ArgIterator::typeid);\n    LocalBuilder^ locNext = il1-&gt;DeclareLocal(bool::typeid);\n\n    Label labelCheckCondition = il1-&gt;DefineLabel();\n    Label labelNext = il1-&gt;DefineLabel();\n\n    // Load the fixed argument and print it.\n    il1-&gt;Emit(OpCodes::Ldarg_0);\n    il1-&gt;Emit(OpCodes::Call, Console::typeid-&gt;GetMethod(&quot;Write&quot;, \n         gcnew array&lt;Type^&gt; { String::typeid }));\n\n    // Load the address of the local variable represented by\n    // locAi, which will hold the ArgIterator.\n    il1-&gt;Emit(OpCodes::Ldloca_S, locAi);\n\n    // Load the address of the argument list, and call the \n    // ArgIterator constructor that takes an array of runtime\n    // argument handles. \n    il1-&gt;Emit(OpCodes::Arglist);\n    il1-&gt;Emit(OpCodes::Call, ArgIterator::typeid-&gt;GetConstructor(\n         gcnew array&lt;Type^&gt; { RuntimeArgumentHandle::typeid }));\n\n    // Enter the loop at the point where the remaining argument\n    // count is tested.\n    il1-&gt;Emit(OpCodes::Br_S, labelCheckCondition);\n\n    // At the top of the loop, call GetNextArg to get the next \n    // argument from the ArgIterator. Convert the typed reference\n    // to an object reference and write the object to the console.\n    il1-&gt;MarkLabel(labelNext);\n    il1-&gt;Emit(OpCodes::Ldloca_S, locAi);\n    il1-&gt;Emit(OpCodes::Call, ArgIterator::typeid-&gt;GetMethod(&quot;GetNextArg&quot;, Type::EmptyTypes));\n    il1-&gt;Emit(OpCodes::Call, TypedReference::typeid-&gt;GetMethod(&quot;ToObject&quot;));\n    il1-&gt;Emit(OpCodes::Call, Console::typeid-&gt;GetMethod(&quot;Write&quot;, \n         gcnew array&lt;Type^&gt; { Object::typeid }));\n\n    il1-&gt;MarkLabel(labelCheckCondition);\n    il1-&gt;Emit(OpCodes::Ldloca_S, locAi);\n    il1-&gt;Emit(OpCodes::Call, ArgIterator::typeid-&gt;GetMethod(&quot;GetRemainingCount&quot;));\n\n    // If the remaining count is greater than zero, go to\n    // the top of the loop.\n    il1-&gt;Emit(OpCodes::Ldc_I4_0);\n    il1-&gt;Emit(OpCodes::Cgt);\n    il1-&gt;Emit(OpCodes::Stloc_1);\n    il1-&gt;Emit(OpCodes::Ldloc_1);\n    il1-&gt;Emit(OpCodes::Brtrue_S, labelNext);\n\n    il1-&gt;Emit(OpCodes::Ret);\n\n    // Create a method that contains a call to the vararg \n    // method.\n    MethodBuilder^ mb2 = tb-&gt;DefineMethod(&quot;CallVarargMethod&quot;,\n        MethodAttributes::Public | MethodAttributes::Static,\n        CallingConventions::Standard,\n        nullptr, Type::EmptyTypes);\n\n    ILGenerator^ il2 = mb2-&gt;GetILGenerator();\n\n    // Push arguments on the stack: one for the fixed string\n    // parameter, and two for the list.\n    il2-&gt;Emit(OpCodes::Ldstr, &quot;Hello &quot;);\n    il2-&gt;Emit(OpCodes::Ldstr, &quot;world &quot;);\n    il2-&gt;Emit(OpCodes::Ldc_I4, 2006);\n\n    // Call the vararg method, specifying the types of the \n    // arguments in the list.\n    il2-&gt;EmitCall(OpCodes::Call, mb1, \n        gcnew array&lt;Type^&gt; { String::typeid, int::typeid });\n\n    il2-&gt;Emit(OpCodes::Ret);\n\n    Type^ type = tb-&gt;CreateType();\n    type-&gt;GetMethod(&quot;CallVarargMethod&quot;)-&gt;Invoke(nullptr, nullptr);\n}\n\n/* This code example produces the following output:\n\nHello world 2006\n */\n</code></pre><pre><code class=\"lang-cs\" name=\"Emit.ArgIterator#1\">using System;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\nclass Example\n{\n    static void Main() \n    {\n        string name = &quot;InMemory&quot;;\n\n        AssemblyBuilder asmBldr = \n           AppDomain.CurrentDomain.DefineDynamicAssembly(new AssemblyName(name), \n              AssemblyBuilderAccess.Run);\n        ModuleBuilder modBldr = asmBldr.DefineDynamicModule(name); \n\n        TypeBuilder tb = modBldr.DefineType(&quot;DemoVararg&quot;);\n\n        // Create a vararg method with no return value and one \n        // string argument. (The string argument type is the only\n        // element of an array of Type objects.)\n        //\n        MethodBuilder mb1 = tb.DefineMethod(&quot;VarargMethod&quot;,\n            MethodAttributes.Public | MethodAttributes.Static,\n            CallingConventions.VarArgs,\n            null, \n            new Type[] { typeof(string) });\n\n        ILGenerator il1 = mb1.GetILGenerator();\n\n        LocalBuilder locAi = il1.DeclareLocal(typeof(ArgIterator));\n        LocalBuilder locNext = il1.DeclareLocal(typeof(bool));\n\n        Label labelCheckCondition = il1.DefineLabel();\n        Label labelNext = il1.DefineLabel();\n\n        // Load the fixed argument and print it.\n        il1.Emit(OpCodes.Ldarg_0);\n        il1.Emit(OpCodes.Call, typeof(Console).GetMethod(&quot;Write&quot;, new Type[] { typeof(string) }));\n\n        // Load the address of the local variable represented by\n        // locAi, which will hold the ArgIterator.\n        il1.Emit(OpCodes.Ldloca_S, locAi);\n\n        // Load the address of the argument list, and call the \n        // ArgIterator constructor that takes an array of runtime\n        // argument handles. \n        il1.Emit(OpCodes.Arglist);\n        il1.Emit(OpCodes.Call, typeof(ArgIterator).GetConstructor(new Type[] { typeof(RuntimeArgumentHandle) }));\n\n        // Enter the loop at the point where the remaining argument\n        // count is tested.\n        il1.Emit(OpCodes.Br_S, labelCheckCondition);\n\n        // At the top of the loop, call GetNextArg to get the next \n        // argument from the ArgIterator. Convert the typed reference\n        // to an object reference and write the object to the console.\n        il1.MarkLabel(labelNext);\n        il1.Emit(OpCodes.Ldloca_S, locAi);\n        il1.Emit(OpCodes.Call, typeof(ArgIterator).GetMethod(&quot;GetNextArg&quot;, Type.EmptyTypes));\n        il1.Emit(OpCodes.Call, typeof(TypedReference).GetMethod(&quot;ToObject&quot;));\n        il1.Emit(OpCodes.Call, typeof(Console).GetMethod(&quot;Write&quot;, new Type[] { typeof(object) }));\n\n        il1.MarkLabel(labelCheckCondition);\n        il1.Emit(OpCodes.Ldloca_S, locAi);\n        il1.Emit(OpCodes.Call, typeof(ArgIterator).GetMethod(&quot;GetRemainingCount&quot;));\n\n        // If the remaining count is greater than zero, go to\n        // the top of the loop.\n        il1.Emit(OpCodes.Ldc_I4_0);\n        il1.Emit(OpCodes.Cgt);\n        il1.Emit(OpCodes.Stloc_1);\n        il1.Emit(OpCodes.Ldloc_1);\n        il1.Emit(OpCodes.Brtrue_S, labelNext);\n\n        il1.Emit(OpCodes.Ret);\n\n        // Create a method that contains a call to the vararg \n        // method.\n        MethodBuilder mb2 = tb.DefineMethod(&quot;CallVarargMethod&quot;,\n            MethodAttributes.Public | MethodAttributes.Static,\n            CallingConventions.Standard,\n            typeof(void), Type.EmptyTypes);\n        ILGenerator il2 = mb2.GetILGenerator();\n\n        // Push arguments on the stack: one for the fixed string\n        // parameter, and two for the list.\n        il2.Emit(OpCodes.Ldstr, &quot;Hello &quot;);\n        il2.Emit(OpCodes.Ldstr, &quot;world &quot;);\n        il2.Emit(OpCodes.Ldc_I4, 2006);\n\n        // Call the vararg method, specifying the types of the \n        // arguments in the list.\n        il2.EmitCall(OpCodes.Call, mb1, new Type[] { typeof(string), typeof(int) });\n\n        il2.Emit(OpCodes.Ret);\n\n        Type type = tb.CreateType();\n        type.GetMethod(&quot;CallVarargMethod&quot;).Invoke(null, null);\n    }\n}\n\n/* This code example produces the following output:\n\nHello world 2006\n */\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_EmitCalli_System_Reflection_Emit_OpCode_System_Runtime_InteropServices_CallingConvention_System_Type_System_Type___\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_EmitCalli_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">EmitCalli(OpCode,CallingConvention,Type,Type[])</div>        \r\n          </div>\r\n    \r\n            <p>Puts a <a class=\"xref\" href=\"system.reflection.emit.opcodes#System_Reflection_Emit_OpCodes_Calli\" data-linktype=\"relative-path\">Calli</a> instruction onto the Microsoft intermediate language (MSIL) stream, specifying an unmanaged calling convention for the indirect call.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void EmitCalli (System.Reflection.Emit.OpCode opcode, System.Runtime.InteropServices.CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>opcode</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.opcode\" data-linktype=\"relative-path\">OpCode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The MSIL instruction to be emitted onto the stream. Must be <a class=\"xref\" href=\"system.reflection.emit.opcodes#System_Reflection_Emit_OpCodes_Calli\" data-linktype=\"relative-path\">Calli</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>unmanagedCallConv</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.runtime.interopservices.callingconvention\" data-linktype=\"relative-path\">CallingConvention</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The unmanaged calling convention to be used.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>returnType</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> of the result.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>parameterTypes</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The types of the required arguments to the instruction.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Use<a class=\"xref\" href=\"system.reflection.emit.ilgenerator#System_Reflection_Emit_ILGenerator_EmitCalli_\" data-linktype=\"relative-path\">EmitCalli</a> to put a <a class=\"xref\" href=\"system.reflection.emit.opcodes#System_Reflection_Emit_OpCodes_Calli\" data-linktype=\"relative-path\">Calli</a> instruction onto the stream. Do not use <a class=\"xref\" href=\"system.reflection.emit.ilgenerator#System_Reflection_Emit_ILGenerator_Emit_\" data-linktype=\"relative-path\">Emit</a>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code sample demonstrates the contextual usage of the <a class=\"xref\" href=\"system.reflection.emit.ilgenerator#System_Reflection_Emit_ILGenerator_EmitCalli_\" data-linktype=\"relative-path\">EmitCalli</a> method to call an unmanaged type method external to the dynamic class.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Reflection.Emit.ILGenerator.EmitCalli Example#1\">      MethodBuilder^ myMthdBuilder = myTypeBuilder-&gt;DefineMethod( &quot;MyMethod&quot;,\n                                     MethodAttributes::Public,\n                                     returnType, mthdParamTypes );\n      \n      // We will assume that an external unmanaged type &quot;LegacyNumber&quot; has been loaded, and\n      // that it has a method &quot;ToString&quot; which returns a String.\n\n      MethodInfo^ unmanagedMthdMI = Type::GetType( &quot;LegacyNumber&quot; )-&gt;GetMethod( &quot;ToString&quot; );\n      ILGenerator^ myMthdIL = myMthdBuilder-&gt;GetILGenerator();\n      \n      // Code to emit various IL opcodes here ...\n\n      // Load a reference to the specific Object instance onto the stack.\n\n      myMthdIL-&gt;Emit( OpCodes::Ldc_I4, addrOfLegacyNumberObject );\n      myMthdIL-&gt;Emit( OpCodes::Ldobj, Type::GetType( &quot;LegacyNumber&quot; ) );\n      \n      // Make the call to the unmanaged type method, telling it that the method is\n      // the member of a specific instance, to expect a String\n      // as a return value, and that there are no explicit parameters.\n      myMthdIL-&gt;EmitCalli( OpCodes::Calli,\n                           System::Runtime::InteropServices::CallingConvention::ThisCall,\n                           String::typeid,\n                           gcnew array&lt;Type^&gt;( 0 ) );\n      \n      // More IL code emission here ...\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Reflection.Emit.ILGenerator.EmitCalli Example#1\">\tMethodBuilder myMthdBuilder = myTypeBuilder.DefineMethod(&quot;MyMethod&quot;, \n\t\t\t\t      MethodAttributes.Public,\n\t\t\t\t      returnType, mthdParamTypes);\n\t\t\t\t\t\t\t\t\n\t// We will assume that an external unmanaged type &quot;LegacyNumber&quot; has been loaded, and\n\t// that it has a method &quot;ToString&quot; which returns a string.\n \n\tMethodInfo unmanagedMthdMI = Type.GetType(&quot;LegacyNumber&quot;).GetMethod(&quot;ToString&quot;);\n\tILGenerator myMthdIL = myMthdBuilder.GetILGenerator();\n\n\t// Code to emit various IL opcodes here ...\n\n\t// Load a reference to the specific object instance onto the stack.\n\n\tmyMthdIL.Emit(OpCodes.Ldc_I4, addrOfLegacyNumberObject);\n\tmyMthdIL.Emit(OpCodes.Ldobj, Type.GetType(&quot;LegacyNumber&quot;));\n\n\t// Make the call to the unmanaged type method, telling it that the method is\n\t// the member of a specific instance, to expect a string \n\t// as a return value, and that there are no explicit parameters.\n\tmyMthdIL.EmitCalli(OpCodes.Calli, \n\t\t\t   System.Runtime.InteropServices.CallingConvention.ThisCall,\n\t\t    \t   typeof(string),\n\t\t\t   new Type[] {});\n\n\t// More IL code emission here ...\n\t\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Reflection.Emit.ILGenerator.EmitCalli Example#1\">      \tDim myMthdBuilder As MethodBuilder = myTypeBuilder.DefineMethod(&quot;MyMethod&quot;, _\n\t\t\t\t\t\tMethodAttributes.Public, _\n\t\t\t\t\t\treturnType, mthdParamTypes)\n      \n      \t&#39; We will assume that an external unmanaged type &quot;LegacyNumber&quot; has been loaded, and\n      \t&#39; that it has a method &quot;ToString&quot; which returns a string.\n\n      \tDim unmanagedMthdMI As MethodInfo = Type.GetType(&quot;LegacyNumber&quot;).GetMethod(&quot;ToString&quot;)\n      \tDim myMthdIL As ILGenerator = myMthdBuilder.GetILGenerator()\n      \n      \t&#39; Code to emit various IL opcodes here ...\n      \t&#39; Load a reference to the specific object instance onto the stack.\n\n      \tmyMthdIL.Emit(OpCodes.Ldc_I4, addrOfLegacyNumberObject)\n      \tmyMthdIL.Emit(OpCodes.Ldobj, Type.GetType(&quot;LegacyNumber&quot;))\n      \n      \t&#39; Make the call to the unmanaged type method, telling it that the method is\n      \t&#39; the member of a specific instance, to expect a string \n      \t&#39; as a return value, and that there are no explicit parameters.\n\n      \tmyMthdIL.EmitCalli(OpCodes.Calli, System.Runtime.InteropServices.CallingConvention.ThisCall, _\n\t\t\t\t\t  GetType(String), New Type() {})\n\n\t&#39; More IL code emission here ...\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_EmitCalli_System_Reflection_Emit_OpCode_System_Reflection_CallingConventions_System_Type_System_Type___System_Type___\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_EmitCalli_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">EmitCalli(OpCode,CallingConventions,Type,Type[],Type[])</div>        \r\n          </div>\r\n    \r\n            <p>Puts a <a class=\"xref\" href=\"system.reflection.emit.opcodes#System_Reflection_Emit_OpCodes_Calli\" data-linktype=\"relative-path\">Calli</a> instruction onto the Microsoft intermediate language (MSIL) stream, specifying a managed calling convention for the indirect call.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void EmitCalli (System.Reflection.Emit.OpCode opcode, System.Reflection.CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>opcode</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.opcode\" data-linktype=\"relative-path\">OpCode</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The MSIL instruction to be emitted onto the stream. Must be <a class=\"xref\" href=\"system.reflection.emit.opcodes#System_Reflection_Emit_OpCodes_Calli\" data-linktype=\"relative-path\">Calli</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>callingConvention</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.callingconventions\" data-linktype=\"relative-path\">CallingConventions</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The managed calling convention to be used.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>returnType</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The <a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a> of the result.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>parameterTypes</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The types of the required arguments to the instruction.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>optionalParameterTypes</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a>[]</div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The types of the optional arguments for <code>varargs</code> calls.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p><code>optionalParameterTypes</code> is not <code>null</code>, but <code>callingConvention</code> does not include the <a class=\"xref\" href=\"system.reflection.callingconventions\" data-linktype=\"relative-path\">CallingConventions</a> flag.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Use EmitCalli to put a <a class=\"xref\" href=\"system.reflection.emit.opcodes#System_Reflection_Emit_OpCodes_Calli\" data-linktype=\"relative-path\">Calli</a> instruction onto the stream. Do not use <a class=\"xref\" href=\"system.reflection.emit.ilgenerator#System_Reflection_Emit_ILGenerator_Emit_\" data-linktype=\"relative-path\">Emit</a>.  </p>\n<p> If <code>optionalParameterTypes</code> specifies optional arguments, <code>callingConvention</code> must include the <a class=\"xref\" href=\"system.reflection.callingconventions\" data-linktype=\"relative-path\">System.Reflection.CallingConventions</a> flag.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_EmitWriteLine_System_Reflection_Emit_LocalBuilder_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_EmitWriteLine_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">EmitWriteLine(LocalBuilder)</div>        \r\n          </div>\r\n    \r\n            <p>Emits the Microsoft intermediate language (MSIL) necessary to call <span class=\"xref\">stem.Console.WriteLine*</span> with the given local variable.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void EmitWriteLine (System.Reflection.Emit.LocalBuilder localBuilder);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>localBuilder</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.localbuilder\" data-linktype=\"relative-path\">LocalBuilder</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The local variable whose value is to be written to the console.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p>The type of <code>localBuilder</code> is <a class=\"xref\" href=\"system.reflection.emit.typebuilder\" data-linktype=\"relative-path\">TypeBuilder</a> or <a class=\"xref\" href=\"system.reflection.emit.enumbuilder\" data-linktype=\"relative-path\">EnumBuilder</a>, which are not supported.  </p>\n<p> -or-  </p>\n<p> There is no overload of <span class=\"xref\">stem.Console.WriteLine*</span> that accepts the type of <code>localBuilder</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>localBuilder</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The type of <code>localBuilder</code> must match the parameter type of an overload of the <a class=\"xref\" href=\"system.console#System_Console_WriteLine_\" data-linktype=\"relative-path\">WriteLine</a> method.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The code sample below demonstrates the contextual usage of the EmitWriteLine method to write a string to the console in a dynamic method.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Reflection.Emit.ILGenerator.OpCodes Example#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Reflection;\nusing namespace System::Reflection::Emit;\nType^ CreateDynamicType()\n{\n   array&lt;Type^&gt;^ctorParams = {int::typeid,int::typeid};\n   AppDomain^ myDomain = Thread::GetDomain();\n   AssemblyName^ myAsmName = gcnew AssemblyName;\n   myAsmName-&gt;Name = &quot;MyDynamicAssembly&quot;;\n   AssemblyBuilder^ myAsmBuilder = myDomain-&gt;DefineDynamicAssembly( myAsmName, AssemblyBuilderAccess::Run );\n   ModuleBuilder^ pointModule = myAsmBuilder-&gt;DefineDynamicModule( &quot;PointModule&quot;, &quot;Point.dll&quot; );\n   TypeBuilder^ pointTypeBld = pointModule-&gt;DefineType( &quot;Point&quot;, TypeAttributes::Public );\n   FieldBuilder^ xField = pointTypeBld-&gt;DefineField( &quot;x&quot;, int::typeid, FieldAttributes::Public );\n   FieldBuilder^ yField = pointTypeBld-&gt;DefineField( &quot;y&quot;, int::typeid, FieldAttributes::Public );\n   Type^ objType = Type::GetType( &quot;System.Object&quot; );\n   ConstructorInfo^ objCtor = objType-&gt;GetConstructor( gcnew array&lt;Type^&gt;(0) );\n   ConstructorBuilder^ pointCtor = pointTypeBld-&gt;DefineConstructor( MethodAttributes::Public, CallingConventions::Standard, ctorParams );\n   ILGenerator^ ctorIL = pointCtor-&gt;GetILGenerator();\n   \n   // First, you build the constructor.\n   ctorIL-&gt;Emit( OpCodes::Ldarg_0 );\n   ctorIL-&gt;Emit( OpCodes::Call, objCtor );\n   ctorIL-&gt;Emit( OpCodes::Ldarg_0 );\n   ctorIL-&gt;Emit( OpCodes::Ldarg_1 );\n   ctorIL-&gt;Emit( OpCodes::Stfld, xField );\n   ctorIL-&gt;Emit( OpCodes::Ldarg_0 );\n   ctorIL-&gt;Emit( OpCodes::Ldarg_2 );\n   ctorIL-&gt;Emit( OpCodes::Stfld, yField );\n   ctorIL-&gt;Emit( OpCodes::Ret );\n   \n   //  Now, you&#39;ll build a method to output some information on the\n   // inside your dynamic class. This method will have the following\n   // definition in C#:\n   //  public void WritePoint()\n   MethodBuilder^ writeStrMthd = pointTypeBld-&gt;DefineMethod( &quot;WritePoint&quot;, MethodAttributes::Public, void::typeid, nullptr );\n   ILGenerator^ writeStrIL = writeStrMthd-&gt;GetILGenerator();\n   \n   // The below ILGenerator created demonstrates a few ways to create\n   // String* output through STDIN.\n   // ILGenerator::EmitWriteLine(String*) will generate a ldstr and a\n   // call to WriteLine for you.\n   writeStrIL-&gt;EmitWriteLine( &quot;The value of this current instance is:&quot; );\n   \n   // Here, you will do the hard work yourself. First, you need to create\n   // the String* we will be passing and obtain the correct WriteLine overload\n   // for said String*. In the below case, you are substituting in two values,\n   // so the chosen overload is Console::WriteLine(String*, Object*, Object*).\n   String^ inStr = &quot;( {0}, {1})&quot;;\n   array&lt;Type^&gt;^wlParams = {String::typeid,Object::typeid,Object::typeid};\n   \n   // We need the MethodInfo to pass into EmitCall later.\n   MethodInfo^ writeLineMI = Console::typeid-&gt;GetMethod( &quot;WriteLine&quot;, wlParams );\n   \n   // Push the String* with the substitutions onto the stack.\n   // This is the first argument for WriteLine - the String* one.\n   writeStrIL-&gt;Emit( OpCodes::Ldstr, inStr );\n   \n   // Since the second argument is an Object*, and it corresponds to\n   // to the substitution for the value of our integer field, you\n   // need to box that field to an Object*. First, push a reference\n   // to the current instance, and then push the value stored in\n   // field &#39;x&#39;. We need the reference to the current instance (stored\n   // in local argument index 0) so Ldfld can load from the correct\n   // instance (this one).\n   writeStrIL-&gt;Emit( OpCodes::Ldarg_0 );\n   writeStrIL-&gt;Emit( OpCodes::Ldfld, xField );\n   \n   // Now, we execute the box opcode, which pops the value of field &#39;x&#39;,\n   // returning a reference to the integer value boxed as an Object*.\n   writeStrIL-&gt;Emit( OpCodes::Box, int::typeid );\n   \n   // Atop the stack, you&#39;ll find our String* inStr, followed by a reference\n   // to the boxed value of &#39;x&#39;. Now, you need to likewise box field &#39;y&#39;.\n   writeStrIL-&gt;Emit( OpCodes::Ldarg_0 );\n   writeStrIL-&gt;Emit( OpCodes::Ldfld, yField );\n   writeStrIL-&gt;Emit( OpCodes::Box, int::typeid );\n   \n   // Now, you have all of the arguments for your call to\n   // Console::WriteLine(String*, Object*, Object*) atop the stack:\n   // the String* InStr, a reference to the boxed value of &#39;x&#39;, and\n   // a reference to the boxed value of &#39;y&#39;.\n   // Call Console::WriteLine(String*, Object*, Object*) with EmitCall.\n   writeStrIL-&gt;EmitCall( OpCodes::Call, writeLineMI, nullptr );\n   \n   // Lastly, EmitWriteLine can also output the value of a field\n   // using the overload EmitWriteLine(FieldInfo).\n   writeStrIL-&gt;EmitWriteLine( &quot;The value of &#39;x&#39; is:&quot; );\n   writeStrIL-&gt;EmitWriteLine( xField );\n   writeStrIL-&gt;EmitWriteLine( &quot;The value of &#39;y&#39; is:&quot; );\n   writeStrIL-&gt;EmitWriteLine( yField );\n   \n   // Since we return no value (void), the the ret opcode will not\n   // return the top stack value.\n   writeStrIL-&gt;Emit( OpCodes::Ret );\n   return pointTypeBld-&gt;CreateType();\n}\n\nint main()\n{\n   array&lt;Object^&gt;^ctorParams = gcnew array&lt;Object^&gt;(2);\n   Console::Write( &quot;Enter a integer value for X: &quot; );\n   String^ myX = Console::ReadLine();\n   Console::Write( &quot;Enter a integer value for Y: &quot; );\n   String^ myY = Console::ReadLine();\n   Console::WriteLine( &quot;---&quot; );\n   ctorParams[ 0 ] = Convert::ToInt32( myX );\n   ctorParams[ 1 ] = Convert::ToInt32( myY );\n   Type^ ptType = CreateDynamicType();\n   Object^ ptInstance = Activator::CreateInstance( ptType, ctorParams );\n   ptType-&gt;InvokeMember( &quot;WritePoint&quot;, BindingFlags::InvokeMethod, nullptr, ptInstance, gcnew array&lt;Object^&gt;(0) );\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Reflection.Emit.ILGenerator.OpCodes Example#1\">\nusing System;\nusing System.Threading;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\nclass EmitWriteLineDemo {\n\n   public static Type CreateDynamicType() {       \n       Type[] ctorParams = new Type[] {typeof(int),\n\t\t\t\t   typeof(int)};\n \t\n       AppDomain myDomain = Thread.GetDomain();\n       AssemblyName myAsmName = new AssemblyName();\n       myAsmName.Name = &quot;MyDynamicAssembly&quot;;\n\n       AssemblyBuilder myAsmBuilder = myDomain.DefineDynamicAssembly(\n\t\t\t\t      myAsmName, \n\t\t\t\t      AssemblyBuilderAccess.Run);\n\n       ModuleBuilder pointModule = myAsmBuilder.DefineDynamicModule(&quot;PointModule&quot;,\n\t\t\t\t\t\t\t\t    &quot;Point.dll&quot;);\n\n       TypeBuilder pointTypeBld = pointModule.DefineType(&quot;Point&quot;,\n\t\t\t\t\t              TypeAttributes.Public);\n\n       FieldBuilder xField = pointTypeBld.DefineField(&quot;x&quot;, typeof(int),\n                                                      FieldAttributes.Public);\n       FieldBuilder yField = pointTypeBld.DefineField(&quot;y&quot;, typeof(int), \n                                                      FieldAttributes.Public);\n\n\n       Type objType = Type.GetType(&quot;System.Object&quot;); \n       ConstructorInfo objCtor = objType.GetConstructor(new Type[0]);\n\n       ConstructorBuilder pointCtor = pointTypeBld.DefineConstructor(\n \t\t\t\t                   MethodAttributes.Public,\n\t\t\t\t                   CallingConventions.Standard,\n\t\t\t\t                   ctorParams);\n       ILGenerator ctorIL = pointCtor.GetILGenerator();\n\n\n       // First, you build the constructor.\n       ctorIL.Emit(OpCodes.Ldarg_0);\n       ctorIL.Emit(OpCodes.Call, objCtor);\n       ctorIL.Emit(OpCodes.Ldarg_0);\n       ctorIL.Emit(OpCodes.Ldarg_1);\n       ctorIL.Emit(OpCodes.Stfld, xField); \n       ctorIL.Emit(OpCodes.Ldarg_0);\n       ctorIL.Emit(OpCodes.Ldarg_2);\n       ctorIL.Emit(OpCodes.Stfld, yField); \n       ctorIL.Emit(OpCodes.Ret); \n\n       //  Now, you&#39;ll build a method to output some information on the\n       // inside your dynamic class. This method will have the following\n       // definition in C#:\n\t//  public void WritePoint()\n      \n       MethodBuilder writeStrMthd = pointTypeBld.DefineMethod(\n        \t\t                     &quot;WritePoint&quot;, \n\t\t\t\t             MethodAttributes.Public,\n                                             typeof(void), \n                                             null);\n\n       \n       ILGenerator writeStrIL = writeStrMthd.GetILGenerator();\n      \n       // The below ILGenerator created demonstrates a few ways to create\n       // string output through STDIN. \n\n       // ILGenerator.EmitWriteLine(string) will generate a ldstr and a \n       // call to WriteLine for you.\n\n       writeStrIL.EmitWriteLine(&quot;The value of this current instance is:&quot;);\n\n       // Here, you will do the hard work yourself. First, you need to create\n       // the string we will be passing and obtain the correct WriteLine overload\n       // for said string. In the below case, you are substituting in two values,\n       // so the chosen overload is Console.WriteLine(string, object, object).\n\n       String inStr = &quot;({0}, {1})&quot;;\n       Type[] wlParams = new Type[] {typeof(string),\n\t\t\t\t     typeof(object),\n\t\t\t\t     typeof(object)};\n\n       // We need the MethodInfo to pass into EmitCall later.\n\n       MethodInfo writeLineMI = typeof(Console).GetMethod(\n\t\t\t\t\t        &quot;WriteLine&quot;,\n\t\t\t\t\t\twlParams);\n\n       // Push the string with the substitutions onto the stack.\n       // This is the first argument for WriteLine - the string one. \n\n       writeStrIL.Emit(OpCodes.Ldstr, inStr);\n\n       // Since the second argument is an object, and it corresponds to\n       // to the substitution for the value of our integer field, you \n       // need to box that field to an object. First, push a reference\n       // to the current instance, and then push the value stored in\n       // field &#39;x&#39;. We need the reference to the current instance (stored\n       // in local argument index 0) so Ldfld can load from the correct\n       // instance (this one).\n\n       writeStrIL.Emit(OpCodes.Ldarg_0);\n       writeStrIL.Emit(OpCodes.Ldfld, xField);\n\n       // Now, we execute the box opcode, which pops the value of field &#39;x&#39;,\n       // returning a reference to the integer value boxed as an object.\n\n       writeStrIL.Emit(OpCodes.Box, typeof(int));\n\n       // Atop the stack, you&#39;ll find our string inStr, followed by a reference\n       // to the boxed value of &#39;x&#39;. Now, you need to likewise box field &#39;y&#39;.\n\n       writeStrIL.Emit(OpCodes.Ldarg_0);\n       writeStrIL.Emit(OpCodes.Ldfld, yField);\n       writeStrIL.Emit(OpCodes.Box, typeof(int));\n\n       // Now, you have all of the arguments for your call to\n       // Console.WriteLine(string, object, object) atop the stack:\n       // the string InStr, a reference to the boxed value of &#39;x&#39;, and\n       // a reference to the boxed value of &#39;y&#39;.\n\n       // Call Console.WriteLine(string, object, object) with EmitCall.\n\n       writeStrIL.EmitCall(OpCodes.Call, writeLineMI, null);\n\n       // Lastly, EmitWriteLine can also output the value of a field\n       // using the overload EmitWriteLine(FieldInfo).\n\n       writeStrIL.EmitWriteLine(&quot;The value of &#39;x&#39; is:&quot;);\n       writeStrIL.EmitWriteLine(xField);\n       writeStrIL.EmitWriteLine(&quot;The value of &#39;y&#39; is:&quot;);\n       writeStrIL.EmitWriteLine(yField);\n\n       // Since we return no value (void), the the ret opcode will not\n       // return the top stack value.\n\n       writeStrIL.Emit(OpCodes.Ret);\n      \n       return pointTypeBld.CreateType();\n\n   }\n\n   public static void Main() {\n\n      object[] ctorParams = new object[2];\n\n      Console.Write(&quot;Enter a integer value for X: &quot;); \n      string myX = Console.ReadLine();\n      Console.Write(&quot;Enter a integer value for Y: &quot;); \n      string myY = Console.ReadLine();\n\n      Console.WriteLine(&quot;---&quot;);\n\n      ctorParams[0] = Convert.ToInt32(myX);\n      ctorParams[1] = Convert.ToInt32(myY);\n\n      Type ptType = CreateDynamicType();\n  \n      object ptInstance = Activator.CreateInstance(ptType, ctorParams);\n      ptType.InvokeMember(&quot;WritePoint&quot;,\n\t\t\t  BindingFlags.InvokeMethod,\n\t\t\t  null,\n\t\t\t  ptInstance,\n\t\t\t  new object[0]);\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Reflection.Emit.ILGenerator.OpCodes Example#1\">\nImports System\nImports System.Threading\nImports System.Reflection\nImports System.Reflection.Emit\n\n _\n\nClass EmitWriteLineDemo\n   \n   \n   Public Shared Function CreateDynamicType() As Type\n\n      Dim ctorParams() As Type = {GetType(Integer), GetType(Integer)}\n      \n      Dim myDomain As AppDomain = Thread.GetDomain()\n      Dim myAsmName As New AssemblyName()\n      myAsmName.Name = &quot;MyDynamicAssembly&quot;\n      \n      Dim myAsmBuilder As AssemblyBuilder = myDomain.DefineDynamicAssembly(myAsmName, AssemblyBuilderAccess.RunAndSave)\n      \n      Dim pointModule As ModuleBuilder = myAsmBuilder.DefineDynamicModule(&quot;PointModule&quot;, &quot;Point.dll&quot;)\n      \n      Dim pointTypeBld As TypeBuilder = pointModule.DefineType(&quot;Point&quot;, _\n\t\t\t\t\t\t\t       TypeAttributes.Public)\n      \n      Dim xField As FieldBuilder = pointTypeBld.DefineField(&quot;x&quot;, _\n\t\t\t\t\t\t\t    GetType(Integer), _\n\t\t\t\t\t\t\t    FieldAttributes.Public)\n      Dim yField As FieldBuilder = pointTypeBld.DefineField(&quot;y&quot;, _\n\t\t\t\t\t\t\t    GetType(Integer), _\n\t\t\t\t\t\t \t    FieldAttributes.Public)\n      \n      \n      Dim objType As Type = Type.GetType(&quot;System.Object&quot;)\n      Dim objCtor As ConstructorInfo = objType.GetConstructor(New Type(){})\n      \n      Dim pointCtor As ConstructorBuilder = pointTypeBld.DefineConstructor( _\n\t\t\t\t\t\t\t MethodAttributes.Public, _\n\t\t\t\t\t\t\t CallingConventions.Standard, _\n\t\t\t\t\t\t\t ctorParams)\n      Dim ctorIL As ILGenerator = pointCtor.GetILGenerator()\n      \n      \n      &#39; First, you build the constructor.\n\n      ctorIL.Emit(OpCodes.Ldarg_0)\n      ctorIL.Emit(OpCodes.Call, objCtor)\n      ctorIL.Emit(OpCodes.Ldarg_0)\n      ctorIL.Emit(OpCodes.Ldarg_1)\n      ctorIL.Emit(OpCodes.Stfld, xField)\n      ctorIL.Emit(OpCodes.Ldarg_0)\n      ctorIL.Emit(OpCodes.Ldarg_2)\n      ctorIL.Emit(OpCodes.Stfld, yField)\n      ctorIL.Emit(OpCodes.Ret)\n      \n      &#39;  Now, you&#39;ll build a method to output some information on the\n      &#39; inside your dynamic class. This method will have the following\n      &#39; definition in C#:\n      &#39;  Public Sub WritePoint() \n\n      Dim writeStrMthd As MethodBuilder = pointTypeBld.DefineMethod(&quot;WritePoint&quot;, _\n\t\t\t\t\t\t\t\t    MethodAttributes.Public, _\n\t\t\t\t\t\t\t\t    Nothing, Nothing)\n      \n      Dim writeStrIL As ILGenerator = writeStrMthd.GetILGenerator()\n      \n      &#39; The below ILGenerator created demonstrates a few ways to create\n      &#39; string output through STDIN. \n      &#39; ILGenerator.EmitWriteLine(string) will generate a ldstr and a \n      &#39; call to WriteLine for you.\n\n      writeStrIL.EmitWriteLine(&quot;The value of this current instance is:&quot;)\n      \n      &#39; Here, you will do the hard work yourself. First, you need to create\n      &#39; the string we will be passing and obtain the correct WriteLine overload\n      &#39; for said string. In the below case, you are substituting in two values,\n      &#39; so the chosen overload is Console.WriteLine(string, object, object).\n\n      Dim inStr As [String] = &quot;({0}, {1})&quot;\n      Dim wlParams() As Type = {GetType(String), GetType(Object), GetType(Object)}\n      \n      &#39; We need the MethodInfo to pass into EmitCall later.\n\n      Dim writeLineMI As MethodInfo = GetType(Console).GetMethod(&quot;WriteLine&quot;, wlParams)\n      \n      &#39; Push the string with the substitutions onto the stack.\n      &#39; This is the first argument for WriteLine - the string one. \n\n      writeStrIL.Emit(OpCodes.Ldstr, inStr)\n      \n      &#39; Since the second argument is an object, and it corresponds to\n      &#39; to the substitution for the value of our integer field, you \n      &#39; need to box that field to an object. First, push a reference\n      &#39; to the current instance, and then push the value stored in\n      &#39; field &#39;x&#39;. We need the reference to the current instance (stored\n      &#39; in local argument index 0) so Ldfld can load from the correct\n      &#39; instance (this one).\n\n      writeStrIL.Emit(OpCodes.Ldarg_0)\n      writeStrIL.Emit(OpCodes.Ldfld, xField)\n      \n      &#39; Now, we execute the box opcode, which pops the value of field &#39;x&#39;,\n      &#39; returning a reference to the integer value boxed as an object.\n\n      writeStrIL.Emit(OpCodes.Box, GetType(Integer))\n      \n      &#39; Atop the stack, you&#39;ll find our string inStr, followed by a reference\n      &#39; to the boxed value of &#39;x&#39;. Now, you need to likewise box field &#39;y&#39;.\n\n      writeStrIL.Emit(OpCodes.Ldarg_0)\n      writeStrIL.Emit(OpCodes.Ldfld, yField)\n      writeStrIL.Emit(OpCodes.Box, GetType(Integer))\n      \n      &#39; Now, you have all of the arguments for your call to\n      &#39; Console.WriteLine(string, object, object) atop the stack:\n      &#39; the string InStr, a reference to the boxed value of &#39;x&#39;, and\n      &#39; a reference to the boxed value of &#39;y&#39;.\n      &#39; Call Console.WriteLine(string, object, object) with EmitCall.\n\n      writeStrIL.EmitCall(OpCodes.Call, writeLineMI, Nothing)\n      \n      &#39; Lastly, EmitWriteLine can also output the value of a field\n      &#39; using the overload EmitWriteLine(FieldInfo).\n\n      writeStrIL.EmitWriteLine(&quot;The value of &#39;x&#39; is:&quot;)\n      writeStrIL.EmitWriteLine(xField)\n      writeStrIL.EmitWriteLine(&quot;The value of &#39;y&#39; is:&quot;)\n      writeStrIL.EmitWriteLine(yField)\n      \n      &#39; Since we return no value (void), the the ret opcode will not\n      &#39; return the top stack value.\n\n      writeStrIL.Emit(OpCodes.Ret)\n      \n      Return pointTypeBld.CreateType()\n\n   End Function &#39;CreateDynamicType\n    \n   \n   Public Shared Sub Main()\n      \n      Dim ctorParams(1) As Object\n      \n      Console.Write(&quot;Enter a integer value for X: &quot;)\n      Dim myX As String = Console.ReadLine()\n      Console.Write(&quot;Enter a integer value for Y: &quot;)\n      Dim myY As String = Console.ReadLine()\n      \n      Console.WriteLine(&quot;---&quot;)\n      \n      ctorParams(0) = Convert.ToInt32(myX)\n      ctorParams(1) = Convert.ToInt32(myY)\n      \n      Dim ptType As Type = CreateDynamicType()\n\n      Dim ptInstance As Object = Activator.CreateInstance(ptType, ctorParams)\n\n      ptType.InvokeMember(&quot;WritePoint&quot;, _\n\t\t\t  BindingFlags.InvokeMethod, _\n\t\t\t  Nothing, ptInstance, Nothing)\n\n   End Sub &#39;Main\n\nEnd Class &#39;EmitWriteLineDemo\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_EmitWriteLine_System_Reflection_FieldInfo_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_EmitWriteLine_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">EmitWriteLine(FieldInfo)</div>        \r\n          </div>\r\n    \r\n            <p>Emits the Microsoft intermediate language (MSIL) necessary to call <span class=\"xref\">stem.Console.WriteLine*</span> with the given field.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void EmitWriteLine (System.Reflection.FieldInfo fld);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>fld</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.fieldinfo\" data-linktype=\"relative-path\">FieldInfo</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The field whose value is to be written to the console.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p>There is no overload of the <span class=\"xref\">stem.Console.WriteLine*</span> method that accepts the type of the specified field.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>fld</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The type of the field is <a class=\"xref\" href=\"system.reflection.emit.typebuilder\" data-linktype=\"relative-path\">TypeBuilder</a> or <a class=\"xref\" href=\"system.reflection.emit.enumbuilder\" data-linktype=\"relative-path\">EnumBuilder</a>, which are not supported.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The type of <code>fld</code> must match the parameter type of an overload of the <a class=\"xref\" href=\"system.console#System_Console_WriteLine_\" data-linktype=\"relative-path\">WriteLine</a> method.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code sample demonstrates the use of the EmitWriteLine method to write a string to the console in a dynamic method.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Reflection.Emit.ILGenerator.OpCodes Example#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Reflection;\nusing namespace System::Reflection::Emit;\nType^ CreateDynamicType()\n{\n   array&lt;Type^&gt;^ctorParams = {int::typeid,int::typeid};\n   AppDomain^ myDomain = Thread::GetDomain();\n   AssemblyName^ myAsmName = gcnew AssemblyName;\n   myAsmName-&gt;Name = &quot;MyDynamicAssembly&quot;;\n   AssemblyBuilder^ myAsmBuilder = myDomain-&gt;DefineDynamicAssembly( myAsmName, AssemblyBuilderAccess::Run );\n   ModuleBuilder^ pointModule = myAsmBuilder-&gt;DefineDynamicModule( &quot;PointModule&quot;, &quot;Point.dll&quot; );\n   TypeBuilder^ pointTypeBld = pointModule-&gt;DefineType( &quot;Point&quot;, TypeAttributes::Public );\n   FieldBuilder^ xField = pointTypeBld-&gt;DefineField( &quot;x&quot;, int::typeid, FieldAttributes::Public );\n   FieldBuilder^ yField = pointTypeBld-&gt;DefineField( &quot;y&quot;, int::typeid, FieldAttributes::Public );\n   Type^ objType = Type::GetType( &quot;System.Object&quot; );\n   ConstructorInfo^ objCtor = objType-&gt;GetConstructor( gcnew array&lt;Type^&gt;(0) );\n   ConstructorBuilder^ pointCtor = pointTypeBld-&gt;DefineConstructor( MethodAttributes::Public, CallingConventions::Standard, ctorParams );\n   ILGenerator^ ctorIL = pointCtor-&gt;GetILGenerator();\n   \n   // First, you build the constructor.\n   ctorIL-&gt;Emit( OpCodes::Ldarg_0 );\n   ctorIL-&gt;Emit( OpCodes::Call, objCtor );\n   ctorIL-&gt;Emit( OpCodes::Ldarg_0 );\n   ctorIL-&gt;Emit( OpCodes::Ldarg_1 );\n   ctorIL-&gt;Emit( OpCodes::Stfld, xField );\n   ctorIL-&gt;Emit( OpCodes::Ldarg_0 );\n   ctorIL-&gt;Emit( OpCodes::Ldarg_2 );\n   ctorIL-&gt;Emit( OpCodes::Stfld, yField );\n   ctorIL-&gt;Emit( OpCodes::Ret );\n   \n   //  Now, you&#39;ll build a method to output some information on the\n   // inside your dynamic class. This method will have the following\n   // definition in C#:\n   //  public void WritePoint()\n   MethodBuilder^ writeStrMthd = pointTypeBld-&gt;DefineMethod( &quot;WritePoint&quot;, MethodAttributes::Public, void::typeid, nullptr );\n   ILGenerator^ writeStrIL = writeStrMthd-&gt;GetILGenerator();\n   \n   // The below ILGenerator created demonstrates a few ways to create\n   // String* output through STDIN.\n   // ILGenerator::EmitWriteLine(String*) will generate a ldstr and a\n   // call to WriteLine for you.\n   writeStrIL-&gt;EmitWriteLine( &quot;The value of this current instance is:&quot; );\n   \n   // Here, you will do the hard work yourself. First, you need to create\n   // the String* we will be passing and obtain the correct WriteLine overload\n   // for said String*. In the below case, you are substituting in two values,\n   // so the chosen overload is Console::WriteLine(String*, Object*, Object*).\n   String^ inStr = &quot;( {0}, {1})&quot;;\n   array&lt;Type^&gt;^wlParams = {String::typeid,Object::typeid,Object::typeid};\n   \n   // We need the MethodInfo to pass into EmitCall later.\n   MethodInfo^ writeLineMI = Console::typeid-&gt;GetMethod( &quot;WriteLine&quot;, wlParams );\n   \n   // Push the String* with the substitutions onto the stack.\n   // This is the first argument for WriteLine - the String* one.\n   writeStrIL-&gt;Emit( OpCodes::Ldstr, inStr );\n   \n   // Since the second argument is an Object*, and it corresponds to\n   // to the substitution for the value of our integer field, you\n   // need to box that field to an Object*. First, push a reference\n   // to the current instance, and then push the value stored in\n   // field &#39;x&#39;. We need the reference to the current instance (stored\n   // in local argument index 0) so Ldfld can load from the correct\n   // instance (this one).\n   writeStrIL-&gt;Emit( OpCodes::Ldarg_0 );\n   writeStrIL-&gt;Emit( OpCodes::Ldfld, xField );\n   \n   // Now, we execute the box opcode, which pops the value of field &#39;x&#39;,\n   // returning a reference to the integer value boxed as an Object*.\n   writeStrIL-&gt;Emit( OpCodes::Box, int::typeid );\n   \n   // Atop the stack, you&#39;ll find our String* inStr, followed by a reference\n   // to the boxed value of &#39;x&#39;. Now, you need to likewise box field &#39;y&#39;.\n   writeStrIL-&gt;Emit( OpCodes::Ldarg_0 );\n   writeStrIL-&gt;Emit( OpCodes::Ldfld, yField );\n   writeStrIL-&gt;Emit( OpCodes::Box, int::typeid );\n   \n   // Now, you have all of the arguments for your call to\n   // Console::WriteLine(String*, Object*, Object*) atop the stack:\n   // the String* InStr, a reference to the boxed value of &#39;x&#39;, and\n   // a reference to the boxed value of &#39;y&#39;.\n   // Call Console::WriteLine(String*, Object*, Object*) with EmitCall.\n   writeStrIL-&gt;EmitCall( OpCodes::Call, writeLineMI, nullptr );\n   \n   // Lastly, EmitWriteLine can also output the value of a field\n   // using the overload EmitWriteLine(FieldInfo).\n   writeStrIL-&gt;EmitWriteLine( &quot;The value of &#39;x&#39; is:&quot; );\n   writeStrIL-&gt;EmitWriteLine( xField );\n   writeStrIL-&gt;EmitWriteLine( &quot;The value of &#39;y&#39; is:&quot; );\n   writeStrIL-&gt;EmitWriteLine( yField );\n   \n   // Since we return no value (void), the the ret opcode will not\n   // return the top stack value.\n   writeStrIL-&gt;Emit( OpCodes::Ret );\n   return pointTypeBld-&gt;CreateType();\n}\n\nint main()\n{\n   array&lt;Object^&gt;^ctorParams = gcnew array&lt;Object^&gt;(2);\n   Console::Write( &quot;Enter a integer value for X: &quot; );\n   String^ myX = Console::ReadLine();\n   Console::Write( &quot;Enter a integer value for Y: &quot; );\n   String^ myY = Console::ReadLine();\n   Console::WriteLine( &quot;---&quot; );\n   ctorParams[ 0 ] = Convert::ToInt32( myX );\n   ctorParams[ 1 ] = Convert::ToInt32( myY );\n   Type^ ptType = CreateDynamicType();\n   Object^ ptInstance = Activator::CreateInstance( ptType, ctorParams );\n   ptType-&gt;InvokeMember( &quot;WritePoint&quot;, BindingFlags::InvokeMethod, nullptr, ptInstance, gcnew array&lt;Object^&gt;(0) );\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Reflection.Emit.ILGenerator.OpCodes Example#1\">\nusing System;\nusing System.Threading;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\nclass EmitWriteLineDemo {\n\n   public static Type CreateDynamicType() {       \n       Type[] ctorParams = new Type[] {typeof(int),\n\t\t\t\t   typeof(int)};\n \t\n       AppDomain myDomain = Thread.GetDomain();\n       AssemblyName myAsmName = new AssemblyName();\n       myAsmName.Name = &quot;MyDynamicAssembly&quot;;\n\n       AssemblyBuilder myAsmBuilder = myDomain.DefineDynamicAssembly(\n\t\t\t\t      myAsmName, \n\t\t\t\t      AssemblyBuilderAccess.Run);\n\n       ModuleBuilder pointModule = myAsmBuilder.DefineDynamicModule(&quot;PointModule&quot;,\n\t\t\t\t\t\t\t\t    &quot;Point.dll&quot;);\n\n       TypeBuilder pointTypeBld = pointModule.DefineType(&quot;Point&quot;,\n\t\t\t\t\t              TypeAttributes.Public);\n\n       FieldBuilder xField = pointTypeBld.DefineField(&quot;x&quot;, typeof(int),\n                                                      FieldAttributes.Public);\n       FieldBuilder yField = pointTypeBld.DefineField(&quot;y&quot;, typeof(int), \n                                                      FieldAttributes.Public);\n\n\n       Type objType = Type.GetType(&quot;System.Object&quot;); \n       ConstructorInfo objCtor = objType.GetConstructor(new Type[0]);\n\n       ConstructorBuilder pointCtor = pointTypeBld.DefineConstructor(\n \t\t\t\t                   MethodAttributes.Public,\n\t\t\t\t                   CallingConventions.Standard,\n\t\t\t\t                   ctorParams);\n       ILGenerator ctorIL = pointCtor.GetILGenerator();\n\n\n       // First, you build the constructor.\n       ctorIL.Emit(OpCodes.Ldarg_0);\n       ctorIL.Emit(OpCodes.Call, objCtor);\n       ctorIL.Emit(OpCodes.Ldarg_0);\n       ctorIL.Emit(OpCodes.Ldarg_1);\n       ctorIL.Emit(OpCodes.Stfld, xField); \n       ctorIL.Emit(OpCodes.Ldarg_0);\n       ctorIL.Emit(OpCodes.Ldarg_2);\n       ctorIL.Emit(OpCodes.Stfld, yField); \n       ctorIL.Emit(OpCodes.Ret); \n\n       //  Now, you&#39;ll build a method to output some information on the\n       // inside your dynamic class. This method will have the following\n       // definition in C#:\n\t//  public void WritePoint()\n      \n       MethodBuilder writeStrMthd = pointTypeBld.DefineMethod(\n        \t\t                     &quot;WritePoint&quot;, \n\t\t\t\t             MethodAttributes.Public,\n                                             typeof(void), \n                                             null);\n\n       \n       ILGenerator writeStrIL = writeStrMthd.GetILGenerator();\n      \n       // The below ILGenerator created demonstrates a few ways to create\n       // string output through STDIN. \n\n       // ILGenerator.EmitWriteLine(string) will generate a ldstr and a \n       // call to WriteLine for you.\n\n       writeStrIL.EmitWriteLine(&quot;The value of this current instance is:&quot;);\n\n       // Here, you will do the hard work yourself. First, you need to create\n       // the string we will be passing and obtain the correct WriteLine overload\n       // for said string. In the below case, you are substituting in two values,\n       // so the chosen overload is Console.WriteLine(string, object, object).\n\n       String inStr = &quot;({0}, {1})&quot;;\n       Type[] wlParams = new Type[] {typeof(string),\n\t\t\t\t     typeof(object),\n\t\t\t\t     typeof(object)};\n\n       // We need the MethodInfo to pass into EmitCall later.\n\n       MethodInfo writeLineMI = typeof(Console).GetMethod(\n\t\t\t\t\t        &quot;WriteLine&quot;,\n\t\t\t\t\t\twlParams);\n\n       // Push the string with the substitutions onto the stack.\n       // This is the first argument for WriteLine - the string one. \n\n       writeStrIL.Emit(OpCodes.Ldstr, inStr);\n\n       // Since the second argument is an object, and it corresponds to\n       // to the substitution for the value of our integer field, you \n       // need to box that field to an object. First, push a reference\n       // to the current instance, and then push the value stored in\n       // field &#39;x&#39;. We need the reference to the current instance (stored\n       // in local argument index 0) so Ldfld can load from the correct\n       // instance (this one).\n\n       writeStrIL.Emit(OpCodes.Ldarg_0);\n       writeStrIL.Emit(OpCodes.Ldfld, xField);\n\n       // Now, we execute the box opcode, which pops the value of field &#39;x&#39;,\n       // returning a reference to the integer value boxed as an object.\n\n       writeStrIL.Emit(OpCodes.Box, typeof(int));\n\n       // Atop the stack, you&#39;ll find our string inStr, followed by a reference\n       // to the boxed value of &#39;x&#39;. Now, you need to likewise box field &#39;y&#39;.\n\n       writeStrIL.Emit(OpCodes.Ldarg_0);\n       writeStrIL.Emit(OpCodes.Ldfld, yField);\n       writeStrIL.Emit(OpCodes.Box, typeof(int));\n\n       // Now, you have all of the arguments for your call to\n       // Console.WriteLine(string, object, object) atop the stack:\n       // the string InStr, a reference to the boxed value of &#39;x&#39;, and\n       // a reference to the boxed value of &#39;y&#39;.\n\n       // Call Console.WriteLine(string, object, object) with EmitCall.\n\n       writeStrIL.EmitCall(OpCodes.Call, writeLineMI, null);\n\n       // Lastly, EmitWriteLine can also output the value of a field\n       // using the overload EmitWriteLine(FieldInfo).\n\n       writeStrIL.EmitWriteLine(&quot;The value of &#39;x&#39; is:&quot;);\n       writeStrIL.EmitWriteLine(xField);\n       writeStrIL.EmitWriteLine(&quot;The value of &#39;y&#39; is:&quot;);\n       writeStrIL.EmitWriteLine(yField);\n\n       // Since we return no value (void), the the ret opcode will not\n       // return the top stack value.\n\n       writeStrIL.Emit(OpCodes.Ret);\n      \n       return pointTypeBld.CreateType();\n\n   }\n\n   public static void Main() {\n\n      object[] ctorParams = new object[2];\n\n      Console.Write(&quot;Enter a integer value for X: &quot;); \n      string myX = Console.ReadLine();\n      Console.Write(&quot;Enter a integer value for Y: &quot;); \n      string myY = Console.ReadLine();\n\n      Console.WriteLine(&quot;---&quot;);\n\n      ctorParams[0] = Convert.ToInt32(myX);\n      ctorParams[1] = Convert.ToInt32(myY);\n\n      Type ptType = CreateDynamicType();\n  \n      object ptInstance = Activator.CreateInstance(ptType, ctorParams);\n      ptType.InvokeMember(&quot;WritePoint&quot;,\n\t\t\t  BindingFlags.InvokeMethod,\n\t\t\t  null,\n\t\t\t  ptInstance,\n\t\t\t  new object[0]);\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Reflection.Emit.ILGenerator.OpCodes Example#1\">\nImports System\nImports System.Threading\nImports System.Reflection\nImports System.Reflection.Emit\n\n _\n\nClass EmitWriteLineDemo\n   \n   \n   Public Shared Function CreateDynamicType() As Type\n\n      Dim ctorParams() As Type = {GetType(Integer), GetType(Integer)}\n      \n      Dim myDomain As AppDomain = Thread.GetDomain()\n      Dim myAsmName As New AssemblyName()\n      myAsmName.Name = &quot;MyDynamicAssembly&quot;\n      \n      Dim myAsmBuilder As AssemblyBuilder = myDomain.DefineDynamicAssembly(myAsmName, AssemblyBuilderAccess.RunAndSave)\n      \n      Dim pointModule As ModuleBuilder = myAsmBuilder.DefineDynamicModule(&quot;PointModule&quot;, &quot;Point.dll&quot;)\n      \n      Dim pointTypeBld As TypeBuilder = pointModule.DefineType(&quot;Point&quot;, _\n\t\t\t\t\t\t\t       TypeAttributes.Public)\n      \n      Dim xField As FieldBuilder = pointTypeBld.DefineField(&quot;x&quot;, _\n\t\t\t\t\t\t\t    GetType(Integer), _\n\t\t\t\t\t\t\t    FieldAttributes.Public)\n      Dim yField As FieldBuilder = pointTypeBld.DefineField(&quot;y&quot;, _\n\t\t\t\t\t\t\t    GetType(Integer), _\n\t\t\t\t\t\t \t    FieldAttributes.Public)\n      \n      \n      Dim objType As Type = Type.GetType(&quot;System.Object&quot;)\n      Dim objCtor As ConstructorInfo = objType.GetConstructor(New Type(){})\n      \n      Dim pointCtor As ConstructorBuilder = pointTypeBld.DefineConstructor( _\n\t\t\t\t\t\t\t MethodAttributes.Public, _\n\t\t\t\t\t\t\t CallingConventions.Standard, _\n\t\t\t\t\t\t\t ctorParams)\n      Dim ctorIL As ILGenerator = pointCtor.GetILGenerator()\n      \n      \n      &#39; First, you build the constructor.\n\n      ctorIL.Emit(OpCodes.Ldarg_0)\n      ctorIL.Emit(OpCodes.Call, objCtor)\n      ctorIL.Emit(OpCodes.Ldarg_0)\n      ctorIL.Emit(OpCodes.Ldarg_1)\n      ctorIL.Emit(OpCodes.Stfld, xField)\n      ctorIL.Emit(OpCodes.Ldarg_0)\n      ctorIL.Emit(OpCodes.Ldarg_2)\n      ctorIL.Emit(OpCodes.Stfld, yField)\n      ctorIL.Emit(OpCodes.Ret)\n      \n      &#39;  Now, you&#39;ll build a method to output some information on the\n      &#39; inside your dynamic class. This method will have the following\n      &#39; definition in C#:\n      &#39;  Public Sub WritePoint() \n\n      Dim writeStrMthd As MethodBuilder = pointTypeBld.DefineMethod(&quot;WritePoint&quot;, _\n\t\t\t\t\t\t\t\t    MethodAttributes.Public, _\n\t\t\t\t\t\t\t\t    Nothing, Nothing)\n      \n      Dim writeStrIL As ILGenerator = writeStrMthd.GetILGenerator()\n      \n      &#39; The below ILGenerator created demonstrates a few ways to create\n      &#39; string output through STDIN. \n      &#39; ILGenerator.EmitWriteLine(string) will generate a ldstr and a \n      &#39; call to WriteLine for you.\n\n      writeStrIL.EmitWriteLine(&quot;The value of this current instance is:&quot;)\n      \n      &#39; Here, you will do the hard work yourself. First, you need to create\n      &#39; the string we will be passing and obtain the correct WriteLine overload\n      &#39; for said string. In the below case, you are substituting in two values,\n      &#39; so the chosen overload is Console.WriteLine(string, object, object).\n\n      Dim inStr As [String] = &quot;({0}, {1})&quot;\n      Dim wlParams() As Type = {GetType(String), GetType(Object), GetType(Object)}\n      \n      &#39; We need the MethodInfo to pass into EmitCall later.\n\n      Dim writeLineMI As MethodInfo = GetType(Console).GetMethod(&quot;WriteLine&quot;, wlParams)\n      \n      &#39; Push the string with the substitutions onto the stack.\n      &#39; This is the first argument for WriteLine - the string one. \n\n      writeStrIL.Emit(OpCodes.Ldstr, inStr)\n      \n      &#39; Since the second argument is an object, and it corresponds to\n      &#39; to the substitution for the value of our integer field, you \n      &#39; need to box that field to an object. First, push a reference\n      &#39; to the current instance, and then push the value stored in\n      &#39; field &#39;x&#39;. We need the reference to the current instance (stored\n      &#39; in local argument index 0) so Ldfld can load from the correct\n      &#39; instance (this one).\n\n      writeStrIL.Emit(OpCodes.Ldarg_0)\n      writeStrIL.Emit(OpCodes.Ldfld, xField)\n      \n      &#39; Now, we execute the box opcode, which pops the value of field &#39;x&#39;,\n      &#39; returning a reference to the integer value boxed as an object.\n\n      writeStrIL.Emit(OpCodes.Box, GetType(Integer))\n      \n      &#39; Atop the stack, you&#39;ll find our string inStr, followed by a reference\n      &#39; to the boxed value of &#39;x&#39;. Now, you need to likewise box field &#39;y&#39;.\n\n      writeStrIL.Emit(OpCodes.Ldarg_0)\n      writeStrIL.Emit(OpCodes.Ldfld, yField)\n      writeStrIL.Emit(OpCodes.Box, GetType(Integer))\n      \n      &#39; Now, you have all of the arguments for your call to\n      &#39; Console.WriteLine(string, object, object) atop the stack:\n      &#39; the string InStr, a reference to the boxed value of &#39;x&#39;, and\n      &#39; a reference to the boxed value of &#39;y&#39;.\n      &#39; Call Console.WriteLine(string, object, object) with EmitCall.\n\n      writeStrIL.EmitCall(OpCodes.Call, writeLineMI, Nothing)\n      \n      &#39; Lastly, EmitWriteLine can also output the value of a field\n      &#39; using the overload EmitWriteLine(FieldInfo).\n\n      writeStrIL.EmitWriteLine(&quot;The value of &#39;x&#39; is:&quot;)\n      writeStrIL.EmitWriteLine(xField)\n      writeStrIL.EmitWriteLine(&quot;The value of &#39;y&#39; is:&quot;)\n      writeStrIL.EmitWriteLine(yField)\n      \n      &#39; Since we return no value (void), the the ret opcode will not\n      &#39; return the top stack value.\n\n      writeStrIL.Emit(OpCodes.Ret)\n      \n      Return pointTypeBld.CreateType()\n\n   End Function &#39;CreateDynamicType\n    \n   \n   Public Shared Sub Main()\n      \n      Dim ctorParams(1) As Object\n      \n      Console.Write(&quot;Enter a integer value for X: &quot;)\n      Dim myX As String = Console.ReadLine()\n      Console.Write(&quot;Enter a integer value for Y: &quot;)\n      Dim myY As String = Console.ReadLine()\n      \n      Console.WriteLine(&quot;---&quot;)\n      \n      ctorParams(0) = Convert.ToInt32(myX)\n      ctorParams(1) = Convert.ToInt32(myY)\n      \n      Dim ptType As Type = CreateDynamicType()\n\n      Dim ptInstance As Object = Activator.CreateInstance(ptType, ctorParams)\n\n      ptType.InvokeMember(&quot;WritePoint&quot;, _\n\t\t\t  BindingFlags.InvokeMethod, _\n\t\t\t  Nothing, ptInstance, Nothing)\n\n   End Sub &#39;Main\n\nEnd Class &#39;EmitWriteLineDemo\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_EmitWriteLine_System_String_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_EmitWriteLine_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">EmitWriteLine(String)</div>        \r\n          </div>\r\n    \r\n            <p>Emits the Microsoft intermediate language (MSIL) to call <span class=\"xref\">stem.Console.WriteLine*</span> with a string.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void EmitWriteLine (string value);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>value</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The string to be printed.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The string must have already been defined.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The code sample below demonstrates the contextual usage of the <code>EmitWriteLine</code> method to write a string to the console in a dynamic method.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Reflection.Emit.ILGenerator.OpCodes Example#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Reflection;\nusing namespace System::Reflection::Emit;\nType^ CreateDynamicType()\n{\n   array&lt;Type^&gt;^ctorParams = {int::typeid,int::typeid};\n   AppDomain^ myDomain = Thread::GetDomain();\n   AssemblyName^ myAsmName = gcnew AssemblyName;\n   myAsmName-&gt;Name = &quot;MyDynamicAssembly&quot;;\n   AssemblyBuilder^ myAsmBuilder = myDomain-&gt;DefineDynamicAssembly( myAsmName, AssemblyBuilderAccess::Run );\n   ModuleBuilder^ pointModule = myAsmBuilder-&gt;DefineDynamicModule( &quot;PointModule&quot;, &quot;Point.dll&quot; );\n   TypeBuilder^ pointTypeBld = pointModule-&gt;DefineType( &quot;Point&quot;, TypeAttributes::Public );\n   FieldBuilder^ xField = pointTypeBld-&gt;DefineField( &quot;x&quot;, int::typeid, FieldAttributes::Public );\n   FieldBuilder^ yField = pointTypeBld-&gt;DefineField( &quot;y&quot;, int::typeid, FieldAttributes::Public );\n   Type^ objType = Type::GetType( &quot;System.Object&quot; );\n   ConstructorInfo^ objCtor = objType-&gt;GetConstructor( gcnew array&lt;Type^&gt;(0) );\n   ConstructorBuilder^ pointCtor = pointTypeBld-&gt;DefineConstructor( MethodAttributes::Public, CallingConventions::Standard, ctorParams );\n   ILGenerator^ ctorIL = pointCtor-&gt;GetILGenerator();\n   \n   // First, you build the constructor.\n   ctorIL-&gt;Emit( OpCodes::Ldarg_0 );\n   ctorIL-&gt;Emit( OpCodes::Call, objCtor );\n   ctorIL-&gt;Emit( OpCodes::Ldarg_0 );\n   ctorIL-&gt;Emit( OpCodes::Ldarg_1 );\n   ctorIL-&gt;Emit( OpCodes::Stfld, xField );\n   ctorIL-&gt;Emit( OpCodes::Ldarg_0 );\n   ctorIL-&gt;Emit( OpCodes::Ldarg_2 );\n   ctorIL-&gt;Emit( OpCodes::Stfld, yField );\n   ctorIL-&gt;Emit( OpCodes::Ret );\n   \n   //  Now, you&#39;ll build a method to output some information on the\n   // inside your dynamic class. This method will have the following\n   // definition in C#:\n   //  public void WritePoint()\n   MethodBuilder^ writeStrMthd = pointTypeBld-&gt;DefineMethod( &quot;WritePoint&quot;, MethodAttributes::Public, void::typeid, nullptr );\n   ILGenerator^ writeStrIL = writeStrMthd-&gt;GetILGenerator();\n   \n   // The below ILGenerator created demonstrates a few ways to create\n   // String* output through STDIN.\n   // ILGenerator::EmitWriteLine(String*) will generate a ldstr and a\n   // call to WriteLine for you.\n   writeStrIL-&gt;EmitWriteLine( &quot;The value of this current instance is:&quot; );\n   \n   // Here, you will do the hard work yourself. First, you need to create\n   // the String* we will be passing and obtain the correct WriteLine overload\n   // for said String*. In the below case, you are substituting in two values,\n   // so the chosen overload is Console::WriteLine(String*, Object*, Object*).\n   String^ inStr = &quot;( {0}, {1})&quot;;\n   array&lt;Type^&gt;^wlParams = {String::typeid,Object::typeid,Object::typeid};\n   \n   // We need the MethodInfo to pass into EmitCall later.\n   MethodInfo^ writeLineMI = Console::typeid-&gt;GetMethod( &quot;WriteLine&quot;, wlParams );\n   \n   // Push the String* with the substitutions onto the stack.\n   // This is the first argument for WriteLine - the String* one.\n   writeStrIL-&gt;Emit( OpCodes::Ldstr, inStr );\n   \n   // Since the second argument is an Object*, and it corresponds to\n   // to the substitution for the value of our integer field, you\n   // need to box that field to an Object*. First, push a reference\n   // to the current instance, and then push the value stored in\n   // field &#39;x&#39;. We need the reference to the current instance (stored\n   // in local argument index 0) so Ldfld can load from the correct\n   // instance (this one).\n   writeStrIL-&gt;Emit( OpCodes::Ldarg_0 );\n   writeStrIL-&gt;Emit( OpCodes::Ldfld, xField );\n   \n   // Now, we execute the box opcode, which pops the value of field &#39;x&#39;,\n   // returning a reference to the integer value boxed as an Object*.\n   writeStrIL-&gt;Emit( OpCodes::Box, int::typeid );\n   \n   // Atop the stack, you&#39;ll find our String* inStr, followed by a reference\n   // to the boxed value of &#39;x&#39;. Now, you need to likewise box field &#39;y&#39;.\n   writeStrIL-&gt;Emit( OpCodes::Ldarg_0 );\n   writeStrIL-&gt;Emit( OpCodes::Ldfld, yField );\n   writeStrIL-&gt;Emit( OpCodes::Box, int::typeid );\n   \n   // Now, you have all of the arguments for your call to\n   // Console::WriteLine(String*, Object*, Object*) atop the stack:\n   // the String* InStr, a reference to the boxed value of &#39;x&#39;, and\n   // a reference to the boxed value of &#39;y&#39;.\n   // Call Console::WriteLine(String*, Object*, Object*) with EmitCall.\n   writeStrIL-&gt;EmitCall( OpCodes::Call, writeLineMI, nullptr );\n   \n   // Lastly, EmitWriteLine can also output the value of a field\n   // using the overload EmitWriteLine(FieldInfo).\n   writeStrIL-&gt;EmitWriteLine( &quot;The value of &#39;x&#39; is:&quot; );\n   writeStrIL-&gt;EmitWriteLine( xField );\n   writeStrIL-&gt;EmitWriteLine( &quot;The value of &#39;y&#39; is:&quot; );\n   writeStrIL-&gt;EmitWriteLine( yField );\n   \n   // Since we return no value (void), the the ret opcode will not\n   // return the top stack value.\n   writeStrIL-&gt;Emit( OpCodes::Ret );\n   return pointTypeBld-&gt;CreateType();\n}\n\nint main()\n{\n   array&lt;Object^&gt;^ctorParams = gcnew array&lt;Object^&gt;(2);\n   Console::Write( &quot;Enter a integer value for X: &quot; );\n   String^ myX = Console::ReadLine();\n   Console::Write( &quot;Enter a integer value for Y: &quot; );\n   String^ myY = Console::ReadLine();\n   Console::WriteLine( &quot;---&quot; );\n   ctorParams[ 0 ] = Convert::ToInt32( myX );\n   ctorParams[ 1 ] = Convert::ToInt32( myY );\n   Type^ ptType = CreateDynamicType();\n   Object^ ptInstance = Activator::CreateInstance( ptType, ctorParams );\n   ptType-&gt;InvokeMember( &quot;WritePoint&quot;, BindingFlags::InvokeMethod, nullptr, ptInstance, gcnew array&lt;Object^&gt;(0) );\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Reflection.Emit.ILGenerator.OpCodes Example#1\">\nusing System;\nusing System.Threading;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\nclass EmitWriteLineDemo {\n\n   public static Type CreateDynamicType() {       \n       Type[] ctorParams = new Type[] {typeof(int),\n\t\t\t\t   typeof(int)};\n \t\n       AppDomain myDomain = Thread.GetDomain();\n       AssemblyName myAsmName = new AssemblyName();\n       myAsmName.Name = &quot;MyDynamicAssembly&quot;;\n\n       AssemblyBuilder myAsmBuilder = myDomain.DefineDynamicAssembly(\n\t\t\t\t      myAsmName, \n\t\t\t\t      AssemblyBuilderAccess.Run);\n\n       ModuleBuilder pointModule = myAsmBuilder.DefineDynamicModule(&quot;PointModule&quot;,\n\t\t\t\t\t\t\t\t    &quot;Point.dll&quot;);\n\n       TypeBuilder pointTypeBld = pointModule.DefineType(&quot;Point&quot;,\n\t\t\t\t\t              TypeAttributes.Public);\n\n       FieldBuilder xField = pointTypeBld.DefineField(&quot;x&quot;, typeof(int),\n                                                      FieldAttributes.Public);\n       FieldBuilder yField = pointTypeBld.DefineField(&quot;y&quot;, typeof(int), \n                                                      FieldAttributes.Public);\n\n\n       Type objType = Type.GetType(&quot;System.Object&quot;); \n       ConstructorInfo objCtor = objType.GetConstructor(new Type[0]);\n\n       ConstructorBuilder pointCtor = pointTypeBld.DefineConstructor(\n \t\t\t\t                   MethodAttributes.Public,\n\t\t\t\t                   CallingConventions.Standard,\n\t\t\t\t                   ctorParams);\n       ILGenerator ctorIL = pointCtor.GetILGenerator();\n\n\n       // First, you build the constructor.\n       ctorIL.Emit(OpCodes.Ldarg_0);\n       ctorIL.Emit(OpCodes.Call, objCtor);\n       ctorIL.Emit(OpCodes.Ldarg_0);\n       ctorIL.Emit(OpCodes.Ldarg_1);\n       ctorIL.Emit(OpCodes.Stfld, xField); \n       ctorIL.Emit(OpCodes.Ldarg_0);\n       ctorIL.Emit(OpCodes.Ldarg_2);\n       ctorIL.Emit(OpCodes.Stfld, yField); \n       ctorIL.Emit(OpCodes.Ret); \n\n       //  Now, you&#39;ll build a method to output some information on the\n       // inside your dynamic class. This method will have the following\n       // definition in C#:\n\t//  public void WritePoint()\n      \n       MethodBuilder writeStrMthd = pointTypeBld.DefineMethod(\n        \t\t                     &quot;WritePoint&quot;, \n\t\t\t\t             MethodAttributes.Public,\n                                             typeof(void), \n                                             null);\n\n       \n       ILGenerator writeStrIL = writeStrMthd.GetILGenerator();\n      \n       // The below ILGenerator created demonstrates a few ways to create\n       // string output through STDIN. \n\n       // ILGenerator.EmitWriteLine(string) will generate a ldstr and a \n       // call to WriteLine for you.\n\n       writeStrIL.EmitWriteLine(&quot;The value of this current instance is:&quot;);\n\n       // Here, you will do the hard work yourself. First, you need to create\n       // the string we will be passing and obtain the correct WriteLine overload\n       // for said string. In the below case, you are substituting in two values,\n       // so the chosen overload is Console.WriteLine(string, object, object).\n\n       String inStr = &quot;({0}, {1})&quot;;\n       Type[] wlParams = new Type[] {typeof(string),\n\t\t\t\t     typeof(object),\n\t\t\t\t     typeof(object)};\n\n       // We need the MethodInfo to pass into EmitCall later.\n\n       MethodInfo writeLineMI = typeof(Console).GetMethod(\n\t\t\t\t\t        &quot;WriteLine&quot;,\n\t\t\t\t\t\twlParams);\n\n       // Push the string with the substitutions onto the stack.\n       // This is the first argument for WriteLine - the string one. \n\n       writeStrIL.Emit(OpCodes.Ldstr, inStr);\n\n       // Since the second argument is an object, and it corresponds to\n       // to the substitution for the value of our integer field, you \n       // need to box that field to an object. First, push a reference\n       // to the current instance, and then push the value stored in\n       // field &#39;x&#39;. We need the reference to the current instance (stored\n       // in local argument index 0) so Ldfld can load from the correct\n       // instance (this one).\n\n       writeStrIL.Emit(OpCodes.Ldarg_0);\n       writeStrIL.Emit(OpCodes.Ldfld, xField);\n\n       // Now, we execute the box opcode, which pops the value of field &#39;x&#39;,\n       // returning a reference to the integer value boxed as an object.\n\n       writeStrIL.Emit(OpCodes.Box, typeof(int));\n\n       // Atop the stack, you&#39;ll find our string inStr, followed by a reference\n       // to the boxed value of &#39;x&#39;. Now, you need to likewise box field &#39;y&#39;.\n\n       writeStrIL.Emit(OpCodes.Ldarg_0);\n       writeStrIL.Emit(OpCodes.Ldfld, yField);\n       writeStrIL.Emit(OpCodes.Box, typeof(int));\n\n       // Now, you have all of the arguments for your call to\n       // Console.WriteLine(string, object, object) atop the stack:\n       // the string InStr, a reference to the boxed value of &#39;x&#39;, and\n       // a reference to the boxed value of &#39;y&#39;.\n\n       // Call Console.WriteLine(string, object, object) with EmitCall.\n\n       writeStrIL.EmitCall(OpCodes.Call, writeLineMI, null);\n\n       // Lastly, EmitWriteLine can also output the value of a field\n       // using the overload EmitWriteLine(FieldInfo).\n\n       writeStrIL.EmitWriteLine(&quot;The value of &#39;x&#39; is:&quot;);\n       writeStrIL.EmitWriteLine(xField);\n       writeStrIL.EmitWriteLine(&quot;The value of &#39;y&#39; is:&quot;);\n       writeStrIL.EmitWriteLine(yField);\n\n       // Since we return no value (void), the the ret opcode will not\n       // return the top stack value.\n\n       writeStrIL.Emit(OpCodes.Ret);\n      \n       return pointTypeBld.CreateType();\n\n   }\n\n   public static void Main() {\n\n      object[] ctorParams = new object[2];\n\n      Console.Write(&quot;Enter a integer value for X: &quot;); \n      string myX = Console.ReadLine();\n      Console.Write(&quot;Enter a integer value for Y: &quot;); \n      string myY = Console.ReadLine();\n\n      Console.WriteLine(&quot;---&quot;);\n\n      ctorParams[0] = Convert.ToInt32(myX);\n      ctorParams[1] = Convert.ToInt32(myY);\n\n      Type ptType = CreateDynamicType();\n  \n      object ptInstance = Activator.CreateInstance(ptType, ctorParams);\n      ptType.InvokeMember(&quot;WritePoint&quot;,\n\t\t\t  BindingFlags.InvokeMethod,\n\t\t\t  null,\n\t\t\t  ptInstance,\n\t\t\t  new object[0]);\n   }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Reflection.Emit.ILGenerator.OpCodes Example#1\">\nImports System\nImports System.Threading\nImports System.Reflection\nImports System.Reflection.Emit\n\n _\n\nClass EmitWriteLineDemo\n   \n   \n   Public Shared Function CreateDynamicType() As Type\n\n      Dim ctorParams() As Type = {GetType(Integer), GetType(Integer)}\n      \n      Dim myDomain As AppDomain = Thread.GetDomain()\n      Dim myAsmName As New AssemblyName()\n      myAsmName.Name = &quot;MyDynamicAssembly&quot;\n      \n      Dim myAsmBuilder As AssemblyBuilder = myDomain.DefineDynamicAssembly(myAsmName, AssemblyBuilderAccess.RunAndSave)\n      \n      Dim pointModule As ModuleBuilder = myAsmBuilder.DefineDynamicModule(&quot;PointModule&quot;, &quot;Point.dll&quot;)\n      \n      Dim pointTypeBld As TypeBuilder = pointModule.DefineType(&quot;Point&quot;, _\n\t\t\t\t\t\t\t       TypeAttributes.Public)\n      \n      Dim xField As FieldBuilder = pointTypeBld.DefineField(&quot;x&quot;, _\n\t\t\t\t\t\t\t    GetType(Integer), _\n\t\t\t\t\t\t\t    FieldAttributes.Public)\n      Dim yField As FieldBuilder = pointTypeBld.DefineField(&quot;y&quot;, _\n\t\t\t\t\t\t\t    GetType(Integer), _\n\t\t\t\t\t\t \t    FieldAttributes.Public)\n      \n      \n      Dim objType As Type = Type.GetType(&quot;System.Object&quot;)\n      Dim objCtor As ConstructorInfo = objType.GetConstructor(New Type(){})\n      \n      Dim pointCtor As ConstructorBuilder = pointTypeBld.DefineConstructor( _\n\t\t\t\t\t\t\t MethodAttributes.Public, _\n\t\t\t\t\t\t\t CallingConventions.Standard, _\n\t\t\t\t\t\t\t ctorParams)\n      Dim ctorIL As ILGenerator = pointCtor.GetILGenerator()\n      \n      \n      &#39; First, you build the constructor.\n\n      ctorIL.Emit(OpCodes.Ldarg_0)\n      ctorIL.Emit(OpCodes.Call, objCtor)\n      ctorIL.Emit(OpCodes.Ldarg_0)\n      ctorIL.Emit(OpCodes.Ldarg_1)\n      ctorIL.Emit(OpCodes.Stfld, xField)\n      ctorIL.Emit(OpCodes.Ldarg_0)\n      ctorIL.Emit(OpCodes.Ldarg_2)\n      ctorIL.Emit(OpCodes.Stfld, yField)\n      ctorIL.Emit(OpCodes.Ret)\n      \n      &#39;  Now, you&#39;ll build a method to output some information on the\n      &#39; inside your dynamic class. This method will have the following\n      &#39; definition in C#:\n      &#39;  Public Sub WritePoint() \n\n      Dim writeStrMthd As MethodBuilder = pointTypeBld.DefineMethod(&quot;WritePoint&quot;, _\n\t\t\t\t\t\t\t\t    MethodAttributes.Public, _\n\t\t\t\t\t\t\t\t    Nothing, Nothing)\n      \n      Dim writeStrIL As ILGenerator = writeStrMthd.GetILGenerator()\n      \n      &#39; The below ILGenerator created demonstrates a few ways to create\n      &#39; string output through STDIN. \n      &#39; ILGenerator.EmitWriteLine(string) will generate a ldstr and a \n      &#39; call to WriteLine for you.\n\n      writeStrIL.EmitWriteLine(&quot;The value of this current instance is:&quot;)\n      \n      &#39; Here, you will do the hard work yourself. First, you need to create\n      &#39; the string we will be passing and obtain the correct WriteLine overload\n      &#39; for said string. In the below case, you are substituting in two values,\n      &#39; so the chosen overload is Console.WriteLine(string, object, object).\n\n      Dim inStr As [String] = &quot;({0}, {1})&quot;\n      Dim wlParams() As Type = {GetType(String), GetType(Object), GetType(Object)}\n      \n      &#39; We need the MethodInfo to pass into EmitCall later.\n\n      Dim writeLineMI As MethodInfo = GetType(Console).GetMethod(&quot;WriteLine&quot;, wlParams)\n      \n      &#39; Push the string with the substitutions onto the stack.\n      &#39; This is the first argument for WriteLine - the string one. \n\n      writeStrIL.Emit(OpCodes.Ldstr, inStr)\n      \n      &#39; Since the second argument is an object, and it corresponds to\n      &#39; to the substitution for the value of our integer field, you \n      &#39; need to box that field to an object. First, push a reference\n      &#39; to the current instance, and then push the value stored in\n      &#39; field &#39;x&#39;. We need the reference to the current instance (stored\n      &#39; in local argument index 0) so Ldfld can load from the correct\n      &#39; instance (this one).\n\n      writeStrIL.Emit(OpCodes.Ldarg_0)\n      writeStrIL.Emit(OpCodes.Ldfld, xField)\n      \n      &#39; Now, we execute the box opcode, which pops the value of field &#39;x&#39;,\n      &#39; returning a reference to the integer value boxed as an object.\n\n      writeStrIL.Emit(OpCodes.Box, GetType(Integer))\n      \n      &#39; Atop the stack, you&#39;ll find our string inStr, followed by a reference\n      &#39; to the boxed value of &#39;x&#39;. Now, you need to likewise box field &#39;y&#39;.\n\n      writeStrIL.Emit(OpCodes.Ldarg_0)\n      writeStrIL.Emit(OpCodes.Ldfld, yField)\n      writeStrIL.Emit(OpCodes.Box, GetType(Integer))\n      \n      &#39; Now, you have all of the arguments for your call to\n      &#39; Console.WriteLine(string, object, object) atop the stack:\n      &#39; the string InStr, a reference to the boxed value of &#39;x&#39;, and\n      &#39; a reference to the boxed value of &#39;y&#39;.\n      &#39; Call Console.WriteLine(string, object, object) with EmitCall.\n\n      writeStrIL.EmitCall(OpCodes.Call, writeLineMI, Nothing)\n      \n      &#39; Lastly, EmitWriteLine can also output the value of a field\n      &#39; using the overload EmitWriteLine(FieldInfo).\n\n      writeStrIL.EmitWriteLine(&quot;The value of &#39;x&#39; is:&quot;)\n      writeStrIL.EmitWriteLine(xField)\n      writeStrIL.EmitWriteLine(&quot;The value of &#39;y&#39; is:&quot;)\n      writeStrIL.EmitWriteLine(yField)\n      \n      &#39; Since we return no value (void), the the ret opcode will not\n      &#39; return the top stack value.\n\n      writeStrIL.Emit(OpCodes.Ret)\n      \n      Return pointTypeBld.CreateType()\n\n   End Function &#39;CreateDynamicType\n    \n   \n   Public Shared Sub Main()\n      \n      Dim ctorParams(1) As Object\n      \n      Console.Write(&quot;Enter a integer value for X: &quot;)\n      Dim myX As String = Console.ReadLine()\n      Console.Write(&quot;Enter a integer value for Y: &quot;)\n      Dim myY As String = Console.ReadLine()\n      \n      Console.WriteLine(&quot;---&quot;)\n      \n      ctorParams(0) = Convert.ToInt32(myX)\n      ctorParams(1) = Convert.ToInt32(myY)\n      \n      Dim ptType As Type = CreateDynamicType()\n\n      Dim ptInstance As Object = Activator.CreateInstance(ptType, ctorParams)\n\n      ptType.InvokeMember(&quot;WritePoint&quot;, _\n\t\t\t  BindingFlags.InvokeMethod, _\n\t\t\t  Nothing, ptInstance, Nothing)\n\n   End Sub &#39;Main\n\nEnd Class &#39;EmitWriteLineDemo\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_EndExceptionBlock\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_EndExceptionBlock_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">EndExceptionBlock()</div>        \r\n          </div>\r\n    \r\n            <p>Ends an exception block.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void EndExceptionBlock ();</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.invalidoperationexception\" data-linktype=\"relative-path\">InvalidOperationException</a></div>\r\n                  </div>\r\n                  <p>The end exception block occurs in an unexpected place in the code stream.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The Microsoft intermediate language (MSIL) being generated is not currently in an exception block.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The code sample below demonstrates the contextual usage of the <code>EndExceptionBlock</code> method.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Reflection.Emit.ILGenerator.ThrowException Example#1\">Imports System\nImports System.Reflection\nImports System.Reflection.Emit\n\nClass ILThrowExceptionDemo\n   \n   Public Shared Sub Main()\n            \n      Dim current As AppDomain = AppDomain.CurrentDomain\n      Dim myAsmName As New AssemblyName()\n      myAsmName.Name = &quot;AdderExceptionAsm&quot;\n      Dim myAsmBldr As AssemblyBuilder = _\n                 current.DefineDynamicAssembly(myAsmName, _\n                     AssemblyBuilderAccess.RunAndSave)\n      \n      Dim myModBldr As ModuleBuilder = _\n                     myAsmBldr.DefineDynamicModule(myAsmName.Name, _\n                         myAsmName.Name &amp; &quot;.dll&quot;)\n      \n      Dim myTypeBldr As TypeBuilder = myModBldr.DefineType(&quot;Adder&quot;)\n      \n      Dim adderParams() As Type = {GetType(Integer), GetType(Integer)}\n      \n      &#39; This method will add two numbers which are 100 or less. If either of the\n      &#39; passed integer vales are greater than 100, it will throw an exception.\n      Dim adderBldr As MethodBuilder = myTypeBldr.DefineMethod(&quot;DoAdd&quot;, _\n                  MethodAttributes.Public Or MethodAttributes.Static, _\n                  GetType(Integer), adderParams)\n      Dim adderIL As ILGenerator = adderBldr.GetILGenerator()\n\n      &#39; Types and methods used in the code to throw, catch, and\n      &#39; display OverflowException. Note that if the catch block were\n      &#39; for a more general type, such as Exception, we would need \n      &#39; a MethodInfo for that type&#39;s ToString method.\n      &#39; \n      Dim overflow As Type = GetType(OverflowException)\n      Dim exCtorInfo As ConstructorInfo = overflow.GetConstructor( _\n                     New Type() {GetType(String)})\n      Dim exToStrMI As MethodInfo = overflow.GetMethod(&quot;ToString&quot;)\n      Dim writeLineMI As MethodInfo = GetType(Console).GetMethod(&quot;WriteLine&quot;, _\n                     New Type() {GetType(String), _\n                            GetType(Object)})\n      \n      Dim tmp1 As LocalBuilder = adderIL.DeclareLocal(GetType(Integer))\n      Dim tmp2 As LocalBuilder = adderIL.DeclareLocal(overflow)\n      \n      &#39; In order to successfully branch, we need to create labels\n      &#39; representing the offset IL instruction block to branch to.\n      &#39; These labels, when the MarkLabel(Label) method is invoked,\n      &#39; will specify the IL instruction to branch to.\n      &#39;\n      Dim failed As Label = adderIL.DefineLabel()\n      Dim endOfMthd As Label = adderIL.DefineLabel()\n\n      &#39; Begin the try block.      \n      Dim exBlock As Label = adderIL.BeginExceptionBlock()\n\n      &#39; First, load argument 0 and the integer value of &quot;100&quot; onto the\n      &#39; stack. If arg0 &gt; 100, branch to the label &quot;failed&quot;, which is marked\n      &#39; as the address of the block that throws an exception.\n      &#39;\n      adderIL.Emit(OpCodes.Ldarg_0)\n      adderIL.Emit(OpCodes.Ldc_I4_S, 100)\n      adderIL.Emit(OpCodes.Bgt_S, failed)\n      \n      &#39; Now, check to see if argument 1 was greater than 100. If it was,\n      &#39; branch to &quot;failed.&quot; Otherwise, fall through and perform the addition,\n      &#39; branching unconditionally to the instruction at the label &quot;endOfMthd&quot;.\n      &#39;\n      adderIL.Emit(OpCodes.Ldarg_1)\n      adderIL.Emit(OpCodes.Ldc_I4_S, 100)\n      adderIL.Emit(OpCodes.Bgt_S, failed)\n      \n      adderIL.Emit(OpCodes.Ldarg_0)\n      adderIL.Emit(OpCodes.Ldarg_1)\n      adderIL.Emit(OpCodes.Add_Ovf_Un)\n      &#39; Store the result of the addition.\n      adderIL.Emit(OpCodes.Stloc_S, tmp1)\n      adderIL.Emit(OpCodes.Br_S, endOfMthd)\n      \n      &#39; If one of the arguments was greater than 100, we need to throw an\n      &#39; exception. We&#39;ll use &quot;OverflowException&quot; with a customized message.\n      &#39; First, we load our message onto the stack, and then create a new\n      &#39; exception object using the constructor overload that accepts a\n      &#39; string message.\n      adderIL.MarkLabel(failed)\n      adderIL.Emit(OpCodes.Ldstr, &quot;Cannot accept values over 100 for add.&quot;)\n      adderIL.Emit(OpCodes.Newobj, exCtorInfo)\n      \n      &#39; Throw the exception now on the stack.\n      adderIL.ThrowException(overflow)\n      \n      &#39; Start the catch block for OverflowException.\n      &#39;\n      adderIL.BeginCatchBlock(overflow)\n\n      &#39; When we enter the catch block, the thrown exception \n      &#39; is on the stack. Store it, then load the format string\n      &#39; for WriteLine. \n      &#39;\n      adderIL.Emit(OpCodes.Stloc_S, tmp2)\n      adderIL.Emit(OpCodes.Ldstr, &quot;Caught {0}&quot;)\n\n      &#39; Push the thrown exception back on the stack, then \n      &#39; call its ToString() method. Note that if this catch block\n      &#39; were for a more general exception type, like Exception,\n      &#39; it would be necessary to use the ToString for that type.\n      &#39;\n      adderIL.Emit(OpCodes.Ldloc_S, tmp2)\n      adderIL.EmitCall(OpCodes.Callvirt, exToStrMI, Nothing)\n      \n      &#39; The format string and the return value from ToString() are\n      &#39; now on the stack. Call WriteLine(string, object).\n      &#39;\n      adderIL.EmitCall(OpCodes.Call, writeLineMI, Nothing)\n      \n      &#39; Since our function has to return an integer value, load -1 onto\n      &#39; the stack to indicate an error, and store it in local variable\n      &#39; tmp1.\n      adderIL.Emit(OpCodes.Ldc_I4_M1)\n      adderIL.Emit(OpCodes.Stloc_S, tmp1)\n      \n      &#39; End the exception handling block.\n\n      adderIL.EndExceptionBlock()\n      \n      &#39; The end of the method. If no exception was thrown, the correct value\n      &#39; will be saved in tmp1. If an exception was thrown, tmp1 will be equal\n      &#39; to -1. Either way, we&#39;ll load the value of tmp1 onto the stack and return.\n      &#39;\n      adderIL.MarkLabel(endOfMthd)\n      adderIL.Emit(OpCodes.Ldloc_S, tmp1)\n      adderIL.Emit(OpCodes.Ret)\n      \n      Dim adderType As Type = myTypeBldr.CreateType()\n\n      Dim addIns As Object = Activator.CreateInstance(adderType)\n      \n      Dim addParams(1) As Object\n      \n      Console.Write(&quot;Enter an integer value: &quot;)\n      addParams(0) = CType(Convert.ToInt32(Console.ReadLine()), Object)\n      \n      Console.Write(&quot;Enter another integer value: &quot;)\n      addParams(1) = CType(Convert.ToInt32(Console.ReadLine()), Object)\n      \n      Console.WriteLine(&quot;If either integer was &gt; 100, an exception will be thrown.&quot;)\n      Console.WriteLine(&quot;---&quot;)\n      \n      Console.WriteLine(&quot;{0} + {1} = {2}&quot;, addParams(0), addParams(1), _\n         adderType.InvokeMember(&quot;DoAdd&quot;, BindingFlags.InvokeMethod, _\n                  Nothing, addIns, addParams))\n   End Sub \n\nEnd Class \n\n&#39; This code example produces output similar to the following:\n&#39;\n&#39;Enter an integer value: 24\n&#39;Enter another integer value: 101\n&#39;If either integer was &gt; 100, an exception will be thrown.\n&#39;---\n&#39;Caught System.OverflowException: Arithmetic operation resulted in an overflow.\n&#39;   at Adder.DoAdd(Int32 , Int32 )\n&#39;24 + 101 = -1\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Reflection.Emit.ILGenerator.ThrowException Example#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Reflection;\nusing namespace System::Reflection::Emit;\n\nint main()\n{\n   AppDomain^ myDomain = Thread::GetDomain();\n   AssemblyName^ myAsmName = gcnew AssemblyName;\n   myAsmName-&gt;Name = &quot;AdderExceptionAsm&quot;;\n   AssemblyBuilder^ myAsmBldr = myDomain-&gt;DefineDynamicAssembly( myAsmName, \n      AssemblyBuilderAccess::RunAndSave );\n   ModuleBuilder^ myModBldr = myAsmBldr-&gt;DefineDynamicModule( myAsmName-&gt;Name,\n      myAsmName-&gt;Name + &quot;.dll&quot; );\n   TypeBuilder^ myTypeBldr = myModBldr-&gt;DefineType( &quot;Adder&quot; );\n   array&lt;Type^&gt;^adderParams = {int::typeid,int::typeid};\n   \n   // This method will add two numbers which are 100 or less. If either of the\n   // passed integer vales are greater than 100, it will throw an exception.\n   MethodBuilder^ adderBldr = myTypeBldr-&gt;DefineMethod( &quot;DoAdd&quot;, \n      static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::Static), \n      int::typeid, adderParams );\n   ILGenerator^ adderIL = adderBldr-&gt;GetILGenerator();\n   \n   // Types and methods used in the code to throw, catch, and\n   // display OverflowException. Note that if the catch block were\n   // for a more general type, such as Exception, we would need \n   // a MethodInfo for that type&#39;s ToString method.\n   // \n   Type^ overflow = OverflowException::typeid;\n   ConstructorInfo^ exCtorInfo = overflow-&gt;GetConstructor( \n      gcnew array&lt;Type^&gt; { String::typeid });\n   MethodInfo^ exToStrMI = overflow-&gt;GetMethod( &quot;ToString&quot; );\n   MethodInfo^ writeLineMI = Console::typeid-&gt;GetMethod( &quot;WriteLine&quot;, \n      gcnew array&lt;Type^&gt; { String::typeid, Object::typeid } );\n\n   LocalBuilder^ tmp1 = adderIL-&gt;DeclareLocal( int::typeid );\n   LocalBuilder^ tmp2 = adderIL-&gt;DeclareLocal( overflow );\n\n   // In order to successfully branch, we need to create labels\n   // representing the offset IL instruction block to branch to.\n   // These labels, when the MarkLabel(Label) method is invoked,\n   // will specify the IL instruction to branch to.\n   //\n   Label failed = adderIL-&gt;DefineLabel();\n   Label endOfMthd = adderIL-&gt;DefineLabel();\n\n   // Begin the try block.\n   Label exBlock = adderIL-&gt;BeginExceptionBlock();\n   \n   // First, load argument 0 and the integer value of S&quot;100&quot; onto the\n   // stack. If arg0 &gt; 100, branch to the label S&quot;failed&quot;, which is marked\n   // as the address of the block that throws an exception.\n   adderIL-&gt;Emit( OpCodes::Ldarg_0 );\n   adderIL-&gt;Emit( OpCodes::Ldc_I4_S, 100 );\n   adderIL-&gt;Emit( OpCodes::Bgt_S, failed );\n   \n   // Now, check to see if argument 1 was greater than 100. If it was,\n   // branch to S&quot;failed.&quot; Otherwise, fall through and perform the addition,\n   // branching unconditionally to the instruction at the label S&quot;endOfMthd&quot;.\n   adderIL-&gt;Emit( OpCodes::Ldarg_1 );\n   adderIL-&gt;Emit( OpCodes::Ldc_I4_S, 100 );\n   adderIL-&gt;Emit( OpCodes::Bgt_S, failed );\n\n   adderIL-&gt;Emit( OpCodes::Ldarg_0 );\n   adderIL-&gt;Emit( OpCodes::Ldarg_1 );\n   adderIL-&gt;Emit( OpCodes::Add_Ovf_Un );\n   // Store the result of the addition.\n   adderIL-&gt;Emit( OpCodes::Stloc_S, tmp1 );\n   adderIL-&gt;Emit( OpCodes::Br_S, endOfMthd );\n   \n   // If one of the arguments was greater than 100, we need to throw an\n   // exception. We&#39;ll use &quot;OverflowException&quot; with a customized message.\n   // First, we load our message onto the stack, and then create a new\n   // exception Object using the constructor overload that accepts a\n   // String* message.\n   adderIL-&gt;MarkLabel( failed );\n   adderIL-&gt;Emit( OpCodes::Ldstr, &quot;Cannot accept values over 100 for add.&quot; );\n   adderIL-&gt;Emit( OpCodes::Newobj, exCtorInfo );\n   \n   // We&#39;re going to need to refer to that exception Object later, so let&#39;s\n   // store it in a temporary variable. Since the store function pops the\n   // the value/reference off the stack, and we&#39;ll need it to throw the\n   // exception, we will subsequently load it back onto the stack as well.\n   adderIL-&gt;Emit( OpCodes::Stloc_S, tmp2 );\n   adderIL-&gt;Emit( OpCodes::Ldloc_S, tmp2 );\n   \n   // Throw the exception now on the stack.\n   adderIL-&gt;ThrowException( overflow );\n   \n   // Start the catch block for OverflowException.\n   //\n   adderIL-&gt;BeginCatchBlock( overflow );\n   \n   // When we enter the catch block, the thrown exception \n   // is on the stack. Store it, then load the format string\n   // for WriteLine. \n   //\n   adderIL-&gt;Emit(OpCodes::Stloc_S, tmp2);\n   adderIL-&gt;Emit(OpCodes::Ldstr, &quot;Caught {0}&quot;);\n\n   // Push the thrown exception back on the stack, then \n   // call its ToString() method. Note that if this catch block\n   // were for a more general exception type, like Exception,\n   // it would be necessary to use the ToString for that type.\n   //\n   adderIL-&gt;Emit(OpCodes::Ldloc_S, tmp2);\n   adderIL-&gt;EmitCall(OpCodes::Callvirt, exToStrMI, nullptr);\n      \n   // The format string and the return value from ToString() are\n   // now on the stack. Call WriteLine(string, object).\n   //\n   adderIL-&gt;EmitCall( OpCodes::Call, writeLineMI, nullptr );\n   \n   // Since our function has to return an integer value, we&#39;ll load -1 onto\n   // the stack to indicate an error, and store it in local variable tmp1.\n   adderIL-&gt;Emit( OpCodes::Ldc_I4_M1 );\n   adderIL-&gt;Emit( OpCodes::Stloc_S, tmp1 );\n   \n   // End the exception handling block.\n   adderIL-&gt;EndExceptionBlock();\n   \n   // The end of the method. If no exception was thrown, the correct value\n   // will be saved in tmp1. If an exception was thrown, tmp1 will be equal\n   // to -1. Either way, we&#39;ll load the value of tmp1 onto the stack and return.\n   adderIL-&gt;MarkLabel( endOfMthd );\n   adderIL-&gt;Emit( OpCodes::Ldloc_S, tmp1 );\n   adderIL-&gt;Emit( OpCodes::Ret );\n\n   Type^ adderType = myTypeBldr-&gt;CreateType();\n\n   Object^ addIns = Activator::CreateInstance( adderType );\n\n   array&lt;Object^&gt;^addParams = gcnew array&lt;Object^&gt;(2);\n\n   Console::Write( &quot;Enter an integer value: &quot; );\n   addParams[ 0 ] = Convert::ToInt32( Console::ReadLine() );\n\n   Console::Write( &quot;Enter another integer value: &quot; );\n   addParams[ 1 ] = Convert::ToInt32( Console::ReadLine() );\n\n   Console::WriteLine( &quot;If either integer was &gt; 100, an exception will be thrown.&quot; );\n\n   Console::WriteLine( &quot;---&quot; );\n   Console::WriteLine( &quot; {0} + {1} = {2}&quot;, addParams[ 0 ], addParams[ 1 ], adderType-&gt;InvokeMember( &quot;DoAdd&quot;, BindingFlags::InvokeMethod, nullptr, addIns, addParams ) );\n}\n\n/* This code produces output similar to the following:\n\nEnter an integer value: 24\nEnter another integer value: 101\nIf either integer was &gt; 100, an exception will be thrown.\n---\nCaught System.OverflowException: Arithmetic operation resulted in an overflow.\n   at Adder.DoAdd(Int32 , Int32 )\n 24 + 101 = -1\n */\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Reflection.Emit.ILGenerator.ThrowException Example#1\">using System;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\nclass ILThrowExceptionDemo \n{\n   public static void Main()\n   {\n      AppDomain current = AppDomain.CurrentDomain;\n      AssemblyName myAsmName = new AssemblyName();\n      myAsmName.Name = &quot;AdderExceptionAsm&quot;;\n      AssemblyBuilder myAsmBldr = current.DefineDynamicAssembly(myAsmName,\n                               AssemblyBuilderAccess.RunAndSave);\n\n      ModuleBuilder myModBldr = myAsmBldr.DefineDynamicModule(myAsmName.Name, \n                         myAsmName.Name + &quot;.dll&quot;);\n\n      TypeBuilder myTypeBldr = myModBldr.DefineType(&quot;Adder&quot;);\n\n      Type[] adderParams = new Type[] {typeof(int), typeof(int)};\n\n      // This method will add two numbers which are 100 or less. If either of the\n      // passed integer vales are greater than 100, it will throw an exception.\n\n      MethodBuilder adderBldr = myTypeBldr.DefineMethod(&quot;DoAdd&quot;,\n                         MethodAttributes.Public |\n                         MethodAttributes.Static,\n                         typeof(int),\n                         adderParams);\n      ILGenerator adderIL = adderBldr.GetILGenerator();\n \n      // Types and methods used in the code to throw, catch, and\n      // display OverflowException. Note that if the catch block were\n      // for a more general type, such as Exception, we would need \n      // a MethodInfo for that type&#39;s ToString method.\n      // \n      Type overflow = typeof(OverflowException);\n      ConstructorInfo exCtorInfo = overflow.GetConstructor(\n                        new Type[]\n                        {typeof(string)});\n      MethodInfo exToStrMI = overflow.GetMethod(&quot;ToString&quot;);\n      MethodInfo writeLineMI = typeof(Console).GetMethod(&quot;WriteLine&quot;,\n                        new Type[] \n                        {typeof(string),\n                         typeof(object)});\n                                                    \n      LocalBuilder tmp1 = adderIL.DeclareLocal(typeof(int));   \n      LocalBuilder tmp2 = adderIL.DeclareLocal(overflow);\n\n      // In order to successfully branch, we need to create labels\n      // representing the offset IL instruction block to branch to.\n      // These labels, when the MarkLabel(Label) method is invoked,\n      // will specify the IL instruction to branch to.\n      //\n      Label failed = adderIL.DefineLabel();\n      Label endOfMthd = adderIL.DefineLabel();\n\n      // Begin the try block.\n      Label exBlock = adderIL.BeginExceptionBlock();\n\n      // First, load argument 0 and the integer value of &quot;100&quot; onto the\n      // stack. If arg0 &gt; 100, branch to the label &quot;failed&quot;, which is marked\n      // as the address of the block that throws an exception.\n      //\n      adderIL.Emit(OpCodes.Ldarg_0);\n      adderIL.Emit(OpCodes.Ldc_I4_S, 100);\n      adderIL.Emit(OpCodes.Bgt_S, failed); \n\n      // Now, check to see if argument 1 was greater than 100. If it was,\n      // branch to &quot;failed.&quot; Otherwise, fall through and perform the addition,\n      // branching unconditionally to the instruction at the label &quot;endOfMthd&quot;.\n      //\n      adderIL.Emit(OpCodes.Ldarg_1);\n      adderIL.Emit(OpCodes.Ldc_I4_S, 100);\n      adderIL.Emit(OpCodes.Bgt_S, failed);\n\n      adderIL.Emit(OpCodes.Ldarg_0);\n      adderIL.Emit(OpCodes.Ldarg_1);\n      adderIL.Emit(OpCodes.Add_Ovf_Un);\n      // Store the result of the addition.\n      adderIL.Emit(OpCodes.Stloc_S, tmp1);\n      adderIL.Emit(OpCodes.Br_S, endOfMthd);\n\n      // If one of the arguments was greater than 100, we need to throw an\n      // exception. We&#39;ll use &quot;OverflowException&quot; with a customized message.\n      // First, we load our message onto the stack, and then create a new\n      // exception object using the constructor overload that accepts a\n      // string message.\n      //\n      adderIL.MarkLabel(failed);\n      adderIL.Emit(OpCodes.Ldstr, &quot;Cannot accept values over 100 for add.&quot;);\n      adderIL.Emit(OpCodes.Newobj, exCtorInfo);\n\n      // We&#39;re going to need to refer to that exception object later, so let&#39;s\n      // store it in a temporary variable. Since the store function pops the\n      // the value/reference off the stack, and we&#39;ll need it to throw the\n      // exception, we will subsequently load it back onto the stack as well.\n\n      adderIL.Emit(OpCodes.Stloc_S, tmp2);\n      adderIL.Emit(OpCodes.Ldloc_S, tmp2);\n\n      // Throw the exception now on the stack.\n\n      adderIL.ThrowException(overflow);\n      \n      // Start the catch block for OverflowException.\n      //\n      adderIL.BeginCatchBlock(overflow);\n\n      // When we enter the catch block, the thrown exception \n      // is on the stack. Store it, then load the format string\n      // for WriteLine. \n      //\n      adderIL.Emit(OpCodes.Stloc_S, tmp2);\n      adderIL.Emit(OpCodes.Ldstr, &quot;Caught {0}&quot;);\n\n      // Push the thrown exception back on the stack, then \n      // call its ToString() method. Note that if this catch block\n      // were for a more general exception type, like Exception,\n      // it would be necessary to use the ToString for that type.\n      //\n      adderIL.Emit(OpCodes.Ldloc_S, tmp2);\n      adderIL.EmitCall(OpCodes.Callvirt, exToStrMI, null);\n      \n      // The format string and the return value from ToString() are\n      // now on the stack. Call WriteLine(string, object).\n      //\n      adderIL.EmitCall(OpCodes.Call, writeLineMI, null);\n\n      // Since our function has to return an integer value, we&#39;ll load -1 onto\n      // the stack to indicate an error, and store it in local variable tmp1.\n      //\n      adderIL.Emit(OpCodes.Ldc_I4_M1);\n      adderIL.Emit(OpCodes.Stloc_S, tmp1);\n\n      // End the exception handling block.\n\n      adderIL.EndExceptionBlock();   \n\n      // The end of the method. If no exception was thrown, the correct value\n      // will be saved in tmp1. If an exception was thrown, tmp1 will be equal\n      // to -1. Either way, we&#39;ll load the value of tmp1 onto the stack and return.\n      //\n      adderIL.MarkLabel(endOfMthd);\n      adderIL.Emit(OpCodes.Ldloc_S, tmp1);\n      adderIL.Emit(OpCodes.Ret);\n   \n      Type adderType = myTypeBldr.CreateType();\n\n      object addIns = Activator.CreateInstance(adderType); \n\n      object[] addParams = new object[2];\n\n      Console.Write(&quot;Enter an integer value: &quot;);\n      addParams[0] = (object)Convert.ToInt32(Console.ReadLine());\n\n      Console.Write(&quot;Enter another integer value: &quot;);\n      addParams[1] = (object)Convert.ToInt32(Console.ReadLine());\n\n      Console.WriteLine(&quot;If either integer was &gt; 100, an exception will be thrown.&quot;);\n      Console.WriteLine(&quot;---&quot;);\n\n      Console.WriteLine(&quot;{0} + {1} = {2}&quot;,\n            addParams[0], addParams[1],\n            adderType.InvokeMember(&quot;DoAdd&quot;,\n               BindingFlags.InvokeMethod,\n               null,\n               addIns,\n               addParams)); \n   }\n}\n\n/* This code produces output similar to the following:\n\nEnter an integer value: 24\nEnter another integer value: 101\nIf either integer was &gt; 100, an exception will be thrown.\n---\nCaught System.OverflowException: Arithmetic operation resulted in an overflow.\n   at Adder.DoAdd(Int32 , Int32 )\n 24 + 101 = -1\n */\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_EndScope\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_EndScope_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">EndScope()</div>        \r\n          </div>\r\n    \r\n            <p>Ends a lexical scope.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void EndScope ();</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>This <a class=\"xref\" href=\"system.reflection.emit.ilgenerator\" data-linktype=\"relative-path\">ILGenerator</a> belongs to a <a class=\"xref\" href=\"system.reflection.emit.dynamicmethod\" data-linktype=\"relative-path\">DynamicMethod</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is used to emit symbolic information. It is used with <a class=\"xref\" href=\"system.reflection.emit.ilgenerator#System_Reflection_Emit_ILGenerator_BeginScope_\" data-linktype=\"relative-path\">BeginScope</a>.  </p>\n<p> If the current <a class=\"xref\" href=\"system.reflection.emit.ilgenerator\" data-linktype=\"relative-path\">ILGenerator</a> is associated with a <a class=\"xref\" href=\"system.reflection.emit.dynamicmethod\" data-linktype=\"relative-path\">DynamicMethod</a> object, it does not support symbolic information.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code sample illustrates the use of <code>BeginScope</code> and <code>EndScope</code>.  </p>\n<pre><code class=\"lang-cs\" name=\"ILGenerator_Begin_EndScope#2\">         // Get the current AppDomain.\n         AppDomain myAppDomain = AppDomain.CurrentDomain;\n         AssemblyName myAssemblyName = new AssemblyName();\n         myAssemblyName.Name = &quot;SampleAssembly&quot;;\n\n         // Create a dynamic assembly &#39;myAssembly&#39; with access mode &#39;Run&#39;.\n         AssemblyBuilder myAssembly = myAppDomain.DefineDynamicAssembly(\n                                 myAssemblyName, AssemblyBuilderAccess.Run);\n         // Create a dynamic module &#39;myModule&#39; in &#39;myAssembly&#39;.\n         ModuleBuilder myModule=myAssembly.DefineDynamicModule(&quot;MyDynamicModule&quot;,true);\n         // Define a public class &#39;MyDynamicClass&#39;.\n         TypeBuilder myTypeBuilder = myModule.DefineType(&quot;MyDynamicClass&quot;,\n                                          TypeAttributes.Public);\n         // Define a public string field.\n         FieldBuilder myField = myTypeBuilder.DefineField(&quot;MyDynamicField&quot;, \n                                  typeof(String), FieldAttributes.Public);\n         // Create the constructor.\n         Type[] myConstructorArgs = {typeof(String)};\n         ConstructorBuilder myConstructor = myTypeBuilder.DefineConstructor(\n            MethodAttributes.Public, CallingConventions.Standard, myConstructorArgs);\n\n         // Generate IL for &#39;myConstructor&#39;.\n         ILGenerator myConstructorIL = myConstructor.GetILGenerator();\n         // Emit the necessary opcodes.\n         myConstructorIL.Emit(OpCodes.Ldarg_0);\n         ConstructorInfo mySuperConstructor = typeof(Object).GetConstructor(new Type[0]);\n         myConstructorIL.Emit(OpCodes.Call, mySuperConstructor);\n         myConstructorIL.Emit(OpCodes.Ldarg_0);\n         myConstructorIL.Emit(OpCodes.Ldarg_1);\n         myConstructorIL.Emit(OpCodes.Stfld, myField);\n         myConstructorIL.Emit(OpCodes.Ret);\n\n         // Define a dynamic method named &#39;MyDynamicMethod&#39;.\n         MethodBuilder myMethod = myTypeBuilder.DefineMethod(&quot;MyDynamicMethod&quot;,\n            MethodAttributes.Public, typeof(String), null);\n         // Generate IL for &#39;myMethod&#39;.\n         ILGenerator myMethodIL = myMethod.GetILGenerator();\n\n         // Begin the scope for a local variable.\n         myMethodIL.BeginScope();\n\n         LocalBuilder myLocalBuilder = myMethodIL.DeclareLocal(typeof(int));\n         Console.WriteLine(&quot;<br>Trying to access the local variable within the scope.&quot;);\n         Console.WriteLine(&quot;&#39;myLocalBuilder&#39; type is: {0}&quot;, myLocalBuilder.LocalType);\n         myMethodIL.Emit(OpCodes.Ldstr, &quot;Local value&quot;);\n         myMethodIL.Emit(OpCodes.Stloc_0, myLocalBuilder);\n         \n         // End the scope of &#39;myLocalBuilder&#39;.\n         myMethodIL.EndScope();\n\n         // Access the local variable outside the scope.\n         Console.WriteLine(&quot;<br>Trying to access the local variable outside the scope:&quot;);\n         myMethodIL.Emit(OpCodes.Stloc_0, myLocalBuilder);\n         myMethodIL.Emit(OpCodes.Ldloc_0 );\n         myMethodIL.Emit(OpCodes.Ret );\n\n         // Create &#39;MyDynamicClass&#39; class.\n         Type myType1 = myTypeBuilder.CreateType();\n</code></pre><pre><code class=\"lang-cpp\" name=\"ILGenerator_Begin_EndScope#2\">      // Get the current AppDomain.\n      AppDomain^ myAppDomain = AppDomain::CurrentDomain;\n      AssemblyName^ myAssemblyName = gcnew AssemblyName;\n      myAssemblyName-&gt;Name = &quot;SampleAssembly&quot;;\n\n      // Create a dynamic assembly &#39;myAssembly&#39; with access mode &#39;Run&#39;.\n      AssemblyBuilder^ myAssembly = myAppDomain-&gt;DefineDynamicAssembly( myAssemblyName, AssemblyBuilderAccess::Run );\n\n      // Create a dynamic module &#39;myModule&#39; in &#39;myAssembly&#39;.\n      ModuleBuilder^ myModule = myAssembly-&gt;DefineDynamicModule( &quot;MyDynamicModule&quot;, true );\n\n      // Define a public class &#39;MyDynamicClass&#39;.\n      TypeBuilder^ myTypeBuilder = myModule-&gt;DefineType( &quot;MyDynamicClass&quot;, TypeAttributes::Public );\n\n      // Define a public string field.\n      FieldBuilder^ myField = myTypeBuilder-&gt;DefineField( &quot;MyDynamicField&quot;, String::typeid, FieldAttributes::Public );\n\n      // Create the constructor.\n      array&lt;Type^&gt;^myConstructorArgs = {String::typeid};\n      ConstructorBuilder^ myConstructor = myTypeBuilder-&gt;DefineConstructor( MethodAttributes::Public, CallingConventions::Standard, myConstructorArgs );\n\n      // Generate IL for &#39;myConstructor&#39;.\n      ILGenerator^ myConstructorIL = myConstructor-&gt;GetILGenerator();\n\n      // Emit the necessary opcodes.\n      myConstructorIL-&gt;Emit( OpCodes::Ldarg_0 );\n      ConstructorInfo^ mySuperConstructor = Object::typeid-&gt;GetConstructor( gcnew array&lt;Type^&gt;(0) );\n      myConstructorIL-&gt;Emit( OpCodes::Call, mySuperConstructor );\n      myConstructorIL-&gt;Emit( OpCodes::Ldarg_0 );\n      myConstructorIL-&gt;Emit( OpCodes::Ldarg_1 );\n      myConstructorIL-&gt;Emit( OpCodes::Stfld, myField );\n      myConstructorIL-&gt;Emit( OpCodes::Ret );\n\n      // Define a dynamic method named &#39;MyDynamicMethod&#39;.\n      MethodBuilder^ myMethod = myTypeBuilder-&gt;DefineMethod( &quot;MyDynamicMethod&quot;, MethodAttributes::Public, String::typeid, nullptr );\n\n      // Generate IL for &#39;myMethod&#39;.\n      ILGenerator^ myMethodIL = myMethod-&gt;GetILGenerator();\n\n      // Begin the scope for a local variable.\n      myMethodIL-&gt;BeginScope();\n      LocalBuilder^ myLocalBuilder = myMethodIL-&gt;DeclareLocal( int::typeid );\n      Console::WriteLine( &quot;<br>Trying to access the local variable within the scope.&quot; );\n      Console::WriteLine( &quot;&#39;myLocalBuilder&#39; type is :{0}&quot;, myLocalBuilder-&gt;LocalType );\n      myMethodIL-&gt;Emit( OpCodes::Ldstr, &quot;Local value&quot; );\n      myMethodIL-&gt;Emit( OpCodes::Stloc_0, myLocalBuilder );\n\n      // End the scope of &#39;myLocalBuilder&#39;.\n      myMethodIL-&gt;EndScope();\n\n      // Access the local variable outside the scope.\n      Console::WriteLine( &quot;<br>Trying to access the local variable outside the scope:<br>&quot; );\n      myMethodIL-&gt;Emit( OpCodes::Stloc_0, myLocalBuilder );\n      myMethodIL-&gt;Emit( OpCodes::Ldloc_0 );\n      myMethodIL-&gt;Emit( OpCodes::Ret );\n\n      // Create &#39;MyDynamicClass&#39; class.\n      Type^ myType1 = myTypeBuilder-&gt;CreateType();\n</code></pre><pre><code class=\"lang-vb\" name=\"ILGenerator_Begin_EndScope#2\">         &#39; Get the current AppDomain.\n         Dim myAppDomain As AppDomain = AppDomain.CurrentDomain\n         Dim myAssemblyName As New AssemblyName()\n         myAssemblyName.Name = &quot;SampleAssembly&quot;\n         \n         &#39; Create a dynamic assembly &#39;myAssembly&#39; with access mode &#39;Run&#39;.\n         Dim myAssembly As AssemblyBuilder = myAppDomain.DefineDynamicAssembly(myAssemblyName, _\n                                                                     AssemblyBuilderAccess.Run)\n         &#39; Create a dynamic module &#39;myModule&#39; in &#39;myAssembly&#39;.\n         Dim myModule As ModuleBuilder = myAssembly.DefineDynamicModule(&quot;MyDynamicModule&quot;, True)\n         &#39; Define a public class &#39;MyDynamicClass&#39;.\n         Dim myTypeBuilder As TypeBuilder = myModule.DefineType(&quot;MyDynamicClass&quot;, _\n                                                                        TypeAttributes.Public)\n         &#39; Define a public string field.\n         Dim myField As FieldBuilder = myTypeBuilder.DefineField(&quot;MyDynamicField&quot;, GetType(String), _\n                                                                        FieldAttributes.Public)\n         &#39; Create the constructor.\n         Dim myConstructorArgs As Type() = {GetType(String)}\n         Dim myConstructor As ConstructorBuilder = myTypeBuilder.DefineConstructor _\n                        (MethodAttributes.Public, CallingConventions.Standard, myConstructorArgs)\n         \n         &#39; Generate IL for &#39;myConstructor&#39;.\n         Dim myConstructorIL As ILGenerator = myConstructor.GetILGenerator()\n         &#39; Emit the necessary opcodes.\n         myConstructorIL.Emit(OpCodes.Ldarg_0)\n         Dim mySuperConstructor As ConstructorInfo = GetType(Object).GetConstructor(New Type() {})\n         myConstructorIL.Emit(OpCodes.Call, mySuperConstructor)\n         myConstructorIL.Emit(OpCodes.Ldarg_0)\n         myConstructorIL.Emit(OpCodes.Ldarg_1)\n         myConstructorIL.Emit(OpCodes.Stfld, myField)\n         myConstructorIL.Emit(OpCodes.Ret)\n         \n         &#39; Define a dynamic method named &#39;MyDynamicMethod&#39;.\n         Dim myMethod As MethodBuilder = myTypeBuilder.DefineMethod(&quot;MyDynamicMethod&quot;, _\n                                 MethodAttributes.Public, GetType(String), Nothing)\n         &#39; Generate IL for &#39;myMethod&#39;.\n         Dim myMethodIL As ILGenerator = myMethod.GetILGenerator()\n         \n         &#39; Begin the scope for a local variable.\n         myMethodIL.BeginScope()\n         \n         Dim myLocalBuilder As LocalBuilder = myMethodIL.DeclareLocal(GetType(Integer))\n         Console.WriteLine(ControlChars.NewLine + &quot;Trying to access the local variable within&quot; + _\n                                                                              &quot; the scope.&quot;)\n         Console.WriteLine(&quot;&#39;myLocalBuilder&#39; type is: {0}&quot;, myLocalBuilder.LocalType)\n         myMethodIL.Emit(OpCodes.Ldstr, &quot;Local value&quot;)\n         myMethodIL.Emit(OpCodes.Stloc_0, myLocalBuilder)\n         \n         &#39; End the scope of &#39;myLocalBuilder&#39;.\n         myMethodIL.EndScope()\n         \n         &#39; Access the local variable outside the scope.\n         Console.WriteLine(ControlChars.NewLine + &quot;Trying to access the local variable outside &quot; + _\n                                                   &quot;the scope:&quot;)\n         myMethodIL.Emit(OpCodes.Stloc_0, myLocalBuilder)\n         myMethodIL.Emit(OpCodes.Ldloc_0)\n         myMethodIL.Emit(OpCodes.Ret)\n         \n         &#39; Create &#39;MyDynamicClass&#39; class.\n         Dim myType1 As Type = myTypeBuilder.CreateType()\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_MarkLabel_System_Reflection_Emit_Label_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_MarkLabel_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">MarkLabel(Label)</div>        \r\n          </div>\r\n    \r\n            <p>Marks the Microsoft intermediate language (MSIL) stream&#39;s current position with the given label.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void MarkLabel (System.Reflection.Emit.Label loc);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>loc</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.reflection.emit.label\" data-linktype=\"relative-path\">Label</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The label for which to set an index.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>loc</code> represents an invalid index into the label array.  </p>\n<p> -or-  </p>\n<p> An index for <code>loc</code> has already been defined.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>A label cannot be defined more than once.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The code sample below demonstrates the contextual usage of <code>MarkLabel</code> to implement MSIL branching in a dynamic method.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Reflection.Emit.ILGenerator.Emit Example 2#1\">\nusing System;\nusing System.Threading;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\nclass DynamicJumpTableDemo\n\n{\n\n   public static Type BuildMyType()\n   {\n\tAppDomain myDomain = Thread.GetDomain();\n\tAssemblyName myAsmName = new AssemblyName();\n\tmyAsmName.Name = &quot;MyDynamicAssembly&quot;;\n\n\tAssemblyBuilder myAsmBuilder = myDomain.DefineDynamicAssembly(\n\t\t\t\t\t\tmyAsmName,\n\t\t\t\t\t\tAssemblyBuilderAccess.Run);\n\tModuleBuilder myModBuilder = myAsmBuilder.DefineDynamicModule(\n\t\t\t\t\t\t&quot;MyJumpTableDemo&quot;);\n\n\tTypeBuilder myTypeBuilder = myModBuilder.DefineType(&quot;JumpTableDemo&quot;,\n\t\t\t\t\t\t\tTypeAttributes.Public);\n\tMethodBuilder myMthdBuilder = myTypeBuilder.DefineMethod(&quot;SwitchMe&quot;, \n\t\t\t\t             MethodAttributes.Public |\n\t\t\t\t             MethodAttributes.Static,\n                                             typeof(string), \n                                             new Type[] {typeof(int)});\n\n\tILGenerator myIL = myMthdBuilder.GetILGenerator();\n\n\tLabel defaultCase = myIL.DefineLabel();\t\n\tLabel endOfMethod = myIL.DefineLabel();\t\n\n\t// We are initializing our jump table. Note that the labels\n\t// will be placed later using the MarkLabel method. \n\n\tLabel[] jumpTable = new Label[] { myIL.DefineLabel(),\n\t\t\t\t\t  myIL.DefineLabel(),\n\t\t\t\t\t  myIL.DefineLabel(),\n\t\t\t\t\t  myIL.DefineLabel(),\n\t\t\t\t\t  myIL.DefineLabel() };\n\n\t// arg0, the number we passed, is pushed onto the stack.\n\t// In this case, due to the design of the code sample,\n\t// the value pushed onto the stack happens to match the\n\t// index of the label (in IL terms, the index of the offset\n\t// in the jump table). If this is not the case, such as\n\t// when switching based on non-integer values, rules for the correspondence\n\t// between the possible case values and each index of the offsets\n\t// must be established outside of the ILGenerator.Emit calls,\n\t// much as a compiler would.\n\n\tmyIL.Emit(OpCodes.Ldarg_0);\n\tmyIL.Emit(OpCodes.Switch, jumpTable);\n\t\n\t// Branch on default case\n\tmyIL.Emit(OpCodes.Br_S, defaultCase);\n\n\t// Case arg0 = 0\n\tmyIL.MarkLabel(jumpTable[0]); \n\tmyIL.Emit(OpCodes.Ldstr, &quot;are no bananas&quot;);\n\tmyIL.Emit(OpCodes.Br_S, endOfMethod);\n\n\t// Case arg0 = 1\n\tmyIL.MarkLabel(jumpTable[1]); \n\tmyIL.Emit(OpCodes.Ldstr, &quot;is one banana&quot;);\n\tmyIL.Emit(OpCodes.Br_S, endOfMethod);\n\n\t// Case arg0 = 2\n\tmyIL.MarkLabel(jumpTable[2]); \n\tmyIL.Emit(OpCodes.Ldstr, &quot;are two bananas&quot;);\n\tmyIL.Emit(OpCodes.Br_S, endOfMethod);\n\n\t// Case arg0 = 3\n\tmyIL.MarkLabel(jumpTable[3]); \n\tmyIL.Emit(OpCodes.Ldstr, &quot;are three bananas&quot;);\n\tmyIL.Emit(OpCodes.Br_S, endOfMethod);\n\n\t// Case arg0 = 4\n\tmyIL.MarkLabel(jumpTable[4]); \n\tmyIL.Emit(OpCodes.Ldstr, &quot;are four bananas&quot;);\n\tmyIL.Emit(OpCodes.Br_S, endOfMethod);\n\n\t// Default case\n\tmyIL.MarkLabel(defaultCase);\n\tmyIL.Emit(OpCodes.Ldstr, &quot;are many bananas&quot;);\n\n\tmyIL.MarkLabel(endOfMethod);\n\tmyIL.Emit(OpCodes.Ret);\n\t\n\treturn myTypeBuilder.CreateType();\n\n   }\n\n   public static void Main()\n   {\n\tType myType = BuildMyType();\n\t\n\tConsole.Write(&quot;Enter an integer between 0 and 5: &quot;);\n\tint theValue = Convert.ToInt32(Console.ReadLine());\n\n\tConsole.WriteLine(&quot;---&quot;);\n\tObject myInstance = Activator.CreateInstance(myType, new object[0]);\t\n\tConsole.WriteLine(&quot;Yes, there {0} today!&quot;, myType.InvokeMember(&quot;SwitchMe&quot;,\n\t\t\t  \t\t           BindingFlags.InvokeMethod,\n\t\t\t  \t\t           null,\n\t\t\t  \t\t           myInstance,\n\t\t\t  \t\t           new object[] {theValue}));  \n\t\t\t  \n   }\n\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Reflection.Emit.ILGenerator.Emit Example 2#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Reflection;\nusing namespace System::Reflection::Emit;\nType^ BuildMyType()\n{\n   AppDomain^ myDomain = Thread::GetDomain();\n   AssemblyName^ myAsmName = gcnew AssemblyName;\n   myAsmName-&gt;Name = &quot;MyDynamicAssembly&quot;;\n   AssemblyBuilder^ myAsmBuilder = myDomain-&gt;DefineDynamicAssembly( myAsmName, AssemblyBuilderAccess::Run );\n   ModuleBuilder^ myModBuilder = myAsmBuilder-&gt;DefineDynamicModule( &quot;MyJumpTableDemo&quot; );\n   TypeBuilder^ myTypeBuilder = myModBuilder-&gt;DefineType( &quot;JumpTableDemo&quot;, TypeAttributes::Public );\n   array&lt;Type^&gt;^temp0 = {int::typeid};\n   MethodBuilder^ myMthdBuilder = myTypeBuilder-&gt;DefineMethod( &quot;SwitchMe&quot;, static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::Static), String::typeid, temp0 );\n   ILGenerator^ myIL = myMthdBuilder-&gt;GetILGenerator();\n   Label defaultCase = myIL-&gt;DefineLabel();\n   Label endOfMethod = myIL-&gt;DefineLabel();\n   \n   // We are initializing our jump table. Note that the labels\n   // will be placed later using the MarkLabel method.\n   array&lt;Label&gt;^jumpTable = gcnew array&lt;Label&gt;(5);\n   jumpTable[ 0 ] = myIL-&gt;DefineLabel();\n   jumpTable[ 1 ] = myIL-&gt;DefineLabel();\n   jumpTable[ 2 ] = myIL-&gt;DefineLabel();\n   jumpTable[ 3 ] = myIL-&gt;DefineLabel();\n   jumpTable[ 4 ] = myIL-&gt;DefineLabel();\n   \n   // arg0, the number we passed, is pushed onto the stack.\n   // In this case, due to the design of the code sample,\n   // the value pushed onto the stack happens to match the\n   // index of the label (in IL terms, the index of the offset\n   // in the jump table). If this is not the case, such as\n   // when switching based on non-integer values, rules for the correspondence\n   // between the possible case values and each index of the offsets\n   // must be established outside of the ILGenerator::Emit calls,\n   // much as a compiler would.\n   myIL-&gt;Emit( OpCodes::Ldarg_0 );\n   myIL-&gt;Emit( OpCodes::Switch, jumpTable );\n   \n   // Branch on default case\n   myIL-&gt;Emit( OpCodes::Br_S, defaultCase );\n   \n   // Case arg0 = 0\n   myIL-&gt;MarkLabel( jumpTable[ 0 ] );\n   myIL-&gt;Emit( OpCodes::Ldstr, &quot;are no bananas&quot; );\n   myIL-&gt;Emit( OpCodes::Br_S, endOfMethod );\n   \n   // Case arg0 = 1\n   myIL-&gt;MarkLabel( jumpTable[ 1 ] );\n   myIL-&gt;Emit( OpCodes::Ldstr, &quot;is one banana&quot; );\n   myIL-&gt;Emit( OpCodes::Br_S, endOfMethod );\n   \n   // Case arg0 = 2\n   myIL-&gt;MarkLabel( jumpTable[ 2 ] );\n   myIL-&gt;Emit( OpCodes::Ldstr, &quot;are two bananas&quot; );\n   myIL-&gt;Emit( OpCodes::Br_S, endOfMethod );\n   \n   // Case arg0 = 3\n   myIL-&gt;MarkLabel( jumpTable[ 3 ] );\n   myIL-&gt;Emit( OpCodes::Ldstr, &quot;are three bananas&quot; );\n   myIL-&gt;Emit( OpCodes::Br_S, endOfMethod );\n   \n   // Case arg0 = 4\n   myIL-&gt;MarkLabel( jumpTable[ 4 ] );\n   myIL-&gt;Emit( OpCodes::Ldstr, &quot;are four bananas&quot; );\n   myIL-&gt;Emit( OpCodes::Br_S, endOfMethod );\n   \n   // Default case\n   myIL-&gt;MarkLabel( defaultCase );\n   myIL-&gt;Emit( OpCodes::Ldstr, &quot;are many bananas&quot; );\n   myIL-&gt;MarkLabel( endOfMethod );\n   myIL-&gt;Emit( OpCodes::Ret );\n   return myTypeBuilder-&gt;CreateType();\n}\n\nint main()\n{\n   Type^ myType = BuildMyType();\n   Console::Write( &quot;Enter an integer between 0 and 5: &quot; );\n   int theValue = Convert::ToInt32( Console::ReadLine() );\n   Console::WriteLine( &quot;---&quot; );\n   Object^ myInstance = Activator::CreateInstance( myType, gcnew array&lt;Object^&gt;(0) );\n   array&lt;Object^&gt;^temp1 = {theValue};\n   Console::WriteLine( &quot;Yes, there {0} today!&quot;, myType-&gt;InvokeMember( &quot;SwitchMe&quot;, BindingFlags::InvokeMethod, nullptr, myInstance, temp1 ) );\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Reflection.Emit.ILGenerator.Emit Example 2#1\">\nImports System\nImports System.Threading\nImports System.Reflection\nImports System.Reflection.Emit\n\n _\n\nClass DynamicJumpTableDemo\n   \n   Public Shared Function BuildMyType() As Type\n\n      Dim myDomain As AppDomain = Thread.GetDomain()\n      Dim myAsmName As New AssemblyName()\n      myAsmName.Name = &quot;MyDynamicAssembly&quot;\n      \n      Dim myAsmBuilder As AssemblyBuilder = myDomain.DefineDynamicAssembly(myAsmName, _\n\t\t\t\t\t\t\tAssemblyBuilderAccess.Run)\n      Dim myModBuilder As ModuleBuilder = myAsmBuilder.DefineDynamicModule(&quot;MyJumpTableDemo&quot;)\n      \n      Dim myTypeBuilder As TypeBuilder = myModBuilder.DefineType(&quot;JumpTableDemo&quot;, _\n\t\t\t\t\t\t\t\t TypeAttributes.Public)\n      Dim myMthdBuilder As MethodBuilder = myTypeBuilder.DefineMethod(&quot;SwitchMe&quot;, _\n\t\t\t\t\t\tMethodAttributes.Public Or MethodAttributes.Static, _\n\t\t\t\t\t\tGetType(String), New Type() {GetType(Integer)})\n      \n      Dim myIL As ILGenerator = myMthdBuilder.GetILGenerator()\n      \n      Dim defaultCase As Label = myIL.DefineLabel()\n      Dim endOfMethod As Label = myIL.DefineLabel()\n      \n      &#39; We are initializing our jump table. Note that the labels\n      &#39; will be placed later using the MarkLabel method. \n\n      Dim jumpTable() As Label = {myIL.DefineLabel(), _\n\t\t\t\t  myIL.DefineLabel(), _\n\t\t\t\t  myIL.DefineLabel(), _\n\t\t\t\t  myIL.DefineLabel(), _\n\t\t\t\t  myIL.DefineLabel()}\n      \n      &#39; arg0, the number we passed, is pushed onto the stack.\n      &#39; In this case, due to the design of the code sample,\n      &#39; the value pushed onto the stack happens to match the\n      &#39; index of the label (in IL terms, the index of the offset\n      &#39; in the jump table). If this is not the case, such as\n      &#39; when switching based on non-integer values, rules for the correspondence\n      &#39; between the possible case values and each index of the offsets\n      &#39; must be established outside of the ILGenerator.Emit calls,\n      &#39; much as a compiler would.\n\n      myIL.Emit(OpCodes.Ldarg_0)\n      myIL.Emit(OpCodes.Switch, jumpTable)\n      \n      &#39; Branch on default case\n      myIL.Emit(OpCodes.Br_S, defaultCase)\n      \n      &#39; Case arg0 = 0\n      myIL.MarkLabel(jumpTable(0))\n      myIL.Emit(OpCodes.Ldstr, &quot;are no bananas&quot;)\n      myIL.Emit(OpCodes.Br_S, endOfMethod)\n      \n      &#39; Case arg0 = 1\n      myIL.MarkLabel(jumpTable(1))\n      myIL.Emit(OpCodes.Ldstr, &quot;is one banana&quot;)\n      myIL.Emit(OpCodes.Br_S, endOfMethod)\n      \n      &#39; Case arg0 = 2\n      myIL.MarkLabel(jumpTable(2))\n      myIL.Emit(OpCodes.Ldstr, &quot;are two bananas&quot;)\n      myIL.Emit(OpCodes.Br_S, endOfMethod)\n      \n      &#39; Case arg0 = 3\n      myIL.MarkLabel(jumpTable(3))\n      myIL.Emit(OpCodes.Ldstr, &quot;are three bananas&quot;)\n      myIL.Emit(OpCodes.Br_S, endOfMethod)\n      \n      &#39; Case arg0 = 4\n      myIL.MarkLabel(jumpTable(4))\n      myIL.Emit(OpCodes.Ldstr, &quot;are four bananas&quot;)\n      myIL.Emit(OpCodes.Br_S, endOfMethod)\n      \n      &#39; Default case\n      myIL.MarkLabel(defaultCase)\n      myIL.Emit(OpCodes.Ldstr, &quot;are many bananas&quot;)\n      \n      myIL.MarkLabel(endOfMethod)\n      myIL.Emit(OpCodes.Ret)\n      \n      Return myTypeBuilder.CreateType()\n\n   End Function &#39;BuildMyType\n    \n   \n   Public Shared Sub Main()\n\n      Dim myType As Type = BuildMyType()\n      \n      Console.Write(&quot;Enter an integer between 0 and 5: &quot;)\n      Dim theValue As Integer = Convert.ToInt32(Console.ReadLine())\n      \n      Console.WriteLine(&quot;---&quot;)\n      Dim myInstance As [Object] = Activator.CreateInstance(myType, New Object() {})\n      Console.WriteLine(&quot;Yes, there {0} today!&quot;, myType.InvokeMember(&quot;SwitchMe&quot;, _\n\t\t\t\t\t\t BindingFlags.InvokeMethod, Nothing, _\n\t\t\t\t\t         myInstance, New Object() {theValue}))\n\n   End Sub &#39;Main\n\nEnd Class &#39;DynamicJumpTableDemo\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_MarkSequencePoint_System_Diagnostics_SymbolStore_ISymbolDocumentWriter_System_Int32_System_Int32_System_Int32_System_Int32_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_MarkSequencePoint_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">MarkSequencePoint(ISymbolDocumentWriter,Int32,Int32,Int32,Int32)</div>        \r\n          </div>\r\n    \r\n            <p>Marks a sequence point in the Microsoft intermediate language (MSIL) stream.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void MarkSequencePoint (System.Diagnostics.SymbolStore.ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>document</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.diagnostics.symbolstore.isymboldocumentwriter\" data-linktype=\"relative-path\">ISymbolDocumentWriter</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The document for which the sequence point is being defined.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>startLine</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The line where the sequence point begins.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>startColumn</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The column in the line where the sequence point begins.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>endLine</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The line where the sequence point ends.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>endColumn</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The column in the line where the sequence point ends.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p><code>startLine</code> or <code>endLine</code> is &lt;= 0.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>This <a class=\"xref\" href=\"system.reflection.emit.ilgenerator\" data-linktype=\"relative-path\">ILGenerator</a> belongs to a <a class=\"xref\" href=\"system.reflection.emit.dynamicmethod\" data-linktype=\"relative-path\">DynamicMethod</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Line numbers are indexed from 1. Columns are indexed from 0.  </p>\n<p> The symbolic information normally includes at least one MSIL offset for each source line. When the just-in-time (JIT) compiler is about to compile a method, it asks the profiling services for a list of MSIL offsets that should be preserved. These MSIL offsets are called <em>sequence points</em>.  </p>\n<p> If the current <a class=\"xref\" href=\"system.reflection.emit.ilgenerator\" data-linktype=\"relative-path\">ILGenerator</a> is associated with a <a class=\"xref\" href=\"system.reflection.emit.dynamicmethod\" data-linktype=\"relative-path\">DynamicMethod</a> object, it does not support symbolic information.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_ThrowException_System_Type_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_ThrowException_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ThrowException(Type)</div>        \r\n          </div>\r\n    \r\n            <p>Emits an instruction to throw an exception.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void ThrowException (Type excType);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>excType</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.type\" data-linktype=\"relative-path\">Type</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The class of the type of exception to throw.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>excType</code> is not the <a class=\"xref\" href=\"system.exception\" data-linktype=\"relative-path\">Exception</a> class or a derived class of <a class=\"xref\" href=\"system.exception\" data-linktype=\"relative-path\">Exception</a>.  </p>\n<p> -or-  </p>\n<p> The type does not have a default constructor.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>excType</code> is <code>null</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code sample demonstrates the contextual usage of <code>ThrowException</code> to throw an exception inside the MSIL of a dynamic method.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Reflection.Emit.ILGenerator.ThrowException Example#1\">Imports System\nImports System.Reflection\nImports System.Reflection.Emit\n\nClass ILThrowExceptionDemo\n   \n   Public Shared Sub Main()\n            \n      Dim current As AppDomain = AppDomain.CurrentDomain\n      Dim myAsmName As New AssemblyName()\n      myAsmName.Name = &quot;AdderExceptionAsm&quot;\n      Dim myAsmBldr As AssemblyBuilder = _\n                 current.DefineDynamicAssembly(myAsmName, _\n                     AssemblyBuilderAccess.RunAndSave)\n      \n      Dim myModBldr As ModuleBuilder = _\n                     myAsmBldr.DefineDynamicModule(myAsmName.Name, _\n                         myAsmName.Name &amp; &quot;.dll&quot;)\n      \n      Dim myTypeBldr As TypeBuilder = myModBldr.DefineType(&quot;Adder&quot;)\n      \n      Dim adderParams() As Type = {GetType(Integer), GetType(Integer)}\n      \n      &#39; This method will add two numbers which are 100 or less. If either of the\n      &#39; passed integer vales are greater than 100, it will throw an exception.\n      Dim adderBldr As MethodBuilder = myTypeBldr.DefineMethod(&quot;DoAdd&quot;, _\n                  MethodAttributes.Public Or MethodAttributes.Static, _\n                  GetType(Integer), adderParams)\n      Dim adderIL As ILGenerator = adderBldr.GetILGenerator()\n\n      &#39; Types and methods used in the code to throw, catch, and\n      &#39; display OverflowException. Note that if the catch block were\n      &#39; for a more general type, such as Exception, we would need \n      &#39; a MethodInfo for that type&#39;s ToString method.\n      &#39; \n      Dim overflow As Type = GetType(OverflowException)\n      Dim exCtorInfo As ConstructorInfo = overflow.GetConstructor( _\n                     New Type() {GetType(String)})\n      Dim exToStrMI As MethodInfo = overflow.GetMethod(&quot;ToString&quot;)\n      Dim writeLineMI As MethodInfo = GetType(Console).GetMethod(&quot;WriteLine&quot;, _\n                     New Type() {GetType(String), _\n                            GetType(Object)})\n      \n      Dim tmp1 As LocalBuilder = adderIL.DeclareLocal(GetType(Integer))\n      Dim tmp2 As LocalBuilder = adderIL.DeclareLocal(overflow)\n      \n      &#39; In order to successfully branch, we need to create labels\n      &#39; representing the offset IL instruction block to branch to.\n      &#39; These labels, when the MarkLabel(Label) method is invoked,\n      &#39; will specify the IL instruction to branch to.\n      &#39;\n      Dim failed As Label = adderIL.DefineLabel()\n      Dim endOfMthd As Label = adderIL.DefineLabel()\n\n      &#39; Begin the try block.      \n      Dim exBlock As Label = adderIL.BeginExceptionBlock()\n\n      &#39; First, load argument 0 and the integer value of &quot;100&quot; onto the\n      &#39; stack. If arg0 &gt; 100, branch to the label &quot;failed&quot;, which is marked\n      &#39; as the address of the block that throws an exception.\n      &#39;\n      adderIL.Emit(OpCodes.Ldarg_0)\n      adderIL.Emit(OpCodes.Ldc_I4_S, 100)\n      adderIL.Emit(OpCodes.Bgt_S, failed)\n      \n      &#39; Now, check to see if argument 1 was greater than 100. If it was,\n      &#39; branch to &quot;failed.&quot; Otherwise, fall through and perform the addition,\n      &#39; branching unconditionally to the instruction at the label &quot;endOfMthd&quot;.\n      &#39;\n      adderIL.Emit(OpCodes.Ldarg_1)\n      adderIL.Emit(OpCodes.Ldc_I4_S, 100)\n      adderIL.Emit(OpCodes.Bgt_S, failed)\n      \n      adderIL.Emit(OpCodes.Ldarg_0)\n      adderIL.Emit(OpCodes.Ldarg_1)\n      adderIL.Emit(OpCodes.Add_Ovf_Un)\n      &#39; Store the result of the addition.\n      adderIL.Emit(OpCodes.Stloc_S, tmp1)\n      adderIL.Emit(OpCodes.Br_S, endOfMthd)\n      \n      &#39; If one of the arguments was greater than 100, we need to throw an\n      &#39; exception. We&#39;ll use &quot;OverflowException&quot; with a customized message.\n      &#39; First, we load our message onto the stack, and then create a new\n      &#39; exception object using the constructor overload that accepts a\n      &#39; string message.\n      adderIL.MarkLabel(failed)\n      adderIL.Emit(OpCodes.Ldstr, &quot;Cannot accept values over 100 for add.&quot;)\n      adderIL.Emit(OpCodes.Newobj, exCtorInfo)\n      \n      &#39; Throw the exception now on the stack.\n      adderIL.ThrowException(overflow)\n      \n      &#39; Start the catch block for OverflowException.\n      &#39;\n      adderIL.BeginCatchBlock(overflow)\n\n      &#39; When we enter the catch block, the thrown exception \n      &#39; is on the stack. Store it, then load the format string\n      &#39; for WriteLine. \n      &#39;\n      adderIL.Emit(OpCodes.Stloc_S, tmp2)\n      adderIL.Emit(OpCodes.Ldstr, &quot;Caught {0}&quot;)\n\n      &#39; Push the thrown exception back on the stack, then \n      &#39; call its ToString() method. Note that if this catch block\n      &#39; were for a more general exception type, like Exception,\n      &#39; it would be necessary to use the ToString for that type.\n      &#39;\n      adderIL.Emit(OpCodes.Ldloc_S, tmp2)\n      adderIL.EmitCall(OpCodes.Callvirt, exToStrMI, Nothing)\n      \n      &#39; The format string and the return value from ToString() are\n      &#39; now on the stack. Call WriteLine(string, object).\n      &#39;\n      adderIL.EmitCall(OpCodes.Call, writeLineMI, Nothing)\n      \n      &#39; Since our function has to return an integer value, load -1 onto\n      &#39; the stack to indicate an error, and store it in local variable\n      &#39; tmp1.\n      adderIL.Emit(OpCodes.Ldc_I4_M1)\n      adderIL.Emit(OpCodes.Stloc_S, tmp1)\n      \n      &#39; End the exception handling block.\n\n      adderIL.EndExceptionBlock()\n      \n      &#39; The end of the method. If no exception was thrown, the correct value\n      &#39; will be saved in tmp1. If an exception was thrown, tmp1 will be equal\n      &#39; to -1. Either way, we&#39;ll load the value of tmp1 onto the stack and return.\n      &#39;\n      adderIL.MarkLabel(endOfMthd)\n      adderIL.Emit(OpCodes.Ldloc_S, tmp1)\n      adderIL.Emit(OpCodes.Ret)\n      \n      Dim adderType As Type = myTypeBldr.CreateType()\n\n      Dim addIns As Object = Activator.CreateInstance(adderType)\n      \n      Dim addParams(1) As Object\n      \n      Console.Write(&quot;Enter an integer value: &quot;)\n      addParams(0) = CType(Convert.ToInt32(Console.ReadLine()), Object)\n      \n      Console.Write(&quot;Enter another integer value: &quot;)\n      addParams(1) = CType(Convert.ToInt32(Console.ReadLine()), Object)\n      \n      Console.WriteLine(&quot;If either integer was &gt; 100, an exception will be thrown.&quot;)\n      Console.WriteLine(&quot;---&quot;)\n      \n      Console.WriteLine(&quot;{0} + {1} = {2}&quot;, addParams(0), addParams(1), _\n         adderType.InvokeMember(&quot;DoAdd&quot;, BindingFlags.InvokeMethod, _\n                  Nothing, addIns, addParams))\n   End Sub \n\nEnd Class \n\n&#39; This code example produces output similar to the following:\n&#39;\n&#39;Enter an integer value: 24\n&#39;Enter another integer value: 101\n&#39;If either integer was &gt; 100, an exception will be thrown.\n&#39;---\n&#39;Caught System.OverflowException: Arithmetic operation resulted in an overflow.\n&#39;   at Adder.DoAdd(Int32 , Int32 )\n&#39;24 + 101 = -1\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Reflection.Emit.ILGenerator.ThrowException Example#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Reflection;\nusing namespace System::Reflection::Emit;\n\nint main()\n{\n   AppDomain^ myDomain = Thread::GetDomain();\n   AssemblyName^ myAsmName = gcnew AssemblyName;\n   myAsmName-&gt;Name = &quot;AdderExceptionAsm&quot;;\n   AssemblyBuilder^ myAsmBldr = myDomain-&gt;DefineDynamicAssembly( myAsmName, \n      AssemblyBuilderAccess::RunAndSave );\n   ModuleBuilder^ myModBldr = myAsmBldr-&gt;DefineDynamicModule( myAsmName-&gt;Name,\n      myAsmName-&gt;Name + &quot;.dll&quot; );\n   TypeBuilder^ myTypeBldr = myModBldr-&gt;DefineType( &quot;Adder&quot; );\n   array&lt;Type^&gt;^adderParams = {int::typeid,int::typeid};\n   \n   // This method will add two numbers which are 100 or less. If either of the\n   // passed integer vales are greater than 100, it will throw an exception.\n   MethodBuilder^ adderBldr = myTypeBldr-&gt;DefineMethod( &quot;DoAdd&quot;, \n      static_cast&lt;MethodAttributes&gt;(MethodAttributes::Public | MethodAttributes::Static), \n      int::typeid, adderParams );\n   ILGenerator^ adderIL = adderBldr-&gt;GetILGenerator();\n   \n   // Types and methods used in the code to throw, catch, and\n   // display OverflowException. Note that if the catch block were\n   // for a more general type, such as Exception, we would need \n   // a MethodInfo for that type&#39;s ToString method.\n   // \n   Type^ overflow = OverflowException::typeid;\n   ConstructorInfo^ exCtorInfo = overflow-&gt;GetConstructor( \n      gcnew array&lt;Type^&gt; { String::typeid });\n   MethodInfo^ exToStrMI = overflow-&gt;GetMethod( &quot;ToString&quot; );\n   MethodInfo^ writeLineMI = Console::typeid-&gt;GetMethod( &quot;WriteLine&quot;, \n      gcnew array&lt;Type^&gt; { String::typeid, Object::typeid } );\n\n   LocalBuilder^ tmp1 = adderIL-&gt;DeclareLocal( int::typeid );\n   LocalBuilder^ tmp2 = adderIL-&gt;DeclareLocal( overflow );\n\n   // In order to successfully branch, we need to create labels\n   // representing the offset IL instruction block to branch to.\n   // These labels, when the MarkLabel(Label) method is invoked,\n   // will specify the IL instruction to branch to.\n   //\n   Label failed = adderIL-&gt;DefineLabel();\n   Label endOfMthd = adderIL-&gt;DefineLabel();\n\n   // Begin the try block.\n   Label exBlock = adderIL-&gt;BeginExceptionBlock();\n   \n   // First, load argument 0 and the integer value of S&quot;100&quot; onto the\n   // stack. If arg0 &gt; 100, branch to the label S&quot;failed&quot;, which is marked\n   // as the address of the block that throws an exception.\n   adderIL-&gt;Emit( OpCodes::Ldarg_0 );\n   adderIL-&gt;Emit( OpCodes::Ldc_I4_S, 100 );\n   adderIL-&gt;Emit( OpCodes::Bgt_S, failed );\n   \n   // Now, check to see if argument 1 was greater than 100. If it was,\n   // branch to S&quot;failed.&quot; Otherwise, fall through and perform the addition,\n   // branching unconditionally to the instruction at the label S&quot;endOfMthd&quot;.\n   adderIL-&gt;Emit( OpCodes::Ldarg_1 );\n   adderIL-&gt;Emit( OpCodes::Ldc_I4_S, 100 );\n   adderIL-&gt;Emit( OpCodes::Bgt_S, failed );\n\n   adderIL-&gt;Emit( OpCodes::Ldarg_0 );\n   adderIL-&gt;Emit( OpCodes::Ldarg_1 );\n   adderIL-&gt;Emit( OpCodes::Add_Ovf_Un );\n   // Store the result of the addition.\n   adderIL-&gt;Emit( OpCodes::Stloc_S, tmp1 );\n   adderIL-&gt;Emit( OpCodes::Br_S, endOfMthd );\n   \n   // If one of the arguments was greater than 100, we need to throw an\n   // exception. We&#39;ll use &quot;OverflowException&quot; with a customized message.\n   // First, we load our message onto the stack, and then create a new\n   // exception Object using the constructor overload that accepts a\n   // String* message.\n   adderIL-&gt;MarkLabel( failed );\n   adderIL-&gt;Emit( OpCodes::Ldstr, &quot;Cannot accept values over 100 for add.&quot; );\n   adderIL-&gt;Emit( OpCodes::Newobj, exCtorInfo );\n   \n   // We&#39;re going to need to refer to that exception Object later, so let&#39;s\n   // store it in a temporary variable. Since the store function pops the\n   // the value/reference off the stack, and we&#39;ll need it to throw the\n   // exception, we will subsequently load it back onto the stack as well.\n   adderIL-&gt;Emit( OpCodes::Stloc_S, tmp2 );\n   adderIL-&gt;Emit( OpCodes::Ldloc_S, tmp2 );\n   \n   // Throw the exception now on the stack.\n   adderIL-&gt;ThrowException( overflow );\n   \n   // Start the catch block for OverflowException.\n   //\n   adderIL-&gt;BeginCatchBlock( overflow );\n   \n   // When we enter the catch block, the thrown exception \n   // is on the stack. Store it, then load the format string\n   // for WriteLine. \n   //\n   adderIL-&gt;Emit(OpCodes::Stloc_S, tmp2);\n   adderIL-&gt;Emit(OpCodes::Ldstr, &quot;Caught {0}&quot;);\n\n   // Push the thrown exception back on the stack, then \n   // call its ToString() method. Note that if this catch block\n   // were for a more general exception type, like Exception,\n   // it would be necessary to use the ToString for that type.\n   //\n   adderIL-&gt;Emit(OpCodes::Ldloc_S, tmp2);\n   adderIL-&gt;EmitCall(OpCodes::Callvirt, exToStrMI, nullptr);\n      \n   // The format string and the return value from ToString() are\n   // now on the stack. Call WriteLine(string, object).\n   //\n   adderIL-&gt;EmitCall( OpCodes::Call, writeLineMI, nullptr );\n   \n   // Since our function has to return an integer value, we&#39;ll load -1 onto\n   // the stack to indicate an error, and store it in local variable tmp1.\n   adderIL-&gt;Emit( OpCodes::Ldc_I4_M1 );\n   adderIL-&gt;Emit( OpCodes::Stloc_S, tmp1 );\n   \n   // End the exception handling block.\n   adderIL-&gt;EndExceptionBlock();\n   \n   // The end of the method. If no exception was thrown, the correct value\n   // will be saved in tmp1. If an exception was thrown, tmp1 will be equal\n   // to -1. Either way, we&#39;ll load the value of tmp1 onto the stack and return.\n   adderIL-&gt;MarkLabel( endOfMthd );\n   adderIL-&gt;Emit( OpCodes::Ldloc_S, tmp1 );\n   adderIL-&gt;Emit( OpCodes::Ret );\n\n   Type^ adderType = myTypeBldr-&gt;CreateType();\n\n   Object^ addIns = Activator::CreateInstance( adderType );\n\n   array&lt;Object^&gt;^addParams = gcnew array&lt;Object^&gt;(2);\n\n   Console::Write( &quot;Enter an integer value: &quot; );\n   addParams[ 0 ] = Convert::ToInt32( Console::ReadLine() );\n\n   Console::Write( &quot;Enter another integer value: &quot; );\n   addParams[ 1 ] = Convert::ToInt32( Console::ReadLine() );\n\n   Console::WriteLine( &quot;If either integer was &gt; 100, an exception will be thrown.&quot; );\n\n   Console::WriteLine( &quot;---&quot; );\n   Console::WriteLine( &quot; {0} + {1} = {2}&quot;, addParams[ 0 ], addParams[ 1 ], adderType-&gt;InvokeMember( &quot;DoAdd&quot;, BindingFlags::InvokeMethod, nullptr, addIns, addParams ) );\n}\n\n/* This code produces output similar to the following:\n\nEnter an integer value: 24\nEnter another integer value: 101\nIf either integer was &gt; 100, an exception will be thrown.\n---\nCaught System.OverflowException: Arithmetic operation resulted in an overflow.\n   at Adder.DoAdd(Int32 , Int32 )\n 24 + 101 = -1\n */\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Reflection.Emit.ILGenerator.ThrowException Example#1\">using System;\nusing System.Reflection;\nusing System.Reflection.Emit;\n\nclass ILThrowExceptionDemo \n{\n   public static void Main()\n   {\n      AppDomain current = AppDomain.CurrentDomain;\n      AssemblyName myAsmName = new AssemblyName();\n      myAsmName.Name = &quot;AdderExceptionAsm&quot;;\n      AssemblyBuilder myAsmBldr = current.DefineDynamicAssembly(myAsmName,\n                               AssemblyBuilderAccess.RunAndSave);\n\n      ModuleBuilder myModBldr = myAsmBldr.DefineDynamicModule(myAsmName.Name, \n                         myAsmName.Name + &quot;.dll&quot;);\n\n      TypeBuilder myTypeBldr = myModBldr.DefineType(&quot;Adder&quot;);\n\n      Type[] adderParams = new Type[] {typeof(int), typeof(int)};\n\n      // This method will add two numbers which are 100 or less. If either of the\n      // passed integer vales are greater than 100, it will throw an exception.\n\n      MethodBuilder adderBldr = myTypeBldr.DefineMethod(&quot;DoAdd&quot;,\n                         MethodAttributes.Public |\n                         MethodAttributes.Static,\n                         typeof(int),\n                         adderParams);\n      ILGenerator adderIL = adderBldr.GetILGenerator();\n \n      // Types and methods used in the code to throw, catch, and\n      // display OverflowException. Note that if the catch block were\n      // for a more general type, such as Exception, we would need \n      // a MethodInfo for that type&#39;s ToString method.\n      // \n      Type overflow = typeof(OverflowException);\n      ConstructorInfo exCtorInfo = overflow.GetConstructor(\n                        new Type[]\n                        {typeof(string)});\n      MethodInfo exToStrMI = overflow.GetMethod(&quot;ToString&quot;);\n      MethodInfo writeLineMI = typeof(Console).GetMethod(&quot;WriteLine&quot;,\n                        new Type[] \n                        {typeof(string),\n                         typeof(object)});\n                                                    \n      LocalBuilder tmp1 = adderIL.DeclareLocal(typeof(int));   \n      LocalBuilder tmp2 = adderIL.DeclareLocal(overflow);\n\n      // In order to successfully branch, we need to create labels\n      // representing the offset IL instruction block to branch to.\n      // These labels, when the MarkLabel(Label) method is invoked,\n      // will specify the IL instruction to branch to.\n      //\n      Label failed = adderIL.DefineLabel();\n      Label endOfMthd = adderIL.DefineLabel();\n\n      // Begin the try block.\n      Label exBlock = adderIL.BeginExceptionBlock();\n\n      // First, load argument 0 and the integer value of &quot;100&quot; onto the\n      // stack. If arg0 &gt; 100, branch to the label &quot;failed&quot;, which is marked\n      // as the address of the block that throws an exception.\n      //\n      adderIL.Emit(OpCodes.Ldarg_0);\n      adderIL.Emit(OpCodes.Ldc_I4_S, 100);\n      adderIL.Emit(OpCodes.Bgt_S, failed); \n\n      // Now, check to see if argument 1 was greater than 100. If it was,\n      // branch to &quot;failed.&quot; Otherwise, fall through and perform the addition,\n      // branching unconditionally to the instruction at the label &quot;endOfMthd&quot;.\n      //\n      adderIL.Emit(OpCodes.Ldarg_1);\n      adderIL.Emit(OpCodes.Ldc_I4_S, 100);\n      adderIL.Emit(OpCodes.Bgt_S, failed);\n\n      adderIL.Emit(OpCodes.Ldarg_0);\n      adderIL.Emit(OpCodes.Ldarg_1);\n      adderIL.Emit(OpCodes.Add_Ovf_Un);\n      // Store the result of the addition.\n      adderIL.Emit(OpCodes.Stloc_S, tmp1);\n      adderIL.Emit(OpCodes.Br_S, endOfMthd);\n\n      // If one of the arguments was greater than 100, we need to throw an\n      // exception. We&#39;ll use &quot;OverflowException&quot; with a customized message.\n      // First, we load our message onto the stack, and then create a new\n      // exception object using the constructor overload that accepts a\n      // string message.\n      //\n      adderIL.MarkLabel(failed);\n      adderIL.Emit(OpCodes.Ldstr, &quot;Cannot accept values over 100 for add.&quot;);\n      adderIL.Emit(OpCodes.Newobj, exCtorInfo);\n\n      // We&#39;re going to need to refer to that exception object later, so let&#39;s\n      // store it in a temporary variable. Since the store function pops the\n      // the value/reference off the stack, and we&#39;ll need it to throw the\n      // exception, we will subsequently load it back onto the stack as well.\n\n      adderIL.Emit(OpCodes.Stloc_S, tmp2);\n      adderIL.Emit(OpCodes.Ldloc_S, tmp2);\n\n      // Throw the exception now on the stack.\n\n      adderIL.ThrowException(overflow);\n      \n      // Start the catch block for OverflowException.\n      //\n      adderIL.BeginCatchBlock(overflow);\n\n      // When we enter the catch block, the thrown exception \n      // is on the stack. Store it, then load the format string\n      // for WriteLine. \n      //\n      adderIL.Emit(OpCodes.Stloc_S, tmp2);\n      adderIL.Emit(OpCodes.Ldstr, &quot;Caught {0}&quot;);\n\n      // Push the thrown exception back on the stack, then \n      // call its ToString() method. Note that if this catch block\n      // were for a more general exception type, like Exception,\n      // it would be necessary to use the ToString for that type.\n      //\n      adderIL.Emit(OpCodes.Ldloc_S, tmp2);\n      adderIL.EmitCall(OpCodes.Callvirt, exToStrMI, null);\n      \n      // The format string and the return value from ToString() are\n      // now on the stack. Call WriteLine(string, object).\n      //\n      adderIL.EmitCall(OpCodes.Call, writeLineMI, null);\n\n      // Since our function has to return an integer value, we&#39;ll load -1 onto\n      // the stack to indicate an error, and store it in local variable tmp1.\n      //\n      adderIL.Emit(OpCodes.Ldc_I4_M1);\n      adderIL.Emit(OpCodes.Stloc_S, tmp1);\n\n      // End the exception handling block.\n\n      adderIL.EndExceptionBlock();   \n\n      // The end of the method. If no exception was thrown, the correct value\n      // will be saved in tmp1. If an exception was thrown, tmp1 will be equal\n      // to -1. Either way, we&#39;ll load the value of tmp1 onto the stack and return.\n      //\n      adderIL.MarkLabel(endOfMthd);\n      adderIL.Emit(OpCodes.Ldloc_S, tmp1);\n      adderIL.Emit(OpCodes.Ret);\n   \n      Type adderType = myTypeBldr.CreateType();\n\n      object addIns = Activator.CreateInstance(adderType); \n\n      object[] addParams = new object[2];\n\n      Console.Write(&quot;Enter an integer value: &quot;);\n      addParams[0] = (object)Convert.ToInt32(Console.ReadLine());\n\n      Console.Write(&quot;Enter another integer value: &quot;);\n      addParams[1] = (object)Convert.ToInt32(Console.ReadLine());\n\n      Console.WriteLine(&quot;If either integer was &gt; 100, an exception will be thrown.&quot;);\n      Console.WriteLine(&quot;---&quot;);\n\n      Console.WriteLine(&quot;{0} + {1} = {2}&quot;,\n            addParams[0], addParams[1],\n            adderType.InvokeMember(&quot;DoAdd&quot;,\n               BindingFlags.InvokeMethod,\n               null,\n               addIns,\n               addParams)); \n   }\n}\n\n/* This code produces output similar to the following:\n\nEnter an integer value: 24\nEnter another integer value: 101\nIf either integer was &gt; 100, an exception will be thrown.\n---\nCaught System.OverflowException: Arithmetic operation resulted in an overflow.\n   at Adder.DoAdd(Int32 , Int32 )\n 24 + 101 = -1\n */\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_UsingNamespace_System_String_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_UsingNamespace_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">UsingNamespace(String)</div>        \r\n          </div>\r\n    \r\n            <p>Specifies the namespace to be used in evaluating locals and watches for the current active lexical scope.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public virtual void UsingNamespace (string usingNamespace);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>usingNamespace</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The namespace to be used in evaluating locals and watches for the current active lexical scope</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p>Length of <code>usingNamespace</code> is zero.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>usingNamespace</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>This <a class=\"xref\" href=\"system.reflection.emit.ilgenerator\" data-linktype=\"relative-path\">ILGenerator</a> belongs to a <a class=\"xref\" href=\"system.reflection.emit.dynamicmethod\" data-linktype=\"relative-path\">DynamicMethod</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the current <a class=\"xref\" href=\"system.reflection.emit.ilgenerator\" data-linktype=\"relative-path\">ILGenerator</a> is associated with a <a class=\"xref\" href=\"system.reflection.emit.dynamicmethod\" data-linktype=\"relative-path\">DynamicMethod</a> object, this method is not supported.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"eii\">\r\n        <h2>Explicit Interface Implementations\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_System_Runtime_InteropServices__ILGenerator_GetIDsOfNames_System_Guid__System_IntPtr_System_UInt32_System_UInt32_System_IntPtr_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_System_Runtime_InteropServices__ILGenerator_GetIDsOfNames_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_ILGenerator.GetIDsOfNames(Guid,IntPtr,UInt32,UInt32,IntPtr)</div>        \r\n          </div>\r\n    \r\n            <p>Maps a set of names to a corresponding set of dispatch identifiers.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">void _ILGenerator.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>riid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.guid\" data-linktype=\"relative-path\">Guid</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Reserved for future use. Must be IID_NULL.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>rgszNames</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Passed-in array of names to be mapped.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>cNames</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Count of the names to be mapped.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>lcid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The locale context in which to interpret the names.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>rgDispId</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Caller-allocated array that receives the IDs corresponding to the names.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notimplementedexception\" data-linktype=\"relative-path\">NotImplementedException</a></div>\r\n                  </div>\r\n                  <p>The method is called late-bound using the COM <code>IDispatch</code> interface.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is for accessing managed classes from unmanaged code, and should not be called from managed code. For more information about <code>IDispatch::GetIDsOfNames</code>, see the MSDN Library.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_System_Runtime_InteropServices__ILGenerator_GetTypeInfo_System_UInt32_System_UInt32_System_IntPtr_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_System_Runtime_InteropServices__ILGenerator_GetTypeInfo_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_ILGenerator.GetTypeInfo(UInt32,UInt32,IntPtr)</div>        \r\n          </div>\r\n    \r\n            <p>Retrieves the type information for an object, which can then be used to get the type information for an interface.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">void _ILGenerator.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>iTInfo</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The type information to return.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>lcid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The locale identifier for the type information.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>ppTInfo</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Receives a pointer to the requested type information object.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notimplementedexception\" data-linktype=\"relative-path\">NotImplementedException</a></div>\r\n                  </div>\r\n                  <p>The method is called late-bound using the COM <code>IDispatch</code> interface.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is for accessing managed classes from unmanaged code, and should not be called from managed code. For more information about <code>IDispatch::GetTypeInfo</code>, see the MSDN Library.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_System_Runtime_InteropServices__ILGenerator_GetTypeInfoCount_System_UInt32__\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_System_Runtime_InteropServices__ILGenerator_GetTypeInfoCount_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_ILGenerator.GetTypeInfoCount(UInt32)</div>        \r\n          </div>\r\n    \r\n            <p>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">void _ILGenerator.GetTypeInfoCount (out uint pcTInfo);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>pcTInfo</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Points to a location that receives the number of type information interfaces provided by the object.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notimplementedexception\" data-linktype=\"relative-path\">NotImplementedException</a></div>\r\n                  </div>\r\n                  <p>The method is called late-bound using the COM <code>IDispatch</code> interface.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is for accessing managed classes from unmanaged code, and should not be called from managed code. For more information about <code>IDispatch::GetTypeInfoCount</code>, see the MSDN Library.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Reflection_Emit_ILGenerator_System_Runtime_InteropServices__ILGenerator_Invoke_System_UInt32_System_Guid__System_UInt32_System_Int16_System_IntPtr_System_IntPtr_System_IntPtr_System_IntPtr_\">\r\n    \r\n            <a id=\"System_Reflection_Emit_ILGenerator_System_Runtime_InteropServices__ILGenerator_Invoke_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">_ILGenerator.Invoke(UInt32,Guid,UInt32,Int16,IntPtr,IntPtr,IntPtr,IntPtr)</div>        \r\n          </div>\r\n    \r\n            <p>Provides access to properties and methods exposed by an object.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">void _ILGenerator.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>dispIdMember</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Identifies the member.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>riid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.guid\" data-linktype=\"relative-path\">Guid</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Reserved for future use. Must be IID_NULL.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>lcid</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.uint32\" data-linktype=\"relative-path\">UInt32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The locale context in which to interpret arguments.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>wFlags</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int16\" data-linktype=\"relative-path\">Int16</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Flags describing the context of the call.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>pDispParams</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>pVarResult</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Pointer to the location where the result is to be stored.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>pExcepInfo</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>Pointer to a structure that contains exception information.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>puArgErr</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.intptr\" data-linktype=\"relative-path\">IntPtr</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The index of the first argument that has an error.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notimplementedexception\" data-linktype=\"relative-path\">NotImplementedException</a></div>\r\n                  </div>\r\n                  <p>The method is called late-bound using the COM <code>IDispatch</code> interface.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This method is for accessing managed classes from unmanaged code, and should not be called from managed code. For more information about <code>IDispatch::Invoke</code>, see the MSDN Library.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n","outputRootRelativePath":"./","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"breadcrumb_path\" content=\"breadcrumb/toc.json\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"fulldocset\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.fulldocset\">\r\n<meta name=\"ref_skeleton_gitcommit\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Reflection.Emit.ILGenerator.yml\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Reflection.Emit.ILGenerator.yml\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.ILGenerator\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.ILGenerator.BeginCatchBlock\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.ILGenerator.BeginExceptFilterBlock\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.ILGenerator.BeginExceptionBlock\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.ILGenerator.BeginFaultBlock\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.ILGenerator.BeginFinallyBlock\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.ILGenerator.BeginScope\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.ILGenerator.DeclareLocal\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.ILGenerator.DefineLabel\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.ILGenerator.Emit\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.ILGenerator.EmitCall\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.ILGenerator.EmitCalli\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.ILGenerator.EmitWriteLine\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.ILGenerator.EndExceptionBlock\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.ILGenerator.EndScope\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.ILGenerator.ILOffset\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.ILGenerator.MarkLabel\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.ILGenerator.MarkSequencePoint\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.ILGenerator._ILGenerator.GetIDsOfNames\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.ILGenerator._ILGenerator.GetTypeInfo\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.ILGenerator._ILGenerator.GetTypeInfoCount\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.ILGenerator._ILGenerator.Invoke\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.ILGenerator.ThrowException\">\r\n<meta name=\"APIName\" content=\"System.Reflection.Emit.ILGenerator.UsingNamespace\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-01 01:37 AM\">\r\n<meta name=\"document_id\" content=\"e4732961-205e-cad4-9298-888d4606c27b\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Generates Microsoft intermediate language (MSIL) instructions.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/System.Reflection.Emit/toc.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Reflection.Emit.ILGenerator\">\r\n","rawMetadata":{"author":"dotnet-bot","breadcrumb_path":"breadcrumb/toc.json","search.ms_sitename":"Docs","search.ms_docsetname":"fulldocset","version":null,"_op_canonicalUrlPrefix":"https://ppe.docs.microsoft.com/en-us/fulldotnet/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":true,"depot_name":"MSDN.fulldocset","_op_gitRefSkeletonCommitHistory":[{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"use plugin in master","commit_sha":"501959ac03e19ac52a27aa4c6bbeb980f8b11c8c","commit_date":"2017-03-01 09:31:20 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"fix pointer ref","commit_sha":"76befb0e7f7b41839ec719047e5b39a5981298f3","commit_date":"2017-02-28 15:47:23 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"switch from platform to version","commit_sha":"78cdacb5ca782478af490a6b30c3a2cb2b6b873e","commit_date":"2017-02-28 15:09:51 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"update platforms","commit_sha":"39ad5a8919a59afc93a79ac4bd8e07c3b471b37a","commit_date":"2017-02-28 10:38:59 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"checkin yml","commit_sha":"da161b792852497df7140d7768cee2eccd9cb43f","commit_date":"2017-02-28 09:36:15 +0800"}],"ref_skeleton_gitcommit":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Reflection.Emit.ILGenerator.yml","original_ref_skeleton_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Reflection.Emit.ILGenerator.yml","open_to_public_contributors":true,"api_name":["System.Reflection.Emit.ILGenerator","System.Reflection.Emit.ILGenerator.BeginCatchBlock","System.Reflection.Emit.ILGenerator.BeginExceptFilterBlock","System.Reflection.Emit.ILGenerator.BeginExceptionBlock","System.Reflection.Emit.ILGenerator.BeginFaultBlock","System.Reflection.Emit.ILGenerator.BeginFinallyBlock","System.Reflection.Emit.ILGenerator.BeginScope","System.Reflection.Emit.ILGenerator.DeclareLocal","System.Reflection.Emit.ILGenerator.DefineLabel","System.Reflection.Emit.ILGenerator.Emit","System.Reflection.Emit.ILGenerator.EmitCall","System.Reflection.Emit.ILGenerator.EmitCalli","System.Reflection.Emit.ILGenerator.EmitWriteLine","System.Reflection.Emit.ILGenerator.EndExceptionBlock","System.Reflection.Emit.ILGenerator.EndScope","System.Reflection.Emit.ILGenerator.ILOffset","System.Reflection.Emit.ILGenerator.MarkLabel","System.Reflection.Emit.ILGenerator.MarkSequencePoint","System.Reflection.Emit.ILGenerator._ILGenerator.GetIDsOfNames","System.Reflection.Emit.ILGenerator._ILGenerator.GetTypeInfo","System.Reflection.Emit.ILGenerator._ILGenerator.GetTypeInfoCount","System.Reflection.Emit.ILGenerator._ILGenerator.Invoke","System.Reflection.Emit.ILGenerator.ThrowException","System.Reflection.Emit.ILGenerator.UsingNamespace"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Reflection.Emit.ILGenerator","System::Reflection::Emit::ILGenerator","System.Reflection.Emit.ILGenerator.BeginCatchBlock","System::Reflection::Emit::ILGenerator::BeginCatchBlock","System.Reflection.Emit.ILGenerator.BeginExceptFilterBlock","System::Reflection::Emit::ILGenerator::BeginExceptFilterBlock","System.Reflection.Emit.ILGenerator.BeginExceptionBlock","System::Reflection::Emit::ILGenerator::BeginExceptionBlock","System.Reflection.Emit.ILGenerator.BeginFaultBlock","System::Reflection::Emit::ILGenerator::BeginFaultBlock","System.Reflection.Emit.ILGenerator.BeginFinallyBlock","System::Reflection::Emit::ILGenerator::BeginFinallyBlock","System.Reflection.Emit.ILGenerator.BeginScope","System::Reflection::Emit::ILGenerator::BeginScope","System.Reflection.Emit.ILGenerator.DeclareLocal","System::Reflection::Emit::ILGenerator::DeclareLocal","System.Reflection.Emit.ILGenerator.DefineLabel","System::Reflection::Emit::ILGenerator::DefineLabel","System.Reflection.Emit.ILGenerator.Emit","System::Reflection::Emit::ILGenerator::Emit","System.Reflection.Emit.ILGenerator.EmitCall","System::Reflection::Emit::ILGenerator::EmitCall","System.Reflection.Emit.ILGenerator.EmitCalli","System::Reflection::Emit::ILGenerator::EmitCalli","System.Reflection.Emit.ILGenerator.EmitWriteLine","System::Reflection::Emit::ILGenerator::EmitWriteLine","System.Reflection.Emit.ILGenerator.EndExceptionBlock","System::Reflection::Emit::ILGenerator::EndExceptionBlock","System.Reflection.Emit.ILGenerator.EndScope","System::Reflection::Emit::ILGenerator::EndScope","System.Reflection.Emit.ILGenerator.ILOffset","System::Reflection::Emit::ILGenerator::ILOffset","System.Reflection.Emit.ILGenerator.MarkLabel","System::Reflection::Emit::ILGenerator::MarkLabel","System.Reflection.Emit.ILGenerator.MarkSequencePoint","System::Reflection::Emit::ILGenerator::MarkSequencePoint","System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#GetIDsOfNames","System::Reflection::Emit::ILGenerator::System#Runtime#InteropServices#_ILGenerator#GetIDsOfNames","System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#GetTypeInfo","System::Reflection::Emit::ILGenerator::System#Runtime#InteropServices#_ILGenerator#GetTypeInfo","System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#GetTypeInfoCount","System::Reflection::Emit::ILGenerator::System#Runtime#InteropServices#_ILGenerator#GetTypeInfoCount","System.Reflection.Emit.ILGenerator.System#Runtime#InteropServices#_ILGenerator#Invoke","System::Reflection::Emit::ILGenerator::System#Runtime#InteropServices#_ILGenerator#Invoke","System.Reflection.Emit.ILGenerator.ThrowException","System::Reflection::Emit::ILGenerator::ThrowException","System.Reflection.Emit.ILGenerator.UsingNamespace","System::Reflection::Emit::ILGenerator::UsingNamespace"],"dev_langs":["csharp"],"updated_at":"2017-03-01 01:37 AM","document_id":"e4732961-205e-cad4-9298-888d4606c27b","content_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/xml/System.Reflection.Emit/ILGenerator.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"ILGenerator class | Microsoft Docs","_op_ogTitle":"ILGenerator class","description":"Generates Microsoft intermediate language (MSIL) instructions.\n","toc_asset_id":"_splitted/System.Reflection.Emit/toc.json","toc_rel":"_splitted/System.Reflection.Emit/toc.json","source_url":"","ms.assetid":"System.Reflection.Emit.ILGenerator","canonical_url":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.reflection.emit.ilgenerator","_op_canonicalUrl":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.reflection.emit.ilgenerator","fileRelativePath":"System.Reflection.Emit.ILGenerator.html"},"themesRelativePathToOutputRoot":"_themes/"}