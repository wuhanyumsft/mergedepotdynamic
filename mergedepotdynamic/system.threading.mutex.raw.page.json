{"content":"    \r\n    <h1 id=\"System_Threading_Mutex\">\r\n      <span class=\"lang-csharp\">Mutex</span>\r\n        Class\r\n    </h1>\r\n    \r\n    \r\n    <nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n      <h3>In this Article</h3>\r\n    </nav><div class=\"summary\">\r\n    \t<p>A synchronization primitive that can also be used for interprocess synchronization.</p>\n\r\n    </div><h2>Syntax</h2>\r\n    \r\n    \t<h3>Declaration</h3>\r\n    \t<pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ComVisible(true)]\npublic sealed class Mutex : System.Threading.WaitHandle</code></pre>\r\n    \r\n    \r\n    \r\n    <h3>Inheritance Hierarchy</h3>\r\n    <ul class=\"inheritance\">\r\n        <li class=\"l0\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>\r\n          </div>\r\n        </li>\r\n        <li class=\"l1\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.marshalbyrefobject\" data-linktype=\"relative-path\">MarshalByRefObject</a>\r\n          </div>\r\n        </li>\r\n        <li class=\"l2\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">System.Threading.WaitHandle</a>\r\n          </div>\r\n        </li>\r\n      <li class=\"l3\">\r\n        <div class=\"xref\">\r\n          <div class=\"lang-csharp\">Mutex</div>\r\n        </div>\r\n      </li>\r\n    </ul>\r\n    \r\n      <div class=\"referencebox inheritedMembers\">\r\n        <h3>Inherited Members</h3>\r\n        <h4></h4>\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.marshalbyrefobject#System_MarshalByRefObject_CreateObjRef_System_Type_\" data-linktype=\"relative-path\">CreateObjRef(Type)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.marshalbyrefobject#System_MarshalByRefObject_GetLifetimeService\" data-linktype=\"relative-path\">GetLifetimeService()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.marshalbyrefobject#System_MarshalByRefObject_InitializeLifetimeService\" data-linktype=\"relative-path\">InitializeLifetimeService()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.marshalbyrefobject#System_MarshalByRefObject_MemberwiseClone_System_Boolean_\" data-linktype=\"relative-path\">MemberwiseClone(Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Close\" data-linktype=\"relative-path\">Close()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Dispose\" data-linktype=\"relative-path\">Dispose()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Dispose_System_Boolean_\" data-linktype=\"relative-path\">Dispose(Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Handle\" data-linktype=\"relative-path\">Handle</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_InvalidHandle\" data-linktype=\"relative-path\">InvalidHandle</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SafeWaitHandle\" data-linktype=\"relative-path\">SafeWaitHandle</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SignalAndWait_System_Threading_WaitHandle_System_Threading_WaitHandle_\" data-linktype=\"relative-path\">SignalAndWait(WaitHandle,WaitHandle)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SignalAndWait_System_Threading_WaitHandle_System_Threading_WaitHandle_System_Int32_System_Boolean_\" data-linktype=\"relative-path\">SignalAndWait(WaitHandle,WaitHandle,Int32,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SignalAndWait_System_Threading_WaitHandle_System_Threading_WaitHandle_System_TimeSpan_System_Boolean_\" data-linktype=\"relative-path\">SignalAndWait(WaitHandle,WaitHandle,TimeSpan,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___\" data-linktype=\"relative-path\">WaitAll(WaitHandle[])</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_Int32_\" data-linktype=\"relative-path\">WaitAll(WaitHandle[],Int32)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_Int32_System_Boolean_\" data-linktype=\"relative-path\">WaitAll(WaitHandle[],Int32,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_TimeSpan_\" data-linktype=\"relative-path\">WaitAll(WaitHandle[],TimeSpan)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_TimeSpan_System_Boolean_\" data-linktype=\"relative-path\">WaitAll(WaitHandle[],TimeSpan,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___\" data-linktype=\"relative-path\">WaitAny(WaitHandle[])</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_Int32_\" data-linktype=\"relative-path\">WaitAny(WaitHandle[],Int32)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_Int32_System_Boolean_\" data-linktype=\"relative-path\">WaitAny(WaitHandle[],Int32,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_TimeSpan_\" data-linktype=\"relative-path\">WaitAny(WaitHandle[],TimeSpan)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_TimeSpan_System_Boolean_\" data-linktype=\"relative-path\">WaitAny(WaitHandle[],TimeSpan,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne\" data-linktype=\"relative-path\">WaitOne()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_System_Int32_\" data-linktype=\"relative-path\">WaitOne(Int32)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_System_Int32_System_Boolean_\" data-linktype=\"relative-path\">WaitOne(Int32,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_System_TimeSpan_\" data-linktype=\"relative-path\">WaitOne(TimeSpan)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_System_TimeSpan_System_Boolean_\" data-linktype=\"relative-path\">WaitOne(TimeSpan,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitTimeout\" data-linktype=\"relative-path\">WaitTimeout</a>\r\n          </div>\r\n          \r\n      </div>\r\n    \r\n    \r\n      <h2>Remarks</h2>\r\n      <div class=\"NOTE\"><h5>Note</h5><p> To view the .NET Framework source code for this type, see the <a href=\"http://referencesource.microsoft.com/#mscorlib/system/threading/mutex.cs#29b92e0e2832a8d6\" data-linktype=\"external\">Reference Source</a>. You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <a href=\"http://referencesource.microsoft.com/\" data-linktype=\"external\">instructions</a>.  </p>\n</div>\n<p> When two or more threads need to access a shared resource at the same time, the system needs a synchronization mechanism to ensure that only one thread at a time uses the resource. Mutex is a synchronization primitive that grants exclusive access to the shared resource to only one thread. If a thread acquires a mutex, the second thread that wants to acquire that mutex is suspended until the first thread releases the mutex.  </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> This type implements the <a class=\"xref\" href=\"system.idisposable\" data-linktype=\"relative-path\">IDisposable</a> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <a class=\"xref\" href=\"system.idisposable#System_IDisposable_Dispose_\" data-linktype=\"relative-path\">Dispose</a> method in a <code>try</code>/<code>catch</code> block. To dispose of it indirectly, use a language construct such as <code>using</code> (in C#) or <code>Using</code> (in Visual Basic). For more information, see the â€œUsing an Object that Implements IDisposableâ€ section in the <a class=\"xref\" href=\"system.idisposable\" data-linktype=\"relative-path\">IDisposable</a> interface topic.  </p>\n</div>\n<p> You can use the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> method to request ownership of a mutex. The calling thread blocks until one of the following occurs:  </p>\n<ul>\n<li><p>The mutex is signaled to indicate that it is not owned. When this happens, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> method returns <code>true</code>, and the calling thread assumes ownership of the mutex and accesses the resource protected by the mutex. When it has finished accessing the resource, the thread must call the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_ReleaseMutex_\" data-linktype=\"relative-path\">ReleaseMutex</a> method to release ownership of the mutex. The first example in the Examples section illustrates this pattern.  </p>\n</li>\n<li><p>The time-out interval specified in the call to a <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> method that has a <code>millisecondsTimeout</code> or <code>timeout</code> parameter has elapsed. When this happens, the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> method returns <code>false</code>, and the calling thread makes no further attempt to acquire ownership of the mutex. In this case, you should structure your code so that access to the resource that is protected by the mutex is denied to the calling thread. Because the thread never acquired ownership of the mutex, it must not call the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_ReleaseMutex_\" data-linktype=\"relative-path\">ReleaseMutex</a> method. The second example in the Examples section illustrates this pattern.  </p>\n<p>The Mutex class enforces thread identity, so a mutex can be released only by the thread that acquired it. By contrast, the <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> class does not enforce thread identity. A mutex can also be passed across application domain boundaries.  </p>\n<p>The thread that owns a mutex can request the same mutex in repeated calls to <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> without blocking its execution. However, the thread must call the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_ReleaseMutex_\" data-linktype=\"relative-path\">ReleaseMutex</a> method the same number of times to release ownership of the mutex.  </p>\n<p>Because the Mutex class inherits from <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a>, you can also call the static <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_\" data-linktype=\"relative-path\">WaitAll</a> and <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_\" data-linktype=\"relative-path\">WaitAny</a> methods to synchronize access to a protected resource.  </p>\n<p>If a thread terminates while owning a mutex, the mutex is said to be abandoned. The state of the mutex is set to signaled, and the next waiting thread gets ownership. Beginning in version 2.0 of the .NET Framework, an <a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> is thrown in the next thread that acquires the abandoned mutex. Before version 2.0 of the .NET Framework, no exception was thrown.  </p>\n</li>\n</ul>\n<div class=\"CAUTION\"><h5>Caution</h5><p> An abandoned mutex often indicates a serious error in the code. When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state. The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.  </p>\n</div>\n<p> In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).  </p>\n<p> Mutexes are of two types: local mutexes, which are unnamed, and named system mutexes. A local mutex exists only within your process. It can be used by any thread in your process that has a reference to the Mutex object that represents the mutex. Each unnamed Mutex object represents a separate local mutex.  </p>\n<p> Named system mutexes are visible throughout the operating system, and can be used to synchronize the activities of processes. You can create a Mutex object that represents a named system mutex by using a constructor that accepts a name. The operating-system object can be created at the same time, or it can exist before the creation of the Mutex object. You can create multiple Mutex objects that represent the same named system mutex, and you can use the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_OpenExisting_\" data-linktype=\"relative-path\">OpenExisting</a> method to open an existing named system mutex.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix &quot;Global\\&quot;, the mutex is visible in all terminal server sessions. If its name begins with the prefix &quot;Local\\&quot;, the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix &quot;Local\\&quot;. Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names &quot;Global\\&quot; and &quot;Local\\&quot; describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</p>\n</div>\n\r\n    \r\n    \r\n    <h2>Constructors\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Mutex__ctor\" data-linktype=\"self-bookmark\">Mutex()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> class with default properties.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Mutex__ctor_System_Boolean_\" data-linktype=\"self-bookmark\">Mutex(Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Mutex__ctor_System_Boolean_System_String_\" data-linktype=\"self-bookmark\">Mutex(Boolean,String)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Mutex__ctor_System_Boolean_System_String_System_Boolean__\" data-linktype=\"self-bookmark\">Mutex(Boolean,String,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Mutex__ctor_System_Boolean_System_String_System_Boolean__System_Security_AccessControl_MutexSecurity_\" data-linktype=\"self-bookmark\">Mutex(Boolean,String,Boolean,MutexSecurity)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Methods\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Mutex_GetAccessControl\" data-linktype=\"self-bookmark\">GetAccessControl()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets a <a class=\"xref\" href=\"system.security.accesscontrol.mutexsecurity\" data-linktype=\"relative-path\">MutexSecurity</a> object that represents the access control security for the named mutex.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Mutex_OpenExisting_System_String_\" data-linktype=\"self-bookmark\">OpenExisting(String)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Opens the specified named mutex, if it already exists.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Mutex_OpenExisting_System_String_System_Security_AccessControl_MutexRights_\" data-linktype=\"self-bookmark\">OpenExisting(String,MutexRights)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Opens the specified named mutex, if it already exists, with the desired security access.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Mutex_ReleaseMutex\" data-linktype=\"self-bookmark\">ReleaseMutex()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Releases the <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> once.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Mutex_SetAccessControl_System_Security_AccessControl_MutexSecurity_\" data-linktype=\"self-bookmark\">SetAccessControl(MutexSecurity)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets the access control security for a named system mutex.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Mutex_TryOpenExisting_System_String_System_Threading_Mutex__\" data-linktype=\"self-bookmark\">TryOpenExisting(String,Mutex)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Mutex_TryOpenExisting_System_String_System_Security_AccessControl_MutexRights_System_Threading_Mutex__\" data-linktype=\"self-bookmark\">TryOpenExisting(String,MutexRights,Mutex)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"constructors\">\r\n        <h2>Constructors\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Mutex__ctor\">\r\n    \r\n            <a id=\"System_Threading_Mutex__ctor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Mutex()</div>        \r\n          </div>\r\n    \r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> class with default properties.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public Mutex ();</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Calling this constructor overload is the same as calling the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex__ctor_System_Boolean_\" data-linktype=\"relative-path\">Mutex(Boolean)</a> constructor overload and specifying <code>false</code> for initial ownership of the mutex. That is, the calling thread does not own the mutex.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example shows how a local <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> object is used to synchronize access to a protected resource. The thread that creates the mutex does not own it initially.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Threading.Mutex Default Ctor Example#1\">&#39; This example shows how a Mutex is used to synchronize access\n&#39; to a protected resource. Unlike Monitor, Mutex can be used with\n&#39; WaitHandle.WaitAll and WaitAny, and can be passed across\n&#39; AppDomain boundaries.\n \nImports System\nImports System.Threading\nImports Microsoft.VisualBasic\n\nClass Test\n    &#39; Create a new Mutex. The creating thread does not own the\n    &#39; Mutex.\n    Private Shared mut As New Mutex()\n    Private Const numIterations As Integer = 1\n    Private Const numThreads As Integer = 3\n\n    &lt;MTAThread&gt; _\n    Shared Sub Main()\n        &#39; Create the threads that will use the protected resource.\n        Dim i As Integer\n        For i = 1 To numThreads\n            Dim myThread As New Thread(AddressOf MyThreadProc)\n            myThread.Name = [String].Format(&quot;Thread{0}&quot;, i)\n            myThread.Start()\n        Next i\n\n        &#39; The main thread exits, but the application continues to\n        &#39; run until all foreground threads have exited.\n\n    End Sub &#39;Main\n\n    Private Shared Sub MyThreadProc()\n        Dim i As Integer\n        For i = 1 To numIterations\n            UseResource()\n        Next i\n    End Sub &#39;MyThreadProc\n\n    &#39; This method represents a resource that must be synchronized\n    &#39; so that only one thread at a time can enter.\n    Private Shared Sub UseResource()\n        &#39; Wait until it is safe to enter.\n        mut.WaitOne()\n\n        Console.WriteLine(&quot;{0} has entered protected area&quot;, _\n            Thread.CurrentThread.Name)\n\n        &#39; Place code to access non-reentrant resources here.\n\n        &#39; Simulate some work\n        Thread.Sleep(500)\n\n        Console.WriteLine(&quot;{0} is leaving protected area&quot; &amp; vbCrLf, _\n            Thread.CurrentThread.Name)\n\n        &#39; Release Mutex.\n        mut.ReleaseMutex()\n    End Sub &#39;UseResource\nEnd Class &#39;MyMainClass\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.Mutex Default Ctor Example#1\">// This example shows how a Mutex is used to synchronize access\n// to a protected resource. Unlike Monitor, Mutex can be used with\n// WaitHandle.WaitAll and WaitAny, and can be passed across\n// AppDomain boundaries.\nusing namespace System;\nusing namespace System::Threading;\nconst int numIterations = 1;\nconst int numThreads = 3;\nref class Test\n{\npublic:\n\n   // Create a new Mutex. The creating thread does not own the\n   // Mutex.\n   static Mutex^ mut = gcnew Mutex;\n   static void MyThreadProc()\n   {\n      for ( int i = 0; i &lt; numIterations; i++ )\n      {\n         UseResource();\n\n      }\n   }\n\n\nprivate:\n\n   // This method represents a resource that must be synchronized\n   // so that only one thread at a time can enter.\n   static void UseResource()\n   {\n      \n      //Wait until it is OK to enter.\n      mut-&gt;WaitOne();\n      Console::WriteLine( &quot;{0} has entered protected the area&quot;, Thread::CurrentThread-&gt;Name );\n      \n      // Place code to access non-reentrant resources here.\n      // Simulate some work.\n      Thread::Sleep( 500 );\n      Console::WriteLine( &quot;{0} is leaving protected the area\\r<br>&quot;, Thread::CurrentThread-&gt;Name );\n      \n      // Release the Mutex.\n      mut-&gt;ReleaseMutex();\n   }\n\n};\n\nint main()\n{\n   \n   // Create the threads that will use the protected resource.\n   for ( int i = 0; i &lt; numThreads; i++ )\n   {\n      Thread^ myThread = gcnew Thread( gcnew ThreadStart( Test::MyThreadProc ) );\n      myThread-&gt;Name = String::Format( &quot;Thread {0}&quot;, i + 1 );\n      myThread-&gt;Start();\n\n   }\n   \n   // The main thread exits, but the application continues to \n   // run until all foreground threads have exited.\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.Mutex Default Ctor Example#1\">// This example shows how a Mutex is used to synchronize access\n// to a protected resource. Unlike Monitor, Mutex can be used with\n// WaitHandle.WaitAll and WaitAny, and can be passed across\n// AppDomain boundaries.\n \nusing System;\nusing System.Threading;\n\nclass Test\n{\n    // Create a new Mutex. The creating thread does not own the\n    // Mutex.\n    private static Mutex mut = new Mutex();\n    private const int numIterations = 1;\n    private const int numThreads = 3;\n\n    static void Main()\n    {\n        // Create the threads that will use the protected resource.\n        for(int i = 0; i &lt; numThreads; i++)\n        {\n            Thread myThread = new Thread(new ThreadStart(MyThreadProc));\n            myThread.Name = String.Format(&quot;Thread{0}&quot;, i + 1);\n            myThread.Start();\n        }\n\n        // The main thread exits, but the application continues to\n        // run until all foreground threads have exited.\n    }\n\n    private static void MyThreadProc()\n    {\n        for(int i = 0; i &lt; numIterations; i++)\n        {\n            UseResource();\n        }\n    }\n\n    // This method represents a resource that must be synchronized\n    // so that only one thread at a time can enter.\n    private static void UseResource()\n    {\n        // Wait until it is safe to enter.\n        mut.WaitOne();\n\n        Console.WriteLine(&quot;{0} has entered the protected area&quot;, \n            Thread.CurrentThread.Name);\n\n        // Place code to access non-reentrant resources here.\n\n        // Simulate some work.\n        Thread.Sleep(500);\n\n        Console.WriteLine(&quot;{0} is leaving the protected area\\r<br>&quot;, \n            Thread.CurrentThread.Name);\n         \n        // Release the Mutex.\n        mut.ReleaseMutex();\n    }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Mutex__ctor_System_Boolean_\">\r\n    \r\n            <a id=\"System_Threading_Mutex__ctor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Mutex(Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public Mutex (bool initiallyOwned);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>initiallyOwned</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to give the calling thread initial ownership of the mutex; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example shows how a local <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> object is used to synchronize access to a protected resource. The thread that creates the <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> owns it initially.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.Mutex 1Arg Ctor Example#1\">using System;\nusing System.Threading;\n\nclass Test\n{\n    // Create a new Mutex. The creating thread owns the Mutex.\n    private static Mutex mut = new Mutex(true);\n    private const int numIterations = 1;\n    private const int numThreads = 3;\n\n    static void Main()\n    {\n        // Create the threads that will use the protected resource.\n        for(int i = 0; i &lt; numThreads; i++)\n        {\n            Thread myThread = new Thread(new ThreadStart(MyThreadProc));\n            myThread.Name = String.Format(&quot;Thread{0}&quot;, i + 1);\n            myThread.Start();\n        }\n\n        // Wait one second before allowing other threads to\n        // acquire the Mutex.\n        Console.WriteLine(&quot;Creating thread owns the Mutex.&quot;);\n        Thread.Sleep(1000);\n\n        Console.WriteLine(&quot;Creating thread releases the Mutex.\\r<br>&quot;);\n        mut.ReleaseMutex();\n    }\n\n    private static void MyThreadProc()\n    {\n        for(int i = 0; i &lt; numIterations; i++)\n        {\n            UseResource();\n        }\n    }\n\n    // This method represents a resource that must be synchronized\n    // so that only one thread at a time can enter.\n    private static void UseResource()\n    {\n        // Wait until it is safe to enter.\n        mut.WaitOne();\n\n        Console.WriteLine(&quot;{0} has entered the protected area&quot;, \n            Thread.CurrentThread.Name);\n\n        // Place code to access non-reentrant resources here.\n\n        // Simulate some work.\n        Thread.Sleep(500);\n\n        Console.WriteLine(&quot;{0} is leaving the protected area\\r<br>&quot;, \n            Thread.CurrentThread.Name);\n         \n        // Release the Mutex.\n        mut.ReleaseMutex();\n    }\n}\n// The example displays output like the following:\n//       Creating thread owns the Mutex.\n//       Creating thread releases the Mutex.\n//       \n//       Thread1 has entered the protected area\n//       Thread1 is leaving the protected area\n//       \n//       Thread2 has entered the protected area\n//       Thread2 is leaving the protected area\n//       \n//       Thread3 has entered the protected area\n//       Thread3 is leaving the protected area\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.Mutex 1Arg Ctor Example#1\">using namespace System;\nusing namespace System::Threading;\n\nconst int numIterations = 1;\nconst int numThreads = 3;\n\nref class Test\n{\npublic:\n\n   // Create a new Mutex. The creating thread owns the\n   // Mutex.\n   static Mutex^ mut = gcnew Mutex( true );\n   static void MyThreadProc()\n   {\n      for ( int i = 0; i &lt; numIterations; i++ )\n      {\n         UseResource();\n\n      }\n   }\n\n\nprivate:\n\n   // This method represents a resource that must be synchronized\n   // so that only one thread at a time can enter.\n   static void UseResource()\n   {\n      \n      //Wait until it is OK to enter.\n      mut-&gt;WaitOne();\n      Console::WriteLine( &quot;{0} has entered protected the area&quot;, Thread::CurrentThread-&gt;Name );\n      \n      // Place code to access non-reentrant resources here.\n      // Simulate some work.\n      Thread::Sleep( 500 );\n      Console::WriteLine( &quot;{0} is leaving protected the area\\r<br>&quot;, Thread::CurrentThread-&gt;Name );\n      \n      // Release the Mutex.\n      mut-&gt;ReleaseMutex();\n   }\n\n};\n\nint main()\n{\n   \n   // Initialize the Mutex.\n   Mutex^ mut = Test::mut;\n   \n   // Create the threads that will use the protected resource.\n   for ( int i = 0; i &lt; numThreads; i++ )\n   {\n      Thread^ myThread = gcnew Thread( gcnew ThreadStart( Test::MyThreadProc ) );\n      myThread-&gt;Name = String::Format( &quot;Thread {0}&quot;, i + 1 );\n      myThread-&gt;Start();\n\n   }\n   \n   // Wait one second before allowing other threads to\n   // acquire the Mutex.\n   Console::WriteLine( &quot;Creating thread owns the Mutex.&quot; );\n   Thread::Sleep( 1000 );\n   Console::WriteLine( &quot;Creating thread releases the Mutex.\\r<br>&quot; );\n   mut-&gt;ReleaseMutex();\n}\n// The example displays output like the following:\n//       Creating thread owns the Mutex.\n//       Creating thread releases the Mutex.\n//       \n//       Thread1 has entered the protected area\n//       Thread1 is leaving the protected area\n//       \n//       Thread2 has entered the protected area\n//       Thread2 is leaving the protected area\n//       \n//       Thread3 has entered the protected area\n//       Thread3 is leaving the protected area\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Mutex 1Arg Ctor Example#1\">Imports System.Threading\n\nClass Test\n    &#39; Create a new Mutex. The creating thread owns the\n    &#39; Mutex.\n    Private Shared mut As New Mutex(True)\n    Private Const numIterations As Integer = 1\n    Private Const numThreads As Integer = 3\n\n    &lt;MTAThread&gt; _\n    Shared Sub Main()\n        &#39; Create the threads that will use the protected resource.\n        Dim i As Integer\n        For i = 1 To numThreads\n            Dim myThread As New Thread(AddressOf MyThreadProc)\n            myThread.Name = [String].Format(&quot;Thread{0}&quot;, i)\n            myThread.Start()\n        Next i\n\n        &#39; Wait one second before allowing other threads to\n        &#39; acquire the Mutex.\n        Console.WriteLine(&quot;Creating thread owns the Mutex.&quot;)\n        Thread.Sleep(1000)\n\n        Console.WriteLine(&quot;Creating thread releases the Mutex.&quot; &amp; vbCrLf)\n        mut.ReleaseMutex()\n    End Sub &#39;Main\n\n    Private Shared Sub MyThreadProc()\n        Dim i As Integer\n        For i = 1 To numIterations\n            UseResource()\n        Next i\n    End Sub &#39;MyThreadProc\n\n    &#39; This method represents a resource that must be synchronized\n    &#39; so that only one thread at a time can enter.\n    Private Shared Sub UseResource()\n        &#39; Wait until it is safe to enter.\n        mut.WaitOne()\n\n        Console.WriteLine(&quot;{0} has entered protected area&quot;, _\n            Thread.CurrentThread.Name)\n\n        &#39; Place code to access non-reentrant resources here.\n\n        &#39; Simulate some work\n        Thread.Sleep(500)\n\n        Console.WriteLine(&quot;{0} is leaving protected area&quot; &amp; vbCrLf, _\n            Thread.CurrentThread.Name)\n\n        &#39; Release Mutex.\n        mut.ReleaseMutex()\n    End Sub &#39;UseResource\nEnd Class &#39;MyMainClass\n&#39; The example displays output like the following:\n&#39;       Creating thread owns the Mutex.\n&#39;       Creating thread releases the Mutex.\n&#39;       \n&#39;       Thread1 has entered the protected area\n&#39;       Thread1 is leaving the protected area\n&#39;       \n&#39;       Thread2 has entered the protected area\n&#39;       Thread2 is leaving the protected area\n&#39;       \n&#39;       Thread3 has entered the protected area\n&#39;       Thread3 is leaving the protected area\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Mutex__ctor_System_Boolean_System_String_\">\r\n    \r\n            <a id=\"System_Threading_Mutex__ctor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Mutex(Boolean,String)</div>        \r\n          </div>\r\n    \r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public Mutex (bool initiallyOwned, string name);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>initiallyOwned</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of the <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a>. If the value is <code>null</code>, the <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> is unnamed.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The named mutex exists and has access control security, but the user does not have <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">MutexRights</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a></div>\r\n                  </div>\r\n                  <p>A Win32 error occurred.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandlecannotbeopenedexception\" data-linktype=\"relative-path\">WaitHandleCannotBeOpenedException</a></div>\r\n                  </div>\r\n                  <p>The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is longer than 260 characters.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If <code>name</code> is not <code>null</code> and <code>initiallyOwned</code> is <code>true</code>, the calling thread owns the mutex only if the named system mutex was created as a result of this call. Since there is no mechanism for determining whether the named system mutex was created, it is better to specify <code>false</code> for <code>initiallyOwned</code> when calling this constructor overload. You can use the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex__ctor_System_Boolean_System_String_System_Boolean__\" data-linktype=\"relative-path\">Mutex(Boolean,String,Boolean)</a> constructor if you need to determine initial ownership.  </p>\n<p> This constructor initializes a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> object that represents a named system mutex. You can create multiple <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> objects that represent the same named system mutex.  </p>\n<p> If the named mutex has already been created with access control security, and the caller does not have <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">System.Security.AccessControl.MutexRights</a>, an exception is thrown. To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_OpenExisting_\" data-linktype=\"relative-path\">OpenExisting</a> method.  </p>\n<p> If you specify <code>null</code> or an empty string for <code>name</code>, a local mutex is created, as if you had called the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex__ctor_System_Boolean_\" data-linktype=\"relative-path\">Mutex(Boolean)</a> constructor. In this case, <code>createdNew</code> is always <code>true</code>.  </p>\n<p> Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix &quot;Global\\&quot;, the mutex is visible in all terminal server sessions. If its name begins with the prefix &quot;Local\\&quot;, the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix &quot;Local\\&quot;. Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names &quot;Global\\&quot; and &quot;Local\\&quot; describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example shows how a named mutex is used to signal between threads running in two separate processes.  </p>\n<p> Run this program from two or more command windows. Each process creates a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> object that represents the named mutex <code>MyMutex</code>. The named mutex is a system object whose lifetime is bounded by the lifetimes of the <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> objects that represent it. The named mutex is created when the first process creates its <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> object; in this example, the named mutex is owned by the first process that runs the program. The named mutex is destroyed when all the <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> objects that represent it have been released.  </p>\n<p> The constructor overload used in this example cannot tell the calling thread whether initial ownership of the named mutex was granted. You should not use this constructor to request initial ownership unless you can be certain that the thread will create the named mutex.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.Mutex 2Arg Ctor Example#1\">using System;\nusing System.Threading;\n\npublic class Test\n{\n    public static void Main()\n    {\n        // Create the named mutex. Only one system object named \n        // &quot;MyMutex&quot; can exist; the local Mutex object represents \n        // this system object, regardless of which process or thread\n        // caused &quot;MyMutex&quot; to be created.\n        Mutex m = new Mutex(false, &quot;MyMutex&quot;);\n        \n        // Try to gain control of the named mutex. If the mutex is \n        // controlled by another thread, wait for it to be released.        \n        Console.WriteLine(&quot;Waiting for the Mutex.&quot;);\n        m.WaitOne();\n\n        // Keep control of the mutex until the user presses\n        // ENTER.\n        Console.WriteLine(&quot;This application owns the mutex. &quot; +\n            &quot;Press ENTER to release the mutex and exit.&quot;);\n        Console.ReadLine();\n\n        m.ReleaseMutex();\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.Mutex 2Arg Ctor Example#1\">using namespace System;\nusing namespace System::Threading;\n\nint main()\n{\n   // Create the named mutex. Only one system object named \n   // &quot;MyMutex&quot; can exist; the local Mutex object represents \n   // this system object, regardless of which process or thread\n   // caused &quot;MyMutex&quot; to be created.\n   Mutex^ m = gcnew Mutex( false,&quot;MyMutex&quot; );\n   \n   // Try to gain control of the named mutex. If the mutex is \n   // controlled by another thread, wait for it to be released.        \n   Console::WriteLine(  &quot;Waiting for the Mutex.&quot; );\n   m-&gt;WaitOne();\n   \n   // Keep control of the mutex until the user presses\n   // ENTER.\n   Console::WriteLine( &quot;This application owns the mutex. &quot;\n   &quot;Press ENTER to release the mutex and exit.&quot; );\n   Console::ReadLine();\n   m-&gt;ReleaseMutex();\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Mutex 2Arg Ctor Example#1\">Imports System.Threading\nPublic Class Test\n   Public Shared Sub Main()\n      &#39; Create the named mutex. Only one system object named \n      &#39; &quot;MyMutex&quot; can exist; the local Mutex object represents \n      &#39; this system object, regardless of which process or thread\n      &#39; caused &quot;MyMutex&quot; to be created.\n      Dim m As New Mutex(False, &quot;MyMutex&quot;)\n      \n      &#39; Try to gain control of the named mutex. If the mutex is \n      &#39; controlled by another thread, wait for it to be released.        \n      Console.WriteLine(&quot;Waiting for the Mutex.&quot;)\n      m.WaitOne()\n      \n      &#39; Keep control of the mutex until the user presses\n      &#39; ENTER.\n      Console.WriteLine(&quot;This application owns the mutex. &quot; _\n          &amp; &quot;Press ENTER to release the mutex and exit.&quot;)\n      Console.ReadLine()\n      \n      m.ReleaseMutex()\n   End Sub \nEnd Class \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Mutex__ctor_System_Boolean_System_String_System_Boolean__\">\r\n    \r\n            <a id=\"System_Threading_Mutex__ctor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Mutex(Boolean,String,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public Mutex (bool initiallyOwned, string name, out bool createdNew);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>initiallyOwned</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of the <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a>. If the value is <code>null</code>, the <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> is unnamed.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>createdNew</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>When this method returns, contains a Boolean that is <code>true</code> if a local mutex was created (that is, if <code>name</code> is <code>null</code> or an empty string) or if the specified named system mutex was created; <code>false</code> if the specified named system mutex already existed. This parameter is passed uninitialized.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The named mutex exists and has access control security, but the user does not have <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">MutexRights</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a></div>\r\n                  </div>\r\n                  <p>A Win32 error occurred.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandlecannotbeopenedexception\" data-linktype=\"relative-path\">WaitHandleCannotBeOpenedException</a></div>\r\n                  </div>\r\n                  <p>The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is longer than 260 characters.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If <code>name</code> is not <code>null</code> and <code>initiallyOwned</code> is <code>true</code>, the calling thread owns the named mutex only if <code>createdNew</code> is <code>true</code> after the call. Otherwise the thread can request the mutex by calling the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a>method.  </p>\n<p> This constructor initializes a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> object that represents a named system mutex. You can create multiple <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> objects that represent the same named system mutex.  </p>\n<p> If the named mutex has already been created with access control security, and the caller does not have <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">System.Security.AccessControl.MutexRights</a> rights, an exception is thrown. To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_OpenExisting_\" data-linktype=\"relative-path\">OpenExisting</a> method.  </p>\n<p> If you specify <code>null</code> or an empty string for <code>name</code>, a local mutex is created, as if you had called the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex__ctor_System_Boolean_\" data-linktype=\"relative-path\">Mutex(Boolean)</a> constructor. In this case, <code>createdNew</code> is always <code>true</code>.  </p>\n<p> Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix &quot;Global\\&quot;, the mutex is visible in all terminal server sessions. If its name begins with the prefix &quot;Local\\&quot;, the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix &quot;Local\\&quot;. Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names &quot;Global\\&quot; and &quot;Local\\&quot; describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example shows how a named mutex is used to signal between processes or threads. Run this program from two or more command windows. Each process creates a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> object that represents the named mutex &quot;MyMutex&quot;. The named mutex is a system object. In this example, its lifetime is bounded by the lifetimes of the <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> objects that represent it. The named mutex is created when the first process creates its local <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> object, and destroyed when all the <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> objects that represent it have been released. The named mutex is initially owned by the first process. The second process and any subsequent processes wait for earlier processes to release the named mutex.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.Mutex 3Arg Ctor Example#1\">// This example shows how a named mutex is used to signal between\n// processes or threads.\n// Run this program from two (or more) command windows. Each process\n// creates a Mutex object that represents the named mutex &quot;MyMutex&quot;.\n// The named mutex is a system object whose lifetime is bounded by the\n// lifetimes of the Mutex objects that represent it. The named mutex\n// is created when the first process creates its local Mutex; in this\n// example, the named mutex is owned by the first process. The named \n// mutex is destroyed when all the Mutex objects that represent it\n// have been released. \n// The second process (and any subsequent process) waits for earlier\n// processes to release the named mutex.\n\nusing System;\nusing System.Threading;\n\npublic class Test\n{\n    public static void Main()\n    {\n        // Set this variable to false if you do not want to request \n        // initial ownership of the named mutex.\n        bool requestInitialOwnership = true;\n        bool mutexWasCreated;\n\n        // Request initial ownership of the named mutex by passing\n        // true for the first parameter. Only one system object named \n        // &quot;MyMutex&quot; can exist; the local Mutex object represents \n        // this system object. If &quot;MyMutex&quot; is created by this call,\n        // then mutexWasCreated contains true; otherwise, it contains\n        // false.\n        Mutex m = new Mutex(requestInitialOwnership, \n                            &quot;MyMutex&quot;, \n                            out mutexWasCreated);\n        \n        // This thread owns the mutex only if it both requested \n        // initial ownership and created the named mutex. Otherwise,\n        // it can request the named mutex by calling WaitOne.\n        if (!(requestInitialOwnership &amp;&amp; mutexWasCreated))\n        {\n            Console.WriteLine(&quot;Waiting for the named mutex.&quot;);\n            m.WaitOne();\n        }\n\n        // Once the process has gained control of the named mutex,\n        // hold onto it until the user presses ENTER.\n        Console.WriteLine(&quot;This process owns the named mutex. &quot; +\n            &quot;Press ENTER to release the mutex and exit.&quot;);\n        Console.ReadLine();\n\n        // Call ReleaseMutex to allow other threads to gain control\n        // of the named mutex. If you keep a reference to the local\n        // Mutex, you can call WaitOne to request control of the \n        // named mutex.\n        m.ReleaseMutex();\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Mutex 3Arg Ctor Example#1\">&#39; This example shows how a named mutex is used to signal between\n&#39; processes or threads.\n&#39; Run this program from two (or more) command windows. Each process\n&#39; creates a Mutex object that represents the named mutex &quot;MyMutex&quot;.\n&#39; The named mutex is a system object whose lifetime is bounded by the\n&#39; lifetimes of the Mutex objects that represent it. The named mutex\n&#39; is created when the first process creates its local Mutex; in this\n&#39; example, the named mutex is owned by the first process. The named \n&#39; mutex is destroyed when all the Mutex objects that represent it\n&#39; have been released. \n&#39; The second process (and any subsequent process) waits for earlier\n&#39; processes to release the named mutex.\n\nImports System\nImports System.Threading\n\nPublic Class Test\n   \n   &lt;MTAThread&gt; _\n   Public Shared Sub Main()\n      &#39; Set this variable to false if you do not want to request \n      &#39; initial ownership of the named mutex.\n      Dim requestInitialOwnership As Boolean = True\n      Dim mutexWasCreated As Boolean\n      \n      &#39; Request initial ownership of the named mutex by passing\n      &#39; true for the first parameter. Only one system object named \n      &#39; &quot;MyMutex&quot; can exist; the local Mutex object represents \n      &#39; this system object. If &quot;MyMutex&quot; is created by this call,\n      &#39; then mutexWasCreated contains true; otherwise, it contains\n      &#39; false.\n      Dim m As New Mutex(requestInitialOwnership, &quot;MyMutex&quot;, _\n          mutexWasCreated)\n      \n      &#39; This thread owns the mutex only if it both requested \n      &#39; initial ownership and created the named mutex. Otherwise,\n      &#39; it can request the named mutex by calling WaitOne.\n      If Not (requestInitialOwnership And mutexWasCreated) Then\n         Console.WriteLine(&quot;Waiting for the named mutex.&quot;)\n         m.WaitOne()\n      End If\n      \n      &#39; Once the process has gained control of the named mutex,\n      &#39; hold onto it until the user presses ENTER.\n      Console.WriteLine(&quot;This process owns the named mutex. &quot; _\n          &amp; &quot;Press ENTER to release the mutex and exit.&quot;)\n      Console.ReadLine()\n      \n      &#39; Call ReleaseMutex to allow other threads to gain control\n      &#39; of the named mutex. If you keep a reference to the local\n      &#39; Mutex, you can call WaitOne to request control of the \n      &#39; named mutex.\n      m.ReleaseMutex()\n   End Sub &#39;Main\nEnd Class &#39;Test\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.Mutex 3Arg Ctor Example#1\">// This example shows how a named mutex is used to signal between\n// processes or threads.\n// Run this program from two (or more) command windows. Each process\n// creates a Mutex object that represents the named mutex &quot;MyMutex&quot;.\n// The named mutex is a system object whose lifetime is bounded by the\n// lifetimes of the Mutex objects that represent it. The named mutex\n// is created when the first process creates its local Mutex; in this\n// example, the named mutex is owned by the first process. The named \n// mutex is destroyed when all the Mutex objects that represent it\n// have been released. \n// The second process (and any subsequent process) waits for earlier\n// processes to release the named mutex.\nusing namespace System;\nusing namespace System::Threading;\nint main()\n{\n   \n   // Set this variable to false if you do not want to request \n   // initial ownership of the named mutex.\n   bool requestInitialOwnership = true;\n   bool mutexWasCreated;\n   \n   // Request initial ownership of the named mutex by passing\n   // true for the first parameter. Only one system object named \n   // &quot;MyMutex&quot; can exist; the local Mutex object represents \n   // this system object. If &quot;MyMutex&quot; is created by this call,\n   // then mutexWasCreated contains true; otherwise, it contains\n   // false.\n   Mutex^ m = gcnew Mutex( requestInitialOwnership, &quot;MyMutex&quot;, mutexWasCreated );\n   \n   // This thread owns the mutex only if it both requested \n   // initial ownership and created the named mutex. Otherwise,\n   // it can request the named mutex by calling WaitOne.\n   if (  !(requestInitialOwnership &amp;&amp; mutexWasCreated) )\n   {\n      Console::WriteLine(  &quot;Waiting for the named mutex.&quot; );\n      m-&gt;WaitOne();\n   }\n\n   \n   // Once the process has gained control of the named mutex,\n   // hold onto it until the user presses ENTER.\n   Console::WriteLine(  &quot;This process owns the named mutex. &quot;\n    &quot;Press ENTER to release the mutex and exit.&quot; );\n   Console::ReadLine();\n   \n   // Call ReleaseMutex to allow other threads to gain control\n   // of the named mutex. If you keep a reference to the local\n   // Mutex, you can call WaitOne to request control of the \n   // named mutex.\n   m-&gt;ReleaseMutex();\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Mutex__ctor_System_Boolean_System_String_System_Boolean__System_Security_AccessControl_MutexSecurity_\">\r\n    \r\n            <a id=\"System_Threading_Mutex__ctor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Mutex(Boolean,String,Boolean,MutexSecurity)</div>        \r\n          </div>\r\n    \r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>initiallyOwned</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p><code>true</code> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of the system mutex. If the value is <code>null</code>, the <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> is unnamed.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>createdNew</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>When this method returns, contains a Boolean that is <code>true</code> if a local mutex was created (that is, if <code>name</code> is <code>null</code> or an empty string) or if the specified named system mutex was created; <code>false</code> if the specified named system mutex already existed. This parameter is passed uninitialized.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>mutexSecurity</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.accesscontrol.mutexsecurity\" data-linktype=\"relative-path\">MutexSecurity</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <a class=\"xref\" href=\"system.security.accesscontrol.mutexsecurity\" data-linktype=\"relative-path\">MutexSecurity</a> object that represents the access control security to be applied to the named system mutex.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a></div>\r\n                  </div>\r\n                  <p>A Win32 error occurred.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The named mutex exists and has access control security, but the user does not have <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">MutexRights</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandlecannotbeopenedexception\" data-linktype=\"relative-path\">WaitHandleCannotBeOpenedException</a></div>\r\n                  </div>\r\n                  <p>The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is longer than 260 characters.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If <code>name</code> is not <code>null</code> and <code>initiallyOwned</code> is <code>true</code>, the calling thread owns the named mutex only if <code>createdNew</code> is <code>true</code> after the call. Otherwise the thread can request the mutex by calling the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> method.  </p>\n<p> Use this constructor to apply access control security to a named system mutex when it is created, preventing other code from taking control of the mutex.  </p>\n<p> This constructor initializes a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> object that represents a named system mutex. You can create multiple <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> objects that represent the same named system mutex.  </p>\n<p> If the named system mutex does not exist, it is created with the specified access control security. If the named mutex exists, the specified access control security is ignored.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The caller has full control over the newly created <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> object even if <code>mutexSecurity</code> denies or fails to grant some access rights to the current user. However, if the current user attempts to get another <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> object to represent the same named mutex, using either a constructor or the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_OpenExisting_\" data-linktype=\"relative-path\">OpenExisting</a> method, Windows access control security is applied.  </p>\n</div>\n<p> If the named mutex has already been created with access control security, and the caller does not have <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">System.Security.AccessControl.MutexRights</a>, an exception is thrown. To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_OpenExisting_\" data-linktype=\"relative-path\">OpenExisting</a> method.  </p>\n<p> If you specify <code>null</code> or an empty string for <code>name</code>, a local mutex is created, as if you had called the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex__ctor_System_Boolean_\" data-linktype=\"relative-path\">Mutex(Boolean)</a> constructor. In this case, <code>createdNew</code> is always <code>true</code>.  </p>\n<p> Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> On a server that is running Terminal Services, a named system mutex can have two levels of visibility. If its name begins with the prefix &quot;Global\\&quot;, the mutex is visible in all terminal server sessions. If its name begins with the prefix &quot;Local\\&quot;, the mutex is visible only in the terminal server session where it was created. In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server. If you do not specify a prefix when you create a named mutex, it takes the prefix &quot;Local\\&quot;. Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session. That is, the prefix names &quot;Global\\&quot; and &quot;Local\\&quot; describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</p>\n</div>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates the cross-process behavior of a named mutex with access control security. The example uses the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a> method overload to test for the existence of a named mutex.  </p>\n<p> If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.  </p>\n<p> If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a>. The exception is caught, and the example uses the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_OpenExisting_System_String_System_Security_AccessControl_MutexRights_\" data-linktype=\"relative-path\">OpenExisting(String,MutexRights)</a> method overload to open the mutex with the rights needed to read and change the permissions.  </p>\n<p> After the permissions are changed, the mutex is opened with the rights required to enter and release it. If you run the compiled example from a third command window, it runs using the new permissions.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.Mutex.ctor named 4#1\">using System;\nusing System.Threading;\nusing System.Security.AccessControl;\n\ninternal class Example\n{\n    internal static void Main()\n    {\n        const string mutexName = &quot;MutexExample4&quot;;\n\n        Mutex m = null;\n        bool doesNotExist = false;\n        bool unauthorized = false;\n\n        // The value of this variable is set by the mutex\n        // constructor. It is true if the named system mutex was\n        // created, and false if the named mutex already existed.\n        //\n        bool mutexWasCreated = false;\n\n        // Attempt to open the named mutex.\n        try\n        {\n            // Open the mutex with (MutexRights.Synchronize |\n            // MutexRights.Modify), to enter and release the\n            // named mutex.\n            //\n            m = Mutex.OpenExisting(mutexName);\n        }\n        catch(WaitHandleCannotBeOpenedException)\n        {\n            Console.WriteLine(&quot;Mutex does not exist.&quot;);\n            doesNotExist = true;\n        }\n        catch(UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n            unauthorized = true;\n        }\n\n        // There are three cases: (1) The mutex does not exist.\n        // (2) The mutex exists, but the current user doesn&#39;t \n        // have access. (3) The mutex exists and the user has\n        // access.\n        //\n        if (doesNotExist)\n        {\n            // The mutex does not exist, so create it.\n\n            // Create an access control list (ACL) that denies the\n            // current user the right to enter or release the \n            // mutex, but allows the right to read and change\n            // security information for the mutex.\n            //\n            string user = Environment.UserDomainName + &quot;\\\\&quot;\n                + Environment.UserName;\n            MutexSecurity mSec = new MutexSecurity();\n\n            MutexAccessRule rule = new MutexAccessRule(user, \n                MutexRights.Synchronize | MutexRights.Modify, \n                AccessControlType.Deny);\n            mSec.AddAccessRule(rule);\n\n            rule = new MutexAccessRule(user, \n                MutexRights.ReadPermissions | MutexRights.ChangePermissions,\n                AccessControlType.Allow);\n            mSec.AddAccessRule(rule);\n\n            // Create a Mutex object that represents the system\n            // mutex named by the constant &#39;mutexName&#39;, with\n            // initial ownership for this thread, and with the\n            // specified security access. The Boolean value that \n            // indicates creation of the underlying system object\n            // is placed in mutexWasCreated.\n            //\n            m = new Mutex(true, mutexName, out mutexWasCreated, mSec);\n\n            // If the named system mutex was created, it can be\n            // used by the current instance of this program, even \n            // though the current user is denied access. The current\n            // program owns the mutex. Otherwise, exit the program.\n            // \n            if (mutexWasCreated)\n            {\n                Console.WriteLine(&quot;Created the mutex.&quot;);\n            }\n            else\n            {\n                Console.WriteLine(&quot;Unable to create the mutex.&quot;);\n                return;\n            }\n\n        }\n        else if (unauthorized)\n        {\n            // Open the mutex to read and change the access control\n            // security. The access control security defined above\n            // allows the current user to do this.\n            //\n            try\n            {\n                m = Mutex.OpenExisting(mutexName, \n                    MutexRights.ReadPermissions | MutexRights.ChangePermissions);\n\n                // Get the current ACL. This requires \n                // MutexRights.ReadPermissions.\n                MutexSecurity mSec = m.GetAccessControl();\n                \n                string user = Environment.UserDomainName + &quot;\\\\&quot;\n                    + Environment.UserName;\n\n                // First, the rule that denied the current user \n                // the right to enter and release the mutex must\n                // be removed.\n                MutexAccessRule rule = new MutexAccessRule(user, \n                     MutexRights.Synchronize | MutexRights.Modify,\n                     AccessControlType.Deny);\n                mSec.RemoveAccessRule(rule);\n\n                // Now grant the user the correct rights.\n                // \n                rule = new MutexAccessRule(user, \n                    MutexRights.Synchronize | MutexRights.Modify,\n                    AccessControlType.Allow);\n                mSec.AddAccessRule(rule);\n\n                // Update the ACL. This requires\n                // MutexRights.ChangePermissions.\n                m.SetAccessControl(mSec);\n\n                Console.WriteLine(&quot;Updated mutex security.&quot;);\n\n                // Open the mutex with (MutexRights.Synchronize \n                // | MutexRights.Modify), the rights required to\n                // enter and release the mutex.\n                //\n                m = Mutex.OpenExisting(mutexName);\n\n            }\n            catch(UnauthorizedAccessException ex)\n            {\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;,\n                    ex.Message);\n                return;\n            }\n\n        }\n\n        // If this program created the mutex, it already owns\n        // the mutex.\n        //\n        if (!mutexWasCreated)\n        {\n            // Enter the mutex, and hold it until the program\n            // exits.\n            //\n            try\n            {\n                Console.WriteLine(&quot;Wait for the mutex.&quot;);\n                m.WaitOne();\n                Console.WriteLine(&quot;Entered the mutex.&quot;);\n            }\n            catch(UnauthorizedAccessException ex)\n            {\n                Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n            }\n        }\n\n        Console.WriteLine(&quot;Press the Enter key to exit.&quot;);\n        Console.ReadLine();\n        m.ReleaseMutex();\n        m.Dispose();\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Mutex.ctor named 4#1\">Imports System\nImports System.Threading\nImports System.Security.AccessControl\n\nFriend Class Example\n\n    &lt;MTAThread&gt; _\n    Friend Shared Sub Main()\n        Const mutexName As String = &quot;MutexExample4&quot;\n\n        Dim m As Mutex = Nothing\n        Dim doesNotExist as Boolean = False\n        Dim unauthorized As Boolean = False\n\n        &#39; The value of this variable is set by the mutex\n        &#39; constructor. It is True if the named system mutex was\n        &#39; created, and False if the named mutex already existed.\n        &#39;\n        Dim mutexWasCreated As Boolean\n\n        &#39; Attempt to open the named mutex.\n        Try\n            &#39; Open the mutex with (MutexRights.Synchronize Or\n            &#39; MutexRights.Modify), to enter and release the\n            &#39; named mutex.\n            &#39;\n            m = Mutex.OpenExisting(mutexName)\n        Catch ex As WaitHandleCannotBeOpenedException\n            Console.WriteLine(&quot;Mutex does not exist.&quot;)\n            doesNotExist = True\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message)\n            unauthorized = True\n        End Try\n\n        &#39; There are three cases: (1) The mutex does not exist.\n        &#39; (2) The mutex exists, but the current user doesn&#39;t \n        &#39; have access. (3) The mutex exists and the user has\n        &#39; access.\n        &#39;\n        If doesNotExist Then\n            &#39; The mutex does not exist, so create it.\n\n            &#39; Create an access control list (ACL) that denies the\n            &#39; current user the right to enter or release the \n            &#39; mutex, but allows the right to read and change\n            &#39; security information for the mutex.\n            &#39;\n            Dim user As String = Environment.UserDomainName _ \n                &amp; &quot;\\&quot; &amp; Environment.UserName\n            Dim mSec As New MutexSecurity()\n\n            Dim rule As New MutexAccessRule(user, _\n                MutexRights.Synchronize Or MutexRights.Modify, _\n                AccessControlType.Deny)\n            mSec.AddAccessRule(rule)\n\n            rule = New MutexAccessRule(user, _\n                MutexRights.ReadPermissions Or _\n                MutexRights.ChangePermissions, _\n                AccessControlType.Allow)\n            mSec.AddAccessRule(rule)\n\n            &#39; Create a Mutex object that represents the system\n            &#39; mutex named by the constant &#39;mutexName&#39;, with\n            &#39; initial ownership for this thread, and with the\n            &#39; specified security access. The Boolean value that \n            &#39; indicates creation of the underlying system object\n            &#39; is placed in mutexWasCreated.\n            &#39;\n            m = New Mutex(True, mutexName, mutexWasCreated, mSec)\n\n            &#39; If the named system mutex was created, it can be\n            &#39; used by the current instance of this program, even \n            &#39; though the current user is denied access. The current\n            &#39; program owns the mutex. Otherwise, exit the program.\n            &#39; \n            If mutexWasCreated Then\n                Console.WriteLine(&quot;Created the mutex.&quot;)\n            Else\n                Console.WriteLine(&quot;Unable to create the mutex.&quot;)\n                Return\n            End If\n\n        ElseIf unauthorized Then\n\n            &#39; Open the mutex to read and change the access control\n            &#39; security. The access control security defined above\n            &#39; allows the current user to do this.\n            &#39;\n            Try\n                m = Mutex.OpenExisting(mutexName, _\n                    MutexRights.ReadPermissions Or _\n                    MutexRights.ChangePermissions)\n\n                &#39; Get the current ACL. This requires \n                &#39; MutexRights.ReadPermissions.\n                Dim mSec As MutexSecurity = m.GetAccessControl()\n                \n                Dim user As String = Environment.UserDomainName _ \n                    &amp; &quot;\\&quot; &amp; Environment.UserName\n\n                &#39; First, the rule that denied the current user \n                &#39; the right to enter and release the mutex must\n                &#39; be removed.\n                Dim rule As New MutexAccessRule(user, _\n                    MutexRights.Synchronize Or MutexRights.Modify, _\n                    AccessControlType.Deny)\n                mSec.RemoveAccessRule(rule)\n\n                &#39; Now grant the user the correct rights.\n                &#39; \n                rule = New MutexAccessRule(user, _\n                    MutexRights.Synchronize Or MutexRights.Modify, _\n                    AccessControlType.Allow)\n                mSec.AddAccessRule(rule)\n\n                &#39; Update the ACL. This requires\n                &#39; MutexRights.ChangePermissions.\n                m.SetAccessControl(mSec)\n\n                Console.WriteLine(&quot;Updated mutex security.&quot;)\n\n                &#39; Open the mutex with (MutexRights.Synchronize \n                &#39; Or MutexRights.Modify), the rights required to\n                &#39; enter and release the mutex.\n                &#39;\n                m = Mutex.OpenExisting(mutexName)\n\n            Catch ex As UnauthorizedAccessException\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;, _\n                    ex.Message)\n                Return\n            End Try\n\n        End If\n\n        &#39; If this program created the mutex, it already owns\n        &#39; the mutex.\n        &#39;\n        If Not mutexWasCreated Then\n            &#39; Enter the mutex, and hold it until the program\n            &#39; exits.\n            &#39;\n            Try\n                Console.WriteLine(&quot;Wait for the mutex.&quot;)\n                m.WaitOne()\n                Console.WriteLine(&quot;Entered the mutex.&quot;)\n            Catch ex As UnauthorizedAccessException\n                Console.WriteLine(&quot;Unauthorized access: {0}&quot;, _\n                    ex.Message)\n            End Try\n        End If\n\n        Console.WriteLine(&quot;Press the Enter key to exit.&quot;)\n        Console.ReadLine()\n        m.ReleaseMutex()\n        m.Dispose()\n    End Sub \nEnd Class \n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.Mutex.ctor named 4#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Security::AccessControl;\nusing namespace System::Security::Permissions;\n\npublic ref class Example\n{\npublic:\n   [SecurityPermissionAttribute(SecurityAction::Demand,Flags=SecurityPermissionFlag::UnmanagedCode)]\n   static void Main()\n   {\n      String^ mutexName = L&quot;MutexExample4&quot;;\n\n      Mutex^ m = nullptr;\n      bool doesNotExist = false;\n      bool unauthorized = false;\n      \n      // The value of this variable is set by the mutex\n      // constructor. It is true if the named system mutex was\n      // created, and false if the named mutex already existed.\n      //\n      bool mutexWasCreated = false;\n\n      // Attempt to open the named mutex.\n      try\n      {\n         // Open the mutex with (MutexRights.Synchronize |\n         // MutexRights.Modify), to enter and release the\n         // named mutex.\n         //\n         m = Mutex::OpenExisting( mutexName );\n      }\n      catch ( WaitHandleCannotBeOpenedException^ ) \n      {\n         Console::WriteLine( L&quot;Mutex does not exist.&quot; );\n         doesNotExist = true;\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n         unauthorized = true;\n      }\n\n      // There are three cases: (1) The mutex does not exist.\n      // (2) The mutex exists, but the current user doesn&#39;t\n      // have access. (3) The mutex exists and the user has\n      // access.\n      //\n      if ( doesNotExist )\n      {\n         // The mutex does not exist, so create it.\n         // Create an access control list (ACL) that denies the\n         // current user the right to enter or release the\n         // mutex, but allows the right to read and change\n         // security information for the mutex.\n         //\n         String^ user = String::Concat( Environment::UserDomainName, L&quot;\\\\&quot;,\n            Environment::UserName );\n         MutexSecurity^ mSec = gcnew MutexSecurity;\n\n         MutexAccessRule^ rule = gcnew MutexAccessRule( user,\n            static_cast&lt;MutexRights&gt;(\n               MutexRights::Synchronize |\n               MutexRights::Modify),\n            AccessControlType::Deny );\n         mSec-&gt;AddAccessRule( rule );\n\n         rule = gcnew MutexAccessRule( user,\n            static_cast&lt;MutexRights&gt;(\n               MutexRights::ReadPermissions |\n                MutexRights::ChangePermissions),\n            AccessControlType::Allow );\n         mSec-&gt;AddAccessRule( rule );\n         \n         // Create a Mutex object that represents the system\n         // mutex named by the constant &#39;mutexName&#39;, with\n         // initial ownership for this thread, and with the\n         // specified security access. The Boolean value that\n         // indicates creation of the underlying system object\n         // is placed in mutexWasCreated.\n         //\n         m = gcnew Mutex( true,mutexName, mutexWasCreated,mSec );\n         \n         // If the named system mutex was created, it can be\n         // used by the current instance of this program, even\n         // though the current user is denied access. The current\n         // program owns the mutex. Otherwise, exit the program.\n         //\n         if ( mutexWasCreated )\n         {\n            Console::WriteLine( L&quot;Created the mutex.&quot; );\n         }\n         else\n         {\n            Console::WriteLine( L&quot;Unable to create the mutex.&quot; );\n            return;\n         }\n      }\n      else if ( unauthorized )\n      {\n         // Open the mutex to read and change the access control\n         // security. The access control security defined above\n         // allows the current user to do this.\n         //\n         try\n         {\n            m = Mutex::OpenExisting( mutexName,\n               static_cast&lt;MutexRights&gt;(\n                  MutexRights::ReadPermissions |\n                  MutexRights::ChangePermissions) );\n            \n            // Get the current ACL. This requires\n            // MutexRights.ReadPermissions.\n            MutexSecurity^ mSec = m-&gt;GetAccessControl();\n\n            String^ user = String::Concat( Environment::UserDomainName,\n               L&quot;\\\\&quot;, Environment::UserName );\n            \n            // First, the rule that denied the current user\n            // the right to enter and release the mutex must\n            // be removed.\n            MutexAccessRule^ rule = gcnew MutexAccessRule( user,\n               static_cast&lt;MutexRights&gt;(\n                  MutexRights::Synchronize |\n                  MutexRights::Modify),\n               AccessControlType::Deny );\n            mSec-&gt;RemoveAccessRule( rule );\n            \n            // Now grant the user the correct rights.\n            //\n            rule = gcnew MutexAccessRule( user,\n               static_cast&lt;MutexRights&gt;(\n                  MutexRights::Synchronize |\n                  MutexRights::Modify),\n               AccessControlType::Allow );\n            mSec-&gt;AddAccessRule( rule );\n            \n            // Update the ACL. This requires\n            // MutexRights.ChangePermissions.\n            m-&gt;SetAccessControl( mSec );\n\n            Console::WriteLine( L&quot;Updated mutex security.&quot; );\n            \n            // Open the mutex with (MutexRights.Synchronize\n            // | MutexRights.Modify), the rights required to\n            // enter and release the mutex.\n            //\n            m = Mutex::OpenExisting( mutexName );\n         }\n         catch ( UnauthorizedAccessException^ ex ) \n         {\n            Console::WriteLine(\n               L&quot;Unable to change permissions: {0}&quot;, ex-&gt;Message );\n            return;\n         }\n      }\n      \n      // If this program created the mutex, it already owns\n      // the mutex.\n      //\n      if ( !mutexWasCreated )\n      {\n         // Enter the mutex, and hold it until the program\n         // exits.\n         //\n         try\n         {\n            Console::WriteLine( L&quot;Wait for the mutex.&quot; );\n            m-&gt;WaitOne();\n            Console::WriteLine( L&quot;Entered the mutex.&quot; );\n         }\n         catch ( UnauthorizedAccessException^ ex ) \n         {\n            Console::WriteLine( L&quot;Unauthorized access: {0}&quot;,\n               ex-&gt;Message );\n         }\n      }\n\n      Console::WriteLine( L&quot;Press the Enter key to exit.&quot; );\n      Console::ReadLine();\n      m-&gt;ReleaseMutex();\n      m-&gt;Dispose();\n   }\n};\n\nint main()\n{\n   Example::Main();\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"methods\">\r\n        <h2>Methods\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Mutex_GetAccessControl\">\r\n    \r\n            <a id=\"System_Threading_Mutex_GetAccessControl_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetAccessControl()</div>        \r\n          </div>\r\n    \r\n            <p>Gets a <a class=\"xref\" href=\"system.security.accesscontrol.mutexsecurity\" data-linktype=\"relative-path\">MutexSecurity</a> object that represents the access control security for the named mutex.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Security.AccessControl.MutexSecurity GetAccessControl ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.accesscontrol.mutexsecurity\" data-linktype=\"relative-path\">MutexSecurity</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"system.security.accesscontrol.mutexsecurity\" data-linktype=\"relative-path\">MutexSecurity</a> object that represents the access control security for the named mutex.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The current <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> object represents a named system mutex, but the user does not have <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">MutexRights</a>.  </p>\n<p> -or-  </p>\n<p> The current <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> object represents a named system mutex, and was not opened with <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">MutexRights</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>Not supported for Windows 98 or Windows Millennium Edition.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The GetAccessControl method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <a class=\"xref\" href=\"system.security.accesscontrol.accesscontrolsections\" data-linktype=\"relative-path\">System.Security.AccessControl.AccessControlSections</a>, <a class=\"xref\" href=\"system.security.accesscontrol.accesscontrolsections\" data-linktype=\"relative-path\">System.Security.AccessControl.AccessControlSections</a>, and <a class=\"xref\" href=\"system.security.accesscontrol.accesscontrolsections\" data-linktype=\"relative-path\">System.Security.AccessControl.AccessControlSections</a>.  </p>\n<p> The user must have <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">System.Security.AccessControl.MutexRights</a> to call this method, and the mutex must have been opened with <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">System.Security.AccessControl.MutexRights</a>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates the cross-process behavior of a named mutex with access control security. The example uses the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a> method overload to test for the existence of a named mutex.  </p>\n<p> If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.  </p>\n<p> If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a>. The exception is caught, and the example uses the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_OpenExisting_System_String_System_Security_AccessControl_MutexRights_\" data-linktype=\"relative-path\">OpenExisting(String,MutexRights)</a> method overload to open the mutex with the rights needed to read and change the permissions, using the GetAccessControl and <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_SetAccessControl_\" data-linktype=\"relative-path\">SetAccessControl</a> methods.  </p>\n<p> After the permissions are changed, the mutex is opened with the rights required to enter and release it. If you run the compiled example from a third command window, it runs using the new permissions.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.Mutex.ctor named 4#1\">using System;\nusing System.Threading;\nusing System.Security.AccessControl;\n\ninternal class Example\n{\n    internal static void Main()\n    {\n        const string mutexName = &quot;MutexExample4&quot;;\n\n        Mutex m = null;\n        bool doesNotExist = false;\n        bool unauthorized = false;\n\n        // The value of this variable is set by the mutex\n        // constructor. It is true if the named system mutex was\n        // created, and false if the named mutex already existed.\n        //\n        bool mutexWasCreated = false;\n\n        // Attempt to open the named mutex.\n        try\n        {\n            // Open the mutex with (MutexRights.Synchronize |\n            // MutexRights.Modify), to enter and release the\n            // named mutex.\n            //\n            m = Mutex.OpenExisting(mutexName);\n        }\n        catch(WaitHandleCannotBeOpenedException)\n        {\n            Console.WriteLine(&quot;Mutex does not exist.&quot;);\n            doesNotExist = true;\n        }\n        catch(UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n            unauthorized = true;\n        }\n\n        // There are three cases: (1) The mutex does not exist.\n        // (2) The mutex exists, but the current user doesn&#39;t \n        // have access. (3) The mutex exists and the user has\n        // access.\n        //\n        if (doesNotExist)\n        {\n            // The mutex does not exist, so create it.\n\n            // Create an access control list (ACL) that denies the\n            // current user the right to enter or release the \n            // mutex, but allows the right to read and change\n            // security information for the mutex.\n            //\n            string user = Environment.UserDomainName + &quot;\\\\&quot;\n                + Environment.UserName;\n            MutexSecurity mSec = new MutexSecurity();\n\n            MutexAccessRule rule = new MutexAccessRule(user, \n                MutexRights.Synchronize | MutexRights.Modify, \n                AccessControlType.Deny);\n            mSec.AddAccessRule(rule);\n\n            rule = new MutexAccessRule(user, \n                MutexRights.ReadPermissions | MutexRights.ChangePermissions,\n                AccessControlType.Allow);\n            mSec.AddAccessRule(rule);\n\n            // Create a Mutex object that represents the system\n            // mutex named by the constant &#39;mutexName&#39;, with\n            // initial ownership for this thread, and with the\n            // specified security access. The Boolean value that \n            // indicates creation of the underlying system object\n            // is placed in mutexWasCreated.\n            //\n            m = new Mutex(true, mutexName, out mutexWasCreated, mSec);\n\n            // If the named system mutex was created, it can be\n            // used by the current instance of this program, even \n            // though the current user is denied access. The current\n            // program owns the mutex. Otherwise, exit the program.\n            // \n            if (mutexWasCreated)\n            {\n                Console.WriteLine(&quot;Created the mutex.&quot;);\n            }\n            else\n            {\n                Console.WriteLine(&quot;Unable to create the mutex.&quot;);\n                return;\n            }\n\n        }\n        else if (unauthorized)\n        {\n            // Open the mutex to read and change the access control\n            // security. The access control security defined above\n            // allows the current user to do this.\n            //\n            try\n            {\n                m = Mutex.OpenExisting(mutexName, \n                    MutexRights.ReadPermissions | MutexRights.ChangePermissions);\n\n                // Get the current ACL. This requires \n                // MutexRights.ReadPermissions.\n                MutexSecurity mSec = m.GetAccessControl();\n                \n                string user = Environment.UserDomainName + &quot;\\\\&quot;\n                    + Environment.UserName;\n\n                // First, the rule that denied the current user \n                // the right to enter and release the mutex must\n                // be removed.\n                MutexAccessRule rule = new MutexAccessRule(user, \n                     MutexRights.Synchronize | MutexRights.Modify,\n                     AccessControlType.Deny);\n                mSec.RemoveAccessRule(rule);\n\n                // Now grant the user the correct rights.\n                // \n                rule = new MutexAccessRule(user, \n                    MutexRights.Synchronize | MutexRights.Modify,\n                    AccessControlType.Allow);\n                mSec.AddAccessRule(rule);\n\n                // Update the ACL. This requires\n                // MutexRights.ChangePermissions.\n                m.SetAccessControl(mSec);\n\n                Console.WriteLine(&quot;Updated mutex security.&quot;);\n\n                // Open the mutex with (MutexRights.Synchronize \n                // | MutexRights.Modify), the rights required to\n                // enter and release the mutex.\n                //\n                m = Mutex.OpenExisting(mutexName);\n\n            }\n            catch(UnauthorizedAccessException ex)\n            {\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;,\n                    ex.Message);\n                return;\n            }\n\n        }\n\n        // If this program created the mutex, it already owns\n        // the mutex.\n        //\n        if (!mutexWasCreated)\n        {\n            // Enter the mutex, and hold it until the program\n            // exits.\n            //\n            try\n            {\n                Console.WriteLine(&quot;Wait for the mutex.&quot;);\n                m.WaitOne();\n                Console.WriteLine(&quot;Entered the mutex.&quot;);\n            }\n            catch(UnauthorizedAccessException ex)\n            {\n                Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n            }\n        }\n\n        Console.WriteLine(&quot;Press the Enter key to exit.&quot;);\n        Console.ReadLine();\n        m.ReleaseMutex();\n        m.Dispose();\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Mutex.ctor named 4#1\">Imports System\nImports System.Threading\nImports System.Security.AccessControl\n\nFriend Class Example\n\n    &lt;MTAThread&gt; _\n    Friend Shared Sub Main()\n        Const mutexName As String = &quot;MutexExample4&quot;\n\n        Dim m As Mutex = Nothing\n        Dim doesNotExist as Boolean = False\n        Dim unauthorized As Boolean = False\n\n        &#39; The value of this variable is set by the mutex\n        &#39; constructor. It is True if the named system mutex was\n        &#39; created, and False if the named mutex already existed.\n        &#39;\n        Dim mutexWasCreated As Boolean\n\n        &#39; Attempt to open the named mutex.\n        Try\n            &#39; Open the mutex with (MutexRights.Synchronize Or\n            &#39; MutexRights.Modify), to enter and release the\n            &#39; named mutex.\n            &#39;\n            m = Mutex.OpenExisting(mutexName)\n        Catch ex As WaitHandleCannotBeOpenedException\n            Console.WriteLine(&quot;Mutex does not exist.&quot;)\n            doesNotExist = True\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message)\n            unauthorized = True\n        End Try\n\n        &#39; There are three cases: (1) The mutex does not exist.\n        &#39; (2) The mutex exists, but the current user doesn&#39;t \n        &#39; have access. (3) The mutex exists and the user has\n        &#39; access.\n        &#39;\n        If doesNotExist Then\n            &#39; The mutex does not exist, so create it.\n\n            &#39; Create an access control list (ACL) that denies the\n            &#39; current user the right to enter or release the \n            &#39; mutex, but allows the right to read and change\n            &#39; security information for the mutex.\n            &#39;\n            Dim user As String = Environment.UserDomainName _ \n                &amp; &quot;\\&quot; &amp; Environment.UserName\n            Dim mSec As New MutexSecurity()\n\n            Dim rule As New MutexAccessRule(user, _\n                MutexRights.Synchronize Or MutexRights.Modify, _\n                AccessControlType.Deny)\n            mSec.AddAccessRule(rule)\n\n            rule = New MutexAccessRule(user, _\n                MutexRights.ReadPermissions Or _\n                MutexRights.ChangePermissions, _\n                AccessControlType.Allow)\n            mSec.AddAccessRule(rule)\n\n            &#39; Create a Mutex object that represents the system\n            &#39; mutex named by the constant &#39;mutexName&#39;, with\n            &#39; initial ownership for this thread, and with the\n            &#39; specified security access. The Boolean value that \n            &#39; indicates creation of the underlying system object\n            &#39; is placed in mutexWasCreated.\n            &#39;\n            m = New Mutex(True, mutexName, mutexWasCreated, mSec)\n\n            &#39; If the named system mutex was created, it can be\n            &#39; used by the current instance of this program, even \n            &#39; though the current user is denied access. The current\n            &#39; program owns the mutex. Otherwise, exit the program.\n            &#39; \n            If mutexWasCreated Then\n                Console.WriteLine(&quot;Created the mutex.&quot;)\n            Else\n                Console.WriteLine(&quot;Unable to create the mutex.&quot;)\n                Return\n            End If\n\n        ElseIf unauthorized Then\n\n            &#39; Open the mutex to read and change the access control\n            &#39; security. The access control security defined above\n            &#39; allows the current user to do this.\n            &#39;\n            Try\n                m = Mutex.OpenExisting(mutexName, _\n                    MutexRights.ReadPermissions Or _\n                    MutexRights.ChangePermissions)\n\n                &#39; Get the current ACL. This requires \n                &#39; MutexRights.ReadPermissions.\n                Dim mSec As MutexSecurity = m.GetAccessControl()\n                \n                Dim user As String = Environment.UserDomainName _ \n                    &amp; &quot;\\&quot; &amp; Environment.UserName\n\n                &#39; First, the rule that denied the current user \n                &#39; the right to enter and release the mutex must\n                &#39; be removed.\n                Dim rule As New MutexAccessRule(user, _\n                    MutexRights.Synchronize Or MutexRights.Modify, _\n                    AccessControlType.Deny)\n                mSec.RemoveAccessRule(rule)\n\n                &#39; Now grant the user the correct rights.\n                &#39; \n                rule = New MutexAccessRule(user, _\n                    MutexRights.Synchronize Or MutexRights.Modify, _\n                    AccessControlType.Allow)\n                mSec.AddAccessRule(rule)\n\n                &#39; Update the ACL. This requires\n                &#39; MutexRights.ChangePermissions.\n                m.SetAccessControl(mSec)\n\n                Console.WriteLine(&quot;Updated mutex security.&quot;)\n\n                &#39; Open the mutex with (MutexRights.Synchronize \n                &#39; Or MutexRights.Modify), the rights required to\n                &#39; enter and release the mutex.\n                &#39;\n                m = Mutex.OpenExisting(mutexName)\n\n            Catch ex As UnauthorizedAccessException\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;, _\n                    ex.Message)\n                Return\n            End Try\n\n        End If\n\n        &#39; If this program created the mutex, it already owns\n        &#39; the mutex.\n        &#39;\n        If Not mutexWasCreated Then\n            &#39; Enter the mutex, and hold it until the program\n            &#39; exits.\n            &#39;\n            Try\n                Console.WriteLine(&quot;Wait for the mutex.&quot;)\n                m.WaitOne()\n                Console.WriteLine(&quot;Entered the mutex.&quot;)\n            Catch ex As UnauthorizedAccessException\n                Console.WriteLine(&quot;Unauthorized access: {0}&quot;, _\n                    ex.Message)\n            End Try\n        End If\n\n        Console.WriteLine(&quot;Press the Enter key to exit.&quot;)\n        Console.ReadLine()\n        m.ReleaseMutex()\n        m.Dispose()\n    End Sub \nEnd Class \n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.Mutex.ctor named 4#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Security::AccessControl;\nusing namespace System::Security::Permissions;\n\npublic ref class Example\n{\npublic:\n   [SecurityPermissionAttribute(SecurityAction::Demand,Flags=SecurityPermissionFlag::UnmanagedCode)]\n   static void Main()\n   {\n      String^ mutexName = L&quot;MutexExample4&quot;;\n\n      Mutex^ m = nullptr;\n      bool doesNotExist = false;\n      bool unauthorized = false;\n      \n      // The value of this variable is set by the mutex\n      // constructor. It is true if the named system mutex was\n      // created, and false if the named mutex already existed.\n      //\n      bool mutexWasCreated = false;\n\n      // Attempt to open the named mutex.\n      try\n      {\n         // Open the mutex with (MutexRights.Synchronize |\n         // MutexRights.Modify), to enter and release the\n         // named mutex.\n         //\n         m = Mutex::OpenExisting( mutexName );\n      }\n      catch ( WaitHandleCannotBeOpenedException^ ) \n      {\n         Console::WriteLine( L&quot;Mutex does not exist.&quot; );\n         doesNotExist = true;\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n         unauthorized = true;\n      }\n\n      // There are three cases: (1) The mutex does not exist.\n      // (2) The mutex exists, but the current user doesn&#39;t\n      // have access. (3) The mutex exists and the user has\n      // access.\n      //\n      if ( doesNotExist )\n      {\n         // The mutex does not exist, so create it.\n         // Create an access control list (ACL) that denies the\n         // current user the right to enter or release the\n         // mutex, but allows the right to read and change\n         // security information for the mutex.\n         //\n         String^ user = String::Concat( Environment::UserDomainName, L&quot;\\\\&quot;,\n            Environment::UserName );\n         MutexSecurity^ mSec = gcnew MutexSecurity;\n\n         MutexAccessRule^ rule = gcnew MutexAccessRule( user,\n            static_cast&lt;MutexRights&gt;(\n               MutexRights::Synchronize |\n               MutexRights::Modify),\n            AccessControlType::Deny );\n         mSec-&gt;AddAccessRule( rule );\n\n         rule = gcnew MutexAccessRule( user,\n            static_cast&lt;MutexRights&gt;(\n               MutexRights::ReadPermissions |\n                MutexRights::ChangePermissions),\n            AccessControlType::Allow );\n         mSec-&gt;AddAccessRule( rule );\n         \n         // Create a Mutex object that represents the system\n         // mutex named by the constant &#39;mutexName&#39;, with\n         // initial ownership for this thread, and with the\n         // specified security access. The Boolean value that\n         // indicates creation of the underlying system object\n         // is placed in mutexWasCreated.\n         //\n         m = gcnew Mutex( true,mutexName, mutexWasCreated,mSec );\n         \n         // If the named system mutex was created, it can be\n         // used by the current instance of this program, even\n         // though the current user is denied access. The current\n         // program owns the mutex. Otherwise, exit the program.\n         //\n         if ( mutexWasCreated )\n         {\n            Console::WriteLine( L&quot;Created the mutex.&quot; );\n         }\n         else\n         {\n            Console::WriteLine( L&quot;Unable to create the mutex.&quot; );\n            return;\n         }\n      }\n      else if ( unauthorized )\n      {\n         // Open the mutex to read and change the access control\n         // security. The access control security defined above\n         // allows the current user to do this.\n         //\n         try\n         {\n            m = Mutex::OpenExisting( mutexName,\n               static_cast&lt;MutexRights&gt;(\n                  MutexRights::ReadPermissions |\n                  MutexRights::ChangePermissions) );\n            \n            // Get the current ACL. This requires\n            // MutexRights.ReadPermissions.\n            MutexSecurity^ mSec = m-&gt;GetAccessControl();\n\n            String^ user = String::Concat( Environment::UserDomainName,\n               L&quot;\\\\&quot;, Environment::UserName );\n            \n            // First, the rule that denied the current user\n            // the right to enter and release the mutex must\n            // be removed.\n            MutexAccessRule^ rule = gcnew MutexAccessRule( user,\n               static_cast&lt;MutexRights&gt;(\n                  MutexRights::Synchronize |\n                  MutexRights::Modify),\n               AccessControlType::Deny );\n            mSec-&gt;RemoveAccessRule( rule );\n            \n            // Now grant the user the correct rights.\n            //\n            rule = gcnew MutexAccessRule( user,\n               static_cast&lt;MutexRights&gt;(\n                  MutexRights::Synchronize |\n                  MutexRights::Modify),\n               AccessControlType::Allow );\n            mSec-&gt;AddAccessRule( rule );\n            \n            // Update the ACL. This requires\n            // MutexRights.ChangePermissions.\n            m-&gt;SetAccessControl( mSec );\n\n            Console::WriteLine( L&quot;Updated mutex security.&quot; );\n            \n            // Open the mutex with (MutexRights.Synchronize\n            // | MutexRights.Modify), the rights required to\n            // enter and release the mutex.\n            //\n            m = Mutex::OpenExisting( mutexName );\n         }\n         catch ( UnauthorizedAccessException^ ex ) \n         {\n            Console::WriteLine(\n               L&quot;Unable to change permissions: {0}&quot;, ex-&gt;Message );\n            return;\n         }\n      }\n      \n      // If this program created the mutex, it already owns\n      // the mutex.\n      //\n      if ( !mutexWasCreated )\n      {\n         // Enter the mutex, and hold it until the program\n         // exits.\n         //\n         try\n         {\n            Console::WriteLine( L&quot;Wait for the mutex.&quot; );\n            m-&gt;WaitOne();\n            Console::WriteLine( L&quot;Entered the mutex.&quot; );\n         }\n         catch ( UnauthorizedAccessException^ ex ) \n         {\n            Console::WriteLine( L&quot;Unauthorized access: {0}&quot;,\n               ex-&gt;Message );\n         }\n      }\n\n      Console::WriteLine( L&quot;Press the Enter key to exit.&quot; );\n      Console::ReadLine();\n      m-&gt;ReleaseMutex();\n      m-&gt;Dispose();\n   }\n};\n\nint main()\n{\n   Example::Main();\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Mutex_OpenExisting_System_String_\">\r\n    \r\n            <a id=\"System_Threading_Mutex_OpenExisting_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">OpenExisting(String)</div>        \r\n          </div>\r\n    \r\n            <p>Opens the specified named mutex, if it already exists.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Threading.Mutex OpenExisting (string name);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of the system mutex to open.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a></div>\r\n                  </div>\r\n                  <p>An object that represents the named system mutex.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is an empty string.  </p>\n<p> -or-  </p>\n<p> <code>name</code> is longer than 260 characters.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandlecannotbeopenedexception\" data-linktype=\"relative-path\">WaitHandleCannotBeOpenedException</a></div>\r\n                  </div>\r\n                  <p>The named mutex does not exist.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a></div>\r\n                  </div>\r\n                  <p>A Win32 error occurred.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The named mutex exists, but the user does not have the security access required to use it.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_OpenExisting_\" data-linktype=\"relative-path\">OpenExisting</a> method tries to open the specified named system mutex. If the system mutex does not exist, this method throws an exception instead of creating the system object. To create the system mutex when it does not already exist, use one of the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex__ctor_\" data-linktype=\"relative-path\">Mutex</a> constructors that has a <code>name</code> parameter.  </p>\n<p> Multiple calls to this method that use the same value for <code>name</code> do not necessarily return the same <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> object, even though the objects that are returned represent the same named system mutex.  </p>\n<p> This method overload is equivalent to calling the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_OpenExisting_System_String_System_Security_AccessControl_MutexRights_\" data-linktype=\"relative-path\">OpenExisting(String,MutexRights)</a> method overload and specifying <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">System.Security.AccessControl.MutexRights</a> and <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">System.Security.AccessControl.MutexRights</a> rights, combined by using the bitwise OR operation.  </p>\n<p> Specifying the <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">System.Security.AccessControl.MutexRights</a> flag allows a thread to wait on the mutex, and specifying the <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">System.Security.AccessControl.MutexRights</a> flag allows a thread to call the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_ReleaseMutex_\" data-linktype=\"relative-path\">ReleaseMutex</a> method.  </p>\n<p> This method does not request ownership of the mutex.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates the cross-process behavior of a named mutex with access control security. The example uses the OpenExisting method overload to test for the existence of a named mutex.  </p>\n<p> If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.  </p>\n<p> If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to OpenExisting. The exception is caught, and the example uses the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_OpenExisting_System_String_System_Security_AccessControl_MutexRights_\" data-linktype=\"relative-path\">OpenExisting(String,MutexRights)</a> method overload to open the mutex with the rights needed to read and change the permissions.  </p>\n<p> After the permissions are changed, the mutex is opened with the rights required to enter and release it. If you run the compiled example from a third command window, it runs using the new permissions.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.Mutex.ctor named 4#1\">using System;\nusing System.Threading;\nusing System.Security.AccessControl;\n\ninternal class Example\n{\n    internal static void Main()\n    {\n        const string mutexName = &quot;MutexExample4&quot;;\n\n        Mutex m = null;\n        bool doesNotExist = false;\n        bool unauthorized = false;\n\n        // The value of this variable is set by the mutex\n        // constructor. It is true if the named system mutex was\n        // created, and false if the named mutex already existed.\n        //\n        bool mutexWasCreated = false;\n\n        // Attempt to open the named mutex.\n        try\n        {\n            // Open the mutex with (MutexRights.Synchronize |\n            // MutexRights.Modify), to enter and release the\n            // named mutex.\n            //\n            m = Mutex.OpenExisting(mutexName);\n        }\n        catch(WaitHandleCannotBeOpenedException)\n        {\n            Console.WriteLine(&quot;Mutex does not exist.&quot;);\n            doesNotExist = true;\n        }\n        catch(UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n            unauthorized = true;\n        }\n\n        // There are three cases: (1) The mutex does not exist.\n        // (2) The mutex exists, but the current user doesn&#39;t \n        // have access. (3) The mutex exists and the user has\n        // access.\n        //\n        if (doesNotExist)\n        {\n            // The mutex does not exist, so create it.\n\n            // Create an access control list (ACL) that denies the\n            // current user the right to enter or release the \n            // mutex, but allows the right to read and change\n            // security information for the mutex.\n            //\n            string user = Environment.UserDomainName + &quot;\\\\&quot;\n                + Environment.UserName;\n            MutexSecurity mSec = new MutexSecurity();\n\n            MutexAccessRule rule = new MutexAccessRule(user, \n                MutexRights.Synchronize | MutexRights.Modify, \n                AccessControlType.Deny);\n            mSec.AddAccessRule(rule);\n\n            rule = new MutexAccessRule(user, \n                MutexRights.ReadPermissions | MutexRights.ChangePermissions,\n                AccessControlType.Allow);\n            mSec.AddAccessRule(rule);\n\n            // Create a Mutex object that represents the system\n            // mutex named by the constant &#39;mutexName&#39;, with\n            // initial ownership for this thread, and with the\n            // specified security access. The Boolean value that \n            // indicates creation of the underlying system object\n            // is placed in mutexWasCreated.\n            //\n            m = new Mutex(true, mutexName, out mutexWasCreated, mSec);\n\n            // If the named system mutex was created, it can be\n            // used by the current instance of this program, even \n            // though the current user is denied access. The current\n            // program owns the mutex. Otherwise, exit the program.\n            // \n            if (mutexWasCreated)\n            {\n                Console.WriteLine(&quot;Created the mutex.&quot;);\n            }\n            else\n            {\n                Console.WriteLine(&quot;Unable to create the mutex.&quot;);\n                return;\n            }\n\n        }\n        else if (unauthorized)\n        {\n            // Open the mutex to read and change the access control\n            // security. The access control security defined above\n            // allows the current user to do this.\n            //\n            try\n            {\n                m = Mutex.OpenExisting(mutexName, \n                    MutexRights.ReadPermissions | MutexRights.ChangePermissions);\n\n                // Get the current ACL. This requires \n                // MutexRights.ReadPermissions.\n                MutexSecurity mSec = m.GetAccessControl();\n                \n                string user = Environment.UserDomainName + &quot;\\\\&quot;\n                    + Environment.UserName;\n\n                // First, the rule that denied the current user \n                // the right to enter and release the mutex must\n                // be removed.\n                MutexAccessRule rule = new MutexAccessRule(user, \n                     MutexRights.Synchronize | MutexRights.Modify,\n                     AccessControlType.Deny);\n                mSec.RemoveAccessRule(rule);\n\n                // Now grant the user the correct rights.\n                // \n                rule = new MutexAccessRule(user, \n                    MutexRights.Synchronize | MutexRights.Modify,\n                    AccessControlType.Allow);\n                mSec.AddAccessRule(rule);\n\n                // Update the ACL. This requires\n                // MutexRights.ChangePermissions.\n                m.SetAccessControl(mSec);\n\n                Console.WriteLine(&quot;Updated mutex security.&quot;);\n\n                // Open the mutex with (MutexRights.Synchronize \n                // | MutexRights.Modify), the rights required to\n                // enter and release the mutex.\n                //\n                m = Mutex.OpenExisting(mutexName);\n\n            }\n            catch(UnauthorizedAccessException ex)\n            {\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;,\n                    ex.Message);\n                return;\n            }\n\n        }\n\n        // If this program created the mutex, it already owns\n        // the mutex.\n        //\n        if (!mutexWasCreated)\n        {\n            // Enter the mutex, and hold it until the program\n            // exits.\n            //\n            try\n            {\n                Console.WriteLine(&quot;Wait for the mutex.&quot;);\n                m.WaitOne();\n                Console.WriteLine(&quot;Entered the mutex.&quot;);\n            }\n            catch(UnauthorizedAccessException ex)\n            {\n                Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n            }\n        }\n\n        Console.WriteLine(&quot;Press the Enter key to exit.&quot;);\n        Console.ReadLine();\n        m.ReleaseMutex();\n        m.Dispose();\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Mutex.ctor named 4#1\">Imports System\nImports System.Threading\nImports System.Security.AccessControl\n\nFriend Class Example\n\n    &lt;MTAThread&gt; _\n    Friend Shared Sub Main()\n        Const mutexName As String = &quot;MutexExample4&quot;\n\n        Dim m As Mutex = Nothing\n        Dim doesNotExist as Boolean = False\n        Dim unauthorized As Boolean = False\n\n        &#39; The value of this variable is set by the mutex\n        &#39; constructor. It is True if the named system mutex was\n        &#39; created, and False if the named mutex already existed.\n        &#39;\n        Dim mutexWasCreated As Boolean\n\n        &#39; Attempt to open the named mutex.\n        Try\n            &#39; Open the mutex with (MutexRights.Synchronize Or\n            &#39; MutexRights.Modify), to enter and release the\n            &#39; named mutex.\n            &#39;\n            m = Mutex.OpenExisting(mutexName)\n        Catch ex As WaitHandleCannotBeOpenedException\n            Console.WriteLine(&quot;Mutex does not exist.&quot;)\n            doesNotExist = True\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message)\n            unauthorized = True\n        End Try\n\n        &#39; There are three cases: (1) The mutex does not exist.\n        &#39; (2) The mutex exists, but the current user doesn&#39;t \n        &#39; have access. (3) The mutex exists and the user has\n        &#39; access.\n        &#39;\n        If doesNotExist Then\n            &#39; The mutex does not exist, so create it.\n\n            &#39; Create an access control list (ACL) that denies the\n            &#39; current user the right to enter or release the \n            &#39; mutex, but allows the right to read and change\n            &#39; security information for the mutex.\n            &#39;\n            Dim user As String = Environment.UserDomainName _ \n                &amp; &quot;\\&quot; &amp; Environment.UserName\n            Dim mSec As New MutexSecurity()\n\n            Dim rule As New MutexAccessRule(user, _\n                MutexRights.Synchronize Or MutexRights.Modify, _\n                AccessControlType.Deny)\n            mSec.AddAccessRule(rule)\n\n            rule = New MutexAccessRule(user, _\n                MutexRights.ReadPermissions Or _\n                MutexRights.ChangePermissions, _\n                AccessControlType.Allow)\n            mSec.AddAccessRule(rule)\n\n            &#39; Create a Mutex object that represents the system\n            &#39; mutex named by the constant &#39;mutexName&#39;, with\n            &#39; initial ownership for this thread, and with the\n            &#39; specified security access. The Boolean value that \n            &#39; indicates creation of the underlying system object\n            &#39; is placed in mutexWasCreated.\n            &#39;\n            m = New Mutex(True, mutexName, mutexWasCreated, mSec)\n\n            &#39; If the named system mutex was created, it can be\n            &#39; used by the current instance of this program, even \n            &#39; though the current user is denied access. The current\n            &#39; program owns the mutex. Otherwise, exit the program.\n            &#39; \n            If mutexWasCreated Then\n                Console.WriteLine(&quot;Created the mutex.&quot;)\n            Else\n                Console.WriteLine(&quot;Unable to create the mutex.&quot;)\n                Return\n            End If\n\n        ElseIf unauthorized Then\n\n            &#39; Open the mutex to read and change the access control\n            &#39; security. The access control security defined above\n            &#39; allows the current user to do this.\n            &#39;\n            Try\n                m = Mutex.OpenExisting(mutexName, _\n                    MutexRights.ReadPermissions Or _\n                    MutexRights.ChangePermissions)\n\n                &#39; Get the current ACL. This requires \n                &#39; MutexRights.ReadPermissions.\n                Dim mSec As MutexSecurity = m.GetAccessControl()\n                \n                Dim user As String = Environment.UserDomainName _ \n                    &amp; &quot;\\&quot; &amp; Environment.UserName\n\n                &#39; First, the rule that denied the current user \n                &#39; the right to enter and release the mutex must\n                &#39; be removed.\n                Dim rule As New MutexAccessRule(user, _\n                    MutexRights.Synchronize Or MutexRights.Modify, _\n                    AccessControlType.Deny)\n                mSec.RemoveAccessRule(rule)\n\n                &#39; Now grant the user the correct rights.\n                &#39; \n                rule = New MutexAccessRule(user, _\n                    MutexRights.Synchronize Or MutexRights.Modify, _\n                    AccessControlType.Allow)\n                mSec.AddAccessRule(rule)\n\n                &#39; Update the ACL. This requires\n                &#39; MutexRights.ChangePermissions.\n                m.SetAccessControl(mSec)\n\n                Console.WriteLine(&quot;Updated mutex security.&quot;)\n\n                &#39; Open the mutex with (MutexRights.Synchronize \n                &#39; Or MutexRights.Modify), the rights required to\n                &#39; enter and release the mutex.\n                &#39;\n                m = Mutex.OpenExisting(mutexName)\n\n            Catch ex As UnauthorizedAccessException\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;, _\n                    ex.Message)\n                Return\n            End Try\n\n        End If\n\n        &#39; If this program created the mutex, it already owns\n        &#39; the mutex.\n        &#39;\n        If Not mutexWasCreated Then\n            &#39; Enter the mutex, and hold it until the program\n            &#39; exits.\n            &#39;\n            Try\n                Console.WriteLine(&quot;Wait for the mutex.&quot;)\n                m.WaitOne()\n                Console.WriteLine(&quot;Entered the mutex.&quot;)\n            Catch ex As UnauthorizedAccessException\n                Console.WriteLine(&quot;Unauthorized access: {0}&quot;, _\n                    ex.Message)\n            End Try\n        End If\n\n        Console.WriteLine(&quot;Press the Enter key to exit.&quot;)\n        Console.ReadLine()\n        m.ReleaseMutex()\n        m.Dispose()\n    End Sub \nEnd Class \n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.Mutex.ctor named 4#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Security::AccessControl;\nusing namespace System::Security::Permissions;\n\npublic ref class Example\n{\npublic:\n   [SecurityPermissionAttribute(SecurityAction::Demand,Flags=SecurityPermissionFlag::UnmanagedCode)]\n   static void Main()\n   {\n      String^ mutexName = L&quot;MutexExample4&quot;;\n\n      Mutex^ m = nullptr;\n      bool doesNotExist = false;\n      bool unauthorized = false;\n      \n      // The value of this variable is set by the mutex\n      // constructor. It is true if the named system mutex was\n      // created, and false if the named mutex already existed.\n      //\n      bool mutexWasCreated = false;\n\n      // Attempt to open the named mutex.\n      try\n      {\n         // Open the mutex with (MutexRights.Synchronize |\n         // MutexRights.Modify), to enter and release the\n         // named mutex.\n         //\n         m = Mutex::OpenExisting( mutexName );\n      }\n      catch ( WaitHandleCannotBeOpenedException^ ) \n      {\n         Console::WriteLine( L&quot;Mutex does not exist.&quot; );\n         doesNotExist = true;\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n         unauthorized = true;\n      }\n\n      // There are three cases: (1) The mutex does not exist.\n      // (2) The mutex exists, but the current user doesn&#39;t\n      // have access. (3) The mutex exists and the user has\n      // access.\n      //\n      if ( doesNotExist )\n      {\n         // The mutex does not exist, so create it.\n         // Create an access control list (ACL) that denies the\n         // current user the right to enter or release the\n         // mutex, but allows the right to read and change\n         // security information for the mutex.\n         //\n         String^ user = String::Concat( Environment::UserDomainName, L&quot;\\\\&quot;,\n            Environment::UserName );\n         MutexSecurity^ mSec = gcnew MutexSecurity;\n\n         MutexAccessRule^ rule = gcnew MutexAccessRule( user,\n            static_cast&lt;MutexRights&gt;(\n               MutexRights::Synchronize |\n               MutexRights::Modify),\n            AccessControlType::Deny );\n         mSec-&gt;AddAccessRule( rule );\n\n         rule = gcnew MutexAccessRule( user,\n            static_cast&lt;MutexRights&gt;(\n               MutexRights::ReadPermissions |\n                MutexRights::ChangePermissions),\n            AccessControlType::Allow );\n         mSec-&gt;AddAccessRule( rule );\n         \n         // Create a Mutex object that represents the system\n         // mutex named by the constant &#39;mutexName&#39;, with\n         // initial ownership for this thread, and with the\n         // specified security access. The Boolean value that\n         // indicates creation of the underlying system object\n         // is placed in mutexWasCreated.\n         //\n         m = gcnew Mutex( true,mutexName, mutexWasCreated,mSec );\n         \n         // If the named system mutex was created, it can be\n         // used by the current instance of this program, even\n         // though the current user is denied access. The current\n         // program owns the mutex. Otherwise, exit the program.\n         //\n         if ( mutexWasCreated )\n         {\n            Console::WriteLine( L&quot;Created the mutex.&quot; );\n         }\n         else\n         {\n            Console::WriteLine( L&quot;Unable to create the mutex.&quot; );\n            return;\n         }\n      }\n      else if ( unauthorized )\n      {\n         // Open the mutex to read and change the access control\n         // security. The access control security defined above\n         // allows the current user to do this.\n         //\n         try\n         {\n            m = Mutex::OpenExisting( mutexName,\n               static_cast&lt;MutexRights&gt;(\n                  MutexRights::ReadPermissions |\n                  MutexRights::ChangePermissions) );\n            \n            // Get the current ACL. This requires\n            // MutexRights.ReadPermissions.\n            MutexSecurity^ mSec = m-&gt;GetAccessControl();\n\n            String^ user = String::Concat( Environment::UserDomainName,\n               L&quot;\\\\&quot;, Environment::UserName );\n            \n            // First, the rule that denied the current user\n            // the right to enter and release the mutex must\n            // be removed.\n            MutexAccessRule^ rule = gcnew MutexAccessRule( user,\n               static_cast&lt;MutexRights&gt;(\n                  MutexRights::Synchronize |\n                  MutexRights::Modify),\n               AccessControlType::Deny );\n            mSec-&gt;RemoveAccessRule( rule );\n            \n            // Now grant the user the correct rights.\n            //\n            rule = gcnew MutexAccessRule( user,\n               static_cast&lt;MutexRights&gt;(\n                  MutexRights::Synchronize |\n                  MutexRights::Modify),\n               AccessControlType::Allow );\n            mSec-&gt;AddAccessRule( rule );\n            \n            // Update the ACL. This requires\n            // MutexRights.ChangePermissions.\n            m-&gt;SetAccessControl( mSec );\n\n            Console::WriteLine( L&quot;Updated mutex security.&quot; );\n            \n            // Open the mutex with (MutexRights.Synchronize\n            // | MutexRights.Modify), the rights required to\n            // enter and release the mutex.\n            //\n            m = Mutex::OpenExisting( mutexName );\n         }\n         catch ( UnauthorizedAccessException^ ex ) \n         {\n            Console::WriteLine(\n               L&quot;Unable to change permissions: {0}&quot;, ex-&gt;Message );\n            return;\n         }\n      }\n      \n      // If this program created the mutex, it already owns\n      // the mutex.\n      //\n      if ( !mutexWasCreated )\n      {\n         // Enter the mutex, and hold it until the program\n         // exits.\n         //\n         try\n         {\n            Console::WriteLine( L&quot;Wait for the mutex.&quot; );\n            m-&gt;WaitOne();\n            Console::WriteLine( L&quot;Entered the mutex.&quot; );\n         }\n         catch ( UnauthorizedAccessException^ ex ) \n         {\n            Console::WriteLine( L&quot;Unauthorized access: {0}&quot;,\n               ex-&gt;Message );\n         }\n      }\n\n      Console::WriteLine( L&quot;Press the Enter key to exit.&quot; );\n      Console::ReadLine();\n      m-&gt;ReleaseMutex();\n      m-&gt;Dispose();\n   }\n};\n\nint main()\n{\n   Example::Main();\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Mutex_OpenExisting_System_String_System_Security_AccessControl_MutexRights_\">\r\n    \r\n            <a id=\"System_Threading_Mutex_OpenExisting_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">OpenExisting(String,MutexRights)</div>        \r\n          </div>\r\n    \r\n            <p>Opens the specified named mutex, if it already exists, with the desired security access.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of the system mutex to open.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>rights</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">MutexRights</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitwise combination of the enumeration values that represent the desired security access.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a></div>\r\n                  </div>\r\n                  <p>An object that represents the named system mutex.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is an empty string.  </p>\n<p> -or-  </p>\n<p> <code>name</code> is longer than 260 characters.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandlecannotbeopenedexception\" data-linktype=\"relative-path\">WaitHandleCannotBeOpenedException</a></div>\r\n                  </div>\r\n                  <p>The named mutex does not exist.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a></div>\r\n                  </div>\r\n                  <p>A Win32 error occurred.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The named mutex exists, but the user does not have the desired security access.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <code>rights</code> parameter must include the <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">System.Security.AccessControl.MutexRights</a> flag to allow threads to wait on the mutex, and the <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">System.Security.AccessControl.MutexRights</a> flag to allow threads to call the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_ReleaseMutex_\" data-linktype=\"relative-path\">ReleaseMutex</a> method.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_OpenExisting_\" data-linktype=\"relative-path\">OpenExisting</a> method tries to open an existing named mutex. If the system mutex does not exist, this method throws an exception instead of creating the system object. To create the system mutex when it does not already exist, use one of the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex__ctor_\" data-linktype=\"relative-path\">Mutex</a> constructors that has a <code>name</code> parameter.  </p>\n<p> Multiple calls to this method that use the same value for <code>name</code> do not necessarily return the same <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> object, even though the objects that are returned represent the same named system mutex.  </p>\n<p> This method does not request ownership of the mutex.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates the cross-process behavior of a named mutex with access control security. The example uses the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a> method overload to test for the existence of a named mutex.  </p>\n<p> If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.  </p>\n<p> If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a>. The exception is caught, and the example uses the OpenExisting method overload to open the mutex with the rights needed to read and change the permissions.  </p>\n<p> After the permissions are changed, the mutex is opened with the rights required to enter and release it. If you run the compiled example from a third command window, it runs using the new permissions.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.Mutex.ctor named 4#1\">using System;\nusing System.Threading;\nusing System.Security.AccessControl;\n\ninternal class Example\n{\n    internal static void Main()\n    {\n        const string mutexName = &quot;MutexExample4&quot;;\n\n        Mutex m = null;\n        bool doesNotExist = false;\n        bool unauthorized = false;\n\n        // The value of this variable is set by the mutex\n        // constructor. It is true if the named system mutex was\n        // created, and false if the named mutex already existed.\n        //\n        bool mutexWasCreated = false;\n\n        // Attempt to open the named mutex.\n        try\n        {\n            // Open the mutex with (MutexRights.Synchronize |\n            // MutexRights.Modify), to enter and release the\n            // named mutex.\n            //\n            m = Mutex.OpenExisting(mutexName);\n        }\n        catch(WaitHandleCannotBeOpenedException)\n        {\n            Console.WriteLine(&quot;Mutex does not exist.&quot;);\n            doesNotExist = true;\n        }\n        catch(UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n            unauthorized = true;\n        }\n\n        // There are three cases: (1) The mutex does not exist.\n        // (2) The mutex exists, but the current user doesn&#39;t \n        // have access. (3) The mutex exists and the user has\n        // access.\n        //\n        if (doesNotExist)\n        {\n            // The mutex does not exist, so create it.\n\n            // Create an access control list (ACL) that denies the\n            // current user the right to enter or release the \n            // mutex, but allows the right to read and change\n            // security information for the mutex.\n            //\n            string user = Environment.UserDomainName + &quot;\\\\&quot;\n                + Environment.UserName;\n            MutexSecurity mSec = new MutexSecurity();\n\n            MutexAccessRule rule = new MutexAccessRule(user, \n                MutexRights.Synchronize | MutexRights.Modify, \n                AccessControlType.Deny);\n            mSec.AddAccessRule(rule);\n\n            rule = new MutexAccessRule(user, \n                MutexRights.ReadPermissions | MutexRights.ChangePermissions,\n                AccessControlType.Allow);\n            mSec.AddAccessRule(rule);\n\n            // Create a Mutex object that represents the system\n            // mutex named by the constant &#39;mutexName&#39;, with\n            // initial ownership for this thread, and with the\n            // specified security access. The Boolean value that \n            // indicates creation of the underlying system object\n            // is placed in mutexWasCreated.\n            //\n            m = new Mutex(true, mutexName, out mutexWasCreated, mSec);\n\n            // If the named system mutex was created, it can be\n            // used by the current instance of this program, even \n            // though the current user is denied access. The current\n            // program owns the mutex. Otherwise, exit the program.\n            // \n            if (mutexWasCreated)\n            {\n                Console.WriteLine(&quot;Created the mutex.&quot;);\n            }\n            else\n            {\n                Console.WriteLine(&quot;Unable to create the mutex.&quot;);\n                return;\n            }\n\n        }\n        else if (unauthorized)\n        {\n            // Open the mutex to read and change the access control\n            // security. The access control security defined above\n            // allows the current user to do this.\n            //\n            try\n            {\n                m = Mutex.OpenExisting(mutexName, \n                    MutexRights.ReadPermissions | MutexRights.ChangePermissions);\n\n                // Get the current ACL. This requires \n                // MutexRights.ReadPermissions.\n                MutexSecurity mSec = m.GetAccessControl();\n                \n                string user = Environment.UserDomainName + &quot;\\\\&quot;\n                    + Environment.UserName;\n\n                // First, the rule that denied the current user \n                // the right to enter and release the mutex must\n                // be removed.\n                MutexAccessRule rule = new MutexAccessRule(user, \n                     MutexRights.Synchronize | MutexRights.Modify,\n                     AccessControlType.Deny);\n                mSec.RemoveAccessRule(rule);\n\n                // Now grant the user the correct rights.\n                // \n                rule = new MutexAccessRule(user, \n                    MutexRights.Synchronize | MutexRights.Modify,\n                    AccessControlType.Allow);\n                mSec.AddAccessRule(rule);\n\n                // Update the ACL. This requires\n                // MutexRights.ChangePermissions.\n                m.SetAccessControl(mSec);\n\n                Console.WriteLine(&quot;Updated mutex security.&quot;);\n\n                // Open the mutex with (MutexRights.Synchronize \n                // | MutexRights.Modify), the rights required to\n                // enter and release the mutex.\n                //\n                m = Mutex.OpenExisting(mutexName);\n\n            }\n            catch(UnauthorizedAccessException ex)\n            {\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;,\n                    ex.Message);\n                return;\n            }\n\n        }\n\n        // If this program created the mutex, it already owns\n        // the mutex.\n        //\n        if (!mutexWasCreated)\n        {\n            // Enter the mutex, and hold it until the program\n            // exits.\n            //\n            try\n            {\n                Console.WriteLine(&quot;Wait for the mutex.&quot;);\n                m.WaitOne();\n                Console.WriteLine(&quot;Entered the mutex.&quot;);\n            }\n            catch(UnauthorizedAccessException ex)\n            {\n                Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n            }\n        }\n\n        Console.WriteLine(&quot;Press the Enter key to exit.&quot;);\n        Console.ReadLine();\n        m.ReleaseMutex();\n        m.Dispose();\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Mutex.ctor named 4#1\">Imports System\nImports System.Threading\nImports System.Security.AccessControl\n\nFriend Class Example\n\n    &lt;MTAThread&gt; _\n    Friend Shared Sub Main()\n        Const mutexName As String = &quot;MutexExample4&quot;\n\n        Dim m As Mutex = Nothing\n        Dim doesNotExist as Boolean = False\n        Dim unauthorized As Boolean = False\n\n        &#39; The value of this variable is set by the mutex\n        &#39; constructor. It is True if the named system mutex was\n        &#39; created, and False if the named mutex already existed.\n        &#39;\n        Dim mutexWasCreated As Boolean\n\n        &#39; Attempt to open the named mutex.\n        Try\n            &#39; Open the mutex with (MutexRights.Synchronize Or\n            &#39; MutexRights.Modify), to enter and release the\n            &#39; named mutex.\n            &#39;\n            m = Mutex.OpenExisting(mutexName)\n        Catch ex As WaitHandleCannotBeOpenedException\n            Console.WriteLine(&quot;Mutex does not exist.&quot;)\n            doesNotExist = True\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message)\n            unauthorized = True\n        End Try\n\n        &#39; There are three cases: (1) The mutex does not exist.\n        &#39; (2) The mutex exists, but the current user doesn&#39;t \n        &#39; have access. (3) The mutex exists and the user has\n        &#39; access.\n        &#39;\n        If doesNotExist Then\n            &#39; The mutex does not exist, so create it.\n\n            &#39; Create an access control list (ACL) that denies the\n            &#39; current user the right to enter or release the \n            &#39; mutex, but allows the right to read and change\n            &#39; security information for the mutex.\n            &#39;\n            Dim user As String = Environment.UserDomainName _ \n                &amp; &quot;\\&quot; &amp; Environment.UserName\n            Dim mSec As New MutexSecurity()\n\n            Dim rule As New MutexAccessRule(user, _\n                MutexRights.Synchronize Or MutexRights.Modify, _\n                AccessControlType.Deny)\n            mSec.AddAccessRule(rule)\n\n            rule = New MutexAccessRule(user, _\n                MutexRights.ReadPermissions Or _\n                MutexRights.ChangePermissions, _\n                AccessControlType.Allow)\n            mSec.AddAccessRule(rule)\n\n            &#39; Create a Mutex object that represents the system\n            &#39; mutex named by the constant &#39;mutexName&#39;, with\n            &#39; initial ownership for this thread, and with the\n            &#39; specified security access. The Boolean value that \n            &#39; indicates creation of the underlying system object\n            &#39; is placed in mutexWasCreated.\n            &#39;\n            m = New Mutex(True, mutexName, mutexWasCreated, mSec)\n\n            &#39; If the named system mutex was created, it can be\n            &#39; used by the current instance of this program, even \n            &#39; though the current user is denied access. The current\n            &#39; program owns the mutex. Otherwise, exit the program.\n            &#39; \n            If mutexWasCreated Then\n                Console.WriteLine(&quot;Created the mutex.&quot;)\n            Else\n                Console.WriteLine(&quot;Unable to create the mutex.&quot;)\n                Return\n            End If\n\n        ElseIf unauthorized Then\n\n            &#39; Open the mutex to read and change the access control\n            &#39; security. The access control security defined above\n            &#39; allows the current user to do this.\n            &#39;\n            Try\n                m = Mutex.OpenExisting(mutexName, _\n                    MutexRights.ReadPermissions Or _\n                    MutexRights.ChangePermissions)\n\n                &#39; Get the current ACL. This requires \n                &#39; MutexRights.ReadPermissions.\n                Dim mSec As MutexSecurity = m.GetAccessControl()\n                \n                Dim user As String = Environment.UserDomainName _ \n                    &amp; &quot;\\&quot; &amp; Environment.UserName\n\n                &#39; First, the rule that denied the current user \n                &#39; the right to enter and release the mutex must\n                &#39; be removed.\n                Dim rule As New MutexAccessRule(user, _\n                    MutexRights.Synchronize Or MutexRights.Modify, _\n                    AccessControlType.Deny)\n                mSec.RemoveAccessRule(rule)\n\n                &#39; Now grant the user the correct rights.\n                &#39; \n                rule = New MutexAccessRule(user, _\n                    MutexRights.Synchronize Or MutexRights.Modify, _\n                    AccessControlType.Allow)\n                mSec.AddAccessRule(rule)\n\n                &#39; Update the ACL. This requires\n                &#39; MutexRights.ChangePermissions.\n                m.SetAccessControl(mSec)\n\n                Console.WriteLine(&quot;Updated mutex security.&quot;)\n\n                &#39; Open the mutex with (MutexRights.Synchronize \n                &#39; Or MutexRights.Modify), the rights required to\n                &#39; enter and release the mutex.\n                &#39;\n                m = Mutex.OpenExisting(mutexName)\n\n            Catch ex As UnauthorizedAccessException\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;, _\n                    ex.Message)\n                Return\n            End Try\n\n        End If\n\n        &#39; If this program created the mutex, it already owns\n        &#39; the mutex.\n        &#39;\n        If Not mutexWasCreated Then\n            &#39; Enter the mutex, and hold it until the program\n            &#39; exits.\n            &#39;\n            Try\n                Console.WriteLine(&quot;Wait for the mutex.&quot;)\n                m.WaitOne()\n                Console.WriteLine(&quot;Entered the mutex.&quot;)\n            Catch ex As UnauthorizedAccessException\n                Console.WriteLine(&quot;Unauthorized access: {0}&quot;, _\n                    ex.Message)\n            End Try\n        End If\n\n        Console.WriteLine(&quot;Press the Enter key to exit.&quot;)\n        Console.ReadLine()\n        m.ReleaseMutex()\n        m.Dispose()\n    End Sub \nEnd Class \n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.Mutex.ctor named 4#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Security::AccessControl;\nusing namespace System::Security::Permissions;\n\npublic ref class Example\n{\npublic:\n   [SecurityPermissionAttribute(SecurityAction::Demand,Flags=SecurityPermissionFlag::UnmanagedCode)]\n   static void Main()\n   {\n      String^ mutexName = L&quot;MutexExample4&quot;;\n\n      Mutex^ m = nullptr;\n      bool doesNotExist = false;\n      bool unauthorized = false;\n      \n      // The value of this variable is set by the mutex\n      // constructor. It is true if the named system mutex was\n      // created, and false if the named mutex already existed.\n      //\n      bool mutexWasCreated = false;\n\n      // Attempt to open the named mutex.\n      try\n      {\n         // Open the mutex with (MutexRights.Synchronize |\n         // MutexRights.Modify), to enter and release the\n         // named mutex.\n         //\n         m = Mutex::OpenExisting( mutexName );\n      }\n      catch ( WaitHandleCannotBeOpenedException^ ) \n      {\n         Console::WriteLine( L&quot;Mutex does not exist.&quot; );\n         doesNotExist = true;\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n         unauthorized = true;\n      }\n\n      // There are three cases: (1) The mutex does not exist.\n      // (2) The mutex exists, but the current user doesn&#39;t\n      // have access. (3) The mutex exists and the user has\n      // access.\n      //\n      if ( doesNotExist )\n      {\n         // The mutex does not exist, so create it.\n         // Create an access control list (ACL) that denies the\n         // current user the right to enter or release the\n         // mutex, but allows the right to read and change\n         // security information for the mutex.\n         //\n         String^ user = String::Concat( Environment::UserDomainName, L&quot;\\\\&quot;,\n            Environment::UserName );\n         MutexSecurity^ mSec = gcnew MutexSecurity;\n\n         MutexAccessRule^ rule = gcnew MutexAccessRule( user,\n            static_cast&lt;MutexRights&gt;(\n               MutexRights::Synchronize |\n               MutexRights::Modify),\n            AccessControlType::Deny );\n         mSec-&gt;AddAccessRule( rule );\n\n         rule = gcnew MutexAccessRule( user,\n            static_cast&lt;MutexRights&gt;(\n               MutexRights::ReadPermissions |\n                MutexRights::ChangePermissions),\n            AccessControlType::Allow );\n         mSec-&gt;AddAccessRule( rule );\n         \n         // Create a Mutex object that represents the system\n         // mutex named by the constant &#39;mutexName&#39;, with\n         // initial ownership for this thread, and with the\n         // specified security access. The Boolean value that\n         // indicates creation of the underlying system object\n         // is placed in mutexWasCreated.\n         //\n         m = gcnew Mutex( true,mutexName, mutexWasCreated,mSec );\n         \n         // If the named system mutex was created, it can be\n         // used by the current instance of this program, even\n         // though the current user is denied access. The current\n         // program owns the mutex. Otherwise, exit the program.\n         //\n         if ( mutexWasCreated )\n         {\n            Console::WriteLine( L&quot;Created the mutex.&quot; );\n         }\n         else\n         {\n            Console::WriteLine( L&quot;Unable to create the mutex.&quot; );\n            return;\n         }\n      }\n      else if ( unauthorized )\n      {\n         // Open the mutex to read and change the access control\n         // security. The access control security defined above\n         // allows the current user to do this.\n         //\n         try\n         {\n            m = Mutex::OpenExisting( mutexName,\n               static_cast&lt;MutexRights&gt;(\n                  MutexRights::ReadPermissions |\n                  MutexRights::ChangePermissions) );\n            \n            // Get the current ACL. This requires\n            // MutexRights.ReadPermissions.\n            MutexSecurity^ mSec = m-&gt;GetAccessControl();\n\n            String^ user = String::Concat( Environment::UserDomainName,\n               L&quot;\\\\&quot;, Environment::UserName );\n            \n            // First, the rule that denied the current user\n            // the right to enter and release the mutex must\n            // be removed.\n            MutexAccessRule^ rule = gcnew MutexAccessRule( user,\n               static_cast&lt;MutexRights&gt;(\n                  MutexRights::Synchronize |\n                  MutexRights::Modify),\n               AccessControlType::Deny );\n            mSec-&gt;RemoveAccessRule( rule );\n            \n            // Now grant the user the correct rights.\n            //\n            rule = gcnew MutexAccessRule( user,\n               static_cast&lt;MutexRights&gt;(\n                  MutexRights::Synchronize |\n                  MutexRights::Modify),\n               AccessControlType::Allow );\n            mSec-&gt;AddAccessRule( rule );\n            \n            // Update the ACL. This requires\n            // MutexRights.ChangePermissions.\n            m-&gt;SetAccessControl( mSec );\n\n            Console::WriteLine( L&quot;Updated mutex security.&quot; );\n            \n            // Open the mutex with (MutexRights.Synchronize\n            // | MutexRights.Modify), the rights required to\n            // enter and release the mutex.\n            //\n            m = Mutex::OpenExisting( mutexName );\n         }\n         catch ( UnauthorizedAccessException^ ex ) \n         {\n            Console::WriteLine(\n               L&quot;Unable to change permissions: {0}&quot;, ex-&gt;Message );\n            return;\n         }\n      }\n      \n      // If this program created the mutex, it already owns\n      // the mutex.\n      //\n      if ( !mutexWasCreated )\n      {\n         // Enter the mutex, and hold it until the program\n         // exits.\n         //\n         try\n         {\n            Console::WriteLine( L&quot;Wait for the mutex.&quot; );\n            m-&gt;WaitOne();\n            Console::WriteLine( L&quot;Entered the mutex.&quot; );\n         }\n         catch ( UnauthorizedAccessException^ ex ) \n         {\n            Console::WriteLine( L&quot;Unauthorized access: {0}&quot;,\n               ex-&gt;Message );\n         }\n      }\n\n      Console::WriteLine( L&quot;Press the Enter key to exit.&quot; );\n      Console::ReadLine();\n      m-&gt;ReleaseMutex();\n      m-&gt;Dispose();\n   }\n};\n\nint main()\n{\n   Example::Main();\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Mutex_ReleaseMutex\">\r\n    \r\n            <a id=\"System_Threading_Mutex_ReleaseMutex_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">ReleaseMutex()</div>        \r\n          </div>\r\n    \r\n            <p>Releases the <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> once.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void ReleaseMutex ();</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.applicationexception\" data-linktype=\"relative-path\">ApplicationException</a></div>\r\n                  </div>\r\n                  <p>The calling thread does not own the mutex.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.objectdisposedexception\" data-linktype=\"relative-path\">ObjectDisposedException</a></div>\r\n                  </div>\r\n                  <p>The current instance has already been disposed.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Whenever a thread acquires a mutex (for example, by calling its <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> method), it must subsequently call ReleaseMutex to relinquish ownership of the mutex and unblock other threads that are trying to gain ownership of the mutex. If the attempt to get ownership of the mutex fails (for example, when a call to the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> method with a <code>millisecondsTimeout</code> or a <code>timeout</code> parameter returns <code>false</code> because the request times out), the thread shouldn&#39;t call ReleaseMutex, In this case, the thread should also not be allowed to access the resource protected by the mutex, as the following example shows.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.Mutex.Class#2\">using System;\nusing System.Threading;\n\nclass Example\n{\n    // Create a new Mutex. The creating thread does not own the mutex.\n    private static Mutex mut = new Mutex();\n    private const int numIterations = 1;\n    private const int numThreads = 3;\n\n    static void Main()\n    {\n        Example ex = new Example();\n        ex.StartThreads();\n    }\n\n     private void StartThreads()\n     {\n        // Create the threads that will use the protected resource.\n        for(int i = 0; i &lt; numThreads; i++)\n        {\n            Thread newThread = new Thread(new ThreadStart(ThreadProc));\n            newThread.Name = String.Format(&quot;Thread{0}&quot;, i + 1);\n            newThread.Start();\n        }\n\n        // The main thread returns to Main and exits, but the application continues to\n        // run until all foreground threads have exited.\n    }\n\n    private static void ThreadProc()\n    {\n        for(int i = 0; i &lt; numIterations; i++)\n        {\n            UseResource();\n        }\n    }\n\n    // This method represents a resource that must be synchronized\n    // so that only one thread at a time can enter.\n    private static void UseResource()\n    {\n        // Wait until it is safe to enter, and do not enter if the request times out.\n        Console.WriteLine(&quot;{0} is requesting the mutex&quot;, Thread.CurrentThread.Name);\n        if (mut.WaitOne(1000)) {\n           Console.WriteLine(&quot;{0} has entered the protected area&quot;, \n               Thread.CurrentThread.Name);\n   \n           // Place code to access non-reentrant resources here.\n   \n           // Simulate some work.\n           Thread.Sleep(5000);\n   \n           Console.WriteLine(&quot;{0} is leaving the protected area&quot;, \n               Thread.CurrentThread.Name);\n   \n           // Release the Mutex.\n              mut.ReleaseMutex();\n           Console.WriteLine(&quot;{0} has released the mutex&quot;, \n                             Thread.CurrentThread.Name);\n        }\n        else {\n           Console.WriteLine(&quot;{0} will not acquire the mutex&quot;, \n                             Thread.CurrentThread.Name);\n        }\n    }\n\n    ~Example()\n    {\n       mut.Dispose();\n    }\n}\n// The example displays output like the following:\n//       Thread1 is requesting the mutex\n//       Thread1 has entered the protected area\n//       Thread2 is requesting the mutex\n//       Thread3 is requesting the mutex\n//       Thread2 will not acquire the mutex\n//       Thread3 will not acquire the mutex\n//       Thread1 is leaving the protected area\n//       Thread1 has released the mutex\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Mutex.Class#2\">Imports System.Threading\n\nClass Example\n   &#39; Create a new Mutex. The creating thread does not own the mutex.\n   Private mut As New Mutex()\n   Private Const numIterations As Integer = 1\n   Private Const numThreads As Integer = 3\n\n   Public Shared Sub Main()\n      Dim ex As New Example()\n      ex.StartThreads()\n   End Sub\n   \n   Private Sub StartThreads()\n        &#39; Create the threads that will use the protected resource.\n        For i As Integer = 0 To numThreads - 1\n            Dim newThread As New Thread(AddressOf ThreadProc)\n            newThread.Name = String.Format(&quot;Thread{0}&quot;, i + 1)\n            newThread.Start()\n        Next\n\n        &#39; The main thread returns to Main and exits, but the application continues to\n        &#39; run until all foreground threads have exited.\n   End Sub\n\n   Private Sub ThreadProc()\n        For i As Integer = 0 To numIterations - 1\n            UseResource()\n        Next\n   End Sub\n\n   &#39; This method represents a resource that must be synchronized\n   &#39; so that only one thread at a time can enter.\n   Private Sub UseResource()\n        &#39; Wait until it is safe to enter.\n        Console.WriteLine(&quot;{0} is requesting the mutex&quot;, \n                          Thread.CurrentThread.Name)\n        If mut.WaitOne(1000) Then\n           Console.WriteLine(&quot;{0} has entered the protected area&quot;, \n               Thread.CurrentThread.Name)\n   \n           &#39; Place code to access non-reentrant resources here.\n   \n           &#39; Simulate some work.\n           Thread.Sleep(5000)\n   \n           Console.WriteLine(&quot;{0} is leaving the protected area&quot;, \n               Thread.CurrentThread.Name)\n   \n           &#39; Release the Mutex.\n           mut.ReleaseMutex()\n           Console.WriteLine(&quot;{0} has released the mutex&quot;, \n                             Thread.CurrentThread.Name)\n        Else\n           Console.WriteLine(&quot;{0} will not acquire the mutex&quot;, \n                             Thread.CurrentThread.Name)\n        End If\n   End Sub\n   \n   Protected Overrides Sub Finalize()\n      mut.Dispose()\n   End Sub\nEnd Class\n&#39; The example displays output like the following:\n&#39;       Thread1 is requesting the mutex\n&#39;       Thread1 has entered the protected area\n&#39;       Thread2 is requesting the mutex\n&#39;       Thread3 is requesting the mutex\n&#39;       Thread2 will not acquire the mutex\n&#39;       Thread3 will not acquire the mutex\n&#39;       Thread1 is leaving the protected area\n&#39;       Thread1 has released the mutex\n</code></pre><p> A thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution. The number of calls is kept by the common language runtime. The thread must call ReleaseMutex the same number of times to release ownership of the mutex.  </p>\n<p> If a thread terminates while owning a mutex, the mutex is said to be abandoned. The state of the mutex is set to signaled and the next waiting thread gets ownership. If no one owns the mutex, the state of the mutex is signaled. Beginning in version 2.0 of the .NET Framework, an <a class=\"xref\" href=\"system.threading.abandonedmutexexception\" data-linktype=\"relative-path\">AbandonedMutexException</a> is thrown in the next thread that acquires the mutex. Prior to version 2.0 of the .NET Framework, no exception was thrown.  </p>\n<div class=\"CAUTION\"><h5>Caution</h5><p> An abandoned mutex often indicates a serious error in the code. When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state. The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.  </p>\n</div>\n<p> In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example shows how a local <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> object is used to synchronize access to a protected resource. The thread that creates the mutex does not own it initially. The ReleaseMutex method is used to release the mutex when it is no longer needed.  </p>\n<pre><code class=\"lang-vb\" name=\"System.Threading.Mutex Default Ctor Example#1\">&#39; This example shows how a Mutex is used to synchronize access\n&#39; to a protected resource. Unlike Monitor, Mutex can be used with\n&#39; WaitHandle.WaitAll and WaitAny, and can be passed across\n&#39; AppDomain boundaries.\n \nImports System\nImports System.Threading\nImports Microsoft.VisualBasic\n\nClass Test\n    &#39; Create a new Mutex. The creating thread does not own the\n    &#39; Mutex.\n    Private Shared mut As New Mutex()\n    Private Const numIterations As Integer = 1\n    Private Const numThreads As Integer = 3\n\n    &lt;MTAThread&gt; _\n    Shared Sub Main()\n        &#39; Create the threads that will use the protected resource.\n        Dim i As Integer\n        For i = 1 To numThreads\n            Dim myThread As New Thread(AddressOf MyThreadProc)\n            myThread.Name = [String].Format(&quot;Thread{0}&quot;, i)\n            myThread.Start()\n        Next i\n\n        &#39; The main thread exits, but the application continues to\n        &#39; run until all foreground threads have exited.\n\n    End Sub &#39;Main\n\n    Private Shared Sub MyThreadProc()\n        Dim i As Integer\n        For i = 1 To numIterations\n            UseResource()\n        Next i\n    End Sub &#39;MyThreadProc\n\n    &#39; This method represents a resource that must be synchronized\n    &#39; so that only one thread at a time can enter.\n    Private Shared Sub UseResource()\n        &#39; Wait until it is safe to enter.\n        mut.WaitOne()\n\n        Console.WriteLine(&quot;{0} has entered protected area&quot;, _\n            Thread.CurrentThread.Name)\n\n        &#39; Place code to access non-reentrant resources here.\n\n        &#39; Simulate some work\n        Thread.Sleep(500)\n\n        Console.WriteLine(&quot;{0} is leaving protected area&quot; &amp; vbCrLf, _\n            Thread.CurrentThread.Name)\n\n        &#39; Release Mutex.\n        mut.ReleaseMutex()\n    End Sub &#39;UseResource\nEnd Class &#39;MyMainClass\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.Mutex Default Ctor Example#1\">// This example shows how a Mutex is used to synchronize access\n// to a protected resource. Unlike Monitor, Mutex can be used with\n// WaitHandle.WaitAll and WaitAny, and can be passed across\n// AppDomain boundaries.\nusing namespace System;\nusing namespace System::Threading;\nconst int numIterations = 1;\nconst int numThreads = 3;\nref class Test\n{\npublic:\n\n   // Create a new Mutex. The creating thread does not own the\n   // Mutex.\n   static Mutex^ mut = gcnew Mutex;\n   static void MyThreadProc()\n   {\n      for ( int i = 0; i &lt; numIterations; i++ )\n      {\n         UseResource();\n\n      }\n   }\n\n\nprivate:\n\n   // This method represents a resource that must be synchronized\n   // so that only one thread at a time can enter.\n   static void UseResource()\n   {\n      \n      //Wait until it is OK to enter.\n      mut-&gt;WaitOne();\n      Console::WriteLine( &quot;{0} has entered protected the area&quot;, Thread::CurrentThread-&gt;Name );\n      \n      // Place code to access non-reentrant resources here.\n      // Simulate some work.\n      Thread::Sleep( 500 );\n      Console::WriteLine( &quot;{0} is leaving protected the area\\r<br>&quot;, Thread::CurrentThread-&gt;Name );\n      \n      // Release the Mutex.\n      mut-&gt;ReleaseMutex();\n   }\n\n};\n\nint main()\n{\n   \n   // Create the threads that will use the protected resource.\n   for ( int i = 0; i &lt; numThreads; i++ )\n   {\n      Thread^ myThread = gcnew Thread( gcnew ThreadStart( Test::MyThreadProc ) );\n      myThread-&gt;Name = String::Format( &quot;Thread {0}&quot;, i + 1 );\n      myThread-&gt;Start();\n\n   }\n   \n   // The main thread exits, but the application continues to \n   // run until all foreground threads have exited.\n}\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.Mutex Default Ctor Example#1\">// This example shows how a Mutex is used to synchronize access\n// to a protected resource. Unlike Monitor, Mutex can be used with\n// WaitHandle.WaitAll and WaitAny, and can be passed across\n// AppDomain boundaries.\n \nusing System;\nusing System.Threading;\n\nclass Test\n{\n    // Create a new Mutex. The creating thread does not own the\n    // Mutex.\n    private static Mutex mut = new Mutex();\n    private const int numIterations = 1;\n    private const int numThreads = 3;\n\n    static void Main()\n    {\n        // Create the threads that will use the protected resource.\n        for(int i = 0; i &lt; numThreads; i++)\n        {\n            Thread myThread = new Thread(new ThreadStart(MyThreadProc));\n            myThread.Name = String.Format(&quot;Thread{0}&quot;, i + 1);\n            myThread.Start();\n        }\n\n        // The main thread exits, but the application continues to\n        // run until all foreground threads have exited.\n    }\n\n    private static void MyThreadProc()\n    {\n        for(int i = 0; i &lt; numIterations; i++)\n        {\n            UseResource();\n        }\n    }\n\n    // This method represents a resource that must be synchronized\n    // so that only one thread at a time can enter.\n    private static void UseResource()\n    {\n        // Wait until it is safe to enter.\n        mut.WaitOne();\n\n        Console.WriteLine(&quot;{0} has entered the protected area&quot;, \n            Thread.CurrentThread.Name);\n\n        // Place code to access non-reentrant resources here.\n\n        // Simulate some work.\n        Thread.Sleep(500);\n\n        Console.WriteLine(&quot;{0} is leaving the protected area\\r<br>&quot;, \n            Thread.CurrentThread.Name);\n         \n        // Release the Mutex.\n        mut.ReleaseMutex();\n    }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Mutex_SetAccessControl_System_Security_AccessControl_MutexSecurity_\">\r\n    \r\n            <a id=\"System_Threading_Mutex_SetAccessControl_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">SetAccessControl(MutexSecurity)</div>        \r\n          </div>\r\n    \r\n            <p>Sets the access control security for a named system mutex.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>mutexSecurity</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.accesscontrol.mutexsecurity\" data-linktype=\"relative-path\">MutexSecurity</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <a class=\"xref\" href=\"system.security.accesscontrol.mutexsecurity\" data-linktype=\"relative-path\">MutexSecurity</a> object that represents the access control security to be applied to the named system mutex.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>mutexSecurity</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The user does not have <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">MutexRights</a>.  </p>\n<p> -or-  </p>\n<p> The mutex was not opened with <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">MutexRights</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.systemexception\" data-linktype=\"relative-path\">SystemException</a></div>\r\n                  </div>\r\n                  <p>The current <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> object does not represent a named system mutex.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The user must have <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">System.Security.AccessControl.MutexRights</a> rights to call this method, and the mutex must have been opened with <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">System.Security.AccessControl.MutexRights</a>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates the cross-process behavior of a named mutex with access control security. The example uses the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a> method overload to test for the existence of a named mutex.  </p>\n<p> If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.  </p>\n<p> If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a>. The exception is caught, and the example uses the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_OpenExisting_System_String_System_Security_AccessControl_MutexRights_\" data-linktype=\"relative-path\">OpenExisting(String,MutexRights)</a> method overload to open the mutex with the rights needed to read and change the permissions, using the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_GetAccessControl_\" data-linktype=\"relative-path\">GetAccessControl</a> and SetAccessControl methods.  </p>\n<p> After the permissions are changed, the mutex is opened with the rights required to enter and release it. If you run the compiled example from a third command window, it runs using the new permissions.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.Mutex.ctor named 4#1\">using System;\nusing System.Threading;\nusing System.Security.AccessControl;\n\ninternal class Example\n{\n    internal static void Main()\n    {\n        const string mutexName = &quot;MutexExample4&quot;;\n\n        Mutex m = null;\n        bool doesNotExist = false;\n        bool unauthorized = false;\n\n        // The value of this variable is set by the mutex\n        // constructor. It is true if the named system mutex was\n        // created, and false if the named mutex already existed.\n        //\n        bool mutexWasCreated = false;\n\n        // Attempt to open the named mutex.\n        try\n        {\n            // Open the mutex with (MutexRights.Synchronize |\n            // MutexRights.Modify), to enter and release the\n            // named mutex.\n            //\n            m = Mutex.OpenExisting(mutexName);\n        }\n        catch(WaitHandleCannotBeOpenedException)\n        {\n            Console.WriteLine(&quot;Mutex does not exist.&quot;);\n            doesNotExist = true;\n        }\n        catch(UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n            unauthorized = true;\n        }\n\n        // There are three cases: (1) The mutex does not exist.\n        // (2) The mutex exists, but the current user doesn&#39;t \n        // have access. (3) The mutex exists and the user has\n        // access.\n        //\n        if (doesNotExist)\n        {\n            // The mutex does not exist, so create it.\n\n            // Create an access control list (ACL) that denies the\n            // current user the right to enter or release the \n            // mutex, but allows the right to read and change\n            // security information for the mutex.\n            //\n            string user = Environment.UserDomainName + &quot;\\\\&quot;\n                + Environment.UserName;\n            MutexSecurity mSec = new MutexSecurity();\n\n            MutexAccessRule rule = new MutexAccessRule(user, \n                MutexRights.Synchronize | MutexRights.Modify, \n                AccessControlType.Deny);\n            mSec.AddAccessRule(rule);\n\n            rule = new MutexAccessRule(user, \n                MutexRights.ReadPermissions | MutexRights.ChangePermissions,\n                AccessControlType.Allow);\n            mSec.AddAccessRule(rule);\n\n            // Create a Mutex object that represents the system\n            // mutex named by the constant &#39;mutexName&#39;, with\n            // initial ownership for this thread, and with the\n            // specified security access. The Boolean value that \n            // indicates creation of the underlying system object\n            // is placed in mutexWasCreated.\n            //\n            m = new Mutex(true, mutexName, out mutexWasCreated, mSec);\n\n            // If the named system mutex was created, it can be\n            // used by the current instance of this program, even \n            // though the current user is denied access. The current\n            // program owns the mutex. Otherwise, exit the program.\n            // \n            if (mutexWasCreated)\n            {\n                Console.WriteLine(&quot;Created the mutex.&quot;);\n            }\n            else\n            {\n                Console.WriteLine(&quot;Unable to create the mutex.&quot;);\n                return;\n            }\n\n        }\n        else if (unauthorized)\n        {\n            // Open the mutex to read and change the access control\n            // security. The access control security defined above\n            // allows the current user to do this.\n            //\n            try\n            {\n                m = Mutex.OpenExisting(mutexName, \n                    MutexRights.ReadPermissions | MutexRights.ChangePermissions);\n\n                // Get the current ACL. This requires \n                // MutexRights.ReadPermissions.\n                MutexSecurity mSec = m.GetAccessControl();\n                \n                string user = Environment.UserDomainName + &quot;\\\\&quot;\n                    + Environment.UserName;\n\n                // First, the rule that denied the current user \n                // the right to enter and release the mutex must\n                // be removed.\n                MutexAccessRule rule = new MutexAccessRule(user, \n                     MutexRights.Synchronize | MutexRights.Modify,\n                     AccessControlType.Deny);\n                mSec.RemoveAccessRule(rule);\n\n                // Now grant the user the correct rights.\n                // \n                rule = new MutexAccessRule(user, \n                    MutexRights.Synchronize | MutexRights.Modify,\n                    AccessControlType.Allow);\n                mSec.AddAccessRule(rule);\n\n                // Update the ACL. This requires\n                // MutexRights.ChangePermissions.\n                m.SetAccessControl(mSec);\n\n                Console.WriteLine(&quot;Updated mutex security.&quot;);\n\n                // Open the mutex with (MutexRights.Synchronize \n                // | MutexRights.Modify), the rights required to\n                // enter and release the mutex.\n                //\n                m = Mutex.OpenExisting(mutexName);\n\n            }\n            catch(UnauthorizedAccessException ex)\n            {\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;,\n                    ex.Message);\n                return;\n            }\n\n        }\n\n        // If this program created the mutex, it already owns\n        // the mutex.\n        //\n        if (!mutexWasCreated)\n        {\n            // Enter the mutex, and hold it until the program\n            // exits.\n            //\n            try\n            {\n                Console.WriteLine(&quot;Wait for the mutex.&quot;);\n                m.WaitOne();\n                Console.WriteLine(&quot;Entered the mutex.&quot;);\n            }\n            catch(UnauthorizedAccessException ex)\n            {\n                Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n            }\n        }\n\n        Console.WriteLine(&quot;Press the Enter key to exit.&quot;);\n        Console.ReadLine();\n        m.ReleaseMutex();\n        m.Dispose();\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Mutex.ctor named 4#1\">Imports System\nImports System.Threading\nImports System.Security.AccessControl\n\nFriend Class Example\n\n    &lt;MTAThread&gt; _\n    Friend Shared Sub Main()\n        Const mutexName As String = &quot;MutexExample4&quot;\n\n        Dim m As Mutex = Nothing\n        Dim doesNotExist as Boolean = False\n        Dim unauthorized As Boolean = False\n\n        &#39; The value of this variable is set by the mutex\n        &#39; constructor. It is True if the named system mutex was\n        &#39; created, and False if the named mutex already existed.\n        &#39;\n        Dim mutexWasCreated As Boolean\n\n        &#39; Attempt to open the named mutex.\n        Try\n            &#39; Open the mutex with (MutexRights.Synchronize Or\n            &#39; MutexRights.Modify), to enter and release the\n            &#39; named mutex.\n            &#39;\n            m = Mutex.OpenExisting(mutexName)\n        Catch ex As WaitHandleCannotBeOpenedException\n            Console.WriteLine(&quot;Mutex does not exist.&quot;)\n            doesNotExist = True\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message)\n            unauthorized = True\n        End Try\n\n        &#39; There are three cases: (1) The mutex does not exist.\n        &#39; (2) The mutex exists, but the current user doesn&#39;t \n        &#39; have access. (3) The mutex exists and the user has\n        &#39; access.\n        &#39;\n        If doesNotExist Then\n            &#39; The mutex does not exist, so create it.\n\n            &#39; Create an access control list (ACL) that denies the\n            &#39; current user the right to enter or release the \n            &#39; mutex, but allows the right to read and change\n            &#39; security information for the mutex.\n            &#39;\n            Dim user As String = Environment.UserDomainName _ \n                &amp; &quot;\\&quot; &amp; Environment.UserName\n            Dim mSec As New MutexSecurity()\n\n            Dim rule As New MutexAccessRule(user, _\n                MutexRights.Synchronize Or MutexRights.Modify, _\n                AccessControlType.Deny)\n            mSec.AddAccessRule(rule)\n\n            rule = New MutexAccessRule(user, _\n                MutexRights.ReadPermissions Or _\n                MutexRights.ChangePermissions, _\n                AccessControlType.Allow)\n            mSec.AddAccessRule(rule)\n\n            &#39; Create a Mutex object that represents the system\n            &#39; mutex named by the constant &#39;mutexName&#39;, with\n            &#39; initial ownership for this thread, and with the\n            &#39; specified security access. The Boolean value that \n            &#39; indicates creation of the underlying system object\n            &#39; is placed in mutexWasCreated.\n            &#39;\n            m = New Mutex(True, mutexName, mutexWasCreated, mSec)\n\n            &#39; If the named system mutex was created, it can be\n            &#39; used by the current instance of this program, even \n            &#39; though the current user is denied access. The current\n            &#39; program owns the mutex. Otherwise, exit the program.\n            &#39; \n            If mutexWasCreated Then\n                Console.WriteLine(&quot;Created the mutex.&quot;)\n            Else\n                Console.WriteLine(&quot;Unable to create the mutex.&quot;)\n                Return\n            End If\n\n        ElseIf unauthorized Then\n\n            &#39; Open the mutex to read and change the access control\n            &#39; security. The access control security defined above\n            &#39; allows the current user to do this.\n            &#39;\n            Try\n                m = Mutex.OpenExisting(mutexName, _\n                    MutexRights.ReadPermissions Or _\n                    MutexRights.ChangePermissions)\n\n                &#39; Get the current ACL. This requires \n                &#39; MutexRights.ReadPermissions.\n                Dim mSec As MutexSecurity = m.GetAccessControl()\n                \n                Dim user As String = Environment.UserDomainName _ \n                    &amp; &quot;\\&quot; &amp; Environment.UserName\n\n                &#39; First, the rule that denied the current user \n                &#39; the right to enter and release the mutex must\n                &#39; be removed.\n                Dim rule As New MutexAccessRule(user, _\n                    MutexRights.Synchronize Or MutexRights.Modify, _\n                    AccessControlType.Deny)\n                mSec.RemoveAccessRule(rule)\n\n                &#39; Now grant the user the correct rights.\n                &#39; \n                rule = New MutexAccessRule(user, _\n                    MutexRights.Synchronize Or MutexRights.Modify, _\n                    AccessControlType.Allow)\n                mSec.AddAccessRule(rule)\n\n                &#39; Update the ACL. This requires\n                &#39; MutexRights.ChangePermissions.\n                m.SetAccessControl(mSec)\n\n                Console.WriteLine(&quot;Updated mutex security.&quot;)\n\n                &#39; Open the mutex with (MutexRights.Synchronize \n                &#39; Or MutexRights.Modify), the rights required to\n                &#39; enter and release the mutex.\n                &#39;\n                m = Mutex.OpenExisting(mutexName)\n\n            Catch ex As UnauthorizedAccessException\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;, _\n                    ex.Message)\n                Return\n            End Try\n\n        End If\n\n        &#39; If this program created the mutex, it already owns\n        &#39; the mutex.\n        &#39;\n        If Not mutexWasCreated Then\n            &#39; Enter the mutex, and hold it until the program\n            &#39; exits.\n            &#39;\n            Try\n                Console.WriteLine(&quot;Wait for the mutex.&quot;)\n                m.WaitOne()\n                Console.WriteLine(&quot;Entered the mutex.&quot;)\n            Catch ex As UnauthorizedAccessException\n                Console.WriteLine(&quot;Unauthorized access: {0}&quot;, _\n                    ex.Message)\n            End Try\n        End If\n\n        Console.WriteLine(&quot;Press the Enter key to exit.&quot;)\n        Console.ReadLine()\n        m.ReleaseMutex()\n        m.Dispose()\n    End Sub \nEnd Class \n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.Mutex.ctor named 4#1\">using namespace System;\nusing namespace System::Threading;\nusing namespace System::Security::AccessControl;\nusing namespace System::Security::Permissions;\n\npublic ref class Example\n{\npublic:\n   [SecurityPermissionAttribute(SecurityAction::Demand,Flags=SecurityPermissionFlag::UnmanagedCode)]\n   static void Main()\n   {\n      String^ mutexName = L&quot;MutexExample4&quot;;\n\n      Mutex^ m = nullptr;\n      bool doesNotExist = false;\n      bool unauthorized = false;\n      \n      // The value of this variable is set by the mutex\n      // constructor. It is true if the named system mutex was\n      // created, and false if the named mutex already existed.\n      //\n      bool mutexWasCreated = false;\n\n      // Attempt to open the named mutex.\n      try\n      {\n         // Open the mutex with (MutexRights.Synchronize |\n         // MutexRights.Modify), to enter and release the\n         // named mutex.\n         //\n         m = Mutex::OpenExisting( mutexName );\n      }\n      catch ( WaitHandleCannotBeOpenedException^ ) \n      {\n         Console::WriteLine( L&quot;Mutex does not exist.&quot; );\n         doesNotExist = true;\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n         unauthorized = true;\n      }\n\n      // There are three cases: (1) The mutex does not exist.\n      // (2) The mutex exists, but the current user doesn&#39;t\n      // have access. (3) The mutex exists and the user has\n      // access.\n      //\n      if ( doesNotExist )\n      {\n         // The mutex does not exist, so create it.\n         // Create an access control list (ACL) that denies the\n         // current user the right to enter or release the\n         // mutex, but allows the right to read and change\n         // security information for the mutex.\n         //\n         String^ user = String::Concat( Environment::UserDomainName, L&quot;\\\\&quot;,\n            Environment::UserName );\n         MutexSecurity^ mSec = gcnew MutexSecurity;\n\n         MutexAccessRule^ rule = gcnew MutexAccessRule( user,\n            static_cast&lt;MutexRights&gt;(\n               MutexRights::Synchronize |\n               MutexRights::Modify),\n            AccessControlType::Deny );\n         mSec-&gt;AddAccessRule( rule );\n\n         rule = gcnew MutexAccessRule( user,\n            static_cast&lt;MutexRights&gt;(\n               MutexRights::ReadPermissions |\n                MutexRights::ChangePermissions),\n            AccessControlType::Allow );\n         mSec-&gt;AddAccessRule( rule );\n         \n         // Create a Mutex object that represents the system\n         // mutex named by the constant &#39;mutexName&#39;, with\n         // initial ownership for this thread, and with the\n         // specified security access. The Boolean value that\n         // indicates creation of the underlying system object\n         // is placed in mutexWasCreated.\n         //\n         m = gcnew Mutex( true,mutexName, mutexWasCreated,mSec );\n         \n         // If the named system mutex was created, it can be\n         // used by the current instance of this program, even\n         // though the current user is denied access. The current\n         // program owns the mutex. Otherwise, exit the program.\n         //\n         if ( mutexWasCreated )\n         {\n            Console::WriteLine( L&quot;Created the mutex.&quot; );\n         }\n         else\n         {\n            Console::WriteLine( L&quot;Unable to create the mutex.&quot; );\n            return;\n         }\n      }\n      else if ( unauthorized )\n      {\n         // Open the mutex to read and change the access control\n         // security. The access control security defined above\n         // allows the current user to do this.\n         //\n         try\n         {\n            m = Mutex::OpenExisting( mutexName,\n               static_cast&lt;MutexRights&gt;(\n                  MutexRights::ReadPermissions |\n                  MutexRights::ChangePermissions) );\n            \n            // Get the current ACL. This requires\n            // MutexRights.ReadPermissions.\n            MutexSecurity^ mSec = m-&gt;GetAccessControl();\n\n            String^ user = String::Concat( Environment::UserDomainName,\n               L&quot;\\\\&quot;, Environment::UserName );\n            \n            // First, the rule that denied the current user\n            // the right to enter and release the mutex must\n            // be removed.\n            MutexAccessRule^ rule = gcnew MutexAccessRule( user,\n               static_cast&lt;MutexRights&gt;(\n                  MutexRights::Synchronize |\n                  MutexRights::Modify),\n               AccessControlType::Deny );\n            mSec-&gt;RemoveAccessRule( rule );\n            \n            // Now grant the user the correct rights.\n            //\n            rule = gcnew MutexAccessRule( user,\n               static_cast&lt;MutexRights&gt;(\n                  MutexRights::Synchronize |\n                  MutexRights::Modify),\n               AccessControlType::Allow );\n            mSec-&gt;AddAccessRule( rule );\n            \n            // Update the ACL. This requires\n            // MutexRights.ChangePermissions.\n            m-&gt;SetAccessControl( mSec );\n\n            Console::WriteLine( L&quot;Updated mutex security.&quot; );\n            \n            // Open the mutex with (MutexRights.Synchronize\n            // | MutexRights.Modify), the rights required to\n            // enter and release the mutex.\n            //\n            m = Mutex::OpenExisting( mutexName );\n         }\n         catch ( UnauthorizedAccessException^ ex ) \n         {\n            Console::WriteLine(\n               L&quot;Unable to change permissions: {0}&quot;, ex-&gt;Message );\n            return;\n         }\n      }\n      \n      // If this program created the mutex, it already owns\n      // the mutex.\n      //\n      if ( !mutexWasCreated )\n      {\n         // Enter the mutex, and hold it until the program\n         // exits.\n         //\n         try\n         {\n            Console::WriteLine( L&quot;Wait for the mutex.&quot; );\n            m-&gt;WaitOne();\n            Console::WriteLine( L&quot;Entered the mutex.&quot; );\n         }\n         catch ( UnauthorizedAccessException^ ex ) \n         {\n            Console::WriteLine( L&quot;Unauthorized access: {0}&quot;,\n               ex-&gt;Message );\n         }\n      }\n\n      Console::WriteLine( L&quot;Press the Enter key to exit.&quot; );\n      Console::ReadLine();\n      m-&gt;ReleaseMutex();\n      m-&gt;Dispose();\n   }\n};\n\nint main()\n{\n   Example::Main();\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Mutex_TryOpenExisting_System_String_System_Threading_Mutex__\">\r\n    \r\n            <a id=\"System_Threading_Mutex_TryOpenExisting_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">TryOpenExisting(String,Mutex)</div>        \r\n          </div>\r\n    \r\n            <p>Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool TryOpenExisting (string name, out System.Threading.Mutex result);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of the system mutex to open.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>result</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>When this method returns, contains a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> object that represents the named mutex if the call succeeded, or <code>null</code> if the call failed. This parameter is treated as uninitialized.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the named mutex was opened successfully; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is an empty string.  </p>\n<p> -or-  </p>\n<p> <code>name</code> is longer than 260 characters.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a></div>\r\n                  </div>\r\n                  <p>A Win32 error occurred.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The named mutex exists, but the user does not have the security access required to use it.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the named mutex does not exist, this method does not create it. To create the system mutex when it does not already exist, use one of the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex__ctor_\" data-linktype=\"relative-path\">Mutex</a> constructors that has a <code>name</code> parameter.  </p>\n<p> If you are uncertain whether a named mutex exists, use this method overload instead of the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a> method overload, which throws an exception if the mutex does not exist.  </p>\n<p> Multiple calls to this method that use the same value for <code>name</code> do not necessarily return the same <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> object, even though the objects that are returned represent the same named system mutex.  </p>\n<p> This method overload is equivalent to calling the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_TryOpenExisting_System_String_System_Security_AccessControl_MutexRights_System_Threading_Mutex__\" data-linktype=\"relative-path\">TryOpenExisting(String,MutexRights,Mutex)</a> method overload and specifying <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">System.Security.AccessControl.MutexRights</a> and <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">System.Security.AccessControl.MutexRights</a> rights, combined by using the bitwise OR operation. Specifying the <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">System.Security.AccessControl.MutexRights</a> flag allows a thread to wait on the mutex, and specifying the <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">System.Security.AccessControl.MutexRights</a> flag allows a thread to call the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_ReleaseMutex_\" data-linktype=\"relative-path\">ReleaseMutex</a> method.  </p>\n<p> This method does not request ownership of the mutex.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Mutex_TryOpenExisting_System_String_System_Security_AccessControl_MutexRights_System_Threading_Mutex__\">\r\n    \r\n            <a id=\"System_Threading_Mutex_TryOpenExisting_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">TryOpenExisting(String,MutexRights,Mutex)</div>        \r\n          </div>\r\n    \r\n            <p>Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of the system mutex to open.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>rights</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">MutexRights</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitwise combination of the enumeration values that represent the desired security access.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>result</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>When this method returns, contains a <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> object that represents the named mutex if the call succeeded, or <code>null</code> if the call failed. This parameter is treated as uninitialized.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the named mutex was opened successfully; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is an empty string.  </p>\n<p> -or-  </p>\n<p> <code>name</code> is longer than 260 characters.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a></div>\r\n                  </div>\r\n                  <p>A Win32 error occurred.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The named mutex exists, but the user does not have the security access required to use it.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the named mutex does not exist, this method does not create it. To create the system mutex when it does not already exist, use one of the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex__ctor_\" data-linktype=\"relative-path\">Mutex</a> constructors that has a <code>name</code> parameter.  </p>\n<p> If you are uncertain whether a named mutex exists, use this method overload instead of the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_OpenExisting_System_String_System_Security_AccessControl_MutexRights_\" data-linktype=\"relative-path\">OpenExisting(String,MutexRights)</a> method overload, which throws an exception if the mutex does not exist.  </p>\n<p> The <code>rights</code> parameter must include the <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">System.Security.AccessControl.MutexRights</a> flag to allow threads to wait on the mutex, and the <a class=\"xref\" href=\"system.security.accesscontrol.mutexrights\" data-linktype=\"relative-path\">System.Security.AccessControl.MutexRights</a> flag to allow threads to call the <a class=\"xref\" href=\"system.threading.mutex#System_Threading_Mutex_ReleaseMutex_\" data-linktype=\"relative-path\">ReleaseMutex</a> method.  </p>\n<p> Multiple calls to this method that use the same value for <code>name</code> do not necessarily return the same <a class=\"xref\" href=\"system.threading.mutex\" data-linktype=\"relative-path\">Mutex</a> object, even though the objects that are returned represent the same named system mutex.  </p>\n<p> This method does not request ownership of the mutex.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n","outputRootRelativePath":"./","pageMetadata":"<meta name=\"breadcrumb_path\" content=\"breadcrumb/toc1.json\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"fulldocset\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.fulldocset\">\r\n<meta name=\"ref_skeleton_gitcommit\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Threading.Mutex.yml\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Threading.Mutex.yml\">\r\n<meta name=\"APIName\" content=\"System.Threading.Mutex\">\r\n<meta name=\"APIName\" content=\"System.Threading.Mutex..ctor\">\r\n<meta name=\"APIName\" content=\"System.Threading.Mutex.GetAccessControl\">\r\n<meta name=\"APIName\" content=\"System.Threading.Mutex.OpenExisting\">\r\n<meta name=\"APIName\" content=\"System.Threading.Mutex.ReleaseMutex\">\r\n<meta name=\"APIName\" content=\"System.Threading.Mutex.SetAccessControl\">\r\n<meta name=\"APIName\" content=\"System.Threading.Mutex.TryOpenExisting\">\r\n<meta name=\"APILocation\" content=\"mscorlib.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-01 01:37 AM\">\r\n<meta name=\"document_id\" content=\"e623e40e-7f04-fceb-d60e-4df4ee758f54\">\r\n<meta name=\"original_ecmaxml_local_path\" content=\"W:\\vejk\\s\\fulldocset\\xml\\System.Threading\\Mutex.xml\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"A synchronization primitive that can also be used for interprocess synchronization.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/System.Threading/toc1.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Threading.Mutex\">\r\n","rawMetadata":{"breadcrumb_path":"breadcrumb/toc.json","search.ms_sitename":"Docs","search.ms_docsetname":"fulldocset","version":null,"_op_canonicalUrlPrefix":"https://ppe.docs.microsoft.com/en-us/fulldotnet/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":true,"depot_name":"MSDN.fulldocset","_op_gitRefSkeletonCommitHistory":[{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"use plugin in master","commit_sha":"501959ac03e19ac52a27aa4c6bbeb980f8b11c8c","commit_date":"2017-03-01 09:31:20 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"switch from platform to version","commit_sha":"78cdacb5ca782478af490a6b30c3a2cb2b6b873e","commit_date":"2017-02-28 15:09:51 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"update platforms","commit_sha":"39ad5a8919a59afc93a79ac4bd8e07c3b471b37a","commit_date":"2017-02-28 10:38:59 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"checkin yml","commit_sha":"da161b792852497df7140d7768cee2eccd9cb43f","commit_date":"2017-02-28 09:36:15 +0800"}],"ref_skeleton_gitcommit":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Threading.Mutex.yml","original_ref_skeleton_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Threading.Mutex.yml","open_to_public_contributors":true,"api_name":["System.Threading.Mutex","System.Threading.Mutex..ctor","System.Threading.Mutex.GetAccessControl","System.Threading.Mutex.OpenExisting","System.Threading.Mutex.ReleaseMutex","System.Threading.Mutex.SetAccessControl","System.Threading.Mutex.TryOpenExisting"],"api_location":["mscorlib.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Threading.Mutex","System::Threading::Mutex","System.Threading.Mutex.#ctor","System::Threading::Mutex::#ctor","System.Threading.Mutex.GetAccessControl","System::Threading::Mutex::GetAccessControl","System.Threading.Mutex.OpenExisting","System::Threading::Mutex::OpenExisting","System.Threading.Mutex.ReleaseMutex","System::Threading::Mutex::ReleaseMutex","System.Threading.Mutex.SetAccessControl","System::Threading::Mutex::SetAccessControl","System.Threading.Mutex.TryOpenExisting","System::Threading::Mutex::TryOpenExisting"],"dev_langs":["csharp"],"updated_at":"2017-03-01 01:37 AM","document_id":"e623e40e-7f04-fceb-d60e-4df4ee758f54","original_ecmaxml_local_path":"W:\\vejk\\s\\fulldocset\\xml\\System.Threading\\Mutex.xml","content_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/xml/System.Threading/Mutex.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"Mutex class | Microsoft Docs","_op_ogTitle":"Mutex class","description":"A synchronization primitive that can also be used for interprocess synchronization.\n","toc_asset_id":"_splitted/System.Threading/toc.json","toc_rel":"_splitted/System.Threading/toc.json","source_url":"","ms.assetid":"System.Threading.Mutex","canonical_url":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.threading.mutex","_op_canonicalUrl":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.threading.mutex","fileRelativePath":"System.Threading.Mutex.html"},"themesRelativePathToOutputRoot":"_themes/"}