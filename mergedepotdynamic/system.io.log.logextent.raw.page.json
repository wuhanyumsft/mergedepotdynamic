{"content":"    \r\n    <h1 id=\"System_IO_Log_LogExtent\">\r\n      <span class=\"lang-csharp\">LogExtent</span>\r\n        Class\r\n    </h1>\r\n    \r\n    \r\n    <nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n      <h3>In this Article</h3>\r\n    </nav><div class=\"summary\">\r\n    \t<p>Represents a disk extent that contains log data.</p>\n\r\n    </div><h2>Syntax</h2>\r\n    \r\n    \t<h3>Declaration</h3>\r\n    \t<pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public sealed class LogExtent</code></pre>\r\n    \r\n    \r\n    \r\n    <h3>Inheritance Hierarchy</h3>\r\n    <ul class=\"inheritance\">\r\n        <li class=\"l0\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">System.Object</a>\r\n          </div>\r\n        </li>\r\n      <li class=\"l1\">\r\n        <div class=\"xref\">\r\n          <div class=\"lang-csharp\">LogExtent</div>\r\n        </div>\r\n      </li>\r\n    </ul>\r\n    \r\n      <div class=\"referencebox inheritedMembers\">\r\n        <h3>Inherited Members</h3>\r\n        <h4></h4>\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a>\r\n          </div>\r\n          \r\n      </div>\r\n    \r\n    \r\n      <h2>Remarks</h2>\r\n      <p>A <a class=\"xref\" href=\"system.io.log.logstore\" data-linktype=\"relative-path\">LogStore</a> instance stores its data in a collection of disk extents, represented by LogExtent instances. A particular LogExtent is associated with exactly one <a class=\"xref\" href=\"system.io.log.logstore\" data-linktype=\"relative-path\">LogStore</a>, and LogExtent objects in the same <a class=\"xref\" href=\"system.io.log.logstore\" data-linktype=\"relative-path\">LogStore</a> are of identical size. Space is added to and removed from a <a class=\"xref\" href=\"system.io.log.logstore\" data-linktype=\"relative-path\">LogStore</a> instance in extent increments.  </p>\n<p> Although LogExtent objects are represented on disk as files, they should not be moved or deleted as normal files. To delete a LogExtent instance, remove it from the <a class=\"xref\" href=\"system.io.log.logextentcollection\" data-linktype=\"relative-path\">LogExtentCollection</a> that contains it.</p>\n\r\n    \r\n    \r\n    <h2>Properties\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_IO_Log_LogExtent_Path\" data-linktype=\"self-bookmark\">Path</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the fully qualified path of this <a class=\"xref\" href=\"system.io.log.logextent\" data-linktype=\"relative-path\">LogExtent</a> instance.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_IO_Log_LogExtent_Size\" data-linktype=\"self-bookmark\">Size</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the size of this <a class=\"xref\" href=\"system.io.log.logextent\" data-linktype=\"relative-path\">LogExtent</a> instance, in bytes.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_IO_Log_LogExtent_State\" data-linktype=\"self-bookmark\">State</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the state of this <a class=\"xref\" href=\"system.io.log.logextent\" data-linktype=\"relative-path\">LogExtent</a> instance.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"properties\">\r\n        <h2>Properties\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_IO_Log_LogExtent_Path\">\r\n    \r\n            <a id=\"System_IO_Log_LogExtent_Path_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Path</div>        \r\n          </div>\r\n    \r\n            <p>Gets the fully qualified path of this <a class=\"xref\" href=\"system.io.log.logextent\" data-linktype=\"relative-path\">LogExtent</a> instance.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public string Path { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </div>\r\n                  <p>The fully qualified path of this <a class=\"xref\" href=\"system.io.log.logextent\" data-linktype=\"relative-path\">LogExtent</a> instance.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Although <a class=\"xref\" href=\"system.io.log.logextent\" data-linktype=\"relative-path\">LogExtent</a> objects are represented on disk as files, they should not be moved or deleted as normal files. To delete a <a class=\"xref\" href=\"system.io.log.logextent\" data-linktype=\"relative-path\">LogExtent</a> instance, remove it from the <a class=\"xref\" href=\"system.io.log.logextentcollection\" data-linktype=\"relative-path\">LogExtentCollection</a> that contains it.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>This example shows how to use the <a class=\"xref\" href=\"system.io.log.logextent\" data-linktype=\"relative-path\">LogExtent</a> class to add and emulate extents in a log sequence.  </p>\n<pre><code class=\"lang-cs\" name=\"S_UELogRecordSequence#0\">using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.IO.Log;\n\nnamespace MyLogRecordSequence\n{\n    public class MyLog\n    {\n        string logName = &quot;test.log&quot;;\n        string logContainer = &quot;MyExtent0&quot;;\n        int containerSize = 32 * 1024;\n        LogRecordSequence sequence = null;\n        bool delete = true;\n\n        // These are used in the TailPinned event handler.\n        public static LogRecordSequence MySequence = null;\n        public static bool AdvanceBase = true;\n\n        public MyLog()\n        {\n            // Create a LogRecordSequence.\n            sequence = new LogRecordSequence(this.logName,\n                                              FileMode.CreateNew,\n                                              FileAccess.ReadWrite,\n                                              FileShare.None);\n\n            // At least one container/extent must be added for Log Record Sequence.\n            sequence.LogStore.Extents.Add(this.logContainer, this.containerSize);\n     \n            MySequence = sequence;\n\n        }\n\n        public void AddExtents()\n        {\n            // Add two additional extents. The extents are \n            // of the same size as the first extent.\n            sequence.LogStore.Extents.Add(&quot;MyExtent1&quot;);\n            sequence.LogStore.Extents.Add(&quot;MyExtent2&quot;);\n        }\n\n        public void EnumerateExtents()\n        {\n            LogStore store = sequence.LogStore;\n\n            Console.WriteLine(&quot;Enumerating Log Extents...&quot;);\n            Console.WriteLine(&quot;    Extent Count: {0} extents&quot;, store.Extents.Count);\n            Console.WriteLine(&quot;    Extents Are...&quot;);\n            foreach (LogExtent extent in store.Extents)\n            {\n                Console.WriteLine(&quot;      {0} ({1}, {2})&quot;,\n                                  Path.GetFileName(extent.Path),\n                                  extent.Size,\n                                  extent.State);\n            }\n            Console.WriteLine(&quot;    Free Extents: {0} Free&quot;, store.Extents.FreeCount);   \n        }\n\n        public void SetLogPolicy()\n        {\n            Console.WriteLine();\n            Console.WriteLine(&quot;Setting current log policy...&quot;);\n\n            // SET LOG POLICY\n\n            LogPolicy policy = sequence.LogStore.Policy;\n\n            // Set AutoGrow policy. This enables the log to automatically grow\n            // when the existing extents are full. New extents are added until\n            // we reach the MaximumExtentCount extents.\n            // AutoGrow policy is supported only in Windows Vista and not available in R2.\n            \n            //policy.AutoGrow = true;\n\n            // Set the Growth Rate in terms of extents. This policy specifies\n            // &quot;how much&quot; the log should grow. \n            policy.GrowthRate = new PolicyUnit(2, PolicyUnitType.Extents);\n\n            // Set the AutoShrink policy. This enables the log to automatically\n            // shrink if the available free space exceeds the shrink percentage. \n            // AutoGrow/shrink policy is supported only in Windows Vista and not available in R2.\n            \n            //policy.AutoShrinkPercentage = new PolicyUnit(30, PolicyUnitType.Percentage);\n\n            // Set the PinnedTailThreshold policy.\n            // A tail pinned event is triggered when there is no\n            // log space available and log space may be freed by advancing the base.\n            // The user must handle the tail pinned event by advancing the base of the log. \n            // If the user is not able to move the base of the log, the user should report with exception in\n            // the tail pinned handler.\n            // PinnedTailThreashold policy dictates the amount of space that the TailPinned event requests \n            // for advancing the base of the log. The amount of space can be in percentage or in terms of bytes \n            // which is rounded off to the nearest containers in CLFS. The default is 35 percent.\n\n            \n            policy.PinnedTailThreshold = new PolicyUnit(10, PolicyUnitType.Percentage);\n\n            // Set the maximum extents the log can have.\n            policy.MaximumExtentCount = 6;\n            \n            // Set the minimum extents the log can have.\n            policy.MinimumExtentCount = 2;\n            \n            // Set the prefix for new containers that are added. \n            // when AutoGrow is enabled.\n            //policy.NewExtentPrefix = &quot;MyLogPrefix&quot;;\n            \n            // Set the suffix number for new containers that are added.\n            // when AutoGrow is enabled. \n            policy.NextExtentSuffix = 3;\n\n            // Commit the log policy.\n            policy.Commit();\n\n            // Refresh updates the IO.Log policy properties with current log policy \n            // set in the log. \n            policy.Refresh();\n\n            // LOG POLICY END\n            // \n\n            //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n            // Setting up IO.Log provided capabilities...\n            // \n\n            // SET RETRY APPEND\n\n            // IO.Log provides a mechanism similar to AutoGrow.\n            // If the existing log is full and an append fails, setting RetryAppend\n            // invokes the CLFS policy engine to add new extents and re-tries\n            // record appends. If MaximumExtent count has been reached, \n            // a SequenceFullException is thrown. \n            // \n\n            sequence.RetryAppend = true;\n\n            // RETRY APPEND END\n\n            // REGISTER FOR TAILPINNED EVENT NOTIFICATIONS\n\n            // Register for TailPinned Event by passing in an event handler.\n            // An event is raised when the log full condition is reached.\n            // The user should either advance the base sequence number to the \n            // nearest valid sequence number recommended in the tail pinned event or\n            // report a failure that it is not able to advance the base sequence \n            // number. \n            //\n\n            sequence.TailPinned += new EventHandler&lt;TailPinnedEventArgs&gt;(HandleTailPinned);  \n\n            Console.WriteLine(&quot;Done...&quot;);\n        }\n\n        public void ShowLogPolicy()\n        {\n            Console.WriteLine();\n            Console.WriteLine(&quot;Showing current log policy...&quot;);\n\n            LogPolicy policy = sequence.LogStore.Policy;\n\n            Console.WriteLine(&quot;    Minimum extent count:  {0}&quot;, policy.MinimumExtentCount);\n            Console.WriteLine(&quot;    Maximum extent count:  {0}&quot;, policy.MaximumExtentCount);\n            Console.WriteLine(&quot;    Growth rate:           {0}&quot;, policy.GrowthRate);\n            Console.WriteLine(&quot;    Pinned tail threshold: {0}&quot;, policy.PinnedTailThreshold);\n            Console.WriteLine(&quot;    Auto shrink percent:   {0}&quot;, policy.AutoShrinkPercentage);\n            Console.WriteLine(&quot;    Auto grow enabled:     {0}&quot;, policy.AutoGrow);\n            Console.WriteLine(&quot;    New extent prefix:     {0}&quot;, policy.NewExtentPrefix);\n            Console.WriteLine(&quot;    Next extent suffix:    {0}&quot;, policy.NextExtentSuffix);\n\n\t}\n\n        // Append records. Appending three records.  \n        public void AppendRecords()\n        {\n            Console.WriteLine(&quot;Appending Log Records...&quot;);\n            SequenceNumber previous = SequenceNumber.Invalid;\n\n            previous = sequence.Append(CreateData(&quot;Hello World!&quot;), SequenceNumber.Invalid, SequenceNumber.Invalid, RecordAppendOptions.ForceFlush);\n            previous = sequence.Append(CreateData(&quot;This is my first Logging App&quot;), SequenceNumber.Invalid, SequenceNumber.Invalid, RecordAppendOptions.ForceFlush);\n            previous = sequence.Append(CreateData(&quot;Using LogRecordSequence...&quot;), SequenceNumber.Invalid, SequenceNumber.Invalid, RecordAppendOptions.ForceFlush);\n\t    \n            Console.WriteLine(&quot;Done...&quot;);\n        }\n\n\n        // Read the records added to the log. \n        public void ReadRecords()\n        {\n            Encoding enc = Encoding.Unicode;\n\n            Console.WriteLine();\n\n            Console.WriteLine(&quot;Reading Log Records...&quot;);\n            try\n            {\n                foreach (LogRecord record in this.sequence.ReadLogRecords(this.sequence.BaseSequenceNumber, LogRecordEnumeratorType.Next))\n                {\n                    byte[] data = new byte[record.Data.Length];\n                    record.Data.Read(data, 0, (int)record.Data.Length);\n                    string mystr = enc.GetString(data);\n                    Console.WriteLine(&quot;    {0}&quot;, mystr);\n                }\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(&quot;Exception {0} {1}&quot;, e.GetType(), e.Message);\n            }\n\n            Console.WriteLine();\n        }\n\n        public void FillLog()\n        {\n            bool append = true;\n\n            while (append)\n            {\n                try\n                {\n                    sequence.Append(CreateData(16 * 1024), SequenceNumber.Invalid, SequenceNumber.Invalid, RecordAppendOptions.ForceFlush);\n                }\n\n                catch (SequenceFullException)\n                {\n                    Console.WriteLine(&quot;Log is Full...&quot;);\n                    append = false;\n                }\n            }\n        }\n\n        // Dispose the record sequence and delete the log file. \n        public void Cleanup()\n        {\n            // Dispose the sequence\n            sequence.Dispose();\n\n            // Delete the log file.\n            if (delete)\n            {\n                try\n                {\n                    // This deletes the base log file and all the extents associated with the log.\n                    LogStore.Delete(this.logName);\n                }\n                catch (Exception e)\n                {\n                    Console.WriteLine(&quot;Exception {0} {1}&quot;, e.GetType(), e.Message);\n                }\n            }\n        }\n\n        // Converts the given data to an Array of ArraySegment&lt;byte&gt; \n        public static IList&lt;ArraySegment&lt;byte&gt;&gt; CreateData(string str)\n        {\n            Encoding enc = Encoding.Unicode;\n\n            byte[] array = enc.GetBytes(str);\n\n            ArraySegment&lt;byte&gt;[] segments = new ArraySegment&lt;byte&gt;[1];\n            segments[0] = new ArraySegment&lt;byte&gt;(array);\n\n            return Array.AsReadOnly&lt;ArraySegment&lt;byte&gt;&gt;(segments);\n        }\n\n        public static IList&lt;ArraySegment&lt;byte&gt;&gt; CreateData(int size)\n        {\n            byte[] array = new byte[size];\n\n            Random rnd = new Random();\n            rnd.NextBytes(array);\n\n            ArraySegment&lt;byte&gt;[] segments = new ArraySegment&lt;byte&gt;[1];\n            segments[0] = new ArraySegment&lt;byte&gt;(array);\n\n            return Array.AsReadOnly&lt;ArraySegment&lt;byte&gt;&gt;(segments);\n        }\n\n        public static SequenceNumber GetAdvanceBaseSeqNumber(SequenceNumber recTargetSeqNum)\n        {\n            SequenceNumber targetSequenceNumber = SequenceNumber.Invalid;\n\n            Console.WriteLine(&quot;Getting actual target sequence number...&quot;);\n            \n            // \n            // Implement the logic for returning a valid sequence number closer to\n            // recommended target sequence number. \n            //\n\n            return targetSequenceNumber;\n        }\n\n        public static void HandleTailPinned(object arg, TailPinnedEventArgs tailPinnedEventArgs)\n        {\n            Console.WriteLine(&quot;TailPinned has fired&quot;);\n\n            // Based on the implementation of a logging application, the log base can be moved\n            // to free up more log space and if it is not possible to move the \n            // base, the application should report by throwing an exception.\n\n            if(MyLog.AdvanceBase)\n            {\n                try\n                {\n                    // TailPnnedEventArgs has the recommended sequence number and its generated \n                    // based on PinnedTailThreshold policy. \n                    // This does not map to an actual sequence number in the record sequence\n                    // but an approximation and potentially frees up the threshold % log space\n                    // when the log base is advanced to a valid sequence number closer to the \n                    // recommended sequence number. \n                    // The user should use this sequence number to locate a closest valid sequence\n                    // number to advance the base of the log.\n\n                    SequenceNumber recommendedTargetSeqNum = tailPinnedEventArgs.TargetSequenceNumber; \n                    \n                    // Get the actual Target sequence number.\n                    SequenceNumber actualTargetSeqNum = MyLog.GetAdvanceBaseSeqNumber(recommendedTargetSeqNum);\n\n                    MySequence.AdvanceBaseSequenceNumber(actualTargetSeqNum);\n                }\n                catch (Exception e)\n                {\n                    Console.WriteLine(&quot;Exception thrown {0} {1}&quot;, e.GetType(), e.Message);\n                }\n            }\n            else\n            {\n                // Report back Error if under some conditions the log cannot\n                // advance the base sequence number.\n\n                Console.WriteLine(&quot;Reporting Error! Unable to move the base sequence number!&quot;);\n                throw new IOException();\n            }\n        }\n    }\n\n    class LogSample\n    {\n        static void Main(string[] args)\n        {\n            // Create log record sequence.\n            MyLog log = new MyLog();\n\n            // Add additional extents.\n            log.AddExtents();\n\n            // Enumerate the current log extents.\n            log.EnumerateExtents();\n\n            // Set log policies and register for TailPinned event notifications. \n            log.SetLogPolicy();\n\n            log.ShowLogPolicy();\n            \n            // Append a few records and read the appended records. \n            log.AppendRecords();\n            log.ReadRecords();\n\n            // Fill the Log to trigger log growth...and subsequent TailPinned notifications.\n            log.FillLog();\n\n            log.EnumerateExtents();\n\n            log.Cleanup();\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"S_UELogRecordSequence#0\">\nImports System\nImports System.IO\nImports System.Collections.Generic\nImports System.Text\nImports System.IO.Log\n\nNamespace MyLogRecordSequence\n\tPublic Class MyLog\n\t\tPrivate logName As String = &quot;test.log&quot;\n\t\tPrivate logContainer As String = &quot;MyExtent0&quot;\n\t\tPrivate containerSize As Integer = 32 * 1024\n\t\tPrivate sequence As LogRecordSequence = Nothing\n\t\tPrivate delete As Boolean = True\n\n\t\t&#39; These are used in the TailPinned event handler.\n\t\tPublic Shared MySequence As LogRecordSequence = Nothing\n\t\tPublic Shared AdvanceBase As Boolean = True\n\n\t\tPublic Sub New()\n\t\t\t&#39; Create a LogRecordSequence.\n\t\t\tsequence = New LogRecordSequence(Me.logName, FileMode.CreateNew, FileAccess.ReadWrite, FileShare.None)\n\n\t\t\t&#39; At least one container/extent must be added for Log Record Sequence.\n\t\t\tsequence.LogStore.Extents.Add(Me.logContainer, Me.containerSize)\n\n\t\t\tMySequence = sequence\n\n\t\tEnd Sub\n\n\t\tPublic Sub AddExtents()\n\t\t\t&#39; Add two additional extents. The extents are \n\t\t\t&#39; of the same size as the first extent.\n\t\t\tsequence.LogStore.Extents.Add(&quot;MyExtent1&quot;)\n\t\t\tsequence.LogStore.Extents.Add(&quot;MyExtent2&quot;)\n\t\tEnd Sub\n\n\t\tPublic Sub EnumerateExtents()\n\t\t\tDim store As LogStore = sequence.LogStore\n\n\t\t\tConsole.WriteLine(&quot;Enumerating Log Extents...&quot;)\n\t\t\tConsole.WriteLine(&quot;    Extent Count: {0} extents&quot;, store.Extents.Count)\n\t\t\tConsole.WriteLine(&quot;    Extents Are...&quot;)\n            For Each extent In store.Extents\n                Console.WriteLine(&quot;      {0} ({1}, {2})&quot;, Path.GetFileName(extent.Path), extent.Size, extent.State)\n            Next extent\n\t\t\tConsole.WriteLine(&quot;    Free Extents: {0} Free&quot;, store.Extents.FreeCount)\n\t\tEnd Sub\n\n\t\tPublic Sub SetLogPolicy()\n\t\t\tConsole.WriteLine()\n\t\t\tConsole.WriteLine(&quot;Setting current log policy...&quot;)\n\n\t\t\t&#39; SET LOG POLICY\n\n\t\t\tDim policy As LogPolicy = sequence.LogStore.Policy\n\n\t\t\t&#39; Set AutoGrow policy. This enables the log to automatically grow\n\t\t\t&#39; when the existing extents are full. New extents are added until\n\t\t\t&#39; we reach the MaximumExtentCount extents.\n\t\t\t&#39; AutoGrow policy is supported only in Windows Vista and not available in R2.\n\n\t\t\t&#39;policy.AutoGrow = true;\n\n\t\t\t&#39; Set the Growth Rate in terms of extents. This policy specifies\n\t\t\t&#39; &quot;how much&quot; the log should grow. \n\t\t\tpolicy.GrowthRate = New PolicyUnit(2, PolicyUnitType.Extents)\n\n\t\t\t&#39; Set the AutoShrink policy. This enables the log to automatically\n\t\t\t&#39; shrink if the available free space exceeds the shrink percentage. \n\t\t\t&#39; AutoGrow/shrink policy is supported only in Windows Vista and not available in R2.\n\n\t\t\t&#39;policy.AutoShrinkPercentage = new PolicyUnit(30, PolicyUnitType.Percentage);\n\n\t\t\t&#39; Set the PinnedTailThreshold policy.\n\t\t\t&#39; A tail pinned event is triggered when there is no\n\t\t\t&#39; log space available and log space may be freed by advancing the base.\n\t\t\t&#39; The user must handle the tail pinned event by advancing the base of the log. \n\t\t\t&#39; If the user is not able to move the base of the log, the user should report with exception in\n\t\t\t&#39; the tail pinned handler.\n\t\t\t&#39; PinnedTailThreashold policy dictates the amount of space that the TailPinned event requests \n\t\t\t&#39; for advancing the base of the log. The amount of space can be in percentage or in terms of bytes \n\t\t\t&#39; which is rounded off to the nearest containers in CLFS. The default is 35 percent.\n\n\n\t\t\tpolicy.PinnedTailThreshold = New PolicyUnit(10, PolicyUnitType.Percentage)\n\n\t\t\t&#39; Set the maximum extents the log can have.\n\t\t\tpolicy.MaximumExtentCount = 6\n\n\t\t\t&#39; Set the minimum extents the log can have.\n\t\t\tpolicy.MinimumExtentCount = 2\n\n\t\t\t&#39; Set the prefix for new containers that are added. \n\t\t\t&#39; when AutoGrow is enabled.\n\t\t\t&#39;policy.NewExtentPrefix = &quot;MyLogPrefix&quot;;\n\n\t\t\t&#39; Set the suffix number for new containers that are added.\n\t\t\t&#39; when AutoGrow is enabled. \n\t\t\tpolicy.NextExtentSuffix = 3\n\n\t\t\t&#39; Commit the log policy.\n\t\t\tpolicy.Commit()\n\n\t\t\t&#39; Refresh updates the IO.Log policy properties with current log policy \n\t\t\t&#39; set in the log. \n\t\t\tpolicy.Refresh()\n\n\t\t\t&#39; LOG POLICY END\n\t\t\t&#39; \n\n\t\t\t&#39;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\t\t\t&#39; Setting up IO.Log provided capabilities...\n\t\t\t&#39; \n\n\t\t\t&#39; SET RETRY APPEND\n\n\t\t\t&#39; IO.Log provides a mechanism similar to AutoGrow.\n\t\t\t&#39; If the existing log is full and an append fails, setting RetryAppend\n\t\t\t&#39; invokes the CLFS policy engine to add new extents and re-tries\n\t\t\t&#39; record appends. If MaximumExtent count has been reached, \n\t\t\t&#39; a SequenceFullException is thrown. \n\t\t\t&#39; \n\n\t\t\tsequence.RetryAppend = True\n\n\t\t\t&#39; RETRY APPEND END\n\n\t\t\t&#39; REGISTER FOR TAILPINNED EVENT NOTIFICATIONS\n\n\t\t\t&#39; Register for TailPinned Event by passing in an event handler.\n\t\t\t&#39; An event is raised when the log full condition is reached.\n\t\t\t&#39; The user should either advance the base sequence number to the \n\t\t\t&#39; nearest valid sequence number recommended in the tail pinned event or\n\t\t\t&#39; report a failure that it is not able to advance the base sequence \n\t\t\t&#39; number. \n\t\t\t&#39;\n\n\t\t\tAddHandler sequence.TailPinned, AddressOf HandleTailPinned\n\n\t\t\tConsole.WriteLine(&quot;Done...&quot;)\n\t\tEnd Sub\n\n\t\tPublic Sub ShowLogPolicy()\n\t\t\tConsole.WriteLine()\n\t\t\tConsole.WriteLine(&quot;Showing current log policy...&quot;)\n\n\t\t\tDim policy As LogPolicy = sequence.LogStore.Policy\n\n\t\t\tConsole.WriteLine(&quot;    Minimum extent count:  {0}&quot;, policy.MinimumExtentCount)\n\t\t\tConsole.WriteLine(&quot;    Maximum extent count:  {0}&quot;, policy.MaximumExtentCount)\n\t\t\tConsole.WriteLine(&quot;    Growth rate:           {0}&quot;, policy.GrowthRate)\n\t\t\tConsole.WriteLine(&quot;    Pinned tail threshold: {0}&quot;, policy.PinnedTailThreshold)\n\t\t\tConsole.WriteLine(&quot;    Auto shrink percent:   {0}&quot;, policy.AutoShrinkPercentage)\n\t\t\tConsole.WriteLine(&quot;    Auto grow enabled:     {0}&quot;, policy.AutoGrow)\n\t\t\tConsole.WriteLine(&quot;    New extent prefix:     {0}&quot;, policy.NewExtentPrefix)\n\t\t\tConsole.WriteLine(&quot;    Next extent suffix:    {0}&quot;, policy.NextExtentSuffix)\n\n\t\tEnd Sub\n\n\t\t&#39; Append records. Appending three records.  \n\t\tPublic Sub AppendRecords()\n\t\t\tConsole.WriteLine(&quot;Appending Log Records...&quot;)\n\t\t\tDim previous As SequenceNumber = SequenceNumber.Invalid\n\n\t\t\tprevious = sequence.Append(CreateData(&quot;Hello World!&quot;), SequenceNumber.Invalid, SequenceNumber.Invalid, RecordAppendOptions.ForceFlush)\n\t\t\tprevious = sequence.Append(CreateData(&quot;This is my first Logging App&quot;), SequenceNumber.Invalid, SequenceNumber.Invalid, RecordAppendOptions.ForceFlush)\n\t\t\tprevious = sequence.Append(CreateData(&quot;Using LogRecordSequence...&quot;), SequenceNumber.Invalid, SequenceNumber.Invalid, RecordAppendOptions.ForceFlush)\n\n\t\t\tConsole.WriteLine(&quot;Done...&quot;)\n\t\tEnd Sub\n\n\n\t\t&#39; Read the records added to the log. \n\t\tPublic Sub ReadRecords()\n\t\t\tDim enc As Encoding = Encoding.Unicode\n\n\t\t\tConsole.WriteLine()\n\n\t\t\tConsole.WriteLine(&quot;Reading Log Records...&quot;)\n\t\t\tTry\n\t\t\t\tFor Each record As LogRecord In Me.sequence.ReadLogRecords(Me.sequence.BaseSequenceNumber, LogRecordEnumeratorType.Next)\n\t\t\t\t\tDim data(record.Data.Length - 1) As Byte\n\t\t\t\t\trecord.Data.Read(data, 0, CInt(Fix(record.Data.Length)))\n\t\t\t\t\tDim mystr As String = enc.GetString(data)\n\t\t\t\t\tConsole.WriteLine(&quot;    {0}&quot;, mystr)\n\t\t\t\tNext record\n\t\t\tCatch e As Exception\n\t\t\t\tConsole.WriteLine(&quot;Exception {0} {1}&quot;, e.GetType(), e.Message)\n\t\t\tEnd Try\n\n\t\t\tConsole.WriteLine()\n\t\tEnd Sub\n\n\t\tPublic Sub FillLog()\n\t\t\tDim append As Boolean = True\n\n\t\t\tDo While append\n\t\t\t\tTry\n\t\t\t\t\tsequence.Append(CreateData(16 * 1024), SequenceNumber.Invalid, SequenceNumber.Invalid, RecordAppendOptions.ForceFlush)\n\n\t\t\t\tCatch e1 As SequenceFullException\n\t\t\t\t\tConsole.WriteLine(&quot;Log is Full...&quot;)\n\t\t\t\t\tappend = False\n\t\t\t\tEnd Try\n\t\t\tLoop\n\t\tEnd Sub\n\n\t\t&#39; Dispose the record sequence and delete the log file. \n\t\tPublic Sub Cleanup()\n\t\t\t&#39; Dispose the sequence\n\t\t\tsequence.Dispose()\n\n\t\t\t&#39; Delete the log file.\n\t\t\tIf delete Then\n\t\t\t\tTry\n\t\t\t\t\t&#39; This deletes the base log file and all the extents associated with the log.\n\t\t\t\t\tLogStore.Delete(Me.logName)\n\t\t\t\tCatch e As Exception\n\t\t\t\t\tConsole.WriteLine(&quot;Exception {0} {1}&quot;, e.GetType(), e.Message)\n\t\t\t\tEnd Try\n\t\t\tEnd If\n\t\tEnd Sub\n\n\t\t&#39; Converts the given data to an Array of ArraySegment&lt;byte&gt; \n\t\tPublic Shared Function CreateData(ByVal str As String) As IList(Of ArraySegment(Of Byte))\n\t\t\tDim enc As Encoding = Encoding.Unicode\n\n\t\t\tDim array() As Byte = enc.GetBytes(str)\n\n\t\t\tDim segments(0) As ArraySegment(Of Byte)\n\t\t\tsegments(0) = New ArraySegment(Of Byte)(array)\n\n            Return System.Array.AsReadOnly(Of ArraySegment(Of Byte))(segments)\n\t\tEnd Function\n\n\t\tPublic Shared Function CreateData(ByVal size As Integer) As IList(Of ArraySegment(Of Byte))\n\t\t\tDim array(size - 1) As Byte\n\n\t\t\tDim rand As New Random()\n\t\t\trand.NextBytes(array)\n\n\t\t\tDim segments(0) As ArraySegment(Of Byte)\n\t\t\tsegments(0) = New ArraySegment(Of Byte)(array)\n\n            Return System.Array.AsReadOnly(Of ArraySegment(Of Byte))(segments)\n\t\tEnd Function\n\n\t\tPublic Shared Function GetAdvanceBaseSeqNumber(ByVal recTargetSeqNum As SequenceNumber) As SequenceNumber\n\t\t\tDim targetSequenceNumber As SequenceNumber = SequenceNumber.Invalid\n\n\t\t\tConsole.WriteLine(&quot;Getting actual target sequence number...&quot;)\n\n\t\t\t&#39; \n\t\t\t&#39; Implement the logic for returning a valid sequence number closer to\n\t\t\t&#39; recommended target sequence number. \n\t\t\t&#39;\n\n\t\t\tReturn targetSequenceNumber\n\t\tEnd Function\n\n\t\tPublic Shared Sub HandleTailPinned(ByVal arg As Object, ByVal tailPinnedEventArgs As TailPinnedEventArgs)\n\t\t\tConsole.WriteLine(&quot;TailPinned has fired&quot;)\n\n\t\t\t&#39; Based on the implementation of a logging application, the log base can be moved\n\t\t\t&#39; to free up more log space and if it is not possible to move the \n\t\t\t&#39; base, the application should report by throwing an exception.\n\n\t\t\tIf MyLog.AdvanceBase Then\n\t\t\t\tTry\n\t\t\t\t\t&#39; TailPnnedEventArgs has the recommended sequence number and its generated \n\t\t\t\t\t&#39; based on PinnedTailThreshold policy. \n\t\t\t\t\t&#39; This does not map to an actual sequence number in the record sequence\n\t\t\t\t\t&#39; but an approximation and potentially frees up the threshold % log space\n\t\t\t\t\t&#39; when the log base is advanced to a valid sequence number closer to the \n\t\t\t\t\t&#39; recommended sequence number. \n\t\t\t\t\t&#39; The user should use this sequence number to locate a closest valid sequence\n\t\t\t\t\t&#39; number to advance the base of the log.\n\n\t\t\t\t\tDim recommendedTargetSeqNum As SequenceNumber = tailPinnedEventArgs.TargetSequenceNumber\n\n\t\t\t\t\t&#39; Get the actual Target sequence number.\n\t\t\t\t\tDim actualTargetSeqNum As SequenceNumber = MyLog.GetAdvanceBaseSeqNumber(recommendedTargetSeqNum)\n\n\t\t\t\t\tMySequence.AdvanceBaseSequenceNumber(actualTargetSeqNum)\n\t\t\t\tCatch e As Exception\n\t\t\t\t\tConsole.WriteLine(&quot;Exception thrown {0} {1}&quot;, e.GetType(), e.Message)\n\t\t\t\tEnd Try\n\t\t\tElse\n\t\t\t\t&#39; Report back Error if under some conditions the log cannot\n\t\t\t\t&#39; advance the base sequence number.\n\n\t\t\t\tConsole.WriteLine(&quot;Reporting Error! Unable to move the base sequence number!&quot;)\n\t\t\t\tThrow New IOException()\n\t\t\tEnd If\n\t\tEnd Sub\n\tEnd Class\n\n\tFriend Class LogSample\n\t\tShared Sub Main(ByVal args() As String)\n\t\t\t&#39; Create log record sequence.\n\t\t\tDim log As New MyLog()\n\n\t\t\t&#39; Add additional extents.\n\t\t\tlog.AddExtents()\n\n\t\t\t&#39; Enumerate the current log extents.\n\t\t\tlog.EnumerateExtents()\n\n\t\t\t&#39; Set log policies and register for TailPinned event notifications. \n\t\t\tlog.SetLogPolicy()\n\n\t\t\tlog.ShowLogPolicy()\n\n\t\t\t&#39; Append a few records and read the appended records. \n\t\t\tlog.AppendRecords()\n\t\t\tlog.ReadRecords()\n\n\t\t\t&#39; Fill the Log to trigger log growth...and subsequent TailPinned notifications.\n\t\t\tlog.FillLog()\n\n\t\t\tlog.EnumerateExtents()\n\n\t\t\tlog.Cleanup()\n\t\tEnd Sub\n\tEnd Class\nEnd Namespace\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_IO_Log_LogExtent_Size\">\r\n    \r\n            <a id=\"System_IO_Log_LogExtent_Size_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Size</div>        \r\n          </div>\r\n    \r\n            <p>Gets the size of this <a class=\"xref\" href=\"system.io.log.logextent\" data-linktype=\"relative-path\">LogExtent</a> instance, in bytes.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public long Size { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int64\" data-linktype=\"relative-path\">Int64</a></div>\r\n                  </div>\r\n                  <p>The size of this <a class=\"xref\" href=\"system.io.log.logextent\" data-linktype=\"relative-path\">LogExtent</a> instance, in bytes.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>This example shows how to use the <a class=\"xref\" href=\"system.io.log.logextent\" data-linktype=\"relative-path\">LogExtent</a> class to add and emulate extents in a log sequence.  </p>\n<pre><code class=\"lang-cs\" name=\"S_UELogRecordSequence#0\">using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.IO.Log;\n\nnamespace MyLogRecordSequence\n{\n    public class MyLog\n    {\n        string logName = &quot;test.log&quot;;\n        string logContainer = &quot;MyExtent0&quot;;\n        int containerSize = 32 * 1024;\n        LogRecordSequence sequence = null;\n        bool delete = true;\n\n        // These are used in the TailPinned event handler.\n        public static LogRecordSequence MySequence = null;\n        public static bool AdvanceBase = true;\n\n        public MyLog()\n        {\n            // Create a LogRecordSequence.\n            sequence = new LogRecordSequence(this.logName,\n                                              FileMode.CreateNew,\n                                              FileAccess.ReadWrite,\n                                              FileShare.None);\n\n            // At least one container/extent must be added for Log Record Sequence.\n            sequence.LogStore.Extents.Add(this.logContainer, this.containerSize);\n     \n            MySequence = sequence;\n\n        }\n\n        public void AddExtents()\n        {\n            // Add two additional extents. The extents are \n            // of the same size as the first extent.\n            sequence.LogStore.Extents.Add(&quot;MyExtent1&quot;);\n            sequence.LogStore.Extents.Add(&quot;MyExtent2&quot;);\n        }\n\n        public void EnumerateExtents()\n        {\n            LogStore store = sequence.LogStore;\n\n            Console.WriteLine(&quot;Enumerating Log Extents...&quot;);\n            Console.WriteLine(&quot;    Extent Count: {0} extents&quot;, store.Extents.Count);\n            Console.WriteLine(&quot;    Extents Are...&quot;);\n            foreach (LogExtent extent in store.Extents)\n            {\n                Console.WriteLine(&quot;      {0} ({1}, {2})&quot;,\n                                  Path.GetFileName(extent.Path),\n                                  extent.Size,\n                                  extent.State);\n            }\n            Console.WriteLine(&quot;    Free Extents: {0} Free&quot;, store.Extents.FreeCount);   \n        }\n\n        public void SetLogPolicy()\n        {\n            Console.WriteLine();\n            Console.WriteLine(&quot;Setting current log policy...&quot;);\n\n            // SET LOG POLICY\n\n            LogPolicy policy = sequence.LogStore.Policy;\n\n            // Set AutoGrow policy. This enables the log to automatically grow\n            // when the existing extents are full. New extents are added until\n            // we reach the MaximumExtentCount extents.\n            // AutoGrow policy is supported only in Windows Vista and not available in R2.\n            \n            //policy.AutoGrow = true;\n\n            // Set the Growth Rate in terms of extents. This policy specifies\n            // &quot;how much&quot; the log should grow. \n            policy.GrowthRate = new PolicyUnit(2, PolicyUnitType.Extents);\n\n            // Set the AutoShrink policy. This enables the log to automatically\n            // shrink if the available free space exceeds the shrink percentage. \n            // AutoGrow/shrink policy is supported only in Windows Vista and not available in R2.\n            \n            //policy.AutoShrinkPercentage = new PolicyUnit(30, PolicyUnitType.Percentage);\n\n            // Set the PinnedTailThreshold policy.\n            // A tail pinned event is triggered when there is no\n            // log space available and log space may be freed by advancing the base.\n            // The user must handle the tail pinned event by advancing the base of the log. \n            // If the user is not able to move the base of the log, the user should report with exception in\n            // the tail pinned handler.\n            // PinnedTailThreashold policy dictates the amount of space that the TailPinned event requests \n            // for advancing the base of the log. The amount of space can be in percentage or in terms of bytes \n            // which is rounded off to the nearest containers in CLFS. The default is 35 percent.\n\n            \n            policy.PinnedTailThreshold = new PolicyUnit(10, PolicyUnitType.Percentage);\n\n            // Set the maximum extents the log can have.\n            policy.MaximumExtentCount = 6;\n            \n            // Set the minimum extents the log can have.\n            policy.MinimumExtentCount = 2;\n            \n            // Set the prefix for new containers that are added. \n            // when AutoGrow is enabled.\n            //policy.NewExtentPrefix = &quot;MyLogPrefix&quot;;\n            \n            // Set the suffix number for new containers that are added.\n            // when AutoGrow is enabled. \n            policy.NextExtentSuffix = 3;\n\n            // Commit the log policy.\n            policy.Commit();\n\n            // Refresh updates the IO.Log policy properties with current log policy \n            // set in the log. \n            policy.Refresh();\n\n            // LOG POLICY END\n            // \n\n            //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n            // Setting up IO.Log provided capabilities...\n            // \n\n            // SET RETRY APPEND\n\n            // IO.Log provides a mechanism similar to AutoGrow.\n            // If the existing log is full and an append fails, setting RetryAppend\n            // invokes the CLFS policy engine to add new extents and re-tries\n            // record appends. If MaximumExtent count has been reached, \n            // a SequenceFullException is thrown. \n            // \n\n            sequence.RetryAppend = true;\n\n            // RETRY APPEND END\n\n            // REGISTER FOR TAILPINNED EVENT NOTIFICATIONS\n\n            // Register for TailPinned Event by passing in an event handler.\n            // An event is raised when the log full condition is reached.\n            // The user should either advance the base sequence number to the \n            // nearest valid sequence number recommended in the tail pinned event or\n            // report a failure that it is not able to advance the base sequence \n            // number. \n            //\n\n            sequence.TailPinned += new EventHandler&lt;TailPinnedEventArgs&gt;(HandleTailPinned);  \n\n            Console.WriteLine(&quot;Done...&quot;);\n        }\n\n        public void ShowLogPolicy()\n        {\n            Console.WriteLine();\n            Console.WriteLine(&quot;Showing current log policy...&quot;);\n\n            LogPolicy policy = sequence.LogStore.Policy;\n\n            Console.WriteLine(&quot;    Minimum extent count:  {0}&quot;, policy.MinimumExtentCount);\n            Console.WriteLine(&quot;    Maximum extent count:  {0}&quot;, policy.MaximumExtentCount);\n            Console.WriteLine(&quot;    Growth rate:           {0}&quot;, policy.GrowthRate);\n            Console.WriteLine(&quot;    Pinned tail threshold: {0}&quot;, policy.PinnedTailThreshold);\n            Console.WriteLine(&quot;    Auto shrink percent:   {0}&quot;, policy.AutoShrinkPercentage);\n            Console.WriteLine(&quot;    Auto grow enabled:     {0}&quot;, policy.AutoGrow);\n            Console.WriteLine(&quot;    New extent prefix:     {0}&quot;, policy.NewExtentPrefix);\n            Console.WriteLine(&quot;    Next extent suffix:    {0}&quot;, policy.NextExtentSuffix);\n\n\t}\n\n        // Append records. Appending three records.  \n        public void AppendRecords()\n        {\n            Console.WriteLine(&quot;Appending Log Records...&quot;);\n            SequenceNumber previous = SequenceNumber.Invalid;\n\n            previous = sequence.Append(CreateData(&quot;Hello World!&quot;), SequenceNumber.Invalid, SequenceNumber.Invalid, RecordAppendOptions.ForceFlush);\n            previous = sequence.Append(CreateData(&quot;This is my first Logging App&quot;), SequenceNumber.Invalid, SequenceNumber.Invalid, RecordAppendOptions.ForceFlush);\n            previous = sequence.Append(CreateData(&quot;Using LogRecordSequence...&quot;), SequenceNumber.Invalid, SequenceNumber.Invalid, RecordAppendOptions.ForceFlush);\n\t    \n            Console.WriteLine(&quot;Done...&quot;);\n        }\n\n\n        // Read the records added to the log. \n        public void ReadRecords()\n        {\n            Encoding enc = Encoding.Unicode;\n\n            Console.WriteLine();\n\n            Console.WriteLine(&quot;Reading Log Records...&quot;);\n            try\n            {\n                foreach (LogRecord record in this.sequence.ReadLogRecords(this.sequence.BaseSequenceNumber, LogRecordEnumeratorType.Next))\n                {\n                    byte[] data = new byte[record.Data.Length];\n                    record.Data.Read(data, 0, (int)record.Data.Length);\n                    string mystr = enc.GetString(data);\n                    Console.WriteLine(&quot;    {0}&quot;, mystr);\n                }\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(&quot;Exception {0} {1}&quot;, e.GetType(), e.Message);\n            }\n\n            Console.WriteLine();\n        }\n\n        public void FillLog()\n        {\n            bool append = true;\n\n            while (append)\n            {\n                try\n                {\n                    sequence.Append(CreateData(16 * 1024), SequenceNumber.Invalid, SequenceNumber.Invalid, RecordAppendOptions.ForceFlush);\n                }\n\n                catch (SequenceFullException)\n                {\n                    Console.WriteLine(&quot;Log is Full...&quot;);\n                    append = false;\n                }\n            }\n        }\n\n        // Dispose the record sequence and delete the log file. \n        public void Cleanup()\n        {\n            // Dispose the sequence\n            sequence.Dispose();\n\n            // Delete the log file.\n            if (delete)\n            {\n                try\n                {\n                    // This deletes the base log file and all the extents associated with the log.\n                    LogStore.Delete(this.logName);\n                }\n                catch (Exception e)\n                {\n                    Console.WriteLine(&quot;Exception {0} {1}&quot;, e.GetType(), e.Message);\n                }\n            }\n        }\n\n        // Converts the given data to an Array of ArraySegment&lt;byte&gt; \n        public static IList&lt;ArraySegment&lt;byte&gt;&gt; CreateData(string str)\n        {\n            Encoding enc = Encoding.Unicode;\n\n            byte[] array = enc.GetBytes(str);\n\n            ArraySegment&lt;byte&gt;[] segments = new ArraySegment&lt;byte&gt;[1];\n            segments[0] = new ArraySegment&lt;byte&gt;(array);\n\n            return Array.AsReadOnly&lt;ArraySegment&lt;byte&gt;&gt;(segments);\n        }\n\n        public static IList&lt;ArraySegment&lt;byte&gt;&gt; CreateData(int size)\n        {\n            byte[] array = new byte[size];\n\n            Random rnd = new Random();\n            rnd.NextBytes(array);\n\n            ArraySegment&lt;byte&gt;[] segments = new ArraySegment&lt;byte&gt;[1];\n            segments[0] = new ArraySegment&lt;byte&gt;(array);\n\n            return Array.AsReadOnly&lt;ArraySegment&lt;byte&gt;&gt;(segments);\n        }\n\n        public static SequenceNumber GetAdvanceBaseSeqNumber(SequenceNumber recTargetSeqNum)\n        {\n            SequenceNumber targetSequenceNumber = SequenceNumber.Invalid;\n\n            Console.WriteLine(&quot;Getting actual target sequence number...&quot;);\n            \n            // \n            // Implement the logic for returning a valid sequence number closer to\n            // recommended target sequence number. \n            //\n\n            return targetSequenceNumber;\n        }\n\n        public static void HandleTailPinned(object arg, TailPinnedEventArgs tailPinnedEventArgs)\n        {\n            Console.WriteLine(&quot;TailPinned has fired&quot;);\n\n            // Based on the implementation of a logging application, the log base can be moved\n            // to free up more log space and if it is not possible to move the \n            // base, the application should report by throwing an exception.\n\n            if(MyLog.AdvanceBase)\n            {\n                try\n                {\n                    // TailPnnedEventArgs has the recommended sequence number and its generated \n                    // based on PinnedTailThreshold policy. \n                    // This does not map to an actual sequence number in the record sequence\n                    // but an approximation and potentially frees up the threshold % log space\n                    // when the log base is advanced to a valid sequence number closer to the \n                    // recommended sequence number. \n                    // The user should use this sequence number to locate a closest valid sequence\n                    // number to advance the base of the log.\n\n                    SequenceNumber recommendedTargetSeqNum = tailPinnedEventArgs.TargetSequenceNumber; \n                    \n                    // Get the actual Target sequence number.\n                    SequenceNumber actualTargetSeqNum = MyLog.GetAdvanceBaseSeqNumber(recommendedTargetSeqNum);\n\n                    MySequence.AdvanceBaseSequenceNumber(actualTargetSeqNum);\n                }\n                catch (Exception e)\n                {\n                    Console.WriteLine(&quot;Exception thrown {0} {1}&quot;, e.GetType(), e.Message);\n                }\n            }\n            else\n            {\n                // Report back Error if under some conditions the log cannot\n                // advance the base sequence number.\n\n                Console.WriteLine(&quot;Reporting Error! Unable to move the base sequence number!&quot;);\n                throw new IOException();\n            }\n        }\n    }\n\n    class LogSample\n    {\n        static void Main(string[] args)\n        {\n            // Create log record sequence.\n            MyLog log = new MyLog();\n\n            // Add additional extents.\n            log.AddExtents();\n\n            // Enumerate the current log extents.\n            log.EnumerateExtents();\n\n            // Set log policies and register for TailPinned event notifications. \n            log.SetLogPolicy();\n\n            log.ShowLogPolicy();\n            \n            // Append a few records and read the appended records. \n            log.AppendRecords();\n            log.ReadRecords();\n\n            // Fill the Log to trigger log growth...and subsequent TailPinned notifications.\n            log.FillLog();\n\n            log.EnumerateExtents();\n\n            log.Cleanup();\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"S_UELogRecordSequence#0\">\nImports System\nImports System.IO\nImports System.Collections.Generic\nImports System.Text\nImports System.IO.Log\n\nNamespace MyLogRecordSequence\n\tPublic Class MyLog\n\t\tPrivate logName As String = &quot;test.log&quot;\n\t\tPrivate logContainer As String = &quot;MyExtent0&quot;\n\t\tPrivate containerSize As Integer = 32 * 1024\n\t\tPrivate sequence As LogRecordSequence = Nothing\n\t\tPrivate delete As Boolean = True\n\n\t\t&#39; These are used in the TailPinned event handler.\n\t\tPublic Shared MySequence As LogRecordSequence = Nothing\n\t\tPublic Shared AdvanceBase As Boolean = True\n\n\t\tPublic Sub New()\n\t\t\t&#39; Create a LogRecordSequence.\n\t\t\tsequence = New LogRecordSequence(Me.logName, FileMode.CreateNew, FileAccess.ReadWrite, FileShare.None)\n\n\t\t\t&#39; At least one container/extent must be added for Log Record Sequence.\n\t\t\tsequence.LogStore.Extents.Add(Me.logContainer, Me.containerSize)\n\n\t\t\tMySequence = sequence\n\n\t\tEnd Sub\n\n\t\tPublic Sub AddExtents()\n\t\t\t&#39; Add two additional extents. The extents are \n\t\t\t&#39; of the same size as the first extent.\n\t\t\tsequence.LogStore.Extents.Add(&quot;MyExtent1&quot;)\n\t\t\tsequence.LogStore.Extents.Add(&quot;MyExtent2&quot;)\n\t\tEnd Sub\n\n\t\tPublic Sub EnumerateExtents()\n\t\t\tDim store As LogStore = sequence.LogStore\n\n\t\t\tConsole.WriteLine(&quot;Enumerating Log Extents...&quot;)\n\t\t\tConsole.WriteLine(&quot;    Extent Count: {0} extents&quot;, store.Extents.Count)\n\t\t\tConsole.WriteLine(&quot;    Extents Are...&quot;)\n            For Each extent In store.Extents\n                Console.WriteLine(&quot;      {0} ({1}, {2})&quot;, Path.GetFileName(extent.Path), extent.Size, extent.State)\n            Next extent\n\t\t\tConsole.WriteLine(&quot;    Free Extents: {0} Free&quot;, store.Extents.FreeCount)\n\t\tEnd Sub\n\n\t\tPublic Sub SetLogPolicy()\n\t\t\tConsole.WriteLine()\n\t\t\tConsole.WriteLine(&quot;Setting current log policy...&quot;)\n\n\t\t\t&#39; SET LOG POLICY\n\n\t\t\tDim policy As LogPolicy = sequence.LogStore.Policy\n\n\t\t\t&#39; Set AutoGrow policy. This enables the log to automatically grow\n\t\t\t&#39; when the existing extents are full. New extents are added until\n\t\t\t&#39; we reach the MaximumExtentCount extents.\n\t\t\t&#39; AutoGrow policy is supported only in Windows Vista and not available in R2.\n\n\t\t\t&#39;policy.AutoGrow = true;\n\n\t\t\t&#39; Set the Growth Rate in terms of extents. This policy specifies\n\t\t\t&#39; &quot;how much&quot; the log should grow. \n\t\t\tpolicy.GrowthRate = New PolicyUnit(2, PolicyUnitType.Extents)\n\n\t\t\t&#39; Set the AutoShrink policy. This enables the log to automatically\n\t\t\t&#39; shrink if the available free space exceeds the shrink percentage. \n\t\t\t&#39; AutoGrow/shrink policy is supported only in Windows Vista and not available in R2.\n\n\t\t\t&#39;policy.AutoShrinkPercentage = new PolicyUnit(30, PolicyUnitType.Percentage);\n\n\t\t\t&#39; Set the PinnedTailThreshold policy.\n\t\t\t&#39; A tail pinned event is triggered when there is no\n\t\t\t&#39; log space available and log space may be freed by advancing the base.\n\t\t\t&#39; The user must handle the tail pinned event by advancing the base of the log. \n\t\t\t&#39; If the user is not able to move the base of the log, the user should report with exception in\n\t\t\t&#39; the tail pinned handler.\n\t\t\t&#39; PinnedTailThreashold policy dictates the amount of space that the TailPinned event requests \n\t\t\t&#39; for advancing the base of the log. The amount of space can be in percentage or in terms of bytes \n\t\t\t&#39; which is rounded off to the nearest containers in CLFS. The default is 35 percent.\n\n\n\t\t\tpolicy.PinnedTailThreshold = New PolicyUnit(10, PolicyUnitType.Percentage)\n\n\t\t\t&#39; Set the maximum extents the log can have.\n\t\t\tpolicy.MaximumExtentCount = 6\n\n\t\t\t&#39; Set the minimum extents the log can have.\n\t\t\tpolicy.MinimumExtentCount = 2\n\n\t\t\t&#39; Set the prefix for new containers that are added. \n\t\t\t&#39; when AutoGrow is enabled.\n\t\t\t&#39;policy.NewExtentPrefix = &quot;MyLogPrefix&quot;;\n\n\t\t\t&#39; Set the suffix number for new containers that are added.\n\t\t\t&#39; when AutoGrow is enabled. \n\t\t\tpolicy.NextExtentSuffix = 3\n\n\t\t\t&#39; Commit the log policy.\n\t\t\tpolicy.Commit()\n\n\t\t\t&#39; Refresh updates the IO.Log policy properties with current log policy \n\t\t\t&#39; set in the log. \n\t\t\tpolicy.Refresh()\n\n\t\t\t&#39; LOG POLICY END\n\t\t\t&#39; \n\n\t\t\t&#39;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\t\t\t&#39; Setting up IO.Log provided capabilities...\n\t\t\t&#39; \n\n\t\t\t&#39; SET RETRY APPEND\n\n\t\t\t&#39; IO.Log provides a mechanism similar to AutoGrow.\n\t\t\t&#39; If the existing log is full and an append fails, setting RetryAppend\n\t\t\t&#39; invokes the CLFS policy engine to add new extents and re-tries\n\t\t\t&#39; record appends. If MaximumExtent count has been reached, \n\t\t\t&#39; a SequenceFullException is thrown. \n\t\t\t&#39; \n\n\t\t\tsequence.RetryAppend = True\n\n\t\t\t&#39; RETRY APPEND END\n\n\t\t\t&#39; REGISTER FOR TAILPINNED EVENT NOTIFICATIONS\n\n\t\t\t&#39; Register for TailPinned Event by passing in an event handler.\n\t\t\t&#39; An event is raised when the log full condition is reached.\n\t\t\t&#39; The user should either advance the base sequence number to the \n\t\t\t&#39; nearest valid sequence number recommended in the tail pinned event or\n\t\t\t&#39; report a failure that it is not able to advance the base sequence \n\t\t\t&#39; number. \n\t\t\t&#39;\n\n\t\t\tAddHandler sequence.TailPinned, AddressOf HandleTailPinned\n\n\t\t\tConsole.WriteLine(&quot;Done...&quot;)\n\t\tEnd Sub\n\n\t\tPublic Sub ShowLogPolicy()\n\t\t\tConsole.WriteLine()\n\t\t\tConsole.WriteLine(&quot;Showing current log policy...&quot;)\n\n\t\t\tDim policy As LogPolicy = sequence.LogStore.Policy\n\n\t\t\tConsole.WriteLine(&quot;    Minimum extent count:  {0}&quot;, policy.MinimumExtentCount)\n\t\t\tConsole.WriteLine(&quot;    Maximum extent count:  {0}&quot;, policy.MaximumExtentCount)\n\t\t\tConsole.WriteLine(&quot;    Growth rate:           {0}&quot;, policy.GrowthRate)\n\t\t\tConsole.WriteLine(&quot;    Pinned tail threshold: {0}&quot;, policy.PinnedTailThreshold)\n\t\t\tConsole.WriteLine(&quot;    Auto shrink percent:   {0}&quot;, policy.AutoShrinkPercentage)\n\t\t\tConsole.WriteLine(&quot;    Auto grow enabled:     {0}&quot;, policy.AutoGrow)\n\t\t\tConsole.WriteLine(&quot;    New extent prefix:     {0}&quot;, policy.NewExtentPrefix)\n\t\t\tConsole.WriteLine(&quot;    Next extent suffix:    {0}&quot;, policy.NextExtentSuffix)\n\n\t\tEnd Sub\n\n\t\t&#39; Append records. Appending three records.  \n\t\tPublic Sub AppendRecords()\n\t\t\tConsole.WriteLine(&quot;Appending Log Records...&quot;)\n\t\t\tDim previous As SequenceNumber = SequenceNumber.Invalid\n\n\t\t\tprevious = sequence.Append(CreateData(&quot;Hello World!&quot;), SequenceNumber.Invalid, SequenceNumber.Invalid, RecordAppendOptions.ForceFlush)\n\t\t\tprevious = sequence.Append(CreateData(&quot;This is my first Logging App&quot;), SequenceNumber.Invalid, SequenceNumber.Invalid, RecordAppendOptions.ForceFlush)\n\t\t\tprevious = sequence.Append(CreateData(&quot;Using LogRecordSequence...&quot;), SequenceNumber.Invalid, SequenceNumber.Invalid, RecordAppendOptions.ForceFlush)\n\n\t\t\tConsole.WriteLine(&quot;Done...&quot;)\n\t\tEnd Sub\n\n\n\t\t&#39; Read the records added to the log. \n\t\tPublic Sub ReadRecords()\n\t\t\tDim enc As Encoding = Encoding.Unicode\n\n\t\t\tConsole.WriteLine()\n\n\t\t\tConsole.WriteLine(&quot;Reading Log Records...&quot;)\n\t\t\tTry\n\t\t\t\tFor Each record As LogRecord In Me.sequence.ReadLogRecords(Me.sequence.BaseSequenceNumber, LogRecordEnumeratorType.Next)\n\t\t\t\t\tDim data(record.Data.Length - 1) As Byte\n\t\t\t\t\trecord.Data.Read(data, 0, CInt(Fix(record.Data.Length)))\n\t\t\t\t\tDim mystr As String = enc.GetString(data)\n\t\t\t\t\tConsole.WriteLine(&quot;    {0}&quot;, mystr)\n\t\t\t\tNext record\n\t\t\tCatch e As Exception\n\t\t\t\tConsole.WriteLine(&quot;Exception {0} {1}&quot;, e.GetType(), e.Message)\n\t\t\tEnd Try\n\n\t\t\tConsole.WriteLine()\n\t\tEnd Sub\n\n\t\tPublic Sub FillLog()\n\t\t\tDim append As Boolean = True\n\n\t\t\tDo While append\n\t\t\t\tTry\n\t\t\t\t\tsequence.Append(CreateData(16 * 1024), SequenceNumber.Invalid, SequenceNumber.Invalid, RecordAppendOptions.ForceFlush)\n\n\t\t\t\tCatch e1 As SequenceFullException\n\t\t\t\t\tConsole.WriteLine(&quot;Log is Full...&quot;)\n\t\t\t\t\tappend = False\n\t\t\t\tEnd Try\n\t\t\tLoop\n\t\tEnd Sub\n\n\t\t&#39; Dispose the record sequence and delete the log file. \n\t\tPublic Sub Cleanup()\n\t\t\t&#39; Dispose the sequence\n\t\t\tsequence.Dispose()\n\n\t\t\t&#39; Delete the log file.\n\t\t\tIf delete Then\n\t\t\t\tTry\n\t\t\t\t\t&#39; This deletes the base log file and all the extents associated with the log.\n\t\t\t\t\tLogStore.Delete(Me.logName)\n\t\t\t\tCatch e As Exception\n\t\t\t\t\tConsole.WriteLine(&quot;Exception {0} {1}&quot;, e.GetType(), e.Message)\n\t\t\t\tEnd Try\n\t\t\tEnd If\n\t\tEnd Sub\n\n\t\t&#39; Converts the given data to an Array of ArraySegment&lt;byte&gt; \n\t\tPublic Shared Function CreateData(ByVal str As String) As IList(Of ArraySegment(Of Byte))\n\t\t\tDim enc As Encoding = Encoding.Unicode\n\n\t\t\tDim array() As Byte = enc.GetBytes(str)\n\n\t\t\tDim segments(0) As ArraySegment(Of Byte)\n\t\t\tsegments(0) = New ArraySegment(Of Byte)(array)\n\n            Return System.Array.AsReadOnly(Of ArraySegment(Of Byte))(segments)\n\t\tEnd Function\n\n\t\tPublic Shared Function CreateData(ByVal size As Integer) As IList(Of ArraySegment(Of Byte))\n\t\t\tDim array(size - 1) As Byte\n\n\t\t\tDim rand As New Random()\n\t\t\trand.NextBytes(array)\n\n\t\t\tDim segments(0) As ArraySegment(Of Byte)\n\t\t\tsegments(0) = New ArraySegment(Of Byte)(array)\n\n            Return System.Array.AsReadOnly(Of ArraySegment(Of Byte))(segments)\n\t\tEnd Function\n\n\t\tPublic Shared Function GetAdvanceBaseSeqNumber(ByVal recTargetSeqNum As SequenceNumber) As SequenceNumber\n\t\t\tDim targetSequenceNumber As SequenceNumber = SequenceNumber.Invalid\n\n\t\t\tConsole.WriteLine(&quot;Getting actual target sequence number...&quot;)\n\n\t\t\t&#39; \n\t\t\t&#39; Implement the logic for returning a valid sequence number closer to\n\t\t\t&#39; recommended target sequence number. \n\t\t\t&#39;\n\n\t\t\tReturn targetSequenceNumber\n\t\tEnd Function\n\n\t\tPublic Shared Sub HandleTailPinned(ByVal arg As Object, ByVal tailPinnedEventArgs As TailPinnedEventArgs)\n\t\t\tConsole.WriteLine(&quot;TailPinned has fired&quot;)\n\n\t\t\t&#39; Based on the implementation of a logging application, the log base can be moved\n\t\t\t&#39; to free up more log space and if it is not possible to move the \n\t\t\t&#39; base, the application should report by throwing an exception.\n\n\t\t\tIf MyLog.AdvanceBase Then\n\t\t\t\tTry\n\t\t\t\t\t&#39; TailPnnedEventArgs has the recommended sequence number and its generated \n\t\t\t\t\t&#39; based on PinnedTailThreshold policy. \n\t\t\t\t\t&#39; This does not map to an actual sequence number in the record sequence\n\t\t\t\t\t&#39; but an approximation and potentially frees up the threshold % log space\n\t\t\t\t\t&#39; when the log base is advanced to a valid sequence number closer to the \n\t\t\t\t\t&#39; recommended sequence number. \n\t\t\t\t\t&#39; The user should use this sequence number to locate a closest valid sequence\n\t\t\t\t\t&#39; number to advance the base of the log.\n\n\t\t\t\t\tDim recommendedTargetSeqNum As SequenceNumber = tailPinnedEventArgs.TargetSequenceNumber\n\n\t\t\t\t\t&#39; Get the actual Target sequence number.\n\t\t\t\t\tDim actualTargetSeqNum As SequenceNumber = MyLog.GetAdvanceBaseSeqNumber(recommendedTargetSeqNum)\n\n\t\t\t\t\tMySequence.AdvanceBaseSequenceNumber(actualTargetSeqNum)\n\t\t\t\tCatch e As Exception\n\t\t\t\t\tConsole.WriteLine(&quot;Exception thrown {0} {1}&quot;, e.GetType(), e.Message)\n\t\t\t\tEnd Try\n\t\t\tElse\n\t\t\t\t&#39; Report back Error if under some conditions the log cannot\n\t\t\t\t&#39; advance the base sequence number.\n\n\t\t\t\tConsole.WriteLine(&quot;Reporting Error! Unable to move the base sequence number!&quot;)\n\t\t\t\tThrow New IOException()\n\t\t\tEnd If\n\t\tEnd Sub\n\tEnd Class\n\n\tFriend Class LogSample\n\t\tShared Sub Main(ByVal args() As String)\n\t\t\t&#39; Create log record sequence.\n\t\t\tDim log As New MyLog()\n\n\t\t\t&#39; Add additional extents.\n\t\t\tlog.AddExtents()\n\n\t\t\t&#39; Enumerate the current log extents.\n\t\t\tlog.EnumerateExtents()\n\n\t\t\t&#39; Set log policies and register for TailPinned event notifications. \n\t\t\tlog.SetLogPolicy()\n\n\t\t\tlog.ShowLogPolicy()\n\n\t\t\t&#39; Append a few records and read the appended records. \n\t\t\tlog.AppendRecords()\n\t\t\tlog.ReadRecords()\n\n\t\t\t&#39; Fill the Log to trigger log growth...and subsequent TailPinned notifications.\n\t\t\tlog.FillLog()\n\n\t\t\tlog.EnumerateExtents()\n\n\t\t\tlog.Cleanup()\n\t\tEnd Sub\n\tEnd Class\nEnd Namespace\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_IO_Log_LogExtent_State\">\r\n    \r\n            <a id=\"System_IO_Log_LogExtent_State_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">State</div>        \r\n          </div>\r\n    \r\n            <p>Gets the state of this <a class=\"xref\" href=\"system.io.log.logextent\" data-linktype=\"relative-path\">LogExtent</a> instance.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.IO.Log.LogExtentState State { get; }</code></pre>\r\n    \r\n    \r\n    \r\n    \r\n              <h4>Property Value</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.log.logextentstate\" data-linktype=\"relative-path\">LogExtentState</a></div>\r\n                  </div>\r\n                  <p>The state of this <a class=\"xref\" href=\"system.io.log.logextent\" data-linktype=\"relative-path\">LogExtent</a> instance.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n          \r\n    \r\n    \r\n            <h4>Example</h4>\r\n            <p>This example shows how to use the <a class=\"xref\" href=\"system.io.log.logextent\" data-linktype=\"relative-path\">LogExtent</a> class to add and emulate extents in a log sequence.  </p>\n<pre><code class=\"lang-cs\" name=\"S_UELogRecordSequence#0\">using System;\nusing System.IO;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.IO.Log;\n\nnamespace MyLogRecordSequence\n{\n    public class MyLog\n    {\n        string logName = &quot;test.log&quot;;\n        string logContainer = &quot;MyExtent0&quot;;\n        int containerSize = 32 * 1024;\n        LogRecordSequence sequence = null;\n        bool delete = true;\n\n        // These are used in the TailPinned event handler.\n        public static LogRecordSequence MySequence = null;\n        public static bool AdvanceBase = true;\n\n        public MyLog()\n        {\n            // Create a LogRecordSequence.\n            sequence = new LogRecordSequence(this.logName,\n                                              FileMode.CreateNew,\n                                              FileAccess.ReadWrite,\n                                              FileShare.None);\n\n            // At least one container/extent must be added for Log Record Sequence.\n            sequence.LogStore.Extents.Add(this.logContainer, this.containerSize);\n     \n            MySequence = sequence;\n\n        }\n\n        public void AddExtents()\n        {\n            // Add two additional extents. The extents are \n            // of the same size as the first extent.\n            sequence.LogStore.Extents.Add(&quot;MyExtent1&quot;);\n            sequence.LogStore.Extents.Add(&quot;MyExtent2&quot;);\n        }\n\n        public void EnumerateExtents()\n        {\n            LogStore store = sequence.LogStore;\n\n            Console.WriteLine(&quot;Enumerating Log Extents...&quot;);\n            Console.WriteLine(&quot;    Extent Count: {0} extents&quot;, store.Extents.Count);\n            Console.WriteLine(&quot;    Extents Are...&quot;);\n            foreach (LogExtent extent in store.Extents)\n            {\n                Console.WriteLine(&quot;      {0} ({1}, {2})&quot;,\n                                  Path.GetFileName(extent.Path),\n                                  extent.Size,\n                                  extent.State);\n            }\n            Console.WriteLine(&quot;    Free Extents: {0} Free&quot;, store.Extents.FreeCount);   \n        }\n\n        public void SetLogPolicy()\n        {\n            Console.WriteLine();\n            Console.WriteLine(&quot;Setting current log policy...&quot;);\n\n            // SET LOG POLICY\n\n            LogPolicy policy = sequence.LogStore.Policy;\n\n            // Set AutoGrow policy. This enables the log to automatically grow\n            // when the existing extents are full. New extents are added until\n            // we reach the MaximumExtentCount extents.\n            // AutoGrow policy is supported only in Windows Vista and not available in R2.\n            \n            //policy.AutoGrow = true;\n\n            // Set the Growth Rate in terms of extents. This policy specifies\n            // &quot;how much&quot; the log should grow. \n            policy.GrowthRate = new PolicyUnit(2, PolicyUnitType.Extents);\n\n            // Set the AutoShrink policy. This enables the log to automatically\n            // shrink if the available free space exceeds the shrink percentage. \n            // AutoGrow/shrink policy is supported only in Windows Vista and not available in R2.\n            \n            //policy.AutoShrinkPercentage = new PolicyUnit(30, PolicyUnitType.Percentage);\n\n            // Set the PinnedTailThreshold policy.\n            // A tail pinned event is triggered when there is no\n            // log space available and log space may be freed by advancing the base.\n            // The user must handle the tail pinned event by advancing the base of the log. \n            // If the user is not able to move the base of the log, the user should report with exception in\n            // the tail pinned handler.\n            // PinnedTailThreashold policy dictates the amount of space that the TailPinned event requests \n            // for advancing the base of the log. The amount of space can be in percentage or in terms of bytes \n            // which is rounded off to the nearest containers in CLFS. The default is 35 percent.\n\n            \n            policy.PinnedTailThreshold = new PolicyUnit(10, PolicyUnitType.Percentage);\n\n            // Set the maximum extents the log can have.\n            policy.MaximumExtentCount = 6;\n            \n            // Set the minimum extents the log can have.\n            policy.MinimumExtentCount = 2;\n            \n            // Set the prefix for new containers that are added. \n            // when AutoGrow is enabled.\n            //policy.NewExtentPrefix = &quot;MyLogPrefix&quot;;\n            \n            // Set the suffix number for new containers that are added.\n            // when AutoGrow is enabled. \n            policy.NextExtentSuffix = 3;\n\n            // Commit the log policy.\n            policy.Commit();\n\n            // Refresh updates the IO.Log policy properties with current log policy \n            // set in the log. \n            policy.Refresh();\n\n            // LOG POLICY END\n            // \n\n            //+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n            // Setting up IO.Log provided capabilities...\n            // \n\n            // SET RETRY APPEND\n\n            // IO.Log provides a mechanism similar to AutoGrow.\n            // If the existing log is full and an append fails, setting RetryAppend\n            // invokes the CLFS policy engine to add new extents and re-tries\n            // record appends. If MaximumExtent count has been reached, \n            // a SequenceFullException is thrown. \n            // \n\n            sequence.RetryAppend = true;\n\n            // RETRY APPEND END\n\n            // REGISTER FOR TAILPINNED EVENT NOTIFICATIONS\n\n            // Register for TailPinned Event by passing in an event handler.\n            // An event is raised when the log full condition is reached.\n            // The user should either advance the base sequence number to the \n            // nearest valid sequence number recommended in the tail pinned event or\n            // report a failure that it is not able to advance the base sequence \n            // number. \n            //\n\n            sequence.TailPinned += new EventHandler&lt;TailPinnedEventArgs&gt;(HandleTailPinned);  \n\n            Console.WriteLine(&quot;Done...&quot;);\n        }\n\n        public void ShowLogPolicy()\n        {\n            Console.WriteLine();\n            Console.WriteLine(&quot;Showing current log policy...&quot;);\n\n            LogPolicy policy = sequence.LogStore.Policy;\n\n            Console.WriteLine(&quot;    Minimum extent count:  {0}&quot;, policy.MinimumExtentCount);\n            Console.WriteLine(&quot;    Maximum extent count:  {0}&quot;, policy.MaximumExtentCount);\n            Console.WriteLine(&quot;    Growth rate:           {0}&quot;, policy.GrowthRate);\n            Console.WriteLine(&quot;    Pinned tail threshold: {0}&quot;, policy.PinnedTailThreshold);\n            Console.WriteLine(&quot;    Auto shrink percent:   {0}&quot;, policy.AutoShrinkPercentage);\n            Console.WriteLine(&quot;    Auto grow enabled:     {0}&quot;, policy.AutoGrow);\n            Console.WriteLine(&quot;    New extent prefix:     {0}&quot;, policy.NewExtentPrefix);\n            Console.WriteLine(&quot;    Next extent suffix:    {0}&quot;, policy.NextExtentSuffix);\n\n\t}\n\n        // Append records. Appending three records.  \n        public void AppendRecords()\n        {\n            Console.WriteLine(&quot;Appending Log Records...&quot;);\n            SequenceNumber previous = SequenceNumber.Invalid;\n\n            previous = sequence.Append(CreateData(&quot;Hello World!&quot;), SequenceNumber.Invalid, SequenceNumber.Invalid, RecordAppendOptions.ForceFlush);\n            previous = sequence.Append(CreateData(&quot;This is my first Logging App&quot;), SequenceNumber.Invalid, SequenceNumber.Invalid, RecordAppendOptions.ForceFlush);\n            previous = sequence.Append(CreateData(&quot;Using LogRecordSequence...&quot;), SequenceNumber.Invalid, SequenceNumber.Invalid, RecordAppendOptions.ForceFlush);\n\t    \n            Console.WriteLine(&quot;Done...&quot;);\n        }\n\n\n        // Read the records added to the log. \n        public void ReadRecords()\n        {\n            Encoding enc = Encoding.Unicode;\n\n            Console.WriteLine();\n\n            Console.WriteLine(&quot;Reading Log Records...&quot;);\n            try\n            {\n                foreach (LogRecord record in this.sequence.ReadLogRecords(this.sequence.BaseSequenceNumber, LogRecordEnumeratorType.Next))\n                {\n                    byte[] data = new byte[record.Data.Length];\n                    record.Data.Read(data, 0, (int)record.Data.Length);\n                    string mystr = enc.GetString(data);\n                    Console.WriteLine(&quot;    {0}&quot;, mystr);\n                }\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(&quot;Exception {0} {1}&quot;, e.GetType(), e.Message);\n            }\n\n            Console.WriteLine();\n        }\n\n        public void FillLog()\n        {\n            bool append = true;\n\n            while (append)\n            {\n                try\n                {\n                    sequence.Append(CreateData(16 * 1024), SequenceNumber.Invalid, SequenceNumber.Invalid, RecordAppendOptions.ForceFlush);\n                }\n\n                catch (SequenceFullException)\n                {\n                    Console.WriteLine(&quot;Log is Full...&quot;);\n                    append = false;\n                }\n            }\n        }\n\n        // Dispose the record sequence and delete the log file. \n        public void Cleanup()\n        {\n            // Dispose the sequence\n            sequence.Dispose();\n\n            // Delete the log file.\n            if (delete)\n            {\n                try\n                {\n                    // This deletes the base log file and all the extents associated with the log.\n                    LogStore.Delete(this.logName);\n                }\n                catch (Exception e)\n                {\n                    Console.WriteLine(&quot;Exception {0} {1}&quot;, e.GetType(), e.Message);\n                }\n            }\n        }\n\n        // Converts the given data to an Array of ArraySegment&lt;byte&gt; \n        public static IList&lt;ArraySegment&lt;byte&gt;&gt; CreateData(string str)\n        {\n            Encoding enc = Encoding.Unicode;\n\n            byte[] array = enc.GetBytes(str);\n\n            ArraySegment&lt;byte&gt;[] segments = new ArraySegment&lt;byte&gt;[1];\n            segments[0] = new ArraySegment&lt;byte&gt;(array);\n\n            return Array.AsReadOnly&lt;ArraySegment&lt;byte&gt;&gt;(segments);\n        }\n\n        public static IList&lt;ArraySegment&lt;byte&gt;&gt; CreateData(int size)\n        {\n            byte[] array = new byte[size];\n\n            Random rnd = new Random();\n            rnd.NextBytes(array);\n\n            ArraySegment&lt;byte&gt;[] segments = new ArraySegment&lt;byte&gt;[1];\n            segments[0] = new ArraySegment&lt;byte&gt;(array);\n\n            return Array.AsReadOnly&lt;ArraySegment&lt;byte&gt;&gt;(segments);\n        }\n\n        public static SequenceNumber GetAdvanceBaseSeqNumber(SequenceNumber recTargetSeqNum)\n        {\n            SequenceNumber targetSequenceNumber = SequenceNumber.Invalid;\n\n            Console.WriteLine(&quot;Getting actual target sequence number...&quot;);\n            \n            // \n            // Implement the logic for returning a valid sequence number closer to\n            // recommended target sequence number. \n            //\n\n            return targetSequenceNumber;\n        }\n\n        public static void HandleTailPinned(object arg, TailPinnedEventArgs tailPinnedEventArgs)\n        {\n            Console.WriteLine(&quot;TailPinned has fired&quot;);\n\n            // Based on the implementation of a logging application, the log base can be moved\n            // to free up more log space and if it is not possible to move the \n            // base, the application should report by throwing an exception.\n\n            if(MyLog.AdvanceBase)\n            {\n                try\n                {\n                    // TailPnnedEventArgs has the recommended sequence number and its generated \n                    // based on PinnedTailThreshold policy. \n                    // This does not map to an actual sequence number in the record sequence\n                    // but an approximation and potentially frees up the threshold % log space\n                    // when the log base is advanced to a valid sequence number closer to the \n                    // recommended sequence number. \n                    // The user should use this sequence number to locate a closest valid sequence\n                    // number to advance the base of the log.\n\n                    SequenceNumber recommendedTargetSeqNum = tailPinnedEventArgs.TargetSequenceNumber; \n                    \n                    // Get the actual Target sequence number.\n                    SequenceNumber actualTargetSeqNum = MyLog.GetAdvanceBaseSeqNumber(recommendedTargetSeqNum);\n\n                    MySequence.AdvanceBaseSequenceNumber(actualTargetSeqNum);\n                }\n                catch (Exception e)\n                {\n                    Console.WriteLine(&quot;Exception thrown {0} {1}&quot;, e.GetType(), e.Message);\n                }\n            }\n            else\n            {\n                // Report back Error if under some conditions the log cannot\n                // advance the base sequence number.\n\n                Console.WriteLine(&quot;Reporting Error! Unable to move the base sequence number!&quot;);\n                throw new IOException();\n            }\n        }\n    }\n\n    class LogSample\n    {\n        static void Main(string[] args)\n        {\n            // Create log record sequence.\n            MyLog log = new MyLog();\n\n            // Add additional extents.\n            log.AddExtents();\n\n            // Enumerate the current log extents.\n            log.EnumerateExtents();\n\n            // Set log policies and register for TailPinned event notifications. \n            log.SetLogPolicy();\n\n            log.ShowLogPolicy();\n            \n            // Append a few records and read the appended records. \n            log.AppendRecords();\n            log.ReadRecords();\n\n            // Fill the Log to trigger log growth...and subsequent TailPinned notifications.\n            log.FillLog();\n\n            log.EnumerateExtents();\n\n            log.Cleanup();\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"S_UELogRecordSequence#0\">\nImports System\nImports System.IO\nImports System.Collections.Generic\nImports System.Text\nImports System.IO.Log\n\nNamespace MyLogRecordSequence\n\tPublic Class MyLog\n\t\tPrivate logName As String = &quot;test.log&quot;\n\t\tPrivate logContainer As String = &quot;MyExtent0&quot;\n\t\tPrivate containerSize As Integer = 32 * 1024\n\t\tPrivate sequence As LogRecordSequence = Nothing\n\t\tPrivate delete As Boolean = True\n\n\t\t&#39; These are used in the TailPinned event handler.\n\t\tPublic Shared MySequence As LogRecordSequence = Nothing\n\t\tPublic Shared AdvanceBase As Boolean = True\n\n\t\tPublic Sub New()\n\t\t\t&#39; Create a LogRecordSequence.\n\t\t\tsequence = New LogRecordSequence(Me.logName, FileMode.CreateNew, FileAccess.ReadWrite, FileShare.None)\n\n\t\t\t&#39; At least one container/extent must be added for Log Record Sequence.\n\t\t\tsequence.LogStore.Extents.Add(Me.logContainer, Me.containerSize)\n\n\t\t\tMySequence = sequence\n\n\t\tEnd Sub\n\n\t\tPublic Sub AddExtents()\n\t\t\t&#39; Add two additional extents. The extents are \n\t\t\t&#39; of the same size as the first extent.\n\t\t\tsequence.LogStore.Extents.Add(&quot;MyExtent1&quot;)\n\t\t\tsequence.LogStore.Extents.Add(&quot;MyExtent2&quot;)\n\t\tEnd Sub\n\n\t\tPublic Sub EnumerateExtents()\n\t\t\tDim store As LogStore = sequence.LogStore\n\n\t\t\tConsole.WriteLine(&quot;Enumerating Log Extents...&quot;)\n\t\t\tConsole.WriteLine(&quot;    Extent Count: {0} extents&quot;, store.Extents.Count)\n\t\t\tConsole.WriteLine(&quot;    Extents Are...&quot;)\n            For Each extent In store.Extents\n                Console.WriteLine(&quot;      {0} ({1}, {2})&quot;, Path.GetFileName(extent.Path), extent.Size, extent.State)\n            Next extent\n\t\t\tConsole.WriteLine(&quot;    Free Extents: {0} Free&quot;, store.Extents.FreeCount)\n\t\tEnd Sub\n\n\t\tPublic Sub SetLogPolicy()\n\t\t\tConsole.WriteLine()\n\t\t\tConsole.WriteLine(&quot;Setting current log policy...&quot;)\n\n\t\t\t&#39; SET LOG POLICY\n\n\t\t\tDim policy As LogPolicy = sequence.LogStore.Policy\n\n\t\t\t&#39; Set AutoGrow policy. This enables the log to automatically grow\n\t\t\t&#39; when the existing extents are full. New extents are added until\n\t\t\t&#39; we reach the MaximumExtentCount extents.\n\t\t\t&#39; AutoGrow policy is supported only in Windows Vista and not available in R2.\n\n\t\t\t&#39;policy.AutoGrow = true;\n\n\t\t\t&#39; Set the Growth Rate in terms of extents. This policy specifies\n\t\t\t&#39; &quot;how much&quot; the log should grow. \n\t\t\tpolicy.GrowthRate = New PolicyUnit(2, PolicyUnitType.Extents)\n\n\t\t\t&#39; Set the AutoShrink policy. This enables the log to automatically\n\t\t\t&#39; shrink if the available free space exceeds the shrink percentage. \n\t\t\t&#39; AutoGrow/shrink policy is supported only in Windows Vista and not available in R2.\n\n\t\t\t&#39;policy.AutoShrinkPercentage = new PolicyUnit(30, PolicyUnitType.Percentage);\n\n\t\t\t&#39; Set the PinnedTailThreshold policy.\n\t\t\t&#39; A tail pinned event is triggered when there is no\n\t\t\t&#39; log space available and log space may be freed by advancing the base.\n\t\t\t&#39; The user must handle the tail pinned event by advancing the base of the log. \n\t\t\t&#39; If the user is not able to move the base of the log, the user should report with exception in\n\t\t\t&#39; the tail pinned handler.\n\t\t\t&#39; PinnedTailThreashold policy dictates the amount of space that the TailPinned event requests \n\t\t\t&#39; for advancing the base of the log. The amount of space can be in percentage or in terms of bytes \n\t\t\t&#39; which is rounded off to the nearest containers in CLFS. The default is 35 percent.\n\n\n\t\t\tpolicy.PinnedTailThreshold = New PolicyUnit(10, PolicyUnitType.Percentage)\n\n\t\t\t&#39; Set the maximum extents the log can have.\n\t\t\tpolicy.MaximumExtentCount = 6\n\n\t\t\t&#39; Set the minimum extents the log can have.\n\t\t\tpolicy.MinimumExtentCount = 2\n\n\t\t\t&#39; Set the prefix for new containers that are added. \n\t\t\t&#39; when AutoGrow is enabled.\n\t\t\t&#39;policy.NewExtentPrefix = &quot;MyLogPrefix&quot;;\n\n\t\t\t&#39; Set the suffix number for new containers that are added.\n\t\t\t&#39; when AutoGrow is enabled. \n\t\t\tpolicy.NextExtentSuffix = 3\n\n\t\t\t&#39; Commit the log policy.\n\t\t\tpolicy.Commit()\n\n\t\t\t&#39; Refresh updates the IO.Log policy properties with current log policy \n\t\t\t&#39; set in the log. \n\t\t\tpolicy.Refresh()\n\n\t\t\t&#39; LOG POLICY END\n\t\t\t&#39; \n\n\t\t\t&#39;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n\t\t\t&#39; Setting up IO.Log provided capabilities...\n\t\t\t&#39; \n\n\t\t\t&#39; SET RETRY APPEND\n\n\t\t\t&#39; IO.Log provides a mechanism similar to AutoGrow.\n\t\t\t&#39; If the existing log is full and an append fails, setting RetryAppend\n\t\t\t&#39; invokes the CLFS policy engine to add new extents and re-tries\n\t\t\t&#39; record appends. If MaximumExtent count has been reached, \n\t\t\t&#39; a SequenceFullException is thrown. \n\t\t\t&#39; \n\n\t\t\tsequence.RetryAppend = True\n\n\t\t\t&#39; RETRY APPEND END\n\n\t\t\t&#39; REGISTER FOR TAILPINNED EVENT NOTIFICATIONS\n\n\t\t\t&#39; Register for TailPinned Event by passing in an event handler.\n\t\t\t&#39; An event is raised when the log full condition is reached.\n\t\t\t&#39; The user should either advance the base sequence number to the \n\t\t\t&#39; nearest valid sequence number recommended in the tail pinned event or\n\t\t\t&#39; report a failure that it is not able to advance the base sequence \n\t\t\t&#39; number. \n\t\t\t&#39;\n\n\t\t\tAddHandler sequence.TailPinned, AddressOf HandleTailPinned\n\n\t\t\tConsole.WriteLine(&quot;Done...&quot;)\n\t\tEnd Sub\n\n\t\tPublic Sub ShowLogPolicy()\n\t\t\tConsole.WriteLine()\n\t\t\tConsole.WriteLine(&quot;Showing current log policy...&quot;)\n\n\t\t\tDim policy As LogPolicy = sequence.LogStore.Policy\n\n\t\t\tConsole.WriteLine(&quot;    Minimum extent count:  {0}&quot;, policy.MinimumExtentCount)\n\t\t\tConsole.WriteLine(&quot;    Maximum extent count:  {0}&quot;, policy.MaximumExtentCount)\n\t\t\tConsole.WriteLine(&quot;    Growth rate:           {0}&quot;, policy.GrowthRate)\n\t\t\tConsole.WriteLine(&quot;    Pinned tail threshold: {0}&quot;, policy.PinnedTailThreshold)\n\t\t\tConsole.WriteLine(&quot;    Auto shrink percent:   {0}&quot;, policy.AutoShrinkPercentage)\n\t\t\tConsole.WriteLine(&quot;    Auto grow enabled:     {0}&quot;, policy.AutoGrow)\n\t\t\tConsole.WriteLine(&quot;    New extent prefix:     {0}&quot;, policy.NewExtentPrefix)\n\t\t\tConsole.WriteLine(&quot;    Next extent suffix:    {0}&quot;, policy.NextExtentSuffix)\n\n\t\tEnd Sub\n\n\t\t&#39; Append records. Appending three records.  \n\t\tPublic Sub AppendRecords()\n\t\t\tConsole.WriteLine(&quot;Appending Log Records...&quot;)\n\t\t\tDim previous As SequenceNumber = SequenceNumber.Invalid\n\n\t\t\tprevious = sequence.Append(CreateData(&quot;Hello World!&quot;), SequenceNumber.Invalid, SequenceNumber.Invalid, RecordAppendOptions.ForceFlush)\n\t\t\tprevious = sequence.Append(CreateData(&quot;This is my first Logging App&quot;), SequenceNumber.Invalid, SequenceNumber.Invalid, RecordAppendOptions.ForceFlush)\n\t\t\tprevious = sequence.Append(CreateData(&quot;Using LogRecordSequence...&quot;), SequenceNumber.Invalid, SequenceNumber.Invalid, RecordAppendOptions.ForceFlush)\n\n\t\t\tConsole.WriteLine(&quot;Done...&quot;)\n\t\tEnd Sub\n\n\n\t\t&#39; Read the records added to the log. \n\t\tPublic Sub ReadRecords()\n\t\t\tDim enc As Encoding = Encoding.Unicode\n\n\t\t\tConsole.WriteLine()\n\n\t\t\tConsole.WriteLine(&quot;Reading Log Records...&quot;)\n\t\t\tTry\n\t\t\t\tFor Each record As LogRecord In Me.sequence.ReadLogRecords(Me.sequence.BaseSequenceNumber, LogRecordEnumeratorType.Next)\n\t\t\t\t\tDim data(record.Data.Length - 1) As Byte\n\t\t\t\t\trecord.Data.Read(data, 0, CInt(Fix(record.Data.Length)))\n\t\t\t\t\tDim mystr As String = enc.GetString(data)\n\t\t\t\t\tConsole.WriteLine(&quot;    {0}&quot;, mystr)\n\t\t\t\tNext record\n\t\t\tCatch e As Exception\n\t\t\t\tConsole.WriteLine(&quot;Exception {0} {1}&quot;, e.GetType(), e.Message)\n\t\t\tEnd Try\n\n\t\t\tConsole.WriteLine()\n\t\tEnd Sub\n\n\t\tPublic Sub FillLog()\n\t\t\tDim append As Boolean = True\n\n\t\t\tDo While append\n\t\t\t\tTry\n\t\t\t\t\tsequence.Append(CreateData(16 * 1024), SequenceNumber.Invalid, SequenceNumber.Invalid, RecordAppendOptions.ForceFlush)\n\n\t\t\t\tCatch e1 As SequenceFullException\n\t\t\t\t\tConsole.WriteLine(&quot;Log is Full...&quot;)\n\t\t\t\t\tappend = False\n\t\t\t\tEnd Try\n\t\t\tLoop\n\t\tEnd Sub\n\n\t\t&#39; Dispose the record sequence and delete the log file. \n\t\tPublic Sub Cleanup()\n\t\t\t&#39; Dispose the sequence\n\t\t\tsequence.Dispose()\n\n\t\t\t&#39; Delete the log file.\n\t\t\tIf delete Then\n\t\t\t\tTry\n\t\t\t\t\t&#39; This deletes the base log file and all the extents associated with the log.\n\t\t\t\t\tLogStore.Delete(Me.logName)\n\t\t\t\tCatch e As Exception\n\t\t\t\t\tConsole.WriteLine(&quot;Exception {0} {1}&quot;, e.GetType(), e.Message)\n\t\t\t\tEnd Try\n\t\t\tEnd If\n\t\tEnd Sub\n\n\t\t&#39; Converts the given data to an Array of ArraySegment&lt;byte&gt; \n\t\tPublic Shared Function CreateData(ByVal str As String) As IList(Of ArraySegment(Of Byte))\n\t\t\tDim enc As Encoding = Encoding.Unicode\n\n\t\t\tDim array() As Byte = enc.GetBytes(str)\n\n\t\t\tDim segments(0) As ArraySegment(Of Byte)\n\t\t\tsegments(0) = New ArraySegment(Of Byte)(array)\n\n            Return System.Array.AsReadOnly(Of ArraySegment(Of Byte))(segments)\n\t\tEnd Function\n\n\t\tPublic Shared Function CreateData(ByVal size As Integer) As IList(Of ArraySegment(Of Byte))\n\t\t\tDim array(size - 1) As Byte\n\n\t\t\tDim rand As New Random()\n\t\t\trand.NextBytes(array)\n\n\t\t\tDim segments(0) As ArraySegment(Of Byte)\n\t\t\tsegments(0) = New ArraySegment(Of Byte)(array)\n\n            Return System.Array.AsReadOnly(Of ArraySegment(Of Byte))(segments)\n\t\tEnd Function\n\n\t\tPublic Shared Function GetAdvanceBaseSeqNumber(ByVal recTargetSeqNum As SequenceNumber) As SequenceNumber\n\t\t\tDim targetSequenceNumber As SequenceNumber = SequenceNumber.Invalid\n\n\t\t\tConsole.WriteLine(&quot;Getting actual target sequence number...&quot;)\n\n\t\t\t&#39; \n\t\t\t&#39; Implement the logic for returning a valid sequence number closer to\n\t\t\t&#39; recommended target sequence number. \n\t\t\t&#39;\n\n\t\t\tReturn targetSequenceNumber\n\t\tEnd Function\n\n\t\tPublic Shared Sub HandleTailPinned(ByVal arg As Object, ByVal tailPinnedEventArgs As TailPinnedEventArgs)\n\t\t\tConsole.WriteLine(&quot;TailPinned has fired&quot;)\n\n\t\t\t&#39; Based on the implementation of a logging application, the log base can be moved\n\t\t\t&#39; to free up more log space and if it is not possible to move the \n\t\t\t&#39; base, the application should report by throwing an exception.\n\n\t\t\tIf MyLog.AdvanceBase Then\n\t\t\t\tTry\n\t\t\t\t\t&#39; TailPnnedEventArgs has the recommended sequence number and its generated \n\t\t\t\t\t&#39; based on PinnedTailThreshold policy. \n\t\t\t\t\t&#39; This does not map to an actual sequence number in the record sequence\n\t\t\t\t\t&#39; but an approximation and potentially frees up the threshold % log space\n\t\t\t\t\t&#39; when the log base is advanced to a valid sequence number closer to the \n\t\t\t\t\t&#39; recommended sequence number. \n\t\t\t\t\t&#39; The user should use this sequence number to locate a closest valid sequence\n\t\t\t\t\t&#39; number to advance the base of the log.\n\n\t\t\t\t\tDim recommendedTargetSeqNum As SequenceNumber = tailPinnedEventArgs.TargetSequenceNumber\n\n\t\t\t\t\t&#39; Get the actual Target sequence number.\n\t\t\t\t\tDim actualTargetSeqNum As SequenceNumber = MyLog.GetAdvanceBaseSeqNumber(recommendedTargetSeqNum)\n\n\t\t\t\t\tMySequence.AdvanceBaseSequenceNumber(actualTargetSeqNum)\n\t\t\t\tCatch e As Exception\n\t\t\t\t\tConsole.WriteLine(&quot;Exception thrown {0} {1}&quot;, e.GetType(), e.Message)\n\t\t\t\tEnd Try\n\t\t\tElse\n\t\t\t\t&#39; Report back Error if under some conditions the log cannot\n\t\t\t\t&#39; advance the base sequence number.\n\n\t\t\t\tConsole.WriteLine(&quot;Reporting Error! Unable to move the base sequence number!&quot;)\n\t\t\t\tThrow New IOException()\n\t\t\tEnd If\n\t\tEnd Sub\n\tEnd Class\n\n\tFriend Class LogSample\n\t\tShared Sub Main(ByVal args() As String)\n\t\t\t&#39; Create log record sequence.\n\t\t\tDim log As New MyLog()\n\n\t\t\t&#39; Add additional extents.\n\t\t\tlog.AddExtents()\n\n\t\t\t&#39; Enumerate the current log extents.\n\t\t\tlog.EnumerateExtents()\n\n\t\t\t&#39; Set log policies and register for TailPinned event notifications. \n\t\t\tlog.SetLogPolicy()\n\n\t\t\tlog.ShowLogPolicy()\n\n\t\t\t&#39; Append a few records and read the appended records. \n\t\t\tlog.AppendRecords()\n\t\t\tlog.ReadRecords()\n\n\t\t\t&#39; Fill the Log to trigger log growth...and subsequent TailPinned notifications.\n\t\t\tlog.FillLog()\n\n\t\t\tlog.EnumerateExtents()\n\n\t\t\tlog.Cleanup()\n\t\tEnd Sub\n\tEnd Class\nEnd Namespace\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n","outputRootRelativePath":"./","pageMetadata":"<meta name=\"author\" content=\"dotnet-bot\">\r\n<meta name=\"breadcrumb_path\" content=\"breadcrumb/toc.json\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"fulldocset\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.fulldocset\">\r\n<meta name=\"ref_skeleton_gitcommit\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.IO.Log.LogExtent.yml\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.IO.Log.LogExtent.yml\">\r\n<meta name=\"APIName\" content=\"System.IO.Log.LogExtent\">\r\n<meta name=\"APIName\" content=\"System.IO.Log.LogExtent.Path\">\r\n<meta name=\"APIName\" content=\"System.IO.Log.LogExtent.Size\">\r\n<meta name=\"APIName\" content=\"System.IO.Log.LogExtent.State\">\r\n<meta name=\"APILocation\" content=\"System.IO.Log.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-01 01:37 AM\">\r\n<meta name=\"document_id\" content=\"de37d128-55bf-88f0-f8a2-e17bf2cf7cb9\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Represents a disk extent that contains log data.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/System.IO.Log/toc.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.IO.Log.LogExtent\">\r\n","rawMetadata":{"author":"dotnet-bot","breadcrumb_path":"breadcrumb/toc.json","search.ms_sitename":"Docs","search.ms_docsetname":"fulldocset","version":null,"_op_canonicalUrlPrefix":"https://ppe.docs.microsoft.com/en-us/fulldotnet/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":true,"depot_name":"MSDN.fulldocset","_op_gitRefSkeletonCommitHistory":[{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"use plugin in master","commit_sha":"501959ac03e19ac52a27aa4c6bbeb980f8b11c8c","commit_date":"2017-03-01 09:31:20 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"switch from platform to version","commit_sha":"78cdacb5ca782478af490a6b30c3a2cb2b6b873e","commit_date":"2017-02-28 15:09:51 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"update platforms","commit_sha":"39ad5a8919a59afc93a79ac4bd8e07c3b471b37a","commit_date":"2017-02-28 10:38:59 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"checkin yml","commit_sha":"da161b792852497df7140d7768cee2eccd9cb43f","commit_date":"2017-02-28 09:36:15 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"delete ymls","commit_sha":"417c04fd1daf0cb211ec4909020356fc1fe69260","commit_date":"2017-02-27 14:12:48 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"update latest xml","commit_sha":"1e40a158586a88a698e0cb5342785002a56898b2","commit_date":"2017-02-24 16:20:57 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"transform see cref and fix paramref format","commit_sha":"3d0ea34483c97ac77f4020a7f294757d67a5c1d4","commit_date":"2017-02-23 10:03:17 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"convert exceptions","commit_sha":"0a5bf3370731dd35a596c91081e5dc82e2eace3a","commit_date":"2017-02-22 11:54:30 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"remove _yml from url","commit_sha":"f9314af8858edb8c329d223328490093aef4f55f","commit_date":"2017-02-17 15:31:12 +0800"}],"ref_skeleton_gitcommit":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.IO.Log.LogExtent.yml","original_ref_skeleton_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.IO.Log.LogExtent.yml","open_to_public_contributors":true,"api_name":["System.IO.Log.LogExtent","System.IO.Log.LogExtent.Path","System.IO.Log.LogExtent.Size","System.IO.Log.LogExtent.State"],"api_location":["System.IO.Log.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.IO.Log.LogExtent","System::IO::Log::LogExtent","System.IO.Log.LogExtent.Path","System::IO::Log::LogExtent::Path","System.IO.Log.LogExtent.Size","System::IO::Log::LogExtent::Size","System.IO.Log.LogExtent.State","System::IO::Log::LogExtent::State"],"dev_langs":["csharp"],"updated_at":"2017-03-01 01:37 AM","document_id":"de37d128-55bf-88f0-f8a2-e17bf2cf7cb9","content_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/xml/System.IO.Log/LogExtent.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"LogExtent class | Microsoft Docs","_op_ogTitle":"LogExtent class","description":"Represents a disk extent that contains log data.\n","toc_asset_id":"_splitted/System.IO.Log/toc.json","toc_rel":"_splitted/System.IO.Log/toc.json","source_url":"","ms.assetid":"System.IO.Log.LogExtent","canonical_url":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.io.log.logextent","_op_canonicalUrl":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.io.log.logextent","fileRelativePath":"System.IO.Log.LogExtent.html"},"themesRelativePathToOutputRoot":"_themes/"}