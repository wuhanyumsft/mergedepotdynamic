{"content":"    \r\n    <h1 id=\"System_Threading_Semaphore\">\r\n      <span class=\"lang-csharp\">Semaphore</span>\r\n        Class\r\n    </h1>\r\n    \r\n    \r\n    <nav id=\"center-doc-outline\" class=\"doc-outline\" ms.cmpgrp=\"intopic toc\" role=\"navigation\" aria-label=\"On page navigation\">\r\n      <h3>In this Article</h3>\r\n    </nav><div class=\"summary\">\r\n    \t<p>Limits the number of threads that can access a resource or pool of resources concurrently.</p>\n\r\n    </div><h2>Syntax</h2>\r\n    \r\n    \t<h3>Declaration</h3>\r\n    \t<pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">[System.Runtime.InteropServices.ComVisible(false)]\npublic sealed class Semaphore : System.Threading.WaitHandle</code></pre>\r\n    \r\n    \r\n    \r\n    <h3>Inheritance Hierarchy</h3>\r\n    <ul class=\"inheritance\">\r\n        <li class=\"l0\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object\" data-linktype=\"relative-path\">Object</a>\r\n          </div>\r\n        </li>\r\n        <li class=\"l1\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.marshalbyrefobject\" data-linktype=\"relative-path\">MarshalByRefObject</a>\r\n          </div>\r\n        </li>\r\n        <li class=\"l2\">\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">System.Threading.WaitHandle</a>\r\n          </div>\r\n        </li>\r\n      <li class=\"l3\">\r\n        <div class=\"xref\">\r\n          <div class=\"lang-csharp\">Semaphore</div>\r\n        </div>\r\n      </li>\r\n    </ul>\r\n    \r\n      <div class=\"referencebox inheritedMembers\">\r\n        <h3>Inherited Members</h3>\r\n        <h4></h4>\r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.marshalbyrefobject#System_MarshalByRefObject_CreateObjRef_System_Type_\" data-linktype=\"relative-path\">CreateObjRef(Type)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.marshalbyrefobject#System_MarshalByRefObject_GetLifetimeService\" data-linktype=\"relative-path\">GetLifetimeService()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.marshalbyrefobject#System_MarshalByRefObject_InitializeLifetimeService\" data-linktype=\"relative-path\">InitializeLifetimeService()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.marshalbyrefobject#System_MarshalByRefObject_MemberwiseClone_System_Boolean_\" data-linktype=\"relative-path\">MemberwiseClone(Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_\" data-linktype=\"relative-path\">Equals(Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_Equals_System_Object_System_Object_\" data-linktype=\"relative-path\">Equals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetHashCode\" data-linktype=\"relative-path\">GetHashCode()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_GetType\" data-linktype=\"relative-path\">GetType()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_MemberwiseClone\" data-linktype=\"relative-path\">MemberwiseClone()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ReferenceEquals_System_Object_System_Object_\" data-linktype=\"relative-path\">ReferenceEquals(Object,Object)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.object#System_Object_ToString\" data-linktype=\"relative-path\">ToString()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Close\" data-linktype=\"relative-path\">Close()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Dispose\" data-linktype=\"relative-path\">Dispose()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Dispose_System_Boolean_\" data-linktype=\"relative-path\">Dispose(Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_Handle\" data-linktype=\"relative-path\">Handle</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_InvalidHandle\" data-linktype=\"relative-path\">InvalidHandle</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SafeWaitHandle\" data-linktype=\"relative-path\">SafeWaitHandle</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SignalAndWait_System_Threading_WaitHandle_System_Threading_WaitHandle_\" data-linktype=\"relative-path\">SignalAndWait(WaitHandle,WaitHandle)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SignalAndWait_System_Threading_WaitHandle_System_Threading_WaitHandle_System_Int32_System_Boolean_\" data-linktype=\"relative-path\">SignalAndWait(WaitHandle,WaitHandle,Int32,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_SignalAndWait_System_Threading_WaitHandle_System_Threading_WaitHandle_System_TimeSpan_System_Boolean_\" data-linktype=\"relative-path\">SignalAndWait(WaitHandle,WaitHandle,TimeSpan,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___\" data-linktype=\"relative-path\">WaitAll(WaitHandle[])</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_Int32_\" data-linktype=\"relative-path\">WaitAll(WaitHandle[],Int32)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_Int32_System_Boolean_\" data-linktype=\"relative-path\">WaitAll(WaitHandle[],Int32,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_TimeSpan_\" data-linktype=\"relative-path\">WaitAll(WaitHandle[],TimeSpan)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAll_System_Threading_WaitHandle___System_TimeSpan_System_Boolean_\" data-linktype=\"relative-path\">WaitAll(WaitHandle[],TimeSpan,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___\" data-linktype=\"relative-path\">WaitAny(WaitHandle[])</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_Int32_\" data-linktype=\"relative-path\">WaitAny(WaitHandle[],Int32)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_Int32_System_Boolean_\" data-linktype=\"relative-path\">WaitAny(WaitHandle[],Int32,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_TimeSpan_\" data-linktype=\"relative-path\">WaitAny(WaitHandle[],TimeSpan)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitAny_System_Threading_WaitHandle___System_TimeSpan_System_Boolean_\" data-linktype=\"relative-path\">WaitAny(WaitHandle[],TimeSpan,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne\" data-linktype=\"relative-path\">WaitOne()</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_System_Int32_\" data-linktype=\"relative-path\">WaitOne(Int32)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_System_Int32_System_Boolean_\" data-linktype=\"relative-path\">WaitOne(Int32,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_System_TimeSpan_\" data-linktype=\"relative-path\">WaitOne(TimeSpan)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_System_TimeSpan_System_Boolean_\" data-linktype=\"relative-path\">WaitOne(TimeSpan,Boolean)</a>\r\n          </div>\r\n          , \r\n          <div class=\"lang-csharp\">\r\n            <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitTimeout\" data-linktype=\"relative-path\">WaitTimeout</a>\r\n          </div>\r\n          \r\n      </div>\r\n    \r\n    \r\n      <h2>Remarks</h2>\r\n      <p>Use the Semaphore class to control access to a pool of resources. Threads enter the semaphore by calling the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> method, which is inherited from the <a class=\"xref\" href=\"system.threading.waithandle\" data-linktype=\"relative-path\">WaitHandle</a> class, and release the semaphore by calling the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_Release_\" data-linktype=\"relative-path\">Release</a> method.  </p>\n<p> The count on a semaphore is decremented each time a thread enters the semaphore, and incremented when a thread releases the semaphore. When the count is zero, subsequent requests block until other threads release the semaphore. When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created.  </p>\n<p> There is no guaranteed order, such as FIFO or LIFO, in which blocked threads enter the semaphore.  </p>\n<p> A thread can enter the semaphore multiple times, by calling the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> method repeatedly. To release some or all of these entries, the thread can call the parameterless <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_Release\" data-linktype=\"relative-path\">Release()</a> method overload multiple times, or it can call the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_Release_System_Int32_\" data-linktype=\"relative-path\">Release(Int32)</a> method overload that specifies the number of entries to be released.  </p>\n<p> The Semaphore class does not enforce thread identity on calls to <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> or <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_Release_\" data-linktype=\"relative-path\">Release</a>. It is the programmer&#39;s responsibility to ensure that threads do not release the semaphore too many times. For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore. If a programming error in thread B causes it to call <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_Release_\" data-linktype=\"relative-path\">Release</a> twice, both calls succeed. The count on the semaphore is full, and when thread A eventually calls <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_Release_\" data-linktype=\"relative-path\">Release</a>, a <a class=\"xref\" href=\"system.threading.semaphorefullexception\" data-linktype=\"relative-path\">SemaphoreFullException</a> is thrown.  </p>\n<p> Semaphores are of two types: local semaphores and named system semaphores. If you create a Semaphore object using a constructor that accepts a name, it is associated with an operating-system semaphore of that name. Named system semaphores are visible throughout the operating system, and can be used to synchronize the activities of processes. You can create multiple Semaphore objects that represent the same named system semaphore, and you can use the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_OpenExisting_\" data-linktype=\"relative-path\">OpenExisting</a> method to open an existing named system semaphore.  </p>\n<p> A local semaphore exists only within your process. It can be used by any thread in your process that has a reference to the local Semaphore object. Each Semaphore object is a separate local semaphore.</p>\n\r\n    \r\n    \r\n    <h2>Constructors\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Semaphore__ctor_System_Int32_System_Int32_\" data-linktype=\"self-bookmark\">Semaphore(Int32,Int32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> class, specifying the initial number of entries and the maximum number of concurrent entries.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Semaphore__ctor_System_Int32_System_Int32_System_String_\" data-linktype=\"self-bookmark\">Semaphore(Int32,Int32,String)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Semaphore__ctor_System_Int32_System_Int32_System_String_System_Boolean__\" data-linktype=\"self-bookmark\">Semaphore(Int32,Int32,String,Boolean)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Semaphore__ctor_System_Int32_System_Int32_System_String_System_Boolean__System_Security_AccessControl_SemaphoreSecurity_\" data-linktype=\"self-bookmark\">Semaphore(Int32,Int32,String,Boolean,SemaphoreSecurity)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <h2>Methods\r\n     summary</h2>\r\n    \r\n    <table class=\"nameValue\">\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Semaphore_GetAccessControl\" data-linktype=\"self-bookmark\">GetAccessControl()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Gets the access control security for a named system semaphore.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Semaphore_OpenExisting_System_String_\" data-linktype=\"self-bookmark\">OpenExisting(String)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Opens the specified named semaphore, if it already exists.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Semaphore_OpenExisting_System_String_System_Security_AccessControl_SemaphoreRights_\" data-linktype=\"self-bookmark\">OpenExisting(String,SemaphoreRights)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Opens the specified named semaphore, if it already exists, with the desired security access.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Semaphore_Release\" data-linktype=\"self-bookmark\">Release()</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Exits the semaphore and returns the previous count.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Semaphore_Release_System_Int32_\" data-linktype=\"self-bookmark\">Release(Int32)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Exits the semaphore a specified number of times and returns the previous count.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Semaphore_SetAccessControl_System_Security_AccessControl_SemaphoreSecurity_\" data-linktype=\"self-bookmark\">SetAccessControl(SemaphoreSecurity)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Sets the access control security for a named system semaphore.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Semaphore_TryOpenExisting_System_String_System_Threading_Semaphore__\" data-linktype=\"self-bookmark\">TryOpenExisting(String,Semaphore)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</p>\n\r\n            </td>\r\n        </tr>\r\n        <tr class=\" enable-platform-filter\">\r\n          <td>\r\n            <div class=\"lang-csharp\"><a href=\"#System_Threading_Semaphore_TryOpenExisting_System_String_System_Security_AccessControl_SemaphoreRights_System_Threading_Semaphore__\" data-linktype=\"self-bookmark\">TryOpenExisting(String,SemaphoreRights,Semaphore)</a></div>\r\n          </td>\r\n            <td>\r\n            <p>Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</p>\n\r\n            </td>\r\n        </tr>\r\n    </table>\r\n    <section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"constructors\">\r\n        <h2>Constructors\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Semaphore__ctor_System_Int32_System_Int32_\">\r\n    \r\n            <a id=\"System_Threading_Semaphore__ctor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Semaphore(Int32,Int32)</div>        \r\n          </div>\r\n    \r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> class, specifying the initial number of entries and the maximum number of concurrent entries.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public Semaphore (int initialCount, int maximumCount);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>initialCount</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The initial number of requests for the semaphore that can be granted concurrently.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>maximumCount</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The maximum number of requests for the semaphore that can be granted concurrently.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>initialCount</code> is greater than <code>maximumCount</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p><code>maximumCount</code> is less than 1.  </p>\n<p> -or-  </p>\n<p> <code>initialCount</code> is less than 0.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This constructor initializes an unnamed semaphore. All threads that use an instance of such a semaphore must have references to the instance.  </p>\n<p> If <code>initialCount</code> is less than <code>maximumCount</code>, the effect is the same as if the current thread had called <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> (<code>maximumCount</code> minus <code>initialCount</code>) times. If you do not want to reserve any entries for the thread that creates the semaphore, use the same number for <code>maximumCount</code> and <code>initialCount</code>.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following example creates a semaphore with a maximum count of three and an initial count of zero. The example starts five threads, which block waiting for the semaphore. The main thread uses the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_Release_System_Int32_\" data-linktype=\"relative-path\">Release(Int32)</a> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore. Each thread uses the <a class=\"xref\" href=\"system.threading.thread#System_Threading_Thread_Sleep_\" data-linktype=\"relative-path\">Sleep</a> method to wait for one second, to simulate work, and then calls the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_Release\" data-linktype=\"relative-path\">Release()</a> method overload to release the semaphore. Each time the semaphore is released, the previous semaphore count is displayed. Console messages track semaphore use. The simulated work interval is increased slightly for each thread, to make the output easier to read.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Threading.Semaphore2#1\">#using &lt;System.dll&gt;\nusing namespace System;\nusing namespace System::Threading;\n\npublic ref class Example\n{\nprivate:\n   // A semaphore that simulates a limited resource pool.\n   //\n   static Semaphore^ _pool;\n\n   // A padding interval to make the output more orderly.\n   static int _padding;\n\npublic:\n   static void Main()\n   {\n      // Create a semaphore that can satisfy up to three\n      // concurrent requests. Use an initial count of zero,\n      // so that the entire semaphore count is initially\n      // owned by the main program thread.\n      //\n      _pool = gcnew Semaphore( 0,3 );\n      \n      // Create and start five numbered threads.\n      //\n      for ( int i = 1; i &lt;= 5; i++ )\n      {\n         Thread^ t = gcnew Thread(\n            gcnew ParameterizedThreadStart( Worker ) );\n         \n         // Start the thread, passing the number.\n         //\n         t-&gt;Start( i );\n      }\n      \n      // Wait for half a second, to allow all the\n      // threads to start and to block on the semaphore.\n      //\n      Thread::Sleep( 500 );\n      \n      // The main thread starts out holding the entire\n      // semaphore count. Calling Release(3) brings the\n      // semaphore count back to its maximum value, and\n      // allows the waiting threads to enter the semaphore,\n      // up to three at a time.\n      //\n      Console::WriteLine( L&quot;Main thread calls Release(3).&quot; );\n      _pool-&gt;Release( 3 );\n\n      Console::WriteLine( L&quot;Main thread exits.&quot; );\n   }\n\nprivate:\n   static void Worker( Object^ num )\n   {\n      // Each worker thread begins by requesting the\n      // semaphore.\n      Console::WriteLine( L&quot;Thread {0} begins and waits for the semaphore.&quot;, num );\n      _pool-&gt;WaitOne();\n      \n      // A padding interval to make the output more orderly.\n      int padding = Interlocked::Add( _padding, 100 );\n\n      Console::WriteLine( L&quot;Thread {0} enters the semaphore.&quot;, num );\n      \n      // The thread&#39;s &quot;work&quot; consists of sleeping for\n      // about a second. Each thread &quot;works&quot; a little\n      // longer, just to make the output more orderly.\n      //\n      Thread::Sleep( 1000 + padding );\n\n      Console::WriteLine( L&quot;Thread {0} releases the semaphore.&quot;, num );\n      Console::WriteLine( L&quot;Thread {0} previous semaphore count: {1}&quot;,\n         num, _pool-&gt;Release() );\n   }\n};\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Semaphore2#1\">Imports System\nImports System.Threading\n\nPublic Class Example\n\n    &#39; A semaphore that simulates a limited resource pool.\n    &#39;\n    Private Shared _pool As Semaphore\n\n    &#39; A padding interval to make the output more orderly.\n    Private Shared _padding As Integer\n\n    &lt;MTAThread&gt; _\n    Public Shared Sub Main()\n        &#39; Create a semaphore that can satisfy up to three\n        &#39; concurrent requests. Use an initial count of zero,\n        &#39; so that the entire semaphore count is initially\n        &#39; owned by the main program thread.\n        &#39;\n        _pool = New Semaphore(0, 3)\n\n        &#39; Create and start five numbered threads. \n        &#39;\n        For i As Integer = 1 To 5\n            Dim t As New Thread(New ParameterizedThreadStart(AddressOf Worker))\n            &#39;Dim t As New Thread(AddressOf Worker)\n\n            &#39; Start the thread, passing the number.\n            &#39;\n            t.Start(i)\n        Next i\n\n        &#39; Wait for half a second, to allow all the\n        &#39; threads to start and to block on the semaphore.\n        &#39;\n        Thread.Sleep(500)\n\n        &#39; The main thread starts out holding the entire\n        &#39; semaphore count. Calling Release(3) brings the \n        &#39; semaphore count back to its maximum value, and\n        &#39; allows the waiting threads to enter the semaphore,\n        &#39; up to three at a time.\n        &#39;\n        Console.WriteLine(&quot;Main thread calls Release(3).&quot;)\n        _pool.Release(3)\n\n        Console.WriteLine(&quot;Main thread exits.&quot;)\n    End Sub\n\n    Private Shared Sub Worker(ByVal num As Object)\n        &#39; Each worker thread begins by requesting the\n        &#39; semaphore.\n        Console.WriteLine(&quot;Thread {0} begins &quot; _\n            &amp; &quot;and waits for the semaphore.&quot;, num)\n        _pool.WaitOne()\n\n        &#39; A padding interval to make the output more orderly.\n        Dim padding As Integer = Interlocked.Add(_padding, 100)\n\n        Console.WriteLine(&quot;Thread {0} enters the semaphore.&quot;, num)\n        \n        &#39; The thread&#39;s &quot;work&quot; consists of sleeping for \n        &#39; about a second. Each thread &quot;works&quot; a little \n        &#39; longer, just to make the output more orderly.\n        &#39;\n        Thread.Sleep(1000 + padding)\n\n        Console.WriteLine(&quot;Thread {0} releases the semaphore.&quot;, num)\n        Console.WriteLine(&quot;Thread {0} previous semaphore count: {1}&quot;, _\n            num, _\n            _pool.Release())\n    End Sub\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.Semaphore2#1\">using System;\nusing System.Threading;\n\npublic class Example\n{\n    // A semaphore that simulates a limited resource pool.\n    //\n    private static Semaphore _pool;\n\n    // A padding interval to make the output more orderly.\n    private static int _padding;\n\n    public static void Main()\n    {\n        // Create a semaphore that can satisfy up to three\n        // concurrent requests. Use an initial count of zero,\n        // so that the entire semaphore count is initially\n        // owned by the main program thread.\n        //\n        _pool = new Semaphore(0, 3);\n\n        // Create and start five numbered threads. \n        //\n        for(int i = 1; i &lt;= 5; i++)\n        {\n            Thread t = new Thread(new ParameterizedThreadStart(Worker));\n\n            // Start the thread, passing the number.\n            //\n            t.Start(i);\n        }\n\n        // Wait for half a second, to allow all the\n        // threads to start and to block on the semaphore.\n        //\n        Thread.Sleep(500);\n\n        // The main thread starts out holding the entire\n        // semaphore count. Calling Release(3) brings the \n        // semaphore count back to its maximum value, and\n        // allows the waiting threads to enter the semaphore,\n        // up to three at a time.\n        //\n        Console.WriteLine(&quot;Main thread calls Release(3).&quot;);\n        _pool.Release(3);\n\n        Console.WriteLine(&quot;Main thread exits.&quot;);\n    }\n\n    private static void Worker(object num)\n    {\n        // Each worker thread begins by requesting the\n        // semaphore.\n        Console.WriteLine(&quot;Thread {0} begins &quot; +\n            &quot;and waits for the semaphore.&quot;, num);\n        _pool.WaitOne();\n\n        // A padding interval to make the output more orderly.\n        int padding = Interlocked.Add(ref _padding, 100);\n\n        Console.WriteLine(&quot;Thread {0} enters the semaphore.&quot;, num);\n        \n        // The thread&#39;s &quot;work&quot; consists of sleeping for \n        // about a second. Each thread &quot;works&quot; a little \n        // longer, just to make the output more orderly.\n        //\n        Thread.Sleep(1000 + padding);\n\n        Console.WriteLine(&quot;Thread {0} releases the semaphore.&quot;, num);\n        Console.WriteLine(&quot;Thread {0} previous semaphore count: {1}&quot;,\n            num, _pool.Release());\n    }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Semaphore__ctor_System_Int32_System_Int32_System_String_\">\r\n    \r\n            <a id=\"System_Threading_Semaphore__ctor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Semaphore(Int32,Int32,String)</div>        \r\n          </div>\r\n    \r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public Semaphore (int initialCount, int maximumCount, string name);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>initialCount</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The initial number of requests for the semaphore that can be granted concurrently.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>maximumCount</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The maximum number of requests for the semaphore that can be granted concurrently.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of a named system semaphore object.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>initialCount</code> is greater than <code>maximumCount</code>.  </p>\n<p> -or-  </p>\n<p> <code>name</code> is longer than 260 characters.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p><code>maximumCount</code> is less than 1.  </p>\n<p> -or-  </p>\n<p> <code>initialCount</code> is less than 0.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a></div>\r\n                  </div>\r\n                  <p>A Win32 error occurred.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The named semaphore exists and has access control security, and the user does not have <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">SemaphoreRights</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandlecannotbeopenedexception\" data-linktype=\"relative-path\">WaitHandleCannotBeOpenedException</a></div>\r\n                  </div>\r\n                  <p>The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This constructor initializes a <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> object that represents a named system semaphore. You can create multiple <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> objects that represent the same named system semaphore.  </p>\n<p> If the named system semaphore does not exist, it is created with the initial count and maximum count specified by <code>initialCount</code> and <code>maximumCount</code>. If the named system semaphore already exists, <code>initialCount</code> and <code>maximumCount</code> are not used, although invalid values still cause exceptions. If you need to determine whether or not a named system semaphore was created, use the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore__ctor_System_Int32_System_Int32_System_String_System_Boolean__\" data-linktype=\"relative-path\">Semaphore(Int32,Int32,String,Boolean)</a> constructor overload instead.  </p>\n<div class=\"IMPORTANT\"><h5>Important</h5><p> When you use this constructor overload, the recommended practice is to specify the same number for <code>initialCount</code> and <code>maximumCount</code>. If <code>initialCount</code> is less than <code>maximumCount</code>, and a named system semaphore is created, the effect is the same as if the current thread had called <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> (<code>maximumCount</code> minus <code>initialCount</code>) times. However, with this constructor overload there is no way to determine whether a named system semaphore was created.  </p>\n</div>\n<p> If you specify <code>null</code> or an empty string for <code>name</code>, a local semaphore is created, as if you had called the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore__ctor_System_Int32_System_Int32_\" data-linktype=\"relative-path\">Semaphore(Int32,Int32)</a> constructor overload.  </p>\n<p> Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.  </p>\n<p> If you want to find out whether a named system semaphore exists, use the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_OpenExisting_\" data-linktype=\"relative-path\">OpenExisting</a> method. The <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_OpenExisting_\" data-linktype=\"relative-path\">OpenExisting</a> method attempts to open an existing named semaphore, and throws an exception if the system semaphore does not exist.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates the cross-process behavior of a named semaphore. The example creates a named semaphore with a maximum count of five and an initial count of five. The program makes three calls to the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> method. Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a>. Release one or more entries in the first copy of the program to unblock the second.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Threading.Semaphore.ctor named 3#1\">#using &lt;System.dll&gt;\nusing namespace System;\nusing namespace System::Threading;\n\npublic ref class Example\n{\npublic:\n   static void main()\n   {\n      // Create a Semaphore object that represents the named\n      // system semaphore &quot;SemaphoreExample3&quot;. The semaphore has a\n      // maximum count of five. The initial count is also five.\n      // There is no point in using a smaller initial count,\n      // because the initial count is not used if this program\n      // doesn&#39;t create the named system semaphore, and with\n      // this method overload there is no way to tell. Thus, this\n      // program assumes that it is competing with other\n      // programs for the semaphore.\n      //\n      Semaphore^ sem = gcnew Semaphore( 5,5,L&quot;SemaphoreExample3&quot; );\n      \n      // Attempt to enter the semaphore three times. If another\n      // copy of this program is already running, only the first\n      // two requests can be satisfied. The third blocks. Note\n      // that in a real application, timeouts should be used\n      // on the WaitOne calls, to avoid deadlocks.\n      //\n      sem-&gt;WaitOne();\n      Console::WriteLine( L&quot;Entered the semaphore once.&quot; );\n      sem-&gt;WaitOne();\n      Console::WriteLine( L&quot;Entered the semaphore twice.&quot; );\n      sem-&gt;WaitOne();\n      Console::WriteLine( L&quot;Entered the semaphore three times.&quot; );\n      \n      // The thread executing this program has entered the\n      // semaphore three times. If a second copy of the program\n      // is run, it will block until this program releases the\n      // semaphore at least once.\n      //\n      Console::WriteLine( L&quot;Enter the number of times to call Release.&quot; );\n      int n;\n      if ( Int32::TryParse( Console::ReadLine(),n ) )\n      {\n         sem-&gt;Release( n );\n      }\n\n      int remaining = 3 - n;\n      if ( remaining &gt; 0 )\n      {\n         Console::WriteLine( L&quot;Press Enter to release the remaining &quot;\n         L&quot;count ({0}) and exit the program.&quot;, remaining );\n         Console::ReadLine();\n         sem-&gt;Release( remaining );\n      }\n   }\n};\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.Semaphore.ctor named 3#1\">using System;\nusing System.Threading;\n\npublic class Example\n{\n    public static void Main()\n    {\n        // Create a Semaphore object that represents the named \n        // system semaphore &quot;SemaphoreExample3&quot;. The semaphore has a\n        // maximum count of five. The initial count is also five. \n        // There is no point in using a smaller initial count,\n        // because the initial count is not used if this program\n        // doesn&#39;t create the named system semaphore, and with \n        // this method overload there is no way to tell. Thus, this\n        // program assumes that it is competing with other\n        // programs for the semaphore.\n        //\n        Semaphore sem = new Semaphore(5, 5, &quot;SemaphoreExample3&quot;);\n\n        // Attempt to enter the semaphore three times. If another \n        // copy of this program is already running, only the first\n        // two requests can be satisfied. The third blocks. Note \n        // that in a real application, timeouts should be used\n        // on the WaitOne calls, to avoid deadlocks.\n        //\n        sem.WaitOne();\n        Console.WriteLine(&quot;Entered the semaphore once.&quot;);\n        sem.WaitOne();\n        Console.WriteLine(&quot;Entered the semaphore twice.&quot;);\n        sem.WaitOne();\n        Console.WriteLine(&quot;Entered the semaphore three times.&quot;);\n\n        // The thread executing this program has entered the \n        // semaphore three times. If a second copy of the program\n        // is run, it will block until this program releases the \n        // semaphore at least once.\n        //\n        Console.WriteLine(&quot;Enter the number of times to call Release.&quot;);\n        int n;\n        if (int.TryParse(Console.ReadLine(), out n))\n        {\n            sem.Release(n);\n        }\n\n        int remaining = 3 - n;\n        if (remaining &gt; 0)\n        {\n            Console.WriteLine(&quot;Press Enter to release the remaining &quot; +\n                &quot;count ({0}) and exit the program.&quot;, remaining);\n            Console.ReadLine();\n            sem.Release(remaining);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Semaphore.ctor named 3#1\">Imports System\nImports System.Threading\n\nPublic Class Example\n\n    &lt;MTAThread&gt; _\n    Public Shared Sub Main()\n        &#39; Create a Semaphore object that represents the named \n        &#39; system semaphore &quot;SemaphoreExample3&quot;. The semaphore has a\n        &#39; maximum count of five. The initial count is also five. \n        &#39; There is no point in using a smaller initial count,\n        &#39; because the initial count is not used if this program\n        &#39; doesn&#39;t create the named system semaphore, and with \n        &#39; this method overload there is no way to tell. Thus, this\n        &#39; program assumes that it is competing with other\n        &#39; programs for the semaphore.\n        &#39;\n        Dim sem As New Semaphore(5, 5, &quot;SemaphoreExample3&quot;)\n\n        &#39; Attempt to enter the semaphore three times. If another \n        &#39; copy of this program is already running, only the first\n        &#39; two requests can be satisfied. The third blocks. Note \n        &#39; that in a real application, timeouts should be used\n        &#39; on the WaitOne calls, to avoid deadlocks.\n        &#39;\n        sem.WaitOne()\n        Console.WriteLine(&quot;Entered the semaphore once.&quot;)\n        sem.WaitOne()\n        Console.WriteLine(&quot;Entered the semaphore twice.&quot;)\n        sem.WaitOne()\n        Console.WriteLine(&quot;Entered the semaphore three times.&quot;)\n\n        &#39; The thread executing this program has entered the \n        &#39; semaphore three times. If a second copy of the program\n        &#39; is run, it will block until this program releases the \n        &#39; semaphore at least once.\n        &#39;\n        Console.WriteLine(&quot;Enter the number of times to call Release.&quot;)\n        Dim n As Integer\n        If Integer.TryParse(Console.ReadLine(), n) Then\n            sem.Release(n)\n        End If\n\n        Dim remaining As Integer = 3 - n\n        If (remaining) &gt; 0 Then\n            Console.WriteLine(&quot;Press Enter to release the remaining &quot; _\n                &amp; &quot;count ({0}) and exit the program.&quot;, remaining)\n            Console.ReadLine()\n            sem.Release(remaining)\n        End If\n\n    End Sub \nEnd Class \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Semaphore__ctor_System_Int32_System_Int32_System_String_System_Boolean__\">\r\n    \r\n            <a id=\"System_Threading_Semaphore__ctor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Semaphore(Int32,Int32,String,Boolean)</div>        \r\n          </div>\r\n    \r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>initialCount</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The initial number of requests for the semaphore that can be satisfied concurrently.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>maximumCount</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The maximum number of requests for the semaphore that can be satisfied concurrently.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of a named system semaphore object.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>createdNew</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>When this method returns, contains <code>true</code> if a local semaphore was created (that is, if <code>name</code> is <code>null</code> or an empty string) or if the specified named system semaphore was created; <code>false</code> if the specified named system semaphore already existed. This parameter is passed uninitialized.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>initialCount</code> is greater than <code>maximumCount</code>.  </p>\n<p> -or-  </p>\n<p> <code>name</code> is longer than 260 characters.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p><code>maximumCount</code> is less than 1.  </p>\n<p> -or-  </p>\n<p> <code>initialCount</code> is less than 0.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a></div>\r\n                  </div>\r\n                  <p>A Win32 error occurred.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The named semaphore exists and has access control security, and the user does not have <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">SemaphoreRights</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandlecannotbeopenedexception\" data-linktype=\"relative-path\">WaitHandleCannotBeOpenedException</a></div>\r\n                  </div>\r\n                  <p>The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>This constructor initializes a <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> object that represents a named system semaphore. You can create multiple <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> objects that represent the same named system semaphore.  </p>\n<p> If the named system semaphore does not exist, it is created with the initial count and maximum count specified by <code>initialCount</code> and <code>maximumCount</code>. If the named system semaphore already exists, <code>initialCount</code> and <code>maximumCount</code> are not used, although invalid values still cause exceptions. Use <code>createdNew</code> to determine whether the system semaphore was created.  </p>\n<p> If <code>initialCount</code> is less than <code>maximumCount</code>, and <code>createdNew</code> is <code>true</code>, the effect is the same as if the current thread had called <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> (<code>maximumCount</code> minus <code>initialCount</code>) times.  </p>\n<p> If you specify <code>null</code> or an empty string for <code>name</code>, a local semaphore is created, as if you had called the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore__ctor_System_Int32_System_Int32_\" data-linktype=\"relative-path\">Semaphore(Int32,Int32)</a> constructor overload. In this case, <code>createdNew</code> is always <code>true</code>.  </p>\n<p> Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates the cross-process behavior of a named semaphore. The example creates a named semaphore with a maximum count of five and an initial count of two. That is, it reserves three entries for the thread that calls the constructor. If <code>createNew</code> is <code>false</code>, the program makes three calls to the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> method. Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a>. Release one or more entries in the first copy of the program to unblock the second.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.Semaphore.ctor named 4#1\">using System;\nusing System.Threading;\n\npublic class Example\n{\n    public static void Main()\n    {\n        // The value of this variable is set by the semaphore\n        // constructor. It is true if the named system semaphore was\n        // created, and false if the named semaphore already existed.\n        //\n        bool semaphoreWasCreated;\n\n        // Create a Semaphore object that represents the named \n        // system semaphore &quot;SemaphoreExample&quot;. The semaphore has a\n        // maximum count of five, and an initial count of two. The\n        // Boolean value that indicates creation of the underlying \n        // system object is placed in semaphoreWasCreated.\n        //\n        Semaphore sem = new Semaphore(2, 5, &quot;SemaphoreExample&quot;, \n            out semaphoreWasCreated);\n\n        if (semaphoreWasCreated)\n        {\n            // If the named system semaphore was created, its count is\n            // set to the initial count requested in the constructor.\n            // In effect, the current thread has entered the semaphore\n            // three times.\n            // \n            Console.WriteLine(&quot;Entered the semaphore three times.&quot;);\n        }\n        else\n        {      \n            // If the named system semaphore was not created,  \n            // attempt to enter it three times. If another copy of\n            // this program is already running, only the first two\n            // requests can be satisfied. The third blocks.\n            //\n            sem.WaitOne();\n            Console.WriteLine(&quot;Entered the semaphore once.&quot;);\n            sem.WaitOne();\n            Console.WriteLine(&quot;Entered the semaphore twice.&quot;);\n            sem.WaitOne();\n            Console.WriteLine(&quot;Entered the semaphore three times.&quot;);\n        }\n\n        // The thread executing this program has entered the \n        // semaphore three times. If a second copy of the program\n        // is run, it will block until this program releases the \n        // semaphore at least once.\n        //\n        Console.WriteLine(&quot;Enter the number of times to call Release.&quot;);\n        int n;\n        if (int.TryParse(Console.ReadLine(), out n))\n        {\n            sem.Release(n);\n        }\n\n        int remaining = 3 - n;\n        if (remaining &gt; 0)\n        {\n            Console.WriteLine(&quot;Press Enter to release the remaining &quot; +\n                &quot;count ({0}) and exit the program.&quot;, remaining);\n            Console.ReadLine();\n            sem.Release(remaining);\n        }\n    } \n} \n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Semaphore.ctor named 4#1\">Imports System\nImports System.Threading\n\nPublic Class Example\n\n    &lt;MTAThread&gt; _\n    Public Shared Sub Main()\n        &#39; The value of this variable is set by the semaphore\n        &#39; constructor. It is True if the named system semaphore was\n        &#39; created, and False if the named semaphore already existed.\n        &#39;\n        Dim semaphoreWasCreated As Boolean\n\n        &#39; Create a Semaphore object that represents the named \n        &#39; system semaphore &quot;SemaphoreExample&quot;. The semaphore has a\n        &#39; maximum count of five, and an initial count of two. The\n        &#39; Boolean value that indicates creation of the underlying \n        &#39; system object is placed in semaphoreWasCreated.\n        &#39;\n        Dim sem As New Semaphore(2, 5, &quot;SemaphoreExample&quot;, _\n            semaphoreWasCreated)\n\n        If semaphoreWasCreated Then\n            &#39; If the named system semaphore was created, its count is\n            &#39; set to the initial count requested in the constructor.\n            &#39; In effect, the current thread has entered the semaphore\n            &#39; three times.\n            &#39; \n            Console.WriteLine(&quot;Entered the semaphore three times.&quot;)\n        Else\n            &#39; If the named system semaphore was not created,  \n            &#39; attempt to enter it three times. If another copy of\n            &#39; this program is already running, only the first two\n            &#39; requests can be satisfied. The third blocks.\n            &#39;\n            sem.WaitOne()\n            Console.WriteLine(&quot;Entered the semaphore once.&quot;)\n            sem.WaitOne()\n            Console.WriteLine(&quot;Entered the semaphore twice.&quot;)\n            sem.WaitOne()\n            Console.WriteLine(&quot;Entered the semaphore three times.&quot;)\n        End If\n\n        &#39; The thread executing this program has entered the \n        &#39; semaphore three times. If a second copy of the program\n        &#39; is run, it will block until this program releases the \n        &#39; semaphore at least once.\n        &#39;\n        Console.WriteLine(&quot;Enter the number of times to call Release.&quot;)\n        Dim n As Integer\n        If Integer.TryParse(Console.ReadLine(), n) Then\n            sem.Release(n)\n        End If\n\n        Dim remaining As Integer = 3 - n\n        If (remaining) &gt; 0 Then\n            Console.WriteLine(&quot;Press Enter to release the remaining &quot; _\n                &amp; &quot;count ({0}) and exit the program.&quot;, remaining)\n            Console.ReadLine()\n            sem.Release(remaining)\n        End If\n\n    End Sub \nEnd Class \n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.Semaphore.ctor named 4#1\">#using &lt;System.dll&gt;\nusing namespace System;\nusing namespace System::Threading;\n\npublic ref class Example\n{\npublic:\n   static void main()\n   {\n      // The value of this variable is set by the semaphore\n      // constructor. It is true if the named system semaphore was\n      // created, and false if the named semaphore already existed.\n      //\n      bool semaphoreWasCreated;\n      \n      // Create a Semaphore object that represents the named\n      // system semaphore &quot;SemaphoreExample&quot;. The semaphore has a\n      // maximum count of five, and an initial count of two. The\n      // Boolean value that indicates creation of the underlying\n      // system object is placed in semaphoreWasCreated.\n      //\n      Semaphore^ sem = gcnew Semaphore( 2,5,L&quot;SemaphoreExample&quot;,\n         semaphoreWasCreated );\n      if ( semaphoreWasCreated )\n      {\n         // If the named system semaphore was created, its count is\n         // set to the initial count requested in the constructor.\n         // In effect, the current thread has entered the semaphore\n         // three times.\n         //\n         Console::WriteLine( L&quot;Entered the semaphore three times.&quot; );\n      }\n      else\n      {\n         // If the named system semaphore was not created,\n         // attempt to enter it three times. If another copy of\n         // this program is already running, only the first two\n         // requests can be satisfied. The third blocks.\n         //\n         sem-&gt;WaitOne();\n         Console::WriteLine( L&quot;Entered the semaphore once.&quot; );\n         sem-&gt;WaitOne();\n         Console::WriteLine( L&quot;Entered the semaphore twice.&quot; );\n         sem-&gt;WaitOne();\n         Console::WriteLine( L&quot;Entered the semaphore three times.&quot; );\n      }\n      \n      // The thread executing this program has entered the\n      // semaphore three times. If a second copy of the program\n      // is run, it will block until this program releases the\n      // semaphore at least once.\n      //\n      Console::WriteLine( L&quot;Enter the number of times to call Release.&quot; );\n      int n;\n      if ( Int32::TryParse( Console::ReadLine(), n ) )\n      {\n         sem-&gt;Release( n );\n      }\n\n      int remaining = 3 - n;\n      if ( remaining &gt; 0 )\n      {\n         Console::WriteLine( L&quot;Press Enter to release the remaining &quot;\n         L&quot;count ({0}) and exit the program.&quot;, remaining );\n         Console::ReadLine();\n         sem-&gt;Release( remaining );\n      }\n   }\n};\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Semaphore__ctor_System_Int32_System_Int32_System_String_System_Boolean__System_Security_AccessControl_SemaphoreSecurity_\">\r\n    \r\n            <a id=\"System_Threading_Semaphore__ctor_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Semaphore(Int32,Int32,String,Boolean,SemaphoreSecurity)</div>        \r\n          </div>\r\n    \r\n            <p>Initializes a new instance of the <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>initialCount</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The initial number of requests for the semaphore that can be satisfied concurrently.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>maximumCount</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The maximum number of requests for the semaphore that can be satisfied concurrently.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of a named system semaphore object.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>createdNew</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>When this method returns, contains <code>true</code> if a local semaphore was created (that is, if <code>name</code> is <code>null</code> or an empty string) or if the specified named system semaphore was created; <code>false</code> if the specified named system semaphore already existed. This parameter is passed uninitialized.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>semaphoreSecurity</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.accesscontrol.semaphoresecurity\" data-linktype=\"relative-path\">SemaphoreSecurity</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <a class=\"xref\" href=\"system.security.accesscontrol.semaphoresecurity\" data-linktype=\"relative-path\">SemaphoreSecurity</a> object that represents the access control security to be applied to the named system semaphore.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>initialCount</code> is greater than <code>maximumCount</code>.  </p>\n<p> -or-  </p>\n<p> <code>name</code> is longer than 260 characters.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p><code>maximumCount</code> is less than 1.  </p>\n<p> -or-  </p>\n<p> <code>initialCount</code> is less than 0.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The named semaphore exists and has access control security, and the user does not have <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">SemaphoreRights</a>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a></div>\r\n                  </div>\r\n                  <p>A Win32 error occurred.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandlecannotbeopenedexception\" data-linktype=\"relative-path\">WaitHandleCannotBeOpenedException</a></div>\r\n                  </div>\r\n                  <p>The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Use this constructor to apply access control security to a named system semaphore when it is created, preventing other code from taking control of the semaphore.  </p>\n<p> This constructor initializes a <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> object that represents a named system semaphore. You can create multiple <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> objects that represent the same named system semaphore.  </p>\n<p> If the named system semaphore does not exist, it is created with the specified access control security. If the named semaphore exists, the specified access control security is ignored.  </p>\n<div class=\"NOTE\"><h5>Note</h5><p> The caller has full control over the newly created <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> object even if <code>semaphoreSecurity</code> denies or fails to grant some access rights to the current user. However, if the current user attempts to get another <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> object to represent the same named semaphore, using either a constructor or the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_OpenExisting_\" data-linktype=\"relative-path\">OpenExisting</a> method, Windows access control security is applied.  </p>\n</div>\n<p> If the named system semaphore does not exist, it is created with the initial count and maximum count specified by <code>initialCount</code> and <code>maximumCount</code>. If the named system semaphore already exists, <code>initialCount</code> and <code>maximumCount</code> are not used, although invalid values still cause exceptions. Use the <code>createdNew</code> parameter to determine whether the system semaphore was created by this constructor.  </p>\n<p> If <code>initialCount</code> is less than <code>maximumCount</code>, and <code>createdNew</code> is <code>true</code>, the effect is the same as if the current thread had called <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> (<code>maximumCount</code> minus <code>initialCount</code>) times.  </p>\n<p> If you specify <code>null</code> or an empty string for <code>name</code>, a local semaphore is created, as if you had called the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore__ctor_System_Int32_System_Int32_\" data-linktype=\"relative-path\">Semaphore(Int32,Int32)</a> constructor overload. In this case, <code>createdNew</code> is always <code>true</code>.  </p>\n<p> Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates the cross-process behavior of a named semaphore with access control security. The example uses the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a> method overload to test for the existence of a named semaphore. If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore. If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a> method. The exception is caught, and the example uses the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_OpenExisting_System_String_System_Security_AccessControl_SemaphoreRights_\" data-linktype=\"relative-path\">OpenExisting(String,SemaphoreRights)</a> method overload to open the semaphore with the rights needed to read and change the permissions.  </p>\n<p> After the permissions are changed, the semaphore is opened with the rights required to enter and release. If you run the compiled example from a third command window, it runs using the new permissions.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.Semaphore.ctor named 5a#1\">using System;\nusing System.Threading;\nusing System.Security.AccessControl;\n\ninternal class Example\n{\n    internal static void Main()\n    {\n        const string semaphoreName = &quot;SemaphoreExample5&quot;;\n\n        Semaphore sem = null;\n        bool doesNotExist = false;\n        bool unauthorized = false;\n\n        // Attempt to open the named semaphore.\n        try\n        {\n            // Open the semaphore with (SemaphoreRights.Synchronize\n            // | SemaphoreRights.Modify), to enter and release the\n            // named semaphore.\n            //\n            sem = Semaphore.OpenExisting(semaphoreName);\n        }\n        catch(WaitHandleCannotBeOpenedException)\n        {\n            Console.WriteLine(&quot;Semaphore does not exist.&quot;);\n            doesNotExist = true;\n        }\n        catch(UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n            unauthorized = true;\n        }\n\n        // There are three cases: (1) The semaphore does not exist.\n        // (2) The semaphore exists, but the current user doesn&#39;t \n        // have access. (3) The semaphore exists and the user has\n        // access.\n        //\n        if (doesNotExist)\n        {\n            // The semaphore does not exist, so create it.\n            //\n            // The value of this variable is set by the semaphore\n            // constructor. It is true if the named system semaphore was\n            // created, and false if the named semaphore already existed.\n            //\n            bool semaphoreWasCreated;\n\n            // Create an access control list (ACL) that denies the\n            // current user the right to enter or release the \n            // semaphore, but allows the right to read and change\n            // security information for the semaphore.\n            //\n            string user = Environment.UserDomainName + &quot;\\\\&quot; \n                + Environment.UserName;\n            SemaphoreSecurity semSec = new SemaphoreSecurity();\n\n            SemaphoreAccessRule rule = new SemaphoreAccessRule(\n                user, \n                SemaphoreRights.Synchronize | SemaphoreRights.Modify, \n                AccessControlType.Deny);\n            semSec.AddAccessRule(rule);\n\n            rule = new SemaphoreAccessRule(\n                user, \n                SemaphoreRights.ReadPermissions | SemaphoreRights.ChangePermissions,\n                AccessControlType.Allow);\n            semSec.AddAccessRule(rule);\n\n            // Create a Semaphore object that represents the system\n            // semaphore named by the constant &#39;semaphoreName&#39;, with\n            // maximum count three, initial count three, and the\n            // specified security access. The Boolean value that \n            // indicates creation of the underlying system object is\n            // placed in semaphoreWasCreated.\n            //\n            sem = new Semaphore(3, 3, semaphoreName, \n                out semaphoreWasCreated, semSec);\n\n            // If the named system semaphore was created, it can be\n            // used by the current instance of this program, even \n            // though the current user is denied access. The current\n            // program enters the semaphore. Otherwise, exit the\n            // program.\n            // \n            if (semaphoreWasCreated)\n            {\n                Console.WriteLine(&quot;Created the semaphore.&quot;);\n            }\n            else\n            {\n                Console.WriteLine(&quot;Unable to create the semaphore.&quot;);\n                return;\n            }\n\n        }\n        else if (unauthorized)\n        {\n            // Open the semaphore to read and change the access\n            // control security. The access control security defined\n            // above allows the current user to do this.\n            //\n            try\n            {\n                sem = Semaphore.OpenExisting(\n                    semaphoreName, \n                    SemaphoreRights.ReadPermissions \n                        | SemaphoreRights.ChangePermissions);\n\n                // Get the current ACL. This requires \n                // SemaphoreRights.ReadPermissions.\n                SemaphoreSecurity semSec = sem.GetAccessControl();\n                \n                string user = Environment.UserDomainName + &quot;\\\\&quot; \n                    + Environment.UserName;\n\n                // First, the rule that denied the current user \n                // the right to enter and release the semaphore must\n                // be removed.\n                SemaphoreAccessRule rule = new SemaphoreAccessRule(\n                    user, \n                    SemaphoreRights.Synchronize | SemaphoreRights.Modify, \n                    AccessControlType.Deny);\n                semSec.RemoveAccessRule(rule);\n\n                // Now grant the user the correct rights.\n                // \n                rule = new SemaphoreAccessRule(user, \n                     SemaphoreRights.Synchronize | SemaphoreRights.Modify, \n                     AccessControlType.Allow);\n                semSec.AddAccessRule(rule);\n\n                // Update the ACL. This requires\n                // SemaphoreRights.ChangePermissions.\n                sem.SetAccessControl(semSec);\n\n                Console.WriteLine(&quot;Updated semaphore security.&quot;);\n\n                // Open the semaphore with (SemaphoreRights.Synchronize \n                // | SemaphoreRights.Modify), the rights required to\n                // enter and release the semaphore.\n                //\n                sem = Semaphore.OpenExisting(semaphoreName);\n\n            }\n            catch(UnauthorizedAccessException ex)\n            {\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;, ex.Message);\n                return;\n            }\n        }\n\n        // Enter the semaphore, and hold it until the program\n        // exits.\n        //\n        try\n        {\n            sem.WaitOne();\n            Console.WriteLine(&quot;Entered the semaphore.&quot;);\n            Console.WriteLine(&quot;Press the Enter key to exit.&quot;);\n            Console.ReadLine();\n            sem.Release();\n        }\n        catch(UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.Semaphore.ctor named 5a#1\">#using &lt;System.dll&gt;\nusing namespace System;\nusing namespace System::Threading;\nusing namespace System::Security::AccessControl;\nusing namespace System::Security::Permissions;\n\npublic ref class Example\n{\npublic:\n   [SecurityPermissionAttribute(SecurityAction::Demand, Flags = SecurityPermissionFlag::UnmanagedCode)]\n   static void main()\n   {\n      String^ semaphoreName = L&quot;SemaphoreExample5&quot;;\n\n      Semaphore^ sem = nullptr;\n      bool doesNotExist = false;\n      bool unauthorized = false;\n      \n      // Attempt to open the named semaphore.\n      try\n      {\n         // Open the semaphore with (SemaphoreRights.Synchronize\n         // | SemaphoreRights.Modify), to enter and release the\n         // named semaphore.\n         //\n         sem = Semaphore::OpenExisting( semaphoreName );\n      }\n      catch ( WaitHandleCannotBeOpenedException^ ex ) \n      {\n         Console::WriteLine( L&quot;Semaphore does not exist.&quot; );\n         doesNotExist = true;\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n         unauthorized = true;\n      }\n\n      // There are three cases: (1) The semaphore does not exist.\n      // (2) The semaphore exists, but the current user doesn&#39;t\n      // have access. (3) The semaphore exists and the user has\n      // access.\n      //\n      if ( doesNotExist )\n      {\n         // The semaphore does not exist, so create it.\n         //\n         // The value of this variable is set by the semaphore\n         // constructor. It is true if the named system semaphore was\n         // created, and false if the named semaphore already existed.\n         //\n         bool semaphoreWasCreated;\n         \n         // Create an access control list (ACL) that denies the\n         // current user the right to enter or release the\n         // semaphore, but allows the right to read and change\n         // security information for the semaphore.\n         //\n         String^ user = String::Concat( Environment::UserDomainName,\n            L&quot;\\\\&quot;, Environment::UserName );\n         SemaphoreSecurity^ semSec = gcnew SemaphoreSecurity;\n\n         SemaphoreAccessRule^ rule = gcnew SemaphoreAccessRule( user,\n            static_cast&lt;SemaphoreRights&gt;(\n               SemaphoreRights::Synchronize |\n               SemaphoreRights::Modify ),\n            AccessControlType::Deny );\n         semSec-&gt;AddAccessRule( rule );\n\n         rule = gcnew SemaphoreAccessRule( user,\n            static_cast&lt;SemaphoreRights&gt;(\n               SemaphoreRights::ReadPermissions |\n               SemaphoreRights::ChangePermissions ),\n            AccessControlType::Allow );\n         semSec-&gt;AddAccessRule( rule );\n         \n         // Create a Semaphore object that represents the system\n         // semaphore named by the constant &#39;semaphoreName&#39;, with\n         // maximum count three, initial count three, and the\n         // specified security access. The Boolean value that\n         // indicates creation of the underlying system object is\n         // placed in semaphoreWasCreated.\n         //\n         sem = gcnew Semaphore( 3,3,semaphoreName,semaphoreWasCreated,semSec );\n         \n         // If the named system semaphore was created, it can be\n         // used by the current instance of this program, even\n         // though the current user is denied access. The current\n         // program enters the semaphore. Otherwise, exit the\n         // program.\n         //\n         if ( semaphoreWasCreated )\n         {\n            Console::WriteLine( L&quot;Created the semaphore.&quot; );\n         }\n         else\n         {\n            Console::WriteLine( L&quot;Unable to create the semaphore.&quot; );\n            return;\n         }\n\n      }\n      else if ( unauthorized )\n      {\n         // Open the semaphore to read and change the access\n         // control security. The access control security defined\n         // above allows the current user to do this.\n         //\n         try\n         {\n            sem = Semaphore::OpenExisting( semaphoreName,\n               static_cast&lt;SemaphoreRights&gt;(\n                  SemaphoreRights::ReadPermissions |\n                  SemaphoreRights::ChangePermissions ));\n            \n            // Get the current ACL. This requires\n            // SemaphoreRights.ReadPermissions.\n            SemaphoreSecurity^ semSec = sem-&gt;GetAccessControl();\n\n            String^ user = String::Concat( Environment::UserDomainName,\n               L&quot;\\\\&quot;, Environment::UserName );\n            \n            // First, the rule that denied the current user\n            // the right to enter and release the semaphore must\n            // be removed.\n            SemaphoreAccessRule^ rule = gcnew SemaphoreAccessRule( user,\n               static_cast&lt;SemaphoreRights&gt;(\n                  SemaphoreRights::Synchronize |\n                  SemaphoreRights::Modify ),\n               AccessControlType::Deny );\n            semSec-&gt;RemoveAccessRule( rule );\n            \n            // Now grant the user the correct rights.\n            //\n            rule = gcnew SemaphoreAccessRule( user,\n               static_cast&lt;SemaphoreRights&gt;(\n                  SemaphoreRights::Synchronize |\n                  SemaphoreRights::Modify ),\n               AccessControlType::Allow );\n            semSec-&gt;AddAccessRule( rule );\n            \n            // Update the ACL. This requires\n            // SemaphoreRights.ChangePermissions.\n            sem-&gt;SetAccessControl( semSec );\n\n            Console::WriteLine( L&quot;Updated semaphore security.&quot; );\n            \n            // Open the semaphore with (SemaphoreRights.Synchronize\n            // | SemaphoreRights.Modify), the rights required to\n            // enter and release the semaphore.\n            //\n            sem = Semaphore::OpenExisting( semaphoreName );\n\n         }\n         catch ( UnauthorizedAccessException^ ex ) \n         {\n            Console::WriteLine( L&quot;Unable to change permissions: {0}&quot;, ex-&gt;Message );\n            return;\n         }\n      }\n      \n      // Enter the semaphore, and hold it until the program\n      // exits.\n      //\n      try\n      {\n         sem-&gt;WaitOne();\n         Console::WriteLine( L&quot;Entered the semaphore.&quot; );\n         Console::WriteLine( L&quot;Press the Enter key to exit.&quot; );\n         Console::ReadLine();\n         sem-&gt;Release();\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n      }\n   }\n};\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Semaphore.ctor named 5a#1\">Imports System\nImports System.Threading\nImports System.Security.AccessControl\n\nFriend Class Example\n\n    &lt;MTAThread&gt; _\n    Friend Shared Sub Main()\n        Const semaphoreName As String = &quot;SemaphoreExample5&quot;\n\n        Dim sem As Semaphore = Nothing\n        Dim doesNotExist as Boolean = False\n        Dim unauthorized As Boolean = False\n\n        &#39; Attempt to open the named semaphore.\n        Try\n            &#39; Open the semaphore with (SemaphoreRights.Synchronize\n            &#39; Or SemaphoreRights.Modify), to enter and release the\n            &#39; named semaphore.\n            &#39;\n            sem = Semaphore.OpenExisting(semaphoreName)\n        Catch ex As WaitHandleCannotBeOpenedException\n            Console.WriteLine(&quot;Semaphore does not exist.&quot;)\n            doesNotExist = True\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message)\n            unauthorized = True\n        End Try\n\n        &#39; There are three cases: (1) The semaphore does not exist.\n        &#39; (2) The semaphore exists, but the current user doesn&#39;t \n        &#39; have access. (3) The semaphore exists and the user has\n        &#39; access.\n        &#39;\n        If doesNotExist Then\n            &#39; The semaphore does not exist, so create it.\n            &#39;\n            &#39; The value of this variable is set by the semaphore\n            &#39; constructor. It is True if the named system semaphore was\n            &#39; created, and False if the named semaphore already existed.\n            &#39;\n            Dim semaphoreWasCreated As Boolean\n\n            &#39; Create an access control list (ACL) that denies the\n            &#39; current user the right to enter or release the \n            &#39; semaphore, but allows the right to read and change\n            &#39; security information for the semaphore.\n            &#39;\n            Dim user As String = Environment.UserDomainName _ \n                &amp; &quot;\\&quot; &amp; Environment.UserName\n            Dim semSec As New SemaphoreSecurity()\n\n            Dim rule As New SemaphoreAccessRule(user, _\n                SemaphoreRights.Synchronize Or SemaphoreRights.Modify, _\n                AccessControlType.Deny)\n            semSec.AddAccessRule(rule)\n\n            rule = New SemaphoreAccessRule(user, _\n                SemaphoreRights.ReadPermissions Or _\n                SemaphoreRights.ChangePermissions, _\n                AccessControlType.Allow)\n            semSec.AddAccessRule(rule)\n\n            &#39; Create a Semaphore object that represents the system\n            &#39; semaphore named by the constant &#39;semaphoreName&#39;, with\n            &#39; maximum count three, initial count three, and the\n            &#39; specified security access. The Boolean value that \n            &#39; indicates creation of the underlying system object is\n            &#39; placed in semaphoreWasCreated.\n            &#39;\n            sem = New Semaphore(3, 3, semaphoreName, _\n                semaphoreWasCreated, semSec)\n\n            &#39; If the named system semaphore was created, it can be\n            &#39; used by the current instance of this program, even \n            &#39; though the current user is denied access. The current\n            &#39; program enters the semaphore. Otherwise, exit the\n            &#39; program.\n            &#39; \n            If semaphoreWasCreated Then\n                Console.WriteLine(&quot;Created the semaphore.&quot;)\n            Else\n                Console.WriteLine(&quot;Unable to create the semaphore.&quot;)\n                Return\n            End If\n\n        ElseIf unauthorized Then\n\n            &#39; Open the semaphore to read and change the access\n            &#39; control security. The access control security defined\n            &#39; above allows the current user to do this.\n            &#39;\n            Try\n                sem = Semaphore.OpenExisting(semaphoreName, _\n                    SemaphoreRights.ReadPermissions Or _\n                    SemaphoreRights.ChangePermissions)\n\n                &#39; Get the current ACL. This requires \n                &#39; SemaphoreRights.ReadPermissions.\n                Dim semSec As SemaphoreSecurity = sem.GetAccessControl()\n                \n                Dim user As String = Environment.UserDomainName _ \n                    &amp; &quot;\\&quot; &amp; Environment.UserName\n\n                &#39; First, the rule that denied the current user \n                &#39; the right to enter and release the semaphore must\n                &#39; be removed.\n                Dim rule As New SemaphoreAccessRule(user, _\n                    SemaphoreRights.Synchronize Or SemaphoreRights.Modify, _\n                    AccessControlType.Deny)\n                semSec.RemoveAccessRule(rule)\n\n                &#39; Now grant the user the correct rights.\n                &#39; \n                rule = New SemaphoreAccessRule(user, _\n                    SemaphoreRights.Synchronize Or SemaphoreRights.Modify, _\n                    AccessControlType.Allow)\n                semSec.AddAccessRule(rule)\n\n                &#39; Update the ACL. This requires\n                &#39; SemaphoreRights.ChangePermissions.\n                sem.SetAccessControl(semSec)\n\n                Console.WriteLine(&quot;Updated semaphore security.&quot;)\n\n                &#39; Open the semaphore with (SemaphoreRights.Synchronize \n                &#39; Or SemaphoreRights.Modify), the rights required to\n                &#39; enter and release the semaphore.\n                &#39;\n                sem = Semaphore.OpenExisting(semaphoreName)\n\n            Catch ex As UnauthorizedAccessException\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;, _\n                    ex.Message)\n                Return\n            End Try\n\n        End If\n\n        &#39; Enter the semaphore, and hold it until the program\n        &#39; exits.\n        &#39;\n        Try\n            sem.WaitOne()\n            Console.WriteLine(&quot;Entered the semaphore.&quot;)\n            Console.WriteLine(&quot;Press the Enter key to exit.&quot;)\n            Console.ReadLine()\n            sem.Release()\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, _\n                ex.Message)\n        End Try\n    End Sub \nEnd Class \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section><section class=\"memberGroup\">\r\n      <header class=\"header enable-platform-filter\" id=\"methods\">\r\n        <h2>Methods\r\n    </h2>\r\n      </header>\r\n    \r\n      <ul class=\"list-clean enable-platform-filter\">\r\n    \r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Semaphore_GetAccessControl\">\r\n    \r\n            <a id=\"System_Threading_Semaphore_GetAccessControl_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">GetAccessControl()</div>        \r\n          </div>\r\n    \r\n            <p>Gets the access control security for a named system semaphore.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.accesscontrol.semaphoresecurity\" data-linktype=\"relative-path\">SemaphoreSecurity</a></div>\r\n                  </div>\r\n                  <p>A <a class=\"xref\" href=\"system.security.accesscontrol.semaphoresecurity\" data-linktype=\"relative-path\">SemaphoreSecurity</a> object that represents the access control security for the named system semaphore.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The current <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> object represents a named system semaphore, and the user does not have <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">SemaphoreRights</a> rights.  </p>\n<p> -or-  </p>\n<p> The current <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> object represents a named system semaphore and was not opened with <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">SemaphoreRights</a> rights.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>Not supported for Windows 98 or Windows Millennium Edition.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The GetAccessControl method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <a class=\"xref\" href=\"system.security.accesscontrol.accesscontrolsections\" data-linktype=\"relative-path\">System.Security.AccessControl.AccessControlSections</a>, <a class=\"xref\" href=\"system.security.accesscontrol.accesscontrolsections\" data-linktype=\"relative-path\">System.Security.AccessControl.AccessControlSections</a>, and <a class=\"xref\" href=\"system.security.accesscontrol.accesscontrolsections\" data-linktype=\"relative-path\">System.Security.AccessControl.AccessControlSections</a>.  </p>\n<p> The user must have <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">System.Security.AccessControl.SemaphoreRights</a> rights to call this method, and the semaphore must have been opened with <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">System.Security.AccessControl.SemaphoreRights</a> rights.  </p>\n<p> On a local semaphore, access control security is irrelevant. If the <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> object does not represent a named system semaphore, this method returns a <a class=\"xref\" href=\"system.security.accesscontrol.semaphoresecurity\" data-linktype=\"relative-path\">SemaphoreSecurity</a> object that grants all rights to any user.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates the cross-process behavior of a named semaphore with access control security. The example uses the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a> method overload to test for the existence of a named semaphore.  </p>\n<p> If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.  </p>\n<p> If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a> method. The exception is caught, and the example uses the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_OpenExisting_System_String_System_Security_AccessControl_SemaphoreRights_\" data-linktype=\"relative-path\">OpenExisting(String,SemaphoreRights)</a> method overload to open the semaphore with the rights needed to read and change the permissions. The access control security for the system semaphore is obtained using the GetAccessControl method.  </p>\n<p> After the permissions are changed, the semaphore is opened with the rights required to enter and release. If you run the compiled example from a third command window, it runs using the new permissions.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.Semaphore.ctor named 5a#1\">using System;\nusing System.Threading;\nusing System.Security.AccessControl;\n\ninternal class Example\n{\n    internal static void Main()\n    {\n        const string semaphoreName = &quot;SemaphoreExample5&quot;;\n\n        Semaphore sem = null;\n        bool doesNotExist = false;\n        bool unauthorized = false;\n\n        // Attempt to open the named semaphore.\n        try\n        {\n            // Open the semaphore with (SemaphoreRights.Synchronize\n            // | SemaphoreRights.Modify), to enter and release the\n            // named semaphore.\n            //\n            sem = Semaphore.OpenExisting(semaphoreName);\n        }\n        catch(WaitHandleCannotBeOpenedException)\n        {\n            Console.WriteLine(&quot;Semaphore does not exist.&quot;);\n            doesNotExist = true;\n        }\n        catch(UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n            unauthorized = true;\n        }\n\n        // There are three cases: (1) The semaphore does not exist.\n        // (2) The semaphore exists, but the current user doesn&#39;t \n        // have access. (3) The semaphore exists and the user has\n        // access.\n        //\n        if (doesNotExist)\n        {\n            // The semaphore does not exist, so create it.\n            //\n            // The value of this variable is set by the semaphore\n            // constructor. It is true if the named system semaphore was\n            // created, and false if the named semaphore already existed.\n            //\n            bool semaphoreWasCreated;\n\n            // Create an access control list (ACL) that denies the\n            // current user the right to enter or release the \n            // semaphore, but allows the right to read and change\n            // security information for the semaphore.\n            //\n            string user = Environment.UserDomainName + &quot;\\\\&quot; \n                + Environment.UserName;\n            SemaphoreSecurity semSec = new SemaphoreSecurity();\n\n            SemaphoreAccessRule rule = new SemaphoreAccessRule(\n                user, \n                SemaphoreRights.Synchronize | SemaphoreRights.Modify, \n                AccessControlType.Deny);\n            semSec.AddAccessRule(rule);\n\n            rule = new SemaphoreAccessRule(\n                user, \n                SemaphoreRights.ReadPermissions | SemaphoreRights.ChangePermissions,\n                AccessControlType.Allow);\n            semSec.AddAccessRule(rule);\n\n            // Create a Semaphore object that represents the system\n            // semaphore named by the constant &#39;semaphoreName&#39;, with\n            // maximum count three, initial count three, and the\n            // specified security access. The Boolean value that \n            // indicates creation of the underlying system object is\n            // placed in semaphoreWasCreated.\n            //\n            sem = new Semaphore(3, 3, semaphoreName, \n                out semaphoreWasCreated, semSec);\n\n            // If the named system semaphore was created, it can be\n            // used by the current instance of this program, even \n            // though the current user is denied access. The current\n            // program enters the semaphore. Otherwise, exit the\n            // program.\n            // \n            if (semaphoreWasCreated)\n            {\n                Console.WriteLine(&quot;Created the semaphore.&quot;);\n            }\n            else\n            {\n                Console.WriteLine(&quot;Unable to create the semaphore.&quot;);\n                return;\n            }\n\n        }\n        else if (unauthorized)\n        {\n            // Open the semaphore to read and change the access\n            // control security. The access control security defined\n            // above allows the current user to do this.\n            //\n            try\n            {\n                sem = Semaphore.OpenExisting(\n                    semaphoreName, \n                    SemaphoreRights.ReadPermissions \n                        | SemaphoreRights.ChangePermissions);\n\n                // Get the current ACL. This requires \n                // SemaphoreRights.ReadPermissions.\n                SemaphoreSecurity semSec = sem.GetAccessControl();\n                \n                string user = Environment.UserDomainName + &quot;\\\\&quot; \n                    + Environment.UserName;\n\n                // First, the rule that denied the current user \n                // the right to enter and release the semaphore must\n                // be removed.\n                SemaphoreAccessRule rule = new SemaphoreAccessRule(\n                    user, \n                    SemaphoreRights.Synchronize | SemaphoreRights.Modify, \n                    AccessControlType.Deny);\n                semSec.RemoveAccessRule(rule);\n\n                // Now grant the user the correct rights.\n                // \n                rule = new SemaphoreAccessRule(user, \n                     SemaphoreRights.Synchronize | SemaphoreRights.Modify, \n                     AccessControlType.Allow);\n                semSec.AddAccessRule(rule);\n\n                // Update the ACL. This requires\n                // SemaphoreRights.ChangePermissions.\n                sem.SetAccessControl(semSec);\n\n                Console.WriteLine(&quot;Updated semaphore security.&quot;);\n\n                // Open the semaphore with (SemaphoreRights.Synchronize \n                // | SemaphoreRights.Modify), the rights required to\n                // enter and release the semaphore.\n                //\n                sem = Semaphore.OpenExisting(semaphoreName);\n\n            }\n            catch(UnauthorizedAccessException ex)\n            {\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;, ex.Message);\n                return;\n            }\n        }\n\n        // Enter the semaphore, and hold it until the program\n        // exits.\n        //\n        try\n        {\n            sem.WaitOne();\n            Console.WriteLine(&quot;Entered the semaphore.&quot;);\n            Console.WriteLine(&quot;Press the Enter key to exit.&quot;);\n            Console.ReadLine();\n            sem.Release();\n        }\n        catch(UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.Semaphore.ctor named 5a#1\">#using &lt;System.dll&gt;\nusing namespace System;\nusing namespace System::Threading;\nusing namespace System::Security::AccessControl;\nusing namespace System::Security::Permissions;\n\npublic ref class Example\n{\npublic:\n   [SecurityPermissionAttribute(SecurityAction::Demand, Flags = SecurityPermissionFlag::UnmanagedCode)]\n   static void main()\n   {\n      String^ semaphoreName = L&quot;SemaphoreExample5&quot;;\n\n      Semaphore^ sem = nullptr;\n      bool doesNotExist = false;\n      bool unauthorized = false;\n      \n      // Attempt to open the named semaphore.\n      try\n      {\n         // Open the semaphore with (SemaphoreRights.Synchronize\n         // | SemaphoreRights.Modify), to enter and release the\n         // named semaphore.\n         //\n         sem = Semaphore::OpenExisting( semaphoreName );\n      }\n      catch ( WaitHandleCannotBeOpenedException^ ex ) \n      {\n         Console::WriteLine( L&quot;Semaphore does not exist.&quot; );\n         doesNotExist = true;\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n         unauthorized = true;\n      }\n\n      // There are three cases: (1) The semaphore does not exist.\n      // (2) The semaphore exists, but the current user doesn&#39;t\n      // have access. (3) The semaphore exists and the user has\n      // access.\n      //\n      if ( doesNotExist )\n      {\n         // The semaphore does not exist, so create it.\n         //\n         // The value of this variable is set by the semaphore\n         // constructor. It is true if the named system semaphore was\n         // created, and false if the named semaphore already existed.\n         //\n         bool semaphoreWasCreated;\n         \n         // Create an access control list (ACL) that denies the\n         // current user the right to enter or release the\n         // semaphore, but allows the right to read and change\n         // security information for the semaphore.\n         //\n         String^ user = String::Concat( Environment::UserDomainName,\n            L&quot;\\\\&quot;, Environment::UserName );\n         SemaphoreSecurity^ semSec = gcnew SemaphoreSecurity;\n\n         SemaphoreAccessRule^ rule = gcnew SemaphoreAccessRule( user,\n            static_cast&lt;SemaphoreRights&gt;(\n               SemaphoreRights::Synchronize |\n               SemaphoreRights::Modify ),\n            AccessControlType::Deny );\n         semSec-&gt;AddAccessRule( rule );\n\n         rule = gcnew SemaphoreAccessRule( user,\n            static_cast&lt;SemaphoreRights&gt;(\n               SemaphoreRights::ReadPermissions |\n               SemaphoreRights::ChangePermissions ),\n            AccessControlType::Allow );\n         semSec-&gt;AddAccessRule( rule );\n         \n         // Create a Semaphore object that represents the system\n         // semaphore named by the constant &#39;semaphoreName&#39;, with\n         // maximum count three, initial count three, and the\n         // specified security access. The Boolean value that\n         // indicates creation of the underlying system object is\n         // placed in semaphoreWasCreated.\n         //\n         sem = gcnew Semaphore( 3,3,semaphoreName,semaphoreWasCreated,semSec );\n         \n         // If the named system semaphore was created, it can be\n         // used by the current instance of this program, even\n         // though the current user is denied access. The current\n         // program enters the semaphore. Otherwise, exit the\n         // program.\n         //\n         if ( semaphoreWasCreated )\n         {\n            Console::WriteLine( L&quot;Created the semaphore.&quot; );\n         }\n         else\n         {\n            Console::WriteLine( L&quot;Unable to create the semaphore.&quot; );\n            return;\n         }\n\n      }\n      else if ( unauthorized )\n      {\n         // Open the semaphore to read and change the access\n         // control security. The access control security defined\n         // above allows the current user to do this.\n         //\n         try\n         {\n            sem = Semaphore::OpenExisting( semaphoreName,\n               static_cast&lt;SemaphoreRights&gt;(\n                  SemaphoreRights::ReadPermissions |\n                  SemaphoreRights::ChangePermissions ));\n            \n            // Get the current ACL. This requires\n            // SemaphoreRights.ReadPermissions.\n            SemaphoreSecurity^ semSec = sem-&gt;GetAccessControl();\n\n            String^ user = String::Concat( Environment::UserDomainName,\n               L&quot;\\\\&quot;, Environment::UserName );\n            \n            // First, the rule that denied the current user\n            // the right to enter and release the semaphore must\n            // be removed.\n            SemaphoreAccessRule^ rule = gcnew SemaphoreAccessRule( user,\n               static_cast&lt;SemaphoreRights&gt;(\n                  SemaphoreRights::Synchronize |\n                  SemaphoreRights::Modify ),\n               AccessControlType::Deny );\n            semSec-&gt;RemoveAccessRule( rule );\n            \n            // Now grant the user the correct rights.\n            //\n            rule = gcnew SemaphoreAccessRule( user,\n               static_cast&lt;SemaphoreRights&gt;(\n                  SemaphoreRights::Synchronize |\n                  SemaphoreRights::Modify ),\n               AccessControlType::Allow );\n            semSec-&gt;AddAccessRule( rule );\n            \n            // Update the ACL. This requires\n            // SemaphoreRights.ChangePermissions.\n            sem-&gt;SetAccessControl( semSec );\n\n            Console::WriteLine( L&quot;Updated semaphore security.&quot; );\n            \n            // Open the semaphore with (SemaphoreRights.Synchronize\n            // | SemaphoreRights.Modify), the rights required to\n            // enter and release the semaphore.\n            //\n            sem = Semaphore::OpenExisting( semaphoreName );\n\n         }\n         catch ( UnauthorizedAccessException^ ex ) \n         {\n            Console::WriteLine( L&quot;Unable to change permissions: {0}&quot;, ex-&gt;Message );\n            return;\n         }\n      }\n      \n      // Enter the semaphore, and hold it until the program\n      // exits.\n      //\n      try\n      {\n         sem-&gt;WaitOne();\n         Console::WriteLine( L&quot;Entered the semaphore.&quot; );\n         Console::WriteLine( L&quot;Press the Enter key to exit.&quot; );\n         Console::ReadLine();\n         sem-&gt;Release();\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n      }\n   }\n};\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Semaphore.ctor named 5a#1\">Imports System\nImports System.Threading\nImports System.Security.AccessControl\n\nFriend Class Example\n\n    &lt;MTAThread&gt; _\n    Friend Shared Sub Main()\n        Const semaphoreName As String = &quot;SemaphoreExample5&quot;\n\n        Dim sem As Semaphore = Nothing\n        Dim doesNotExist as Boolean = False\n        Dim unauthorized As Boolean = False\n\n        &#39; Attempt to open the named semaphore.\n        Try\n            &#39; Open the semaphore with (SemaphoreRights.Synchronize\n            &#39; Or SemaphoreRights.Modify), to enter and release the\n            &#39; named semaphore.\n            &#39;\n            sem = Semaphore.OpenExisting(semaphoreName)\n        Catch ex As WaitHandleCannotBeOpenedException\n            Console.WriteLine(&quot;Semaphore does not exist.&quot;)\n            doesNotExist = True\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message)\n            unauthorized = True\n        End Try\n\n        &#39; There are three cases: (1) The semaphore does not exist.\n        &#39; (2) The semaphore exists, but the current user doesn&#39;t \n        &#39; have access. (3) The semaphore exists and the user has\n        &#39; access.\n        &#39;\n        If doesNotExist Then\n            &#39; The semaphore does not exist, so create it.\n            &#39;\n            &#39; The value of this variable is set by the semaphore\n            &#39; constructor. It is True if the named system semaphore was\n            &#39; created, and False if the named semaphore already existed.\n            &#39;\n            Dim semaphoreWasCreated As Boolean\n\n            &#39; Create an access control list (ACL) that denies the\n            &#39; current user the right to enter or release the \n            &#39; semaphore, but allows the right to read and change\n            &#39; security information for the semaphore.\n            &#39;\n            Dim user As String = Environment.UserDomainName _ \n                &amp; &quot;\\&quot; &amp; Environment.UserName\n            Dim semSec As New SemaphoreSecurity()\n\n            Dim rule As New SemaphoreAccessRule(user, _\n                SemaphoreRights.Synchronize Or SemaphoreRights.Modify, _\n                AccessControlType.Deny)\n            semSec.AddAccessRule(rule)\n\n            rule = New SemaphoreAccessRule(user, _\n                SemaphoreRights.ReadPermissions Or _\n                SemaphoreRights.ChangePermissions, _\n                AccessControlType.Allow)\n            semSec.AddAccessRule(rule)\n\n            &#39; Create a Semaphore object that represents the system\n            &#39; semaphore named by the constant &#39;semaphoreName&#39;, with\n            &#39; maximum count three, initial count three, and the\n            &#39; specified security access. The Boolean value that \n            &#39; indicates creation of the underlying system object is\n            &#39; placed in semaphoreWasCreated.\n            &#39;\n            sem = New Semaphore(3, 3, semaphoreName, _\n                semaphoreWasCreated, semSec)\n\n            &#39; If the named system semaphore was created, it can be\n            &#39; used by the current instance of this program, even \n            &#39; though the current user is denied access. The current\n            &#39; program enters the semaphore. Otherwise, exit the\n            &#39; program.\n            &#39; \n            If semaphoreWasCreated Then\n                Console.WriteLine(&quot;Created the semaphore.&quot;)\n            Else\n                Console.WriteLine(&quot;Unable to create the semaphore.&quot;)\n                Return\n            End If\n\n        ElseIf unauthorized Then\n\n            &#39; Open the semaphore to read and change the access\n            &#39; control security. The access control security defined\n            &#39; above allows the current user to do this.\n            &#39;\n            Try\n                sem = Semaphore.OpenExisting(semaphoreName, _\n                    SemaphoreRights.ReadPermissions Or _\n                    SemaphoreRights.ChangePermissions)\n\n                &#39; Get the current ACL. This requires \n                &#39; SemaphoreRights.ReadPermissions.\n                Dim semSec As SemaphoreSecurity = sem.GetAccessControl()\n                \n                Dim user As String = Environment.UserDomainName _ \n                    &amp; &quot;\\&quot; &amp; Environment.UserName\n\n                &#39; First, the rule that denied the current user \n                &#39; the right to enter and release the semaphore must\n                &#39; be removed.\n                Dim rule As New SemaphoreAccessRule(user, _\n                    SemaphoreRights.Synchronize Or SemaphoreRights.Modify, _\n                    AccessControlType.Deny)\n                semSec.RemoveAccessRule(rule)\n\n                &#39; Now grant the user the correct rights.\n                &#39; \n                rule = New SemaphoreAccessRule(user, _\n                    SemaphoreRights.Synchronize Or SemaphoreRights.Modify, _\n                    AccessControlType.Allow)\n                semSec.AddAccessRule(rule)\n\n                &#39; Update the ACL. This requires\n                &#39; SemaphoreRights.ChangePermissions.\n                sem.SetAccessControl(semSec)\n\n                Console.WriteLine(&quot;Updated semaphore security.&quot;)\n\n                &#39; Open the semaphore with (SemaphoreRights.Synchronize \n                &#39; Or SemaphoreRights.Modify), the rights required to\n                &#39; enter and release the semaphore.\n                &#39;\n                sem = Semaphore.OpenExisting(semaphoreName)\n\n            Catch ex As UnauthorizedAccessException\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;, _\n                    ex.Message)\n                Return\n            End Try\n\n        End If\n\n        &#39; Enter the semaphore, and hold it until the program\n        &#39; exits.\n        &#39;\n        Try\n            sem.WaitOne()\n            Console.WriteLine(&quot;Entered the semaphore.&quot;)\n            Console.WriteLine(&quot;Press the Enter key to exit.&quot;)\n            Console.ReadLine()\n            sem.Release()\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, _\n                ex.Message)\n        End Try\n    End Sub \nEnd Class \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Semaphore_OpenExisting_System_String_\">\r\n    \r\n            <a id=\"System_Threading_Semaphore_OpenExisting_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">OpenExisting(String)</div>        \r\n          </div>\r\n    \r\n            <p>Opens the specified named semaphore, if it already exists.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Threading.Semaphore OpenExisting (string name);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of the system semaphore to open.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a></div>\r\n                  </div>\r\n                  <p>An object that represents the named system semaphore.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is an empty string.  </p>\n<p> -or-  </p>\n<p> <code>name</code> is longer than 260 characters.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandlecannotbeopenedexception\" data-linktype=\"relative-path\">WaitHandleCannotBeOpenedException</a></div>\r\n                  </div>\r\n                  <p>The named semaphore does not exist.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a></div>\r\n                  </div>\r\n                  <p>A Win32 error occurred.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The named semaphore exists, but the user does not have the security access required to use it.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_OpenExisting_\" data-linktype=\"relative-path\">OpenExisting</a> method tries to open the specified named semaphore. If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore. To create the system semaphore when it does not already exist, use one of the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore__ctor_\" data-linktype=\"relative-path\">Semaphore</a> constructors that has a <code>name</code> parameter.  </p>\n<p> Multiple calls to this method that use the same value for <code>name</code> do not necessarily return the same <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> object, even though the objects that are returned represent the same named system semaphore.  </p>\n<p> This method overload is equivalent to calling the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_OpenExisting_\" data-linktype=\"relative-path\">OpenExisting</a> method overload and specifying <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">System.Security.AccessControl.SemaphoreRights</a> and <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">System.Security.AccessControl.SemaphoreRights</a> rights, combined by using the bitwise OR operation.  </p>\n<p> Specifying the <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">System.Security.AccessControl.SemaphoreRights</a> flag allows a thread to enter the semaphore, and specifying the <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">System.Security.AccessControl.SemaphoreRights</a> flag allows a thread to call the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_Release_\" data-linktype=\"relative-path\">Release</a> method.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates the cross-process behavior of a named semaphore with access control security. The example uses the OpenExisting method overload to test for the existence of a named semaphore.  </p>\n<p> If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but which grants the right to read and change permissions on the semaphore.  </p>\n<p> If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the OpenExisting method overload. The exception is caught, and the example uses the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_OpenExisting_System_String_System_Security_AccessControl_SemaphoreRights_\" data-linktype=\"relative-path\">OpenExisting(String,SemaphoreRights)</a> method overload to open the semaphore with the rights needed to read and change the permissions.  </p>\n<p> After the permissions are changed, the semaphore is opened with the rights required to enter and release it. If you run the compiled example from a third command window, it runs using the new permissions.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.Semaphore.ctor named 5a#1\">using System;\nusing System.Threading;\nusing System.Security.AccessControl;\n\ninternal class Example\n{\n    internal static void Main()\n    {\n        const string semaphoreName = &quot;SemaphoreExample5&quot;;\n\n        Semaphore sem = null;\n        bool doesNotExist = false;\n        bool unauthorized = false;\n\n        // Attempt to open the named semaphore.\n        try\n        {\n            // Open the semaphore with (SemaphoreRights.Synchronize\n            // | SemaphoreRights.Modify), to enter and release the\n            // named semaphore.\n            //\n            sem = Semaphore.OpenExisting(semaphoreName);\n        }\n        catch(WaitHandleCannotBeOpenedException)\n        {\n            Console.WriteLine(&quot;Semaphore does not exist.&quot;);\n            doesNotExist = true;\n        }\n        catch(UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n            unauthorized = true;\n        }\n\n        // There are three cases: (1) The semaphore does not exist.\n        // (2) The semaphore exists, but the current user doesn&#39;t \n        // have access. (3) The semaphore exists and the user has\n        // access.\n        //\n        if (doesNotExist)\n        {\n            // The semaphore does not exist, so create it.\n            //\n            // The value of this variable is set by the semaphore\n            // constructor. It is true if the named system semaphore was\n            // created, and false if the named semaphore already existed.\n            //\n            bool semaphoreWasCreated;\n\n            // Create an access control list (ACL) that denies the\n            // current user the right to enter or release the \n            // semaphore, but allows the right to read and change\n            // security information for the semaphore.\n            //\n            string user = Environment.UserDomainName + &quot;\\\\&quot; \n                + Environment.UserName;\n            SemaphoreSecurity semSec = new SemaphoreSecurity();\n\n            SemaphoreAccessRule rule = new SemaphoreAccessRule(\n                user, \n                SemaphoreRights.Synchronize | SemaphoreRights.Modify, \n                AccessControlType.Deny);\n            semSec.AddAccessRule(rule);\n\n            rule = new SemaphoreAccessRule(\n                user, \n                SemaphoreRights.ReadPermissions | SemaphoreRights.ChangePermissions,\n                AccessControlType.Allow);\n            semSec.AddAccessRule(rule);\n\n            // Create a Semaphore object that represents the system\n            // semaphore named by the constant &#39;semaphoreName&#39;, with\n            // maximum count three, initial count three, and the\n            // specified security access. The Boolean value that \n            // indicates creation of the underlying system object is\n            // placed in semaphoreWasCreated.\n            //\n            sem = new Semaphore(3, 3, semaphoreName, \n                out semaphoreWasCreated, semSec);\n\n            // If the named system semaphore was created, it can be\n            // used by the current instance of this program, even \n            // though the current user is denied access. The current\n            // program enters the semaphore. Otherwise, exit the\n            // program.\n            // \n            if (semaphoreWasCreated)\n            {\n                Console.WriteLine(&quot;Created the semaphore.&quot;);\n            }\n            else\n            {\n                Console.WriteLine(&quot;Unable to create the semaphore.&quot;);\n                return;\n            }\n\n        }\n        else if (unauthorized)\n        {\n            // Open the semaphore to read and change the access\n            // control security. The access control security defined\n            // above allows the current user to do this.\n            //\n            try\n            {\n                sem = Semaphore.OpenExisting(\n                    semaphoreName, \n                    SemaphoreRights.ReadPermissions \n                        | SemaphoreRights.ChangePermissions);\n\n                // Get the current ACL. This requires \n                // SemaphoreRights.ReadPermissions.\n                SemaphoreSecurity semSec = sem.GetAccessControl();\n                \n                string user = Environment.UserDomainName + &quot;\\\\&quot; \n                    + Environment.UserName;\n\n                // First, the rule that denied the current user \n                // the right to enter and release the semaphore must\n                // be removed.\n                SemaphoreAccessRule rule = new SemaphoreAccessRule(\n                    user, \n                    SemaphoreRights.Synchronize | SemaphoreRights.Modify, \n                    AccessControlType.Deny);\n                semSec.RemoveAccessRule(rule);\n\n                // Now grant the user the correct rights.\n                // \n                rule = new SemaphoreAccessRule(user, \n                     SemaphoreRights.Synchronize | SemaphoreRights.Modify, \n                     AccessControlType.Allow);\n                semSec.AddAccessRule(rule);\n\n                // Update the ACL. This requires\n                // SemaphoreRights.ChangePermissions.\n                sem.SetAccessControl(semSec);\n\n                Console.WriteLine(&quot;Updated semaphore security.&quot;);\n\n                // Open the semaphore with (SemaphoreRights.Synchronize \n                // | SemaphoreRights.Modify), the rights required to\n                // enter and release the semaphore.\n                //\n                sem = Semaphore.OpenExisting(semaphoreName);\n\n            }\n            catch(UnauthorizedAccessException ex)\n            {\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;, ex.Message);\n                return;\n            }\n        }\n\n        // Enter the semaphore, and hold it until the program\n        // exits.\n        //\n        try\n        {\n            sem.WaitOne();\n            Console.WriteLine(&quot;Entered the semaphore.&quot;);\n            Console.WriteLine(&quot;Press the Enter key to exit.&quot;);\n            Console.ReadLine();\n            sem.Release();\n        }\n        catch(UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.Semaphore.ctor named 5a#1\">#using &lt;System.dll&gt;\nusing namespace System;\nusing namespace System::Threading;\nusing namespace System::Security::AccessControl;\nusing namespace System::Security::Permissions;\n\npublic ref class Example\n{\npublic:\n   [SecurityPermissionAttribute(SecurityAction::Demand, Flags = SecurityPermissionFlag::UnmanagedCode)]\n   static void main()\n   {\n      String^ semaphoreName = L&quot;SemaphoreExample5&quot;;\n\n      Semaphore^ sem = nullptr;\n      bool doesNotExist = false;\n      bool unauthorized = false;\n      \n      // Attempt to open the named semaphore.\n      try\n      {\n         // Open the semaphore with (SemaphoreRights.Synchronize\n         // | SemaphoreRights.Modify), to enter and release the\n         // named semaphore.\n         //\n         sem = Semaphore::OpenExisting( semaphoreName );\n      }\n      catch ( WaitHandleCannotBeOpenedException^ ex ) \n      {\n         Console::WriteLine( L&quot;Semaphore does not exist.&quot; );\n         doesNotExist = true;\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n         unauthorized = true;\n      }\n\n      // There are three cases: (1) The semaphore does not exist.\n      // (2) The semaphore exists, but the current user doesn&#39;t\n      // have access. (3) The semaphore exists and the user has\n      // access.\n      //\n      if ( doesNotExist )\n      {\n         // The semaphore does not exist, so create it.\n         //\n         // The value of this variable is set by the semaphore\n         // constructor. It is true if the named system semaphore was\n         // created, and false if the named semaphore already existed.\n         //\n         bool semaphoreWasCreated;\n         \n         // Create an access control list (ACL) that denies the\n         // current user the right to enter or release the\n         // semaphore, but allows the right to read and change\n         // security information for the semaphore.\n         //\n         String^ user = String::Concat( Environment::UserDomainName,\n            L&quot;\\\\&quot;, Environment::UserName );\n         SemaphoreSecurity^ semSec = gcnew SemaphoreSecurity;\n\n         SemaphoreAccessRule^ rule = gcnew SemaphoreAccessRule( user,\n            static_cast&lt;SemaphoreRights&gt;(\n               SemaphoreRights::Synchronize |\n               SemaphoreRights::Modify ),\n            AccessControlType::Deny );\n         semSec-&gt;AddAccessRule( rule );\n\n         rule = gcnew SemaphoreAccessRule( user,\n            static_cast&lt;SemaphoreRights&gt;(\n               SemaphoreRights::ReadPermissions |\n               SemaphoreRights::ChangePermissions ),\n            AccessControlType::Allow );\n         semSec-&gt;AddAccessRule( rule );\n         \n         // Create a Semaphore object that represents the system\n         // semaphore named by the constant &#39;semaphoreName&#39;, with\n         // maximum count three, initial count three, and the\n         // specified security access. The Boolean value that\n         // indicates creation of the underlying system object is\n         // placed in semaphoreWasCreated.\n         //\n         sem = gcnew Semaphore( 3,3,semaphoreName,semaphoreWasCreated,semSec );\n         \n         // If the named system semaphore was created, it can be\n         // used by the current instance of this program, even\n         // though the current user is denied access. The current\n         // program enters the semaphore. Otherwise, exit the\n         // program.\n         //\n         if ( semaphoreWasCreated )\n         {\n            Console::WriteLine( L&quot;Created the semaphore.&quot; );\n         }\n         else\n         {\n            Console::WriteLine( L&quot;Unable to create the semaphore.&quot; );\n            return;\n         }\n\n      }\n      else if ( unauthorized )\n      {\n         // Open the semaphore to read and change the access\n         // control security. The access control security defined\n         // above allows the current user to do this.\n         //\n         try\n         {\n            sem = Semaphore::OpenExisting( semaphoreName,\n               static_cast&lt;SemaphoreRights&gt;(\n                  SemaphoreRights::ReadPermissions |\n                  SemaphoreRights::ChangePermissions ));\n            \n            // Get the current ACL. This requires\n            // SemaphoreRights.ReadPermissions.\n            SemaphoreSecurity^ semSec = sem-&gt;GetAccessControl();\n\n            String^ user = String::Concat( Environment::UserDomainName,\n               L&quot;\\\\&quot;, Environment::UserName );\n            \n            // First, the rule that denied the current user\n            // the right to enter and release the semaphore must\n            // be removed.\n            SemaphoreAccessRule^ rule = gcnew SemaphoreAccessRule( user,\n               static_cast&lt;SemaphoreRights&gt;(\n                  SemaphoreRights::Synchronize |\n                  SemaphoreRights::Modify ),\n               AccessControlType::Deny );\n            semSec-&gt;RemoveAccessRule( rule );\n            \n            // Now grant the user the correct rights.\n            //\n            rule = gcnew SemaphoreAccessRule( user,\n               static_cast&lt;SemaphoreRights&gt;(\n                  SemaphoreRights::Synchronize |\n                  SemaphoreRights::Modify ),\n               AccessControlType::Allow );\n            semSec-&gt;AddAccessRule( rule );\n            \n            // Update the ACL. This requires\n            // SemaphoreRights.ChangePermissions.\n            sem-&gt;SetAccessControl( semSec );\n\n            Console::WriteLine( L&quot;Updated semaphore security.&quot; );\n            \n            // Open the semaphore with (SemaphoreRights.Synchronize\n            // | SemaphoreRights.Modify), the rights required to\n            // enter and release the semaphore.\n            //\n            sem = Semaphore::OpenExisting( semaphoreName );\n\n         }\n         catch ( UnauthorizedAccessException^ ex ) \n         {\n            Console::WriteLine( L&quot;Unable to change permissions: {0}&quot;, ex-&gt;Message );\n            return;\n         }\n      }\n      \n      // Enter the semaphore, and hold it until the program\n      // exits.\n      //\n      try\n      {\n         sem-&gt;WaitOne();\n         Console::WriteLine( L&quot;Entered the semaphore.&quot; );\n         Console::WriteLine( L&quot;Press the Enter key to exit.&quot; );\n         Console::ReadLine();\n         sem-&gt;Release();\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n      }\n   }\n};\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Semaphore.ctor named 5a#1\">Imports System\nImports System.Threading\nImports System.Security.AccessControl\n\nFriend Class Example\n\n    &lt;MTAThread&gt; _\n    Friend Shared Sub Main()\n        Const semaphoreName As String = &quot;SemaphoreExample5&quot;\n\n        Dim sem As Semaphore = Nothing\n        Dim doesNotExist as Boolean = False\n        Dim unauthorized As Boolean = False\n\n        &#39; Attempt to open the named semaphore.\n        Try\n            &#39; Open the semaphore with (SemaphoreRights.Synchronize\n            &#39; Or SemaphoreRights.Modify), to enter and release the\n            &#39; named semaphore.\n            &#39;\n            sem = Semaphore.OpenExisting(semaphoreName)\n        Catch ex As WaitHandleCannotBeOpenedException\n            Console.WriteLine(&quot;Semaphore does not exist.&quot;)\n            doesNotExist = True\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message)\n            unauthorized = True\n        End Try\n\n        &#39; There are three cases: (1) The semaphore does not exist.\n        &#39; (2) The semaphore exists, but the current user doesn&#39;t \n        &#39; have access. (3) The semaphore exists and the user has\n        &#39; access.\n        &#39;\n        If doesNotExist Then\n            &#39; The semaphore does not exist, so create it.\n            &#39;\n            &#39; The value of this variable is set by the semaphore\n            &#39; constructor. It is True if the named system semaphore was\n            &#39; created, and False if the named semaphore already existed.\n            &#39;\n            Dim semaphoreWasCreated As Boolean\n\n            &#39; Create an access control list (ACL) that denies the\n            &#39; current user the right to enter or release the \n            &#39; semaphore, but allows the right to read and change\n            &#39; security information for the semaphore.\n            &#39;\n            Dim user As String = Environment.UserDomainName _ \n                &amp; &quot;\\&quot; &amp; Environment.UserName\n            Dim semSec As New SemaphoreSecurity()\n\n            Dim rule As New SemaphoreAccessRule(user, _\n                SemaphoreRights.Synchronize Or SemaphoreRights.Modify, _\n                AccessControlType.Deny)\n            semSec.AddAccessRule(rule)\n\n            rule = New SemaphoreAccessRule(user, _\n                SemaphoreRights.ReadPermissions Or _\n                SemaphoreRights.ChangePermissions, _\n                AccessControlType.Allow)\n            semSec.AddAccessRule(rule)\n\n            &#39; Create a Semaphore object that represents the system\n            &#39; semaphore named by the constant &#39;semaphoreName&#39;, with\n            &#39; maximum count three, initial count three, and the\n            &#39; specified security access. The Boolean value that \n            &#39; indicates creation of the underlying system object is\n            &#39; placed in semaphoreWasCreated.\n            &#39;\n            sem = New Semaphore(3, 3, semaphoreName, _\n                semaphoreWasCreated, semSec)\n\n            &#39; If the named system semaphore was created, it can be\n            &#39; used by the current instance of this program, even \n            &#39; though the current user is denied access. The current\n            &#39; program enters the semaphore. Otherwise, exit the\n            &#39; program.\n            &#39; \n            If semaphoreWasCreated Then\n                Console.WriteLine(&quot;Created the semaphore.&quot;)\n            Else\n                Console.WriteLine(&quot;Unable to create the semaphore.&quot;)\n                Return\n            End If\n\n        ElseIf unauthorized Then\n\n            &#39; Open the semaphore to read and change the access\n            &#39; control security. The access control security defined\n            &#39; above allows the current user to do this.\n            &#39;\n            Try\n                sem = Semaphore.OpenExisting(semaphoreName, _\n                    SemaphoreRights.ReadPermissions Or _\n                    SemaphoreRights.ChangePermissions)\n\n                &#39; Get the current ACL. This requires \n                &#39; SemaphoreRights.ReadPermissions.\n                Dim semSec As SemaphoreSecurity = sem.GetAccessControl()\n                \n                Dim user As String = Environment.UserDomainName _ \n                    &amp; &quot;\\&quot; &amp; Environment.UserName\n\n                &#39; First, the rule that denied the current user \n                &#39; the right to enter and release the semaphore must\n                &#39; be removed.\n                Dim rule As New SemaphoreAccessRule(user, _\n                    SemaphoreRights.Synchronize Or SemaphoreRights.Modify, _\n                    AccessControlType.Deny)\n                semSec.RemoveAccessRule(rule)\n\n                &#39; Now grant the user the correct rights.\n                &#39; \n                rule = New SemaphoreAccessRule(user, _\n                    SemaphoreRights.Synchronize Or SemaphoreRights.Modify, _\n                    AccessControlType.Allow)\n                semSec.AddAccessRule(rule)\n\n                &#39; Update the ACL. This requires\n                &#39; SemaphoreRights.ChangePermissions.\n                sem.SetAccessControl(semSec)\n\n                Console.WriteLine(&quot;Updated semaphore security.&quot;)\n\n                &#39; Open the semaphore with (SemaphoreRights.Synchronize \n                &#39; Or SemaphoreRights.Modify), the rights required to\n                &#39; enter and release the semaphore.\n                &#39;\n                sem = Semaphore.OpenExisting(semaphoreName)\n\n            Catch ex As UnauthorizedAccessException\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;, _\n                    ex.Message)\n                Return\n            End Try\n\n        End If\n\n        &#39; Enter the semaphore, and hold it until the program\n        &#39; exits.\n        &#39;\n        Try\n            sem.WaitOne()\n            Console.WriteLine(&quot;Entered the semaphore.&quot;)\n            Console.WriteLine(&quot;Press the Enter key to exit.&quot;)\n            Console.ReadLine()\n            sem.Release()\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, _\n                ex.Message)\n        End Try\n    End Sub \nEnd Class \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Semaphore_OpenExisting_System_String_System_Security_AccessControl_SemaphoreRights_\">\r\n    \r\n            <a id=\"System_Threading_Semaphore_OpenExisting_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">OpenExisting(String,SemaphoreRights)</div>        \r\n          </div>\r\n    \r\n            <p>Opens the specified named semaphore, if it already exists, with the desired security access.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of the system semaphore to open.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>rights</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">SemaphoreRights</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitwise combination of the enumeration values that represent the desired security access.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a></div>\r\n                  </div>\r\n                  <p>An object that represents the named system semaphore.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is an empty string.  </p>\n<p> -or-  </p>\n<p> <code>name</code> is longer than 260 characters.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.waithandlecannotbeopenedexception\" data-linktype=\"relative-path\">WaitHandleCannotBeOpenedException</a></div>\r\n                  </div>\r\n                  <p>The named semaphore does not exist.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a></div>\r\n                  </div>\r\n                  <p>A Win32 error occurred.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The named semaphore exists, but the user does not have the desired security access rights.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>The <code>rights</code> parameter must include the <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">System.Security.AccessControl.SemaphoreRights</a> flag to allow threads to enter the semaphore, and the <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">System.Security.AccessControl.SemaphoreRights</a> flag to allow threads to call the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_Release_\" data-linktype=\"relative-path\">Release</a> method.  </p>\n<p> The <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_OpenExisting_\" data-linktype=\"relative-path\">OpenExisting</a> method tries to open an existing named semaphore. If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore. To create the system semaphore when it does not already exist, use one of the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore__ctor_\" data-linktype=\"relative-path\">Semaphore</a> constructors that has a <code>name</code> parameter.  </p>\n<p> Multiple calls to this method that use the same value for <code>name</code> do not necessarily return the same <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> object, even though the objects that are returned represent the same named system semaphore.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates the cross-process behavior of a named semaphore with access control security. The example uses the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a> method overload to test for the existence of a named semaphore.  </p>\n<p> If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.  </p>\n<p> If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a> method. The exception is caught, and the example uses the OpenExisting method overload to open the semaphore with the rights needed to read and change the permissions.  </p>\n<p> After the permissions are changed, the semaphore is opened with the rights required to enter and release it. If you run the compiled example from a third command window, it runs using the new permissions.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.Semaphore.ctor named 5a#1\">using System;\nusing System.Threading;\nusing System.Security.AccessControl;\n\ninternal class Example\n{\n    internal static void Main()\n    {\n        const string semaphoreName = &quot;SemaphoreExample5&quot;;\n\n        Semaphore sem = null;\n        bool doesNotExist = false;\n        bool unauthorized = false;\n\n        // Attempt to open the named semaphore.\n        try\n        {\n            // Open the semaphore with (SemaphoreRights.Synchronize\n            // | SemaphoreRights.Modify), to enter and release the\n            // named semaphore.\n            //\n            sem = Semaphore.OpenExisting(semaphoreName);\n        }\n        catch(WaitHandleCannotBeOpenedException)\n        {\n            Console.WriteLine(&quot;Semaphore does not exist.&quot;);\n            doesNotExist = true;\n        }\n        catch(UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n            unauthorized = true;\n        }\n\n        // There are three cases: (1) The semaphore does not exist.\n        // (2) The semaphore exists, but the current user doesn&#39;t \n        // have access. (3) The semaphore exists and the user has\n        // access.\n        //\n        if (doesNotExist)\n        {\n            // The semaphore does not exist, so create it.\n            //\n            // The value of this variable is set by the semaphore\n            // constructor. It is true if the named system semaphore was\n            // created, and false if the named semaphore already existed.\n            //\n            bool semaphoreWasCreated;\n\n            // Create an access control list (ACL) that denies the\n            // current user the right to enter or release the \n            // semaphore, but allows the right to read and change\n            // security information for the semaphore.\n            //\n            string user = Environment.UserDomainName + &quot;\\\\&quot; \n                + Environment.UserName;\n            SemaphoreSecurity semSec = new SemaphoreSecurity();\n\n            SemaphoreAccessRule rule = new SemaphoreAccessRule(\n                user, \n                SemaphoreRights.Synchronize | SemaphoreRights.Modify, \n                AccessControlType.Deny);\n            semSec.AddAccessRule(rule);\n\n            rule = new SemaphoreAccessRule(\n                user, \n                SemaphoreRights.ReadPermissions | SemaphoreRights.ChangePermissions,\n                AccessControlType.Allow);\n            semSec.AddAccessRule(rule);\n\n            // Create a Semaphore object that represents the system\n            // semaphore named by the constant &#39;semaphoreName&#39;, with\n            // maximum count three, initial count three, and the\n            // specified security access. The Boolean value that \n            // indicates creation of the underlying system object is\n            // placed in semaphoreWasCreated.\n            //\n            sem = new Semaphore(3, 3, semaphoreName, \n                out semaphoreWasCreated, semSec);\n\n            // If the named system semaphore was created, it can be\n            // used by the current instance of this program, even \n            // though the current user is denied access. The current\n            // program enters the semaphore. Otherwise, exit the\n            // program.\n            // \n            if (semaphoreWasCreated)\n            {\n                Console.WriteLine(&quot;Created the semaphore.&quot;);\n            }\n            else\n            {\n                Console.WriteLine(&quot;Unable to create the semaphore.&quot;);\n                return;\n            }\n\n        }\n        else if (unauthorized)\n        {\n            // Open the semaphore to read and change the access\n            // control security. The access control security defined\n            // above allows the current user to do this.\n            //\n            try\n            {\n                sem = Semaphore.OpenExisting(\n                    semaphoreName, \n                    SemaphoreRights.ReadPermissions \n                        | SemaphoreRights.ChangePermissions);\n\n                // Get the current ACL. This requires \n                // SemaphoreRights.ReadPermissions.\n                SemaphoreSecurity semSec = sem.GetAccessControl();\n                \n                string user = Environment.UserDomainName + &quot;\\\\&quot; \n                    + Environment.UserName;\n\n                // First, the rule that denied the current user \n                // the right to enter and release the semaphore must\n                // be removed.\n                SemaphoreAccessRule rule = new SemaphoreAccessRule(\n                    user, \n                    SemaphoreRights.Synchronize | SemaphoreRights.Modify, \n                    AccessControlType.Deny);\n                semSec.RemoveAccessRule(rule);\n\n                // Now grant the user the correct rights.\n                // \n                rule = new SemaphoreAccessRule(user, \n                     SemaphoreRights.Synchronize | SemaphoreRights.Modify, \n                     AccessControlType.Allow);\n                semSec.AddAccessRule(rule);\n\n                // Update the ACL. This requires\n                // SemaphoreRights.ChangePermissions.\n                sem.SetAccessControl(semSec);\n\n                Console.WriteLine(&quot;Updated semaphore security.&quot;);\n\n                // Open the semaphore with (SemaphoreRights.Synchronize \n                // | SemaphoreRights.Modify), the rights required to\n                // enter and release the semaphore.\n                //\n                sem = Semaphore.OpenExisting(semaphoreName);\n\n            }\n            catch(UnauthorizedAccessException ex)\n            {\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;, ex.Message);\n                return;\n            }\n        }\n\n        // Enter the semaphore, and hold it until the program\n        // exits.\n        //\n        try\n        {\n            sem.WaitOne();\n            Console.WriteLine(&quot;Entered the semaphore.&quot;);\n            Console.WriteLine(&quot;Press the Enter key to exit.&quot;);\n            Console.ReadLine();\n            sem.Release();\n        }\n        catch(UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.Semaphore.ctor named 5a#1\">#using &lt;System.dll&gt;\nusing namespace System;\nusing namespace System::Threading;\nusing namespace System::Security::AccessControl;\nusing namespace System::Security::Permissions;\n\npublic ref class Example\n{\npublic:\n   [SecurityPermissionAttribute(SecurityAction::Demand, Flags = SecurityPermissionFlag::UnmanagedCode)]\n   static void main()\n   {\n      String^ semaphoreName = L&quot;SemaphoreExample5&quot;;\n\n      Semaphore^ sem = nullptr;\n      bool doesNotExist = false;\n      bool unauthorized = false;\n      \n      // Attempt to open the named semaphore.\n      try\n      {\n         // Open the semaphore with (SemaphoreRights.Synchronize\n         // | SemaphoreRights.Modify), to enter and release the\n         // named semaphore.\n         //\n         sem = Semaphore::OpenExisting( semaphoreName );\n      }\n      catch ( WaitHandleCannotBeOpenedException^ ex ) \n      {\n         Console::WriteLine( L&quot;Semaphore does not exist.&quot; );\n         doesNotExist = true;\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n         unauthorized = true;\n      }\n\n      // There are three cases: (1) The semaphore does not exist.\n      // (2) The semaphore exists, but the current user doesn&#39;t\n      // have access. (3) The semaphore exists and the user has\n      // access.\n      //\n      if ( doesNotExist )\n      {\n         // The semaphore does not exist, so create it.\n         //\n         // The value of this variable is set by the semaphore\n         // constructor. It is true if the named system semaphore was\n         // created, and false if the named semaphore already existed.\n         //\n         bool semaphoreWasCreated;\n         \n         // Create an access control list (ACL) that denies the\n         // current user the right to enter or release the\n         // semaphore, but allows the right to read and change\n         // security information for the semaphore.\n         //\n         String^ user = String::Concat( Environment::UserDomainName,\n            L&quot;\\\\&quot;, Environment::UserName );\n         SemaphoreSecurity^ semSec = gcnew SemaphoreSecurity;\n\n         SemaphoreAccessRule^ rule = gcnew SemaphoreAccessRule( user,\n            static_cast&lt;SemaphoreRights&gt;(\n               SemaphoreRights::Synchronize |\n               SemaphoreRights::Modify ),\n            AccessControlType::Deny );\n         semSec-&gt;AddAccessRule( rule );\n\n         rule = gcnew SemaphoreAccessRule( user,\n            static_cast&lt;SemaphoreRights&gt;(\n               SemaphoreRights::ReadPermissions |\n               SemaphoreRights::ChangePermissions ),\n            AccessControlType::Allow );\n         semSec-&gt;AddAccessRule( rule );\n         \n         // Create a Semaphore object that represents the system\n         // semaphore named by the constant &#39;semaphoreName&#39;, with\n         // maximum count three, initial count three, and the\n         // specified security access. The Boolean value that\n         // indicates creation of the underlying system object is\n         // placed in semaphoreWasCreated.\n         //\n         sem = gcnew Semaphore( 3,3,semaphoreName,semaphoreWasCreated,semSec );\n         \n         // If the named system semaphore was created, it can be\n         // used by the current instance of this program, even\n         // though the current user is denied access. The current\n         // program enters the semaphore. Otherwise, exit the\n         // program.\n         //\n         if ( semaphoreWasCreated )\n         {\n            Console::WriteLine( L&quot;Created the semaphore.&quot; );\n         }\n         else\n         {\n            Console::WriteLine( L&quot;Unable to create the semaphore.&quot; );\n            return;\n         }\n\n      }\n      else if ( unauthorized )\n      {\n         // Open the semaphore to read and change the access\n         // control security. The access control security defined\n         // above allows the current user to do this.\n         //\n         try\n         {\n            sem = Semaphore::OpenExisting( semaphoreName,\n               static_cast&lt;SemaphoreRights&gt;(\n                  SemaphoreRights::ReadPermissions |\n                  SemaphoreRights::ChangePermissions ));\n            \n            // Get the current ACL. This requires\n            // SemaphoreRights.ReadPermissions.\n            SemaphoreSecurity^ semSec = sem-&gt;GetAccessControl();\n\n            String^ user = String::Concat( Environment::UserDomainName,\n               L&quot;\\\\&quot;, Environment::UserName );\n            \n            // First, the rule that denied the current user\n            // the right to enter and release the semaphore must\n            // be removed.\n            SemaphoreAccessRule^ rule = gcnew SemaphoreAccessRule( user,\n               static_cast&lt;SemaphoreRights&gt;(\n                  SemaphoreRights::Synchronize |\n                  SemaphoreRights::Modify ),\n               AccessControlType::Deny );\n            semSec-&gt;RemoveAccessRule( rule );\n            \n            // Now grant the user the correct rights.\n            //\n            rule = gcnew SemaphoreAccessRule( user,\n               static_cast&lt;SemaphoreRights&gt;(\n                  SemaphoreRights::Synchronize |\n                  SemaphoreRights::Modify ),\n               AccessControlType::Allow );\n            semSec-&gt;AddAccessRule( rule );\n            \n            // Update the ACL. This requires\n            // SemaphoreRights.ChangePermissions.\n            sem-&gt;SetAccessControl( semSec );\n\n            Console::WriteLine( L&quot;Updated semaphore security.&quot; );\n            \n            // Open the semaphore with (SemaphoreRights.Synchronize\n            // | SemaphoreRights.Modify), the rights required to\n            // enter and release the semaphore.\n            //\n            sem = Semaphore::OpenExisting( semaphoreName );\n\n         }\n         catch ( UnauthorizedAccessException^ ex ) \n         {\n            Console::WriteLine( L&quot;Unable to change permissions: {0}&quot;, ex-&gt;Message );\n            return;\n         }\n      }\n      \n      // Enter the semaphore, and hold it until the program\n      // exits.\n      //\n      try\n      {\n         sem-&gt;WaitOne();\n         Console::WriteLine( L&quot;Entered the semaphore.&quot; );\n         Console::WriteLine( L&quot;Press the Enter key to exit.&quot; );\n         Console::ReadLine();\n         sem-&gt;Release();\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n      }\n   }\n};\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Semaphore.ctor named 5a#1\">Imports System\nImports System.Threading\nImports System.Security.AccessControl\n\nFriend Class Example\n\n    &lt;MTAThread&gt; _\n    Friend Shared Sub Main()\n        Const semaphoreName As String = &quot;SemaphoreExample5&quot;\n\n        Dim sem As Semaphore = Nothing\n        Dim doesNotExist as Boolean = False\n        Dim unauthorized As Boolean = False\n\n        &#39; Attempt to open the named semaphore.\n        Try\n            &#39; Open the semaphore with (SemaphoreRights.Synchronize\n            &#39; Or SemaphoreRights.Modify), to enter and release the\n            &#39; named semaphore.\n            &#39;\n            sem = Semaphore.OpenExisting(semaphoreName)\n        Catch ex As WaitHandleCannotBeOpenedException\n            Console.WriteLine(&quot;Semaphore does not exist.&quot;)\n            doesNotExist = True\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message)\n            unauthorized = True\n        End Try\n\n        &#39; There are three cases: (1) The semaphore does not exist.\n        &#39; (2) The semaphore exists, but the current user doesn&#39;t \n        &#39; have access. (3) The semaphore exists and the user has\n        &#39; access.\n        &#39;\n        If doesNotExist Then\n            &#39; The semaphore does not exist, so create it.\n            &#39;\n            &#39; The value of this variable is set by the semaphore\n            &#39; constructor. It is True if the named system semaphore was\n            &#39; created, and False if the named semaphore already existed.\n            &#39;\n            Dim semaphoreWasCreated As Boolean\n\n            &#39; Create an access control list (ACL) that denies the\n            &#39; current user the right to enter or release the \n            &#39; semaphore, but allows the right to read and change\n            &#39; security information for the semaphore.\n            &#39;\n            Dim user As String = Environment.UserDomainName _ \n                &amp; &quot;\\&quot; &amp; Environment.UserName\n            Dim semSec As New SemaphoreSecurity()\n\n            Dim rule As New SemaphoreAccessRule(user, _\n                SemaphoreRights.Synchronize Or SemaphoreRights.Modify, _\n                AccessControlType.Deny)\n            semSec.AddAccessRule(rule)\n\n            rule = New SemaphoreAccessRule(user, _\n                SemaphoreRights.ReadPermissions Or _\n                SemaphoreRights.ChangePermissions, _\n                AccessControlType.Allow)\n            semSec.AddAccessRule(rule)\n\n            &#39; Create a Semaphore object that represents the system\n            &#39; semaphore named by the constant &#39;semaphoreName&#39;, with\n            &#39; maximum count three, initial count three, and the\n            &#39; specified security access. The Boolean value that \n            &#39; indicates creation of the underlying system object is\n            &#39; placed in semaphoreWasCreated.\n            &#39;\n            sem = New Semaphore(3, 3, semaphoreName, _\n                semaphoreWasCreated, semSec)\n\n            &#39; If the named system semaphore was created, it can be\n            &#39; used by the current instance of this program, even \n            &#39; though the current user is denied access. The current\n            &#39; program enters the semaphore. Otherwise, exit the\n            &#39; program.\n            &#39; \n            If semaphoreWasCreated Then\n                Console.WriteLine(&quot;Created the semaphore.&quot;)\n            Else\n                Console.WriteLine(&quot;Unable to create the semaphore.&quot;)\n                Return\n            End If\n\n        ElseIf unauthorized Then\n\n            &#39; Open the semaphore to read and change the access\n            &#39; control security. The access control security defined\n            &#39; above allows the current user to do this.\n            &#39;\n            Try\n                sem = Semaphore.OpenExisting(semaphoreName, _\n                    SemaphoreRights.ReadPermissions Or _\n                    SemaphoreRights.ChangePermissions)\n\n                &#39; Get the current ACL. This requires \n                &#39; SemaphoreRights.ReadPermissions.\n                Dim semSec As SemaphoreSecurity = sem.GetAccessControl()\n                \n                Dim user As String = Environment.UserDomainName _ \n                    &amp; &quot;\\&quot; &amp; Environment.UserName\n\n                &#39; First, the rule that denied the current user \n                &#39; the right to enter and release the semaphore must\n                &#39; be removed.\n                Dim rule As New SemaphoreAccessRule(user, _\n                    SemaphoreRights.Synchronize Or SemaphoreRights.Modify, _\n                    AccessControlType.Deny)\n                semSec.RemoveAccessRule(rule)\n\n                &#39; Now grant the user the correct rights.\n                &#39; \n                rule = New SemaphoreAccessRule(user, _\n                    SemaphoreRights.Synchronize Or SemaphoreRights.Modify, _\n                    AccessControlType.Allow)\n                semSec.AddAccessRule(rule)\n\n                &#39; Update the ACL. This requires\n                &#39; SemaphoreRights.ChangePermissions.\n                sem.SetAccessControl(semSec)\n\n                Console.WriteLine(&quot;Updated semaphore security.&quot;)\n\n                &#39; Open the semaphore with (SemaphoreRights.Synchronize \n                &#39; Or SemaphoreRights.Modify), the rights required to\n                &#39; enter and release the semaphore.\n                &#39;\n                sem = Semaphore.OpenExisting(semaphoreName)\n\n            Catch ex As UnauthorizedAccessException\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;, _\n                    ex.Message)\n                Return\n            End Try\n\n        End If\n\n        &#39; Enter the semaphore, and hold it until the program\n        &#39; exits.\n        &#39;\n        Try\n            sem.WaitOne()\n            Console.WriteLine(&quot;Entered the semaphore.&quot;)\n            Console.WriteLine(&quot;Press the Enter key to exit.&quot;)\n            Console.ReadLine()\n            sem.Release()\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, _\n                ex.Message)\n        End Try\n    End Sub \nEnd Class \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Semaphore_Release\">\r\n    \r\n            <a id=\"System_Threading_Semaphore_Release_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Release()</div>        \r\n          </div>\r\n    \r\n            <p>Exits the semaphore and returns the previous count.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public int Release ();</code></pre>\r\n    \r\n    \r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </div>\r\n                  <p>The count on the semaphore before the <span class=\"xref\">stem.Threading.Semaphore.Release*</span> method was called.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.semaphorefullexception\" data-linktype=\"relative-path\">SemaphoreFullException</a></div>\r\n                  </div>\r\n                  <p>The semaphore count is already at the maximum value.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a></div>\r\n                  </div>\r\n                  <p>A Win32 error occurred with a named semaphore.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The current semaphore represents a named system semaphore, but the user does not have <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">SemaphoreRights</a>.  </p>\n<p> -or-  </p>\n<p> The current semaphore represents a named system semaphore, but it was not opened with <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">SemaphoreRights</a>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>Threads typically use the <a class=\"xref\" href=\"system.threading.waithandle#System_Threading_WaitHandle_WaitOne_\" data-linktype=\"relative-path\">WaitOne</a> method to enter the semaphore, and they typically use this method overload to exit.  </p>\n<p> If a <a class=\"xref\" href=\"system.threading.semaphorefullexception\" data-linktype=\"relative-path\">SemaphoreFullException</a> is thrown by the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_Release_\" data-linktype=\"relative-path\">Release</a> method, it does not necessarily indicate a problem with the calling thread. A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.  </p>\n<p> If the current <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> object represents a named system semaphore, the user must have <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">System.Security.AccessControl.SemaphoreRights</a> rights and the semaphore must have been opened with <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">System.Security.AccessControl.SemaphoreRights</a> rights.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example creates a semaphore with a maximum count of three and an initial count of zero. The example starts five threads, which block waiting for the semaphore. The main thread uses the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_Release_System_Int32_\" data-linktype=\"relative-path\">Release(Int32)</a> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore. Each thread uses the <a class=\"xref\" href=\"system.threading.thread#System_Threading_Thread_Sleep_\" data-linktype=\"relative-path\">Sleep</a> method to wait for one second, to simulate work, and then calls the Release method overload to release the semaphore.  </p>\n<p> Each time the semaphore is released, the previous semaphore count is displayed. Console messages track semaphore use. The simulated work interval is increased slightly for each thread, to make the output easier to read.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Threading.Semaphore2#1\">#using &lt;System.dll&gt;\nusing namespace System;\nusing namespace System::Threading;\n\npublic ref class Example\n{\nprivate:\n   // A semaphore that simulates a limited resource pool.\n   //\n   static Semaphore^ _pool;\n\n   // A padding interval to make the output more orderly.\n   static int _padding;\n\npublic:\n   static void Main()\n   {\n      // Create a semaphore that can satisfy up to three\n      // concurrent requests. Use an initial count of zero,\n      // so that the entire semaphore count is initially\n      // owned by the main program thread.\n      //\n      _pool = gcnew Semaphore( 0,3 );\n      \n      // Create and start five numbered threads.\n      //\n      for ( int i = 1; i &lt;= 5; i++ )\n      {\n         Thread^ t = gcnew Thread(\n            gcnew ParameterizedThreadStart( Worker ) );\n         \n         // Start the thread, passing the number.\n         //\n         t-&gt;Start( i );\n      }\n      \n      // Wait for half a second, to allow all the\n      // threads to start and to block on the semaphore.\n      //\n      Thread::Sleep( 500 );\n      \n      // The main thread starts out holding the entire\n      // semaphore count. Calling Release(3) brings the\n      // semaphore count back to its maximum value, and\n      // allows the waiting threads to enter the semaphore,\n      // up to three at a time.\n      //\n      Console::WriteLine( L&quot;Main thread calls Release(3).&quot; );\n      _pool-&gt;Release( 3 );\n\n      Console::WriteLine( L&quot;Main thread exits.&quot; );\n   }\n\nprivate:\n   static void Worker( Object^ num )\n   {\n      // Each worker thread begins by requesting the\n      // semaphore.\n      Console::WriteLine( L&quot;Thread {0} begins and waits for the semaphore.&quot;, num );\n      _pool-&gt;WaitOne();\n      \n      // A padding interval to make the output more orderly.\n      int padding = Interlocked::Add( _padding, 100 );\n\n      Console::WriteLine( L&quot;Thread {0} enters the semaphore.&quot;, num );\n      \n      // The thread&#39;s &quot;work&quot; consists of sleeping for\n      // about a second. Each thread &quot;works&quot; a little\n      // longer, just to make the output more orderly.\n      //\n      Thread::Sleep( 1000 + padding );\n\n      Console::WriteLine( L&quot;Thread {0} releases the semaphore.&quot;, num );\n      Console::WriteLine( L&quot;Thread {0} previous semaphore count: {1}&quot;,\n         num, _pool-&gt;Release() );\n   }\n};\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Semaphore2#1\">Imports System\nImports System.Threading\n\nPublic Class Example\n\n    &#39; A semaphore that simulates a limited resource pool.\n    &#39;\n    Private Shared _pool As Semaphore\n\n    &#39; A padding interval to make the output more orderly.\n    Private Shared _padding As Integer\n\n    &lt;MTAThread&gt; _\n    Public Shared Sub Main()\n        &#39; Create a semaphore that can satisfy up to three\n        &#39; concurrent requests. Use an initial count of zero,\n        &#39; so that the entire semaphore count is initially\n        &#39; owned by the main program thread.\n        &#39;\n        _pool = New Semaphore(0, 3)\n\n        &#39; Create and start five numbered threads. \n        &#39;\n        For i As Integer = 1 To 5\n            Dim t As New Thread(New ParameterizedThreadStart(AddressOf Worker))\n            &#39;Dim t As New Thread(AddressOf Worker)\n\n            &#39; Start the thread, passing the number.\n            &#39;\n            t.Start(i)\n        Next i\n\n        &#39; Wait for half a second, to allow all the\n        &#39; threads to start and to block on the semaphore.\n        &#39;\n        Thread.Sleep(500)\n\n        &#39; The main thread starts out holding the entire\n        &#39; semaphore count. Calling Release(3) brings the \n        &#39; semaphore count back to its maximum value, and\n        &#39; allows the waiting threads to enter the semaphore,\n        &#39; up to three at a time.\n        &#39;\n        Console.WriteLine(&quot;Main thread calls Release(3).&quot;)\n        _pool.Release(3)\n\n        Console.WriteLine(&quot;Main thread exits.&quot;)\n    End Sub\n\n    Private Shared Sub Worker(ByVal num As Object)\n        &#39; Each worker thread begins by requesting the\n        &#39; semaphore.\n        Console.WriteLine(&quot;Thread {0} begins &quot; _\n            &amp; &quot;and waits for the semaphore.&quot;, num)\n        _pool.WaitOne()\n\n        &#39; A padding interval to make the output more orderly.\n        Dim padding As Integer = Interlocked.Add(_padding, 100)\n\n        Console.WriteLine(&quot;Thread {0} enters the semaphore.&quot;, num)\n        \n        &#39; The thread&#39;s &quot;work&quot; consists of sleeping for \n        &#39; about a second. Each thread &quot;works&quot; a little \n        &#39; longer, just to make the output more orderly.\n        &#39;\n        Thread.Sleep(1000 + padding)\n\n        Console.WriteLine(&quot;Thread {0} releases the semaphore.&quot;, num)\n        Console.WriteLine(&quot;Thread {0} previous semaphore count: {1}&quot;, _\n            num, _\n            _pool.Release())\n    End Sub\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.Semaphore2#1\">using System;\nusing System.Threading;\n\npublic class Example\n{\n    // A semaphore that simulates a limited resource pool.\n    //\n    private static Semaphore _pool;\n\n    // A padding interval to make the output more orderly.\n    private static int _padding;\n\n    public static void Main()\n    {\n        // Create a semaphore that can satisfy up to three\n        // concurrent requests. Use an initial count of zero,\n        // so that the entire semaphore count is initially\n        // owned by the main program thread.\n        //\n        _pool = new Semaphore(0, 3);\n\n        // Create and start five numbered threads. \n        //\n        for(int i = 1; i &lt;= 5; i++)\n        {\n            Thread t = new Thread(new ParameterizedThreadStart(Worker));\n\n            // Start the thread, passing the number.\n            //\n            t.Start(i);\n        }\n\n        // Wait for half a second, to allow all the\n        // threads to start and to block on the semaphore.\n        //\n        Thread.Sleep(500);\n\n        // The main thread starts out holding the entire\n        // semaphore count. Calling Release(3) brings the \n        // semaphore count back to its maximum value, and\n        // allows the waiting threads to enter the semaphore,\n        // up to three at a time.\n        //\n        Console.WriteLine(&quot;Main thread calls Release(3).&quot;);\n        _pool.Release(3);\n\n        Console.WriteLine(&quot;Main thread exits.&quot;);\n    }\n\n    private static void Worker(object num)\n    {\n        // Each worker thread begins by requesting the\n        // semaphore.\n        Console.WriteLine(&quot;Thread {0} begins &quot; +\n            &quot;and waits for the semaphore.&quot;, num);\n        _pool.WaitOne();\n\n        // A padding interval to make the output more orderly.\n        int padding = Interlocked.Add(ref _padding, 100);\n\n        Console.WriteLine(&quot;Thread {0} enters the semaphore.&quot;, num);\n        \n        // The thread&#39;s &quot;work&quot; consists of sleeping for \n        // about a second. Each thread &quot;works&quot; a little \n        // longer, just to make the output more orderly.\n        //\n        Thread.Sleep(1000 + padding);\n\n        Console.WriteLine(&quot;Thread {0} releases the semaphore.&quot;, num);\n        Console.WriteLine(&quot;Thread {0} previous semaphore count: {1}&quot;,\n            num, _pool.Release());\n    }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Semaphore_Release_System_Int32_\">\r\n    \r\n            <a id=\"System_Threading_Semaphore_Release_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">Release(Int32)</div>        \r\n          </div>\r\n    \r\n            <p>Exits the semaphore a specified number of times and returns the previous count.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public int Release (int releaseCount);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>releaseCount</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The number of times to exit the semaphore.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.int32\" data-linktype=\"relative-path\">Int32</a></div>\r\n                  </div>\r\n                  <p>The count on the semaphore before the <span class=\"xref\">stem.Threading.Semaphore.Release*</span> method was called.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentoutofrangeexception\" data-linktype=\"relative-path\">ArgumentOutOfRangeException</a></div>\r\n                  </div>\r\n                  <p><code>releaseCount</code> is less than 1.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.semaphorefullexception\" data-linktype=\"relative-path\">SemaphoreFullException</a></div>\r\n                  </div>\r\n                  <p>The semaphore count is already at the maximum value.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a></div>\r\n                  </div>\r\n                  <p>A Win32 error occurred with a named semaphore.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The current semaphore represents a named system semaphore, but the user does not have <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">SemaphoreRights</a> rights.  </p>\n<p> -or-  </p>\n<p> The current semaphore represents a named system semaphore, but it was not opened with <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">SemaphoreRights</a> rights.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If a thread has entered the semaphore multiple times, this method overload allows the entire semaphore count to be restored with one call.  </p>\n<p> If a <a class=\"xref\" href=\"system.threading.semaphorefullexception\" data-linktype=\"relative-path\">SemaphoreFullException</a> is thrown by the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_Release_\" data-linktype=\"relative-path\">Release</a> method, it does not necessarily indicate a problem with the calling thread. A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.  </p>\n<p> If the current <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> object represents a named system semaphore, the user must have <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">System.Security.AccessControl.SemaphoreRights</a> rights and the semaphore must have been opened with <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">System.Security.AccessControl.SemaphoreRights</a> rights.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example creates a semaphore with a maximum count of three and an initial count of zero. The example starts five threads, which block waiting for the semaphore. The main thread uses the Release method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore. Each thread uses the <a class=\"xref\" href=\"system.threading.thread#System_Threading_Thread_Sleep_\" data-linktype=\"relative-path\">Sleep</a> method to wait for one second, to simulate work, and then calls the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_Release\" data-linktype=\"relative-path\">Release()</a> method overload to release the semaphore.  </p>\n<p> Each time the semaphore is released, the previous semaphore count is displayed. Console messages track semaphore use. The simulated work interval is increased slightly for each thread, to make the output easier to read.  </p>\n<pre><code class=\"lang-cpp\" name=\"System.Threading.Semaphore2#1\">#using &lt;System.dll&gt;\nusing namespace System;\nusing namespace System::Threading;\n\npublic ref class Example\n{\nprivate:\n   // A semaphore that simulates a limited resource pool.\n   //\n   static Semaphore^ _pool;\n\n   // A padding interval to make the output more orderly.\n   static int _padding;\n\npublic:\n   static void Main()\n   {\n      // Create a semaphore that can satisfy up to three\n      // concurrent requests. Use an initial count of zero,\n      // so that the entire semaphore count is initially\n      // owned by the main program thread.\n      //\n      _pool = gcnew Semaphore( 0,3 );\n      \n      // Create and start five numbered threads.\n      //\n      for ( int i = 1; i &lt;= 5; i++ )\n      {\n         Thread^ t = gcnew Thread(\n            gcnew ParameterizedThreadStart( Worker ) );\n         \n         // Start the thread, passing the number.\n         //\n         t-&gt;Start( i );\n      }\n      \n      // Wait for half a second, to allow all the\n      // threads to start and to block on the semaphore.\n      //\n      Thread::Sleep( 500 );\n      \n      // The main thread starts out holding the entire\n      // semaphore count. Calling Release(3) brings the\n      // semaphore count back to its maximum value, and\n      // allows the waiting threads to enter the semaphore,\n      // up to three at a time.\n      //\n      Console::WriteLine( L&quot;Main thread calls Release(3).&quot; );\n      _pool-&gt;Release( 3 );\n\n      Console::WriteLine( L&quot;Main thread exits.&quot; );\n   }\n\nprivate:\n   static void Worker( Object^ num )\n   {\n      // Each worker thread begins by requesting the\n      // semaphore.\n      Console::WriteLine( L&quot;Thread {0} begins and waits for the semaphore.&quot;, num );\n      _pool-&gt;WaitOne();\n      \n      // A padding interval to make the output more orderly.\n      int padding = Interlocked::Add( _padding, 100 );\n\n      Console::WriteLine( L&quot;Thread {0} enters the semaphore.&quot;, num );\n      \n      // The thread&#39;s &quot;work&quot; consists of sleeping for\n      // about a second. Each thread &quot;works&quot; a little\n      // longer, just to make the output more orderly.\n      //\n      Thread::Sleep( 1000 + padding );\n\n      Console::WriteLine( L&quot;Thread {0} releases the semaphore.&quot;, num );\n      Console::WriteLine( L&quot;Thread {0} previous semaphore count: {1}&quot;,\n         num, _pool-&gt;Release() );\n   }\n};\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Semaphore2#1\">Imports System\nImports System.Threading\n\nPublic Class Example\n\n    &#39; A semaphore that simulates a limited resource pool.\n    &#39;\n    Private Shared _pool As Semaphore\n\n    &#39; A padding interval to make the output more orderly.\n    Private Shared _padding As Integer\n\n    &lt;MTAThread&gt; _\n    Public Shared Sub Main()\n        &#39; Create a semaphore that can satisfy up to three\n        &#39; concurrent requests. Use an initial count of zero,\n        &#39; so that the entire semaphore count is initially\n        &#39; owned by the main program thread.\n        &#39;\n        _pool = New Semaphore(0, 3)\n\n        &#39; Create and start five numbered threads. \n        &#39;\n        For i As Integer = 1 To 5\n            Dim t As New Thread(New ParameterizedThreadStart(AddressOf Worker))\n            &#39;Dim t As New Thread(AddressOf Worker)\n\n            &#39; Start the thread, passing the number.\n            &#39;\n            t.Start(i)\n        Next i\n\n        &#39; Wait for half a second, to allow all the\n        &#39; threads to start and to block on the semaphore.\n        &#39;\n        Thread.Sleep(500)\n\n        &#39; The main thread starts out holding the entire\n        &#39; semaphore count. Calling Release(3) brings the \n        &#39; semaphore count back to its maximum value, and\n        &#39; allows the waiting threads to enter the semaphore,\n        &#39; up to three at a time.\n        &#39;\n        Console.WriteLine(&quot;Main thread calls Release(3).&quot;)\n        _pool.Release(3)\n\n        Console.WriteLine(&quot;Main thread exits.&quot;)\n    End Sub\n\n    Private Shared Sub Worker(ByVal num As Object)\n        &#39; Each worker thread begins by requesting the\n        &#39; semaphore.\n        Console.WriteLine(&quot;Thread {0} begins &quot; _\n            &amp; &quot;and waits for the semaphore.&quot;, num)\n        _pool.WaitOne()\n\n        &#39; A padding interval to make the output more orderly.\n        Dim padding As Integer = Interlocked.Add(_padding, 100)\n\n        Console.WriteLine(&quot;Thread {0} enters the semaphore.&quot;, num)\n        \n        &#39; The thread&#39;s &quot;work&quot; consists of sleeping for \n        &#39; about a second. Each thread &quot;works&quot; a little \n        &#39; longer, just to make the output more orderly.\n        &#39;\n        Thread.Sleep(1000 + padding)\n\n        Console.WriteLine(&quot;Thread {0} releases the semaphore.&quot;, num)\n        Console.WriteLine(&quot;Thread {0} previous semaphore count: {1}&quot;, _\n            num, _\n            _pool.Release())\n    End Sub\nEnd Class\n</code></pre><pre><code class=\"lang-cs\" name=\"System.Threading.Semaphore2#1\">using System;\nusing System.Threading;\n\npublic class Example\n{\n    // A semaphore that simulates a limited resource pool.\n    //\n    private static Semaphore _pool;\n\n    // A padding interval to make the output more orderly.\n    private static int _padding;\n\n    public static void Main()\n    {\n        // Create a semaphore that can satisfy up to three\n        // concurrent requests. Use an initial count of zero,\n        // so that the entire semaphore count is initially\n        // owned by the main program thread.\n        //\n        _pool = new Semaphore(0, 3);\n\n        // Create and start five numbered threads. \n        //\n        for(int i = 1; i &lt;= 5; i++)\n        {\n            Thread t = new Thread(new ParameterizedThreadStart(Worker));\n\n            // Start the thread, passing the number.\n            //\n            t.Start(i);\n        }\n\n        // Wait for half a second, to allow all the\n        // threads to start and to block on the semaphore.\n        //\n        Thread.Sleep(500);\n\n        // The main thread starts out holding the entire\n        // semaphore count. Calling Release(3) brings the \n        // semaphore count back to its maximum value, and\n        // allows the waiting threads to enter the semaphore,\n        // up to three at a time.\n        //\n        Console.WriteLine(&quot;Main thread calls Release(3).&quot;);\n        _pool.Release(3);\n\n        Console.WriteLine(&quot;Main thread exits.&quot;);\n    }\n\n    private static void Worker(object num)\n    {\n        // Each worker thread begins by requesting the\n        // semaphore.\n        Console.WriteLine(&quot;Thread {0} begins &quot; +\n            &quot;and waits for the semaphore.&quot;, num);\n        _pool.WaitOne();\n\n        // A padding interval to make the output more orderly.\n        int padding = Interlocked.Add(ref _padding, 100);\n\n        Console.WriteLine(&quot;Thread {0} enters the semaphore.&quot;, num);\n        \n        // The thread&#39;s &quot;work&quot; consists of sleeping for \n        // about a second. Each thread &quot;works&quot; a little \n        // longer, just to make the output more orderly.\n        //\n        Thread.Sleep(1000 + padding);\n\n        Console.WriteLine(&quot;Thread {0} releases the semaphore.&quot;, num);\n        Console.WriteLine(&quot;Thread {0} previous semaphore count: {1}&quot;,\n            num, _pool.Release());\n    }\n}\n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Semaphore_SetAccessControl_System_Security_AccessControl_SemaphoreSecurity_\">\r\n    \r\n            <a id=\"System_Threading_Semaphore_SetAccessControl_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">SetAccessControl(SemaphoreSecurity)</div>        \r\n          </div>\r\n    \r\n            <p>Sets the access control security for a named system semaphore.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>semaphoreSecurity</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.accesscontrol.semaphoresecurity\" data-linktype=\"relative-path\">SemaphoreSecurity</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A <a class=\"xref\" href=\"system.security.accesscontrol.semaphoresecurity\" data-linktype=\"relative-path\">SemaphoreSecurity</a> object that represents the access control security to be applied to the named system semaphore.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>semaphoreSecurity</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The user does not have <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">SemaphoreRights</a> rights.  </p>\n<p> -or-  </p>\n<p> The semaphore was not opened with <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">SemaphoreRights</a> rights.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.notsupportedexception\" data-linktype=\"relative-path\">NotSupportedException</a></div>\r\n                  </div>\r\n                  <p>The current <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> object does not represent a named system semaphore.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>You can set access control security only on <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> objects that represent named system semaphores.  </p>\n<p> The user must have <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">System.Security.AccessControl.SemaphoreRights</a> rights to call this method, and the semaphore must have been opened with <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">System.Security.AccessControl.SemaphoreRights</a> rights.</p>\n\r\n    \r\n            <h4>Example</h4>\r\n            <p>The following code example demonstrates the cross-process behavior of a named semaphore with access control security. The example uses the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a> method overload to test for the existence of a named semaphore.  </p>\n<p> If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.  </p>\n<p> If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a> method. The exception is caught, and the example uses the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_OpenExisting_System_String_System_Security_AccessControl_SemaphoreRights_\" data-linktype=\"relative-path\">OpenExisting(String,SemaphoreRights)</a> method overload to open the semaphore with the rights needed to read and change the permissions.  </p>\n<p> After the permissions are changed, using the SetAccessControl method, the semaphore is opened with the rights required to enter and release. If you run the compiled example from a third command window, it runs using the new permissions.  </p>\n<pre><code class=\"lang-cs\" name=\"System.Threading.Semaphore.ctor named 5a#1\">using System;\nusing System.Threading;\nusing System.Security.AccessControl;\n\ninternal class Example\n{\n    internal static void Main()\n    {\n        const string semaphoreName = &quot;SemaphoreExample5&quot;;\n\n        Semaphore sem = null;\n        bool doesNotExist = false;\n        bool unauthorized = false;\n\n        // Attempt to open the named semaphore.\n        try\n        {\n            // Open the semaphore with (SemaphoreRights.Synchronize\n            // | SemaphoreRights.Modify), to enter and release the\n            // named semaphore.\n            //\n            sem = Semaphore.OpenExisting(semaphoreName);\n        }\n        catch(WaitHandleCannotBeOpenedException)\n        {\n            Console.WriteLine(&quot;Semaphore does not exist.&quot;);\n            doesNotExist = true;\n        }\n        catch(UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n            unauthorized = true;\n        }\n\n        // There are three cases: (1) The semaphore does not exist.\n        // (2) The semaphore exists, but the current user doesn&#39;t \n        // have access. (3) The semaphore exists and the user has\n        // access.\n        //\n        if (doesNotExist)\n        {\n            // The semaphore does not exist, so create it.\n            //\n            // The value of this variable is set by the semaphore\n            // constructor. It is true if the named system semaphore was\n            // created, and false if the named semaphore already existed.\n            //\n            bool semaphoreWasCreated;\n\n            // Create an access control list (ACL) that denies the\n            // current user the right to enter or release the \n            // semaphore, but allows the right to read and change\n            // security information for the semaphore.\n            //\n            string user = Environment.UserDomainName + &quot;\\\\&quot; \n                + Environment.UserName;\n            SemaphoreSecurity semSec = new SemaphoreSecurity();\n\n            SemaphoreAccessRule rule = new SemaphoreAccessRule(\n                user, \n                SemaphoreRights.Synchronize | SemaphoreRights.Modify, \n                AccessControlType.Deny);\n            semSec.AddAccessRule(rule);\n\n            rule = new SemaphoreAccessRule(\n                user, \n                SemaphoreRights.ReadPermissions | SemaphoreRights.ChangePermissions,\n                AccessControlType.Allow);\n            semSec.AddAccessRule(rule);\n\n            // Create a Semaphore object that represents the system\n            // semaphore named by the constant &#39;semaphoreName&#39;, with\n            // maximum count three, initial count three, and the\n            // specified security access. The Boolean value that \n            // indicates creation of the underlying system object is\n            // placed in semaphoreWasCreated.\n            //\n            sem = new Semaphore(3, 3, semaphoreName, \n                out semaphoreWasCreated, semSec);\n\n            // If the named system semaphore was created, it can be\n            // used by the current instance of this program, even \n            // though the current user is denied access. The current\n            // program enters the semaphore. Otherwise, exit the\n            // program.\n            // \n            if (semaphoreWasCreated)\n            {\n                Console.WriteLine(&quot;Created the semaphore.&quot;);\n            }\n            else\n            {\n                Console.WriteLine(&quot;Unable to create the semaphore.&quot;);\n                return;\n            }\n\n        }\n        else if (unauthorized)\n        {\n            // Open the semaphore to read and change the access\n            // control security. The access control security defined\n            // above allows the current user to do this.\n            //\n            try\n            {\n                sem = Semaphore.OpenExisting(\n                    semaphoreName, \n                    SemaphoreRights.ReadPermissions \n                        | SemaphoreRights.ChangePermissions);\n\n                // Get the current ACL. This requires \n                // SemaphoreRights.ReadPermissions.\n                SemaphoreSecurity semSec = sem.GetAccessControl();\n                \n                string user = Environment.UserDomainName + &quot;\\\\&quot; \n                    + Environment.UserName;\n\n                // First, the rule that denied the current user \n                // the right to enter and release the semaphore must\n                // be removed.\n                SemaphoreAccessRule rule = new SemaphoreAccessRule(\n                    user, \n                    SemaphoreRights.Synchronize | SemaphoreRights.Modify, \n                    AccessControlType.Deny);\n                semSec.RemoveAccessRule(rule);\n\n                // Now grant the user the correct rights.\n                // \n                rule = new SemaphoreAccessRule(user, \n                     SemaphoreRights.Synchronize | SemaphoreRights.Modify, \n                     AccessControlType.Allow);\n                semSec.AddAccessRule(rule);\n\n                // Update the ACL. This requires\n                // SemaphoreRights.ChangePermissions.\n                sem.SetAccessControl(semSec);\n\n                Console.WriteLine(&quot;Updated semaphore security.&quot;);\n\n                // Open the semaphore with (SemaphoreRights.Synchronize \n                // | SemaphoreRights.Modify), the rights required to\n                // enter and release the semaphore.\n                //\n                sem = Semaphore.OpenExisting(semaphoreName);\n\n            }\n            catch(UnauthorizedAccessException ex)\n            {\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;, ex.Message);\n                return;\n            }\n        }\n\n        // Enter the semaphore, and hold it until the program\n        // exits.\n        //\n        try\n        {\n            sem.WaitOne();\n            Console.WriteLine(&quot;Entered the semaphore.&quot;);\n            Console.WriteLine(&quot;Press the Enter key to exit.&quot;);\n            Console.ReadLine();\n            sem.Release();\n        }\n        catch(UnauthorizedAccessException ex)\n        {\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message);\n        }\n    }\n}\n</code></pre><pre><code class=\"lang-cpp\" name=\"System.Threading.Semaphore.ctor named 5a#1\">#using &lt;System.dll&gt;\nusing namespace System;\nusing namespace System::Threading;\nusing namespace System::Security::AccessControl;\nusing namespace System::Security::Permissions;\n\npublic ref class Example\n{\npublic:\n   [SecurityPermissionAttribute(SecurityAction::Demand, Flags = SecurityPermissionFlag::UnmanagedCode)]\n   static void main()\n   {\n      String^ semaphoreName = L&quot;SemaphoreExample5&quot;;\n\n      Semaphore^ sem = nullptr;\n      bool doesNotExist = false;\n      bool unauthorized = false;\n      \n      // Attempt to open the named semaphore.\n      try\n      {\n         // Open the semaphore with (SemaphoreRights.Synchronize\n         // | SemaphoreRights.Modify), to enter and release the\n         // named semaphore.\n         //\n         sem = Semaphore::OpenExisting( semaphoreName );\n      }\n      catch ( WaitHandleCannotBeOpenedException^ ex ) \n      {\n         Console::WriteLine( L&quot;Semaphore does not exist.&quot; );\n         doesNotExist = true;\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n         unauthorized = true;\n      }\n\n      // There are three cases: (1) The semaphore does not exist.\n      // (2) The semaphore exists, but the current user doesn&#39;t\n      // have access. (3) The semaphore exists and the user has\n      // access.\n      //\n      if ( doesNotExist )\n      {\n         // The semaphore does not exist, so create it.\n         //\n         // The value of this variable is set by the semaphore\n         // constructor. It is true if the named system semaphore was\n         // created, and false if the named semaphore already existed.\n         //\n         bool semaphoreWasCreated;\n         \n         // Create an access control list (ACL) that denies the\n         // current user the right to enter or release the\n         // semaphore, but allows the right to read and change\n         // security information for the semaphore.\n         //\n         String^ user = String::Concat( Environment::UserDomainName,\n            L&quot;\\\\&quot;, Environment::UserName );\n         SemaphoreSecurity^ semSec = gcnew SemaphoreSecurity;\n\n         SemaphoreAccessRule^ rule = gcnew SemaphoreAccessRule( user,\n            static_cast&lt;SemaphoreRights&gt;(\n               SemaphoreRights::Synchronize |\n               SemaphoreRights::Modify ),\n            AccessControlType::Deny );\n         semSec-&gt;AddAccessRule( rule );\n\n         rule = gcnew SemaphoreAccessRule( user,\n            static_cast&lt;SemaphoreRights&gt;(\n               SemaphoreRights::ReadPermissions |\n               SemaphoreRights::ChangePermissions ),\n            AccessControlType::Allow );\n         semSec-&gt;AddAccessRule( rule );\n         \n         // Create a Semaphore object that represents the system\n         // semaphore named by the constant &#39;semaphoreName&#39;, with\n         // maximum count three, initial count three, and the\n         // specified security access. The Boolean value that\n         // indicates creation of the underlying system object is\n         // placed in semaphoreWasCreated.\n         //\n         sem = gcnew Semaphore( 3,3,semaphoreName,semaphoreWasCreated,semSec );\n         \n         // If the named system semaphore was created, it can be\n         // used by the current instance of this program, even\n         // though the current user is denied access. The current\n         // program enters the semaphore. Otherwise, exit the\n         // program.\n         //\n         if ( semaphoreWasCreated )\n         {\n            Console::WriteLine( L&quot;Created the semaphore.&quot; );\n         }\n         else\n         {\n            Console::WriteLine( L&quot;Unable to create the semaphore.&quot; );\n            return;\n         }\n\n      }\n      else if ( unauthorized )\n      {\n         // Open the semaphore to read and change the access\n         // control security. The access control security defined\n         // above allows the current user to do this.\n         //\n         try\n         {\n            sem = Semaphore::OpenExisting( semaphoreName,\n               static_cast&lt;SemaphoreRights&gt;(\n                  SemaphoreRights::ReadPermissions |\n                  SemaphoreRights::ChangePermissions ));\n            \n            // Get the current ACL. This requires\n            // SemaphoreRights.ReadPermissions.\n            SemaphoreSecurity^ semSec = sem-&gt;GetAccessControl();\n\n            String^ user = String::Concat( Environment::UserDomainName,\n               L&quot;\\\\&quot;, Environment::UserName );\n            \n            // First, the rule that denied the current user\n            // the right to enter and release the semaphore must\n            // be removed.\n            SemaphoreAccessRule^ rule = gcnew SemaphoreAccessRule( user,\n               static_cast&lt;SemaphoreRights&gt;(\n                  SemaphoreRights::Synchronize |\n                  SemaphoreRights::Modify ),\n               AccessControlType::Deny );\n            semSec-&gt;RemoveAccessRule( rule );\n            \n            // Now grant the user the correct rights.\n            //\n            rule = gcnew SemaphoreAccessRule( user,\n               static_cast&lt;SemaphoreRights&gt;(\n                  SemaphoreRights::Synchronize |\n                  SemaphoreRights::Modify ),\n               AccessControlType::Allow );\n            semSec-&gt;AddAccessRule( rule );\n            \n            // Update the ACL. This requires\n            // SemaphoreRights.ChangePermissions.\n            sem-&gt;SetAccessControl( semSec );\n\n            Console::WriteLine( L&quot;Updated semaphore security.&quot; );\n            \n            // Open the semaphore with (SemaphoreRights.Synchronize\n            // | SemaphoreRights.Modify), the rights required to\n            // enter and release the semaphore.\n            //\n            sem = Semaphore::OpenExisting( semaphoreName );\n\n         }\n         catch ( UnauthorizedAccessException^ ex ) \n         {\n            Console::WriteLine( L&quot;Unable to change permissions: {0}&quot;, ex-&gt;Message );\n            return;\n         }\n      }\n      \n      // Enter the semaphore, and hold it until the program\n      // exits.\n      //\n      try\n      {\n         sem-&gt;WaitOne();\n         Console::WriteLine( L&quot;Entered the semaphore.&quot; );\n         Console::WriteLine( L&quot;Press the Enter key to exit.&quot; );\n         Console::ReadLine();\n         sem-&gt;Release();\n      }\n      catch ( UnauthorizedAccessException^ ex ) \n      {\n         Console::WriteLine( L&quot;Unauthorized access: {0}&quot;, ex-&gt;Message );\n      }\n   }\n};\n</code></pre><pre><code class=\"lang-vb\" name=\"System.Threading.Semaphore.ctor named 5a#1\">Imports System\nImports System.Threading\nImports System.Security.AccessControl\n\nFriend Class Example\n\n    &lt;MTAThread&gt; _\n    Friend Shared Sub Main()\n        Const semaphoreName As String = &quot;SemaphoreExample5&quot;\n\n        Dim sem As Semaphore = Nothing\n        Dim doesNotExist as Boolean = False\n        Dim unauthorized As Boolean = False\n\n        &#39; Attempt to open the named semaphore.\n        Try\n            &#39; Open the semaphore with (SemaphoreRights.Synchronize\n            &#39; Or SemaphoreRights.Modify), to enter and release the\n            &#39; named semaphore.\n            &#39;\n            sem = Semaphore.OpenExisting(semaphoreName)\n        Catch ex As WaitHandleCannotBeOpenedException\n            Console.WriteLine(&quot;Semaphore does not exist.&quot;)\n            doesNotExist = True\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, ex.Message)\n            unauthorized = True\n        End Try\n\n        &#39; There are three cases: (1) The semaphore does not exist.\n        &#39; (2) The semaphore exists, but the current user doesn&#39;t \n        &#39; have access. (3) The semaphore exists and the user has\n        &#39; access.\n        &#39;\n        If doesNotExist Then\n            &#39; The semaphore does not exist, so create it.\n            &#39;\n            &#39; The value of this variable is set by the semaphore\n            &#39; constructor. It is True if the named system semaphore was\n            &#39; created, and False if the named semaphore already existed.\n            &#39;\n            Dim semaphoreWasCreated As Boolean\n\n            &#39; Create an access control list (ACL) that denies the\n            &#39; current user the right to enter or release the \n            &#39; semaphore, but allows the right to read and change\n            &#39; security information for the semaphore.\n            &#39;\n            Dim user As String = Environment.UserDomainName _ \n                &amp; &quot;\\&quot; &amp; Environment.UserName\n            Dim semSec As New SemaphoreSecurity()\n\n            Dim rule As New SemaphoreAccessRule(user, _\n                SemaphoreRights.Synchronize Or SemaphoreRights.Modify, _\n                AccessControlType.Deny)\n            semSec.AddAccessRule(rule)\n\n            rule = New SemaphoreAccessRule(user, _\n                SemaphoreRights.ReadPermissions Or _\n                SemaphoreRights.ChangePermissions, _\n                AccessControlType.Allow)\n            semSec.AddAccessRule(rule)\n\n            &#39; Create a Semaphore object that represents the system\n            &#39; semaphore named by the constant &#39;semaphoreName&#39;, with\n            &#39; maximum count three, initial count three, and the\n            &#39; specified security access. The Boolean value that \n            &#39; indicates creation of the underlying system object is\n            &#39; placed in semaphoreWasCreated.\n            &#39;\n            sem = New Semaphore(3, 3, semaphoreName, _\n                semaphoreWasCreated, semSec)\n\n            &#39; If the named system semaphore was created, it can be\n            &#39; used by the current instance of this program, even \n            &#39; though the current user is denied access. The current\n            &#39; program enters the semaphore. Otherwise, exit the\n            &#39; program.\n            &#39; \n            If semaphoreWasCreated Then\n                Console.WriteLine(&quot;Created the semaphore.&quot;)\n            Else\n                Console.WriteLine(&quot;Unable to create the semaphore.&quot;)\n                Return\n            End If\n\n        ElseIf unauthorized Then\n\n            &#39; Open the semaphore to read and change the access\n            &#39; control security. The access control security defined\n            &#39; above allows the current user to do this.\n            &#39;\n            Try\n                sem = Semaphore.OpenExisting(semaphoreName, _\n                    SemaphoreRights.ReadPermissions Or _\n                    SemaphoreRights.ChangePermissions)\n\n                &#39; Get the current ACL. This requires \n                &#39; SemaphoreRights.ReadPermissions.\n                Dim semSec As SemaphoreSecurity = sem.GetAccessControl()\n                \n                Dim user As String = Environment.UserDomainName _ \n                    &amp; &quot;\\&quot; &amp; Environment.UserName\n\n                &#39; First, the rule that denied the current user \n                &#39; the right to enter and release the semaphore must\n                &#39; be removed.\n                Dim rule As New SemaphoreAccessRule(user, _\n                    SemaphoreRights.Synchronize Or SemaphoreRights.Modify, _\n                    AccessControlType.Deny)\n                semSec.RemoveAccessRule(rule)\n\n                &#39; Now grant the user the correct rights.\n                &#39; \n                rule = New SemaphoreAccessRule(user, _\n                    SemaphoreRights.Synchronize Or SemaphoreRights.Modify, _\n                    AccessControlType.Allow)\n                semSec.AddAccessRule(rule)\n\n                &#39; Update the ACL. This requires\n                &#39; SemaphoreRights.ChangePermissions.\n                sem.SetAccessControl(semSec)\n\n                Console.WriteLine(&quot;Updated semaphore security.&quot;)\n\n                &#39; Open the semaphore with (SemaphoreRights.Synchronize \n                &#39; Or SemaphoreRights.Modify), the rights required to\n                &#39; enter and release the semaphore.\n                &#39;\n                sem = Semaphore.OpenExisting(semaphoreName)\n\n            Catch ex As UnauthorizedAccessException\n                Console.WriteLine(&quot;Unable to change permissions: {0}&quot;, _\n                    ex.Message)\n                Return\n            End Try\n\n        End If\n\n        &#39; Enter the semaphore, and hold it until the program\n        &#39; exits.\n        &#39;\n        Try\n            sem.WaitOne()\n            Console.WriteLine(&quot;Entered the semaphore.&quot;)\n            Console.WriteLine(&quot;Press the Enter key to exit.&quot;)\n            Console.ReadLine()\n            sem.Release()\n        Catch ex As UnauthorizedAccessException\n            Console.WriteLine(&quot;Unauthorized access: {0}&quot;, _\n                ex.Message)\n        End Try\n    End Sub \nEnd Class \n</code></pre>\r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Semaphore_TryOpenExisting_System_String_System_Threading_Semaphore__\">\r\n    \r\n            <a id=\"System_Threading_Semaphore_TryOpenExisting_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">TryOpenExisting(String,Semaphore)</div>        \r\n          </div>\r\n    \r\n            <p>Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of the system semaphore to open.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>result</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>When this method returns, contains a <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> object that represents the named semaphore if the call succeeded, or <code>null</code> if the call failed. This parameter is treated as uninitialized.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the named semaphore was opened successfully; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is an empty string.  </p>\n<p> -or-  </p>\n<p> <code>name</code> is longer than 260 characters.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a></div>\r\n                  </div>\r\n                  <p>A Win32 error occurred.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The named semaphore exists, but the user does not have the security access required to use it.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the named semaphore does not exist, this method does not create it. To create the system semaphore when it does not already exist, use one of the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore__ctor_\" data-linktype=\"relative-path\">Semaphore</a> constructors that has a <code>name</code> parameter.  </p>\n<p> If you are uncertain whether a named semaphore exists, use this method overload instead of the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_OpenExisting_System_String_\" data-linktype=\"relative-path\">OpenExisting(String)</a> method overload, which throws an exception if the semaphore does not exist.  </p>\n<p> This method overload is equivalent to calling the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_TryOpenExisting_\" data-linktype=\"relative-path\">TryOpenExisting</a> method overload and specifying <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">System.Security.AccessControl.SemaphoreRights</a> and <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">System.Security.AccessControl.SemaphoreRights</a> rights, combined by using the bitwise OR operation. Specifying the <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">System.Security.AccessControl.SemaphoreRights</a> flag allows a thread to enter the semaphore, and specifying the   <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">System.Security.AccessControl.SemaphoreRights</a> flag allows a thread to call the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_Release_\" data-linktype=\"relative-path\">Release</a> method.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n        <li class=\" enable-platform-filter\" id=\"System_Threading_Semaphore_TryOpenExisting_System_String_System_Security_AccessControl_SemaphoreRights_System_Threading_Semaphore__\">\r\n    \r\n            <a id=\"System_Threading_Semaphore_TryOpenExisting_\"></a>\r\n    \r\n    \r\n          <div class=\"memberName\">\r\n            <div class=\"lang-csharp\">TryOpenExisting(String,SemaphoreRights,Semaphore)</div>        \r\n          </div>\r\n    \r\n            <p>Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</p>\n\r\n    \r\n            <pre class=\"memberDeclaration\"><code class=\"csharp lang-csharp\">public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);</code></pre>\r\n    \r\n    \r\n              <h4>Parameters</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <dl>\r\n                  <dt>name</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.string\" data-linktype=\"relative-path\">String</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>The name of the system semaphore to open.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>rights</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">SemaphoreRights</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>A bitwise combination of the enumeration values that represent the desired security access.</p>\n\r\n                </li>\r\n                <li>\r\n                  <dl>\r\n                  <dt>result</dt>\r\n                  <dd>\r\n                    <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a></div>\r\n                  </dd>\r\n                  </dl>\r\n                  <p>When this method returns, contains a <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> object that represents the named semaphore if the call succeeded, or <code>null</code> if the call failed. This parameter is treated as uninitialized.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n              <h4>Returns</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.boolean\" data-linktype=\"relative-path\">Boolean</a></div>\r\n                  </div>\r\n                  <p><code>true</code> if the named semaphore was opened successfully; otherwise, <code>false</code>.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n    \r\n              <h4>Exceptions</h4>\r\n              <ul class=\"memberDetails\">\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentexception\" data-linktype=\"relative-path\">ArgumentException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is an empty string.  </p>\n<p> -or-  </p>\n<p> <code>name</code> is longer than 260 characters.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.argumentnullexception\" data-linktype=\"relative-path\">ArgumentNullException</a></div>\r\n                  </div>\r\n                  <p><code>name</code> is <code>null</code>.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.io.ioexception\" data-linktype=\"relative-path\">IOException</a></div>\r\n                  </div>\r\n                  <p>A Win32 error occurred.</p>\n\r\n                </li>\r\n                <li>\r\n                  <div class=\"single\">                \r\n                      <div class=\"lang-csharp\"><a class=\"xref\" href=\"system.unauthorizedaccessexception\" data-linktype=\"relative-path\">UnauthorizedAccessException</a></div>\r\n                  </div>\r\n                  <p>The named semaphore exists, but the user does not have the security access required to use it.</p>\n\r\n                </li>\r\n              </ul>\r\n    \r\n          \r\n    \r\n            <h4>Remarks</h4>\r\n            <p>If the named semaphore does not exist, this method does not create it. To create the system semaphore when it does not already exist, use one of the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore__ctor_\" data-linktype=\"relative-path\">Semaphore</a> constructors that has a <code>name</code> parameter.  </p>\n<p> If you are uncertain whether a named semaphore exists, use this method overload instead of the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_OpenExisting_System_String_System_Security_AccessControl_SemaphoreRights_\" data-linktype=\"relative-path\">OpenExisting(String,SemaphoreRights)</a> method overload, which throws an exception if the semaphore does not exist.  </p>\n<p> The <code>rights</code> parameter must include the <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">System.Security.AccessControl.SemaphoreRights</a> flag to allow threads to enter the semaphore, and the <a class=\"xref\" href=\"system.security.accesscontrol.semaphorerights\" data-linktype=\"relative-path\">System.Security.AccessControl.SemaphoreRights</a> flag to allow threads to call the <a class=\"xref\" href=\"system.threading.semaphore#System_Threading_Semaphore_Release_\" data-linktype=\"relative-path\">Release</a> method.  </p>\n<p> Multiple calls to this method that use the same value for <code>name</code> do not necessarily return the same <a class=\"xref\" href=\"system.threading.semaphore\" data-linktype=\"relative-path\">Semaphore</a> object, even though the objects that are returned represent the same named system semaphore.</p>\n\r\n    \r\n    \r\n    \r\n        </li>\r\n      </ul>\r\n    </section>\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n","outputRootRelativePath":"./","pageMetadata":"<meta name=\"breadcrumb_path\" content=\"breadcrumb/toc.json\">\r\n<meta name=\"search.ms_sitename\" content=\"Docs\">\r\n<meta name=\"search.ms_docsetname\" content=\"fulldocset\">\r\n<meta name=\"locale\" content=\"en-us\">\r\n<meta name=\"site_name\" content=\"Docs\">\r\n<meta name=\"search.ms_product\" content=\"MSDN\">\r\n<meta name=\"depot_name\" content=\"MSDN.fulldocset\">\r\n<meta name=\"ref_skeleton_gitcommit\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Threading.Semaphore.yml\">\r\n<meta name=\"original_ref_skeleton_git_url\" content=\"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Threading.Semaphore.yml\">\r\n<meta name=\"APIName\" content=\"System.Threading.Semaphore\">\r\n<meta name=\"APIName\" content=\"System.Threading.Semaphore..ctor\">\r\n<meta name=\"APIName\" content=\"System.Threading.Semaphore.GetAccessControl\">\r\n<meta name=\"APIName\" content=\"System.Threading.Semaphore.OpenExisting\">\r\n<meta name=\"APIName\" content=\"System.Threading.Semaphore.Release\">\r\n<meta name=\"APIName\" content=\"System.Threading.Semaphore.SetAccessControl\">\r\n<meta name=\"APIName\" content=\"System.Threading.Semaphore.TryOpenExisting\">\r\n<meta name=\"APILocation\" content=\"System.dll\">\r\n<meta name=\"TopicType\" content=\"apiref\">\r\n<meta name=\"APIType\" content=\"Assembly\">\r\n<meta name=\"updated_at\" content=\"2017-03-01 01:37 AM\">\r\n<meta name=\"document_id\" content=\"23bcc08d-00c5-c395-dd27-749d6b87ae90\">\r\n<meta name=\"pagetype\" content=\"Reference\">\r\n<meta name=\"description\" content=\"Limits the number of threads that can access a resource or pool of resources concurrently.\n\">\r\n<meta name=\"toc_rel\" content=\"_splitted/System.Threading/toc.json\">\r\n<meta name=\"source_url\" content=\"\">\r\n<meta name=\"ms.assetid\" content=\"System.Threading.Semaphore\">\r\n","rawMetadata":{"breadcrumb_path":"breadcrumb/toc.json","search.ms_sitename":"Docs","search.ms_docsetname":"fulldocset","version":null,"_op_canonicalUrlPrefix":"https://ppe.docs.microsoft.com/en-us/fulldotnet/","locale":"en-us","site_name":"Docs","search.ms_product":"MSDN","_op_openToPublicContributors":true,"depot_name":"MSDN.fulldocset","_op_gitRefSkeletonCommitHistory":[{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"use plugin in master","commit_sha":"501959ac03e19ac52a27aa4c6bbeb980f8b11c8c","commit_date":"2017-03-01 09:31:20 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"switch from platform to version","commit_sha":"78cdacb5ca782478af490a6b30c3a2cb2b6b873e","commit_date":"2017-02-28 15:09:51 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"update platforms","commit_sha":"39ad5a8919a59afc93a79ac4bd8e07c3b471b37a","commit_date":"2017-02-28 10:38:59 +0800"},{"author_name":"Tianqi Zhang","author_email":"tianzh@microsoft.com","committer_name":"Tianqi Zhang","comitter_email":"tianzh@microsoft.com","message":"checkin yml","commit_sha":"da161b792852497df7140d7768cee2eccd9cb43f","commit_date":"2017-02-28 09:36:15 +0800"}],"ref_skeleton_gitcommit":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/501959ac03e19ac52a27aa4c6bbeb980f8b11c8c/fulldocset/System.Threading.Semaphore.yml","original_ref_skeleton_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/System.Threading.Semaphore.yml","open_to_public_contributors":true,"api_name":["System.Threading.Semaphore","System.Threading.Semaphore..ctor","System.Threading.Semaphore.GetAccessControl","System.Threading.Semaphore.OpenExisting","System.Threading.Semaphore.Release","System.Threading.Semaphore.SetAccessControl","System.Threading.Semaphore.TryOpenExisting"],"api_location":["System.dll"],"topic_type":["apiref"],"api_type":["Assembly"],"f1_keywords":["System.Threading.Semaphore","System::Threading::Semaphore","System.Threading.Semaphore.#ctor","System::Threading::Semaphore::#ctor","System.Threading.Semaphore.GetAccessControl","System::Threading::Semaphore::GetAccessControl","System.Threading.Semaphore.OpenExisting","System::Threading::Semaphore::OpenExisting","System.Threading.Semaphore.Release","System::Threading::Semaphore::Release","System.Threading.Semaphore.SetAccessControl","System::Threading::Semaphore::SetAccessControl","System.Threading.Semaphore.TryOpenExisting","System::Threading::Semaphore::TryOpenExisting"],"dev_langs":["csharp"],"updated_at":"2017-03-01 01:37 AM","document_id":"23bcc08d-00c5-c395-dd27-749d6b87ae90","content_git_url":"https://github.com/TianqiZhang/ECMA2YamlTestRepo2/blob/master/fulldocset/xml/System.Threading/Semaphore.xml","layout":"Reference","_op_layout":"Reference","pagetype":"Reference","title":"Semaphore class | Microsoft Docs","_op_ogTitle":"Semaphore class","description":"Limits the number of threads that can access a resource or pool of resources concurrently.\n","toc_asset_id":"_splitted/System.Threading/toc.json","toc_rel":"_splitted/System.Threading/toc.json","source_url":"","ms.assetid":"System.Threading.Semaphore","canonical_url":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.threading.semaphore","_op_canonicalUrl":"https://ppe.docs.microsoft.com/en-us/mergedepotdynamic/system.threading.semaphore","fileRelativePath":"System.Threading.Semaphore.html"},"themesRelativePathToOutputRoot":"_themes/"}